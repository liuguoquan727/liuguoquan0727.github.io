<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://liuguoquan727.github.io">
  <title>再读斋</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="像外行一样思考,像专家一样实践。">
<meta property="og:type" content="website">
<meta property="og:title" content="再读斋">
<meta property="og:url" content="http://liuguoquan727.github.io/page/2/index.html">
<meta property="og:site_name" content="再读斋">
<meta property="og:description" content="像外行一样思考,像专家一样实践。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="再读斋">
<meta name="twitter:description" content="像外行一样思考,像专家一样实践。">
  
    <link rel="alternative" href="/atom.xml" title="再读斋" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/main.68ab53.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

</head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/icon.jpg" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">刘涤生</a></h1>
		</hgroup>
		
		<p class="header-subtitle">MICHAEL</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/archives">归档</a></li>
	        
				<li><a href="/tags">标签</a></li>
	        
				<li><a href="/categories">分类</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/liuguoquan727" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="http://weibo.com/liuguoquan0727" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/icon.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">刘涤生</h1>
			</hgroup>
			
			<p class="header-subtitle"><i class="icon icon-quo-left"></i>MICHAEL<i class="icon icon-quo-right"></i></p>
			
			
			
				
			
				
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/liuguoquan727" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/liuguoquan0727" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 70%">
				
				
					<li style="width: 25%"><a href="/">主页</a></li>
		        
					<li style="width: 25%"><a href="/archives">归档</a></li>
		        
					<li style="width: 25%"><a href="/tags">标签</a></li>
		        
					<li style="width: 25%"><a href="/categories">分类</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-Android设计模式之(一)单例模式" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/03/Android设计模式之(一)单例模式/">Android设计模式之(一)单例模式</a>
    </h1>
  

        
        <a href="/2016/06/03/Android设计模式之(一)单例模式/" class="archive-article-date">
  	<time datetime="2016-06-03T12:34:01.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-06-03 20:34:01</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>单例模式是应用最广的模式之一，在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个全局对象，这样有利于我们协调系统整体的行为。如在一个应用中，应该只有一个ImageLoader实例，这个ImageLoader中又含有线程池、缓存系统、网络请求等，很消耗资源。因此不应该让它构造多个实例。这样不能自由构造对象的情况，就是单例模式的使用场景。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>确保某个类有且只要一个对象的场景，避免产生多个对象消耗过多的资源，或者某种类型的对象只应该有且只有一个。例如，创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源，这时就要考虑使用单例模式。</p>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p>单例模式的UML类图如下：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/uml-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<p>角色介绍：</p>
<ul>
<li>Client：高层客户端</li>
<li>Singleton：单例类</li>
</ul>
<p>实现单例模式主要有以下几个关键点：</p>
<ul>
<li>构造函数不对外开放，一般为private；</li>
<li>通过一个静态方法或者枚举返回单例类对象；</li>
<li>确保单例类的对象有且只有一个，尤其是在多线程环境下；</li>
<li>确保单例类对象在反序列化时不会重新构建对象；</li>
</ul>
<p>单例模式中实现比较困难的是在多线程环境下构造单例类的对象有且只有一个。</p>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>单例模式在设计模式中是结构比较简单的，只有一个单例类，没有其他层次结构和抽象。该模式需要确保该类只能生成一个对象，通常是该类需要消耗较多的资源或者没有对个实例的情况。例如一个公司只有一个CEO、一个应用只有一个Application对象等。</p>
<p>下面以公司里的CEO为例来简单演示一下，一个公司可以有多个VP、无数个员工，但只有一个CEO，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * </div><div class="line"> * 普通员工</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Staff</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">//干活</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//副总裁</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VP</span> <span class="keyword">extends</span> <span class="title">Staff</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 管理下面的经理</span></div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//CEO，饿汉式单例</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CEO</span> <span class="keyword">extends</span> <span class="title">Staff</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CEO mCEO = <span class="keyword">new</span> CEO();</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">CEO</span><span class="params">()</span> </span>&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//公有的静态函数，对外暴露获取单例对象的接口</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CEO <span class="title">getCeo</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> mCEO;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 管理VP</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//公司类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> List&lt;Staff&gt; mStaffs = <span class="keyword">new</span> ArrayList&lt;Staff&gt;();</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStaff</span><span class="params">(Staff staff)</span> </span>&#123;</div><div class="line">		mStaffs.add(staff);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showStaffs</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span>(Staff staff : mStaffs) &#123;</div><div class="line">			System.out.println(<span class="string">"Obj: "</span> + staff.toString());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		</div><div class="line">		Company company = <span class="keyword">new</span> Company();</div><div class="line">		</div><div class="line">		<span class="comment">//CEO对象只能通过getCeo获取</span></div><div class="line">		Staff ceo1 = CEO.getCeo();</div><div class="line">		Staff ceo2 = CEO.getCeo();</div><div class="line">		company.addStaff(ceo1);</div><div class="line">		company.addStaff(ceo2);</div><div class="line">		</div><div class="line">		Staff vp1 = <span class="keyword">new</span> VP();</div><div class="line">		Staff vp2 = <span class="keyword">new</span> VP();</div><div class="line">		company.addStaff(vp1);</div><div class="line">		company.addStaff(vp2);</div><div class="line">		</div><div class="line">		Staff staff1 = <span class="keyword">new</span> Staff();</div><div class="line">		Staff staff2 = <span class="keyword">new</span> Staff();</div><div class="line">		</div><div class="line">		company.addStaff(staff1);</div><div class="line">		company.addStaff(staff2);</div><div class="line"></div><div class="line">		company.showStaffs();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>运行输出结果如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Obj</span>: com.liuguoquan.design.single.CEO<span class="variable">@15db9742</span></div><div class="line"><span class="attribute">Obj</span>: com.liuguoquan.design.single.CEO<span class="variable">@15db9742</span></div><div class="line"><span class="attribute">Obj</span>: com.liuguoquan.design.single.VP<span class="variable">@6d06d69c</span></div><div class="line"><span class="attribute">Obj</span>: com.liuguoquan.design.single.VP<span class="variable">@7852e922</span></div><div class="line"><span class="attribute">Obj</span>: com.liuguoquan.design.single.Staff<span class="variable">@4e25154f</span></div><div class="line"><span class="attribute">Obj</span>: com.liuguoquan.design.single.Staff<span class="variable">@70dea4e</span></div></pre></td></tr></table></figure>
<p>从上面代码可以看出，CEO类不能通过new的形式构造函数，只能通过CEO.getCeo()方法来获取，而这个CEO对象是静态对象，并且在声明的时候就已经初始化，这就保证类CEO对象的唯一性。</p>
<p>从输出结果中可以看出，CEO两次输出的CEO对象的地址都一样，说明是同一个CEO对象；而VP、Staff等类型的对象都是不同的。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>饿汉式模式是在声明静态对象时就已经初始化，这种方式简单粗暴，如果单例对象初始化非常快，而且占用内存小的时候这种方式是比较适合的，可以直接在应用启动时加载初始化。实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>懒汉模式是声明一个静态对象，并且在用户第一次调用getInstance时进行初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span>(Singleton.class) &#123;</div><div class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">                instance = <span class="keyword">new</span> Singleton();</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getInstance方法中添加了Synchronized关键字，也就是同步类synchronized关键字包含的代码块，这就是上面所说的在多线程中保证单例对象唯一性的手段。但是仍存在一个问题，<strong>即使instance已经初始化，每次调用getInstance方法都会进行同步，这样会消耗不必要的资源，这也是懒汉式存在的最大问题</strong>。</p>
<p>懒汉单例模式的优点是只有在使用时才会被实例化，在一定程度上节约了资源，缺点是第一次加载时需要及时进行实例化，反应稍慢，最大问题是每次调用geInstance都进行同步，造成不必要的同步开销，这样模式一般不建议使用。</p>
<h3 id="Double-CheckLock-双重校验锁"><a href="#Double-CheckLock-双重校验锁" class="headerlink" title="Double CheckLock(双重校验锁)"></a>Double CheckLock(双重校验锁)</h3><p>DCL方式的优点是既能够在需要时才初始化单例，又能够保证线程的安全，且单例对象初始化后调用getInstance不获取同步锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//private static volatile Singleton instance = null;</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//如果已经初始化，不需要每次获取同步锁</span></div><div class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</div><div class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">                    instance = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到getInstance方法对instance进行了两次判空：第一层判断主要是为了避免不必要的同步，第二层判断主要则是为了在null的情况下创建实例。下面，我们来分析一下：</p>
<p>假设线程A执行到instance=new Singleton()语句，这里看起来是一句代码，但实际上它并不是一个原子操作，这局代码最终会被编译成多条汇编指令，它大致做了3件事情：</p>
<ol>
<li>给Singleton的实例分配内存</li>
<li>调用Singleton()的 构造函数，初始化字段成员</li>
<li>将instance对象执行分配的内存空间（此时instance就不是null了）</li>
</ol>
<p>但是，由于Java编译器运行处理器乱序执行，以及jdk1.5之前Java内存模型中Cache、寄存器到主内存会写顺序的规定，上面的第二和第三的顺序是无法保证的。也就是说，执行顺序可能是1-2-3也可能是1-3-2.如果是后者，并且在3执行完毕、2未执行之前，被切换到线程B上，这时候instance因为已经在线程A内执行3了，instance已经是非null，所有线程B直接取走instance，再使用时就会出错，这就是DCL失效问题，而且这种难以跟踪难以重现的问题很可能会隐藏很久。</p>
<p>在jdk1.5之后，官方已经注意到这种问题，调整了JMM、具体化了volatile关键字，因此，如果是1.5或之后的版本，只需要将instance的定义改成<code>private static volatile Singleton instance = null;</code>就可以保证instance对象每次都是从主内存中读取，就可以使用DCL的写法来完成单例模式。当然，volatile多少会影响到性能，但考虑到程序的正确性，牺牲这点性能还是值得的。</p>
<p>DCL的优点：资源利用率高，第一次执行getInstance时单例对象才会被实例化，效率高。</p>
<p>缺点：第一次加载稍慢，也由于Java内存模型的原因偶尔会失败。在高并发的环境下也有一定的缺陷，虽然概率发生很小。</p>
<blockquote>
<p>DCL模式是使用最多的单例实现模式，它能够在需要时才实例化单例对象，并且能够在绝大多数场景下保证单例对象的唯一性，除非你的代码在并发场景比较复杂或者低于jdk1.6版本下使用，否则这种方式一般能够满足需求。</p>
</blockquote>
<h3 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h3><p>在《Java并发编程实战》中谈到不赞成使用DCL的优化方式，而建议使用如下代码替代：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonHolder.instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//静态内部类</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当第一次加载Singleton类时并不会初始化instance，只有第一次调用Singleton的getInstance方法时才会导致instance被初始化。因此，第一次调用getInstance方法会导致虚拟机加载SingletonHolder类，这种方式不仅能够确保线程安全，也能够保证单例对象的唯一性，同时也延迟了单例的实例化，所以这是推荐使用的单例模式实现方式。</p>
<h3 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</div><div class="line"></div><div class="line">    <span class="comment">//定义一个枚举的元素，它就是Singleton的一个实例</span></div><div class="line">    INSTANCE;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">   Singleton singleton = Singleton.instance;</div><div class="line">   singleton.doSomething();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>写法简单是枚举单例最大的优点，枚举在Java中与普通的类是一样的，不仅能够有字段，还能够有自己的方法。最重要的是默认枚举实例的创建时线程安全的，并且在任何情况下它都是一个单例。</p>
<p>为什么这么说呢？在上述的几种单例模式实现中，在一个情况下它们会出现重新创建对象的情况，那就是反序列化。</p>
<p>通过序列化可以将一个单例的实例对象写到磁盘，然后再读回来，从而有效地获得一个实例。即使构造函数时私有的，反序列化时依然可以通过特殊的途径去创建类的一个新的实例，相当于调用该类的构造函数。反序列化操作提供一个很特别的钩子函数，类中具有一个私有的、被实例化的方法readResolve()，这个方法可以让开发人员控制对象的反序列化。例如，上述几个实例中如果要杜绝单例对象在被反序列化时重新生成对象，那么必须加入如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</div><div class="line">	<span class="keyword">return</span> instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是在readResolve方法中将instance对象返回，而不是默认的重新生成一个新的对象。而对于枚举并不存在这样的问题，因为即使反序列化它也不会重新生成新的实例。</p>
<h3 id="容器管理单例"><a href="#容器管理单例" class="headerlink" title="容器管理单例"></a>容器管理单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; objMap = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key,Object instance)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!objMap.containsKey(key)) &#123;</div><div class="line">            objMap.put(key);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> objMap.get(key);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在程序的初始，将多种单例类注入到一个统一的管理类中，在使用根据key获取对应类型的对象，这种方式使得我们可以管理很多类型的单例，并且在使用它们的时候可以通过统一的接口进行获取操作操作，降低用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单例模式是运用频率很高的模式，但是，由于在客户端通常没有高并发的情况，因此，选择哪种实现方式并不会有太大的影响。即便如此，出于效率考虑，推荐使用双重校验锁和静态内部类单例模式。</p>
<p><strong>优点</strong></p>
<ul>
<li><p>由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁创建、销毁时，而且创建或者销毁时性能又无法优化，单例模式的优势就非常明显。</p>
</li>
<li><p>由于单例模式只生成一个实例，所以，减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永驻内存的方式解决。</p>
</li>
<li><p>单例模式可以避免对资源的多重占用，例如一个写文件操作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。</p>
</li>
<li><p>单例模式可以在系统设置全局访问点，优化和共享资源访问，例如，可以设计一个单例类，负责所有数据表的映射处理。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本没有第二种途径可以实现。</p>
</li>
<li><p>在Android中，单例对象如果持有Context，那么很容易引发内存泄露，此时需要注意传给单例对象的Context最好是Application Context。</p>
</li>
</ul>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list">
			 
        <li class="article-tag-list-item">
        	<a href="javascript:void(0)" class="article-tag-list-link color5">设计模式</a>
        </li>
      
		</ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book icon"></i>
	<a class="article-category-link" href="/categories/设计模式/">设计模式</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/06/03/Android设计模式之(一)单例模式/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Android Context详解" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/02/Android Context详解/">Android Context详解</a>
    </h1>
  

        
        <a href="/2016/06/02/Android Context详解/" class="archive-article-date">
  	<time datetime="2016-06-02T13:20:28.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-06-02 21:20:28</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Activity可以new吗？Android的应用程序开发采用Java语言，Activity本质上也是一个对象，那Activity activity = new Activity()这种写法有什么问题吗？Android应用模型是基于组件的设计模式，组件的运行需要有一个完整的Android工程环境，在这个环境下，Activity、Service等系统组件才能够正常工作，而这些组件并不能采用普通的Java对象创建方式，new一下就能创建实例，而是要有它们各自的上下文环境，也就是我们要介绍的Context。可以这样讲，Context是维持Android程序中各组件能够正常工作的一个核心功能类。</p>
<h1 id="源码中的Context"><a href="#源码中的Context" class="headerlink" title="源码中的Context"></a>源码中的Context</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Interface to global information about an application environment.  This is</div><div class="line"> * an abstract class whose implementation is provided by</div><div class="line"> * the Android system.  It</div><div class="line"> * allows access to application-specific resources and classes, as well as</div><div class="line"> * up-calls for application-level operations such as launching activities,</div><div class="line"> * broadcasting and receiving intents, etc.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * File creation mode: the default mode, where the created file can only</div><div class="line">     * be accessed by the calling application (or all applications sharing the</div><div class="line">     * same user ID).</div><div class="line">     * <span class="doctag">@see</span> #MODE_WORLD_READABLE</div><div class="line">     * <span class="doctag">@see</span> #MODE_WORLD_WRITEABLE</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_PRIVATE = <span class="number">0x0000</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_WORLD_WRITEABLE = <span class="number">0x0002</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_APPEND = <span class="number">0x8000</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MULTI_PROCESS = <span class="number">0x0004</span>;</div><div class="line"></div><div class="line">    .</div><div class="line">    .</div><div class="line">    .</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>源码中的注释是这么来解释Context的：Context提供了关于应用环境全局信息的接口。它是一个抽象类，它的执行被Android系统所提供，它允许获取以应用为特征的资源和类型，是一个统领一些资源的上下文。就是说，它描述一个应用程序环境的信息（即上下文），是一个抽象类，Android提供了该抽象类的具体实现类；通过它我们可以获取应用程序的资源和类（包括应用级别操作，如启动Activity，发广播，接受Intent等）。既然上面Context是一个抽象类，那么肯定有他的实现类，Context抽象类的继承关系如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1187237-1b4c0cd31fd0193f.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></p>
<p>Context类本身是一个纯abstract类，它有两个具体的实现子类：ContextImpl和ContextWrapper。其中ContextWrapper类，如其名所言，这只是一个包装而已，ContextWrapper构造函数中必须包含一个真正的Context引用，同时ContextWrapper中提供了attachBaseContext（）用于给ContextWrapper对象中指定真正的Context对象，调用ContextWrapper的方法都会被转向其所包含的真正的Context对象。ContextThemeWrapper类，如其名所言，其内部包含了与主题（Theme）相关的接口，这里所说的主题就是指在AndroidManifest.xml中通过android：theme为Application元素或者Activity元素指定的主题。当然，只有Activity才需要主题，Service是不需要主题的，因为Service是没有界面的后台场景，所以Service直接继承于ContextWrapper，Application同理。而ContextImpl类则真正实现了Context中的所以函数，应用程序中所调用的各种Context类的方法，其实现均来自于该类。一句话总结：Context的两个子类分工明确，其中ContextImpl是Context的具体实现类，ContextWrapper是Context的包装类。Activity，Application，Service虽都继承自ContextWrapper（Activity继承自ContextWrapper的子类ContextThemeWrapper），但它们初始化的过程中都会创建ContextImpl对象，由ContextImpl实现Context中的方法。</p>
<h1 id="一个应用程序有几个Context"><a href="#一个应用程序有几个Context" class="headerlink" title="一个应用程序有几个Context"></a>一个应用程序有几个Context</h1><p>从上面的关系图可知，在应用程序中Context的具体实现子类就是：Activity、Service、Application。那么context数量 = Activity数量 + Service数量 + 1；而四大组件中BroadcastReceiver和ContentProvider并不是Context的子类，他们所持有的Context都是其他地方传过去的，所以并不计入Context总数。</p>
<h1 id="Context作用"><a href="#Context作用" class="headerlink" title="Context作用"></a>Context作用</h1><p>弹出Toast、启动Activity、启动Service、发送广播、操作数据库等都需要用到Context。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实例化控件</span></div><div class="line">TextView tv = <span class="keyword">new</span> TextView(getContext());</div><div class="line"></div><div class="line">ListAdapter adapter = <span class="keyword">new</span> SimpleCursorAdapter(getApplicationContext(), ...);</div><div class="line"></div><div class="line">AudioManager am = (AudioManager) getContext().getSystemService(Context.AUDIO_SERVICE);getApplicationContext().getSharedPreferences(name, mode);</div><div class="line"></div><div class="line">getApplicationContext().getContentResolver().query(uri, ...);</div><div class="line"></div><div class="line">getContext().getResources().getDisplayMetrics().widthPixels * <span class="number">5</span> / <span class="number">8</span>;</div><div class="line"></div><div class="line">getContext().startActivity(intent);</div><div class="line"></div><div class="line">getContext().startService(intent);</div><div class="line"></div><div class="line">getContext().sendBroadcast(intent);</div></pre></td></tr></table></figure>
<h1 id="Context作用域"><a href="#Context作用域" class="headerlink" title="Context作用域"></a>Context作用域</h1><p>由于Context的具体实例是由ContextImpl类去实现的，因此自绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity、还有弹出Dialog，出于安全的考虑，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，形成返回栈，而Dialog则必须在一个Activity上面弹出（除非是System Alert类型的Dialog），因此在这种场景下，我们只能用Activity类型的Context，否则将会出错。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1187237-fb32b0f992da4781.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></p>
<p>这里说一下上图中Application和Service所不推荐的两种使用情况。</p>
<ul>
<li><p>如果我们用ApplicationContext去启动一个LaunchMode为standard的Activity的时候会报错<code>android.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</code>这是因为非Activity类型的Context并没有所谓的任务栈，所以待启动的Activity就找不到栈了。解决这个问题的方法就是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就为它创建一个新的任务栈，而此时Activity是以singleTask模式启动的。所有这种用Application启动Activity的方式不推荐使用，Service同Application。</p>
</li>
<li><p>在Application和Service中去layout inflate也是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。所以这种方式也不推荐使用。</p>
</li>
</ul>
<p>一句话总结：凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。</p>
<h1 id="获取Context"><a href="#获取Context" class="headerlink" title="获取Context"></a>获取Context</h1><p>通常我们想要获取Context对象，主要有一下四种方法。</p>
<ol>
<li>View.getContext，返回当前View对象的Context对象，通常是正在显示的Activity对象。</li>
<li>Activity.getApplicationContext，获取当前Activity所在的应用进程的Context对象，通常我们使用Context对象时要优先考虑这个全局的进程Context。<br>3.ContextWrapper.getBaseContext()，用来获取一个ContextWrapper进行装饰之前的Context，可以使用这个方法，一般不建议使用</li>
<li>Activity.this，返回当前的Activity实例，如果是UI控件需要使用Activity作为Context对象，但是默认的Toast实际上使用ApplicationContext也可以。</li>
</ol>
<h1 id="getApplication-和getApplicationContext"><a href="#getApplication-和getApplicationContext" class="headerlink" title="getApplication()和getApplicationContext()"></a>getApplication()和getApplicationContext()</h1><p>获取当前Application对象用getApplicationContext，不知道你有没有联想到getApplication()，这两个方法有什么区别？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1187237-593b912ecd199046.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>程序是不会骗人的，我们通过上面的代码，打印得出两者的内存地址都是相同的，看来它们是同一个对象。其实这个结果也很好理解，因为前面已经说过了，Application本身就是一个Context，所以这里获取getApplicationContext()得到的结果就是Application本身的实例。那么问题来了，既然这两个方法得到的结果都是相同的，那么Android为什么要提供两个功能重复的方法呢？实际上这两个方法在作用域上有比较大的区别。<strong>getApplication()方法的语义性非常强，一看就知道是用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。</strong>那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    publicvoidonReceive(Contextcontext,Intentintent)&#123;</div><div class="line">    ApplicationmyApp=(Application)context.getApplicationContext();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Context引起的内存泄露"><a href="#Context引起的内存泄露" class="headerlink" title="Context引起的内存泄露"></a>Context引起的内存泄露</h1><p>Context并不能随便乱用，用的不好有可能会引起内存泄露的问题，下面就示例两种错误的引用方式。</p>
<ul>
<li>错误的单例模式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line">    <span class="keyword">private</span> Context mContext;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mContext = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            instance = <span class="keyword">new</span> Singleton(context);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个非线程安全的单例模式，instance作为静态对象，其生命周期要长于普通的对象，其中也包含Activity，假如Activity A去getInstance获得instance对象，传入this，常驻内存的Singleton保存了你传入的Activity A对象，并一直持有，即使Activity被销毁掉，但因为它的引用还存在于一个Singleton中，就不可能被GC掉，这样就导致了内存泄漏。</p>
<ul>
<li>View持有Activity的引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Drawable mDrawable;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle saveInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(saveInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        ImageView iv = <span class="keyword">new</span> ImageView(<span class="keyword">this</span>);</div><div class="line">        mDrawable = getResources().getDrawable(R.drawable.ic_launcher);</div><div class="line">        iv.setImageDrawable(mDrawable);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有一个静态的Drawable对象当ImageView设置这个Drawable时，ImageView保存了mDrawable的引用，而ImageView传入的this是MainActivity的mContext，因为被static修饰的mDrawable是常驻内存的，MainActivity是它的间接引用，MainActivity被销毁时，也不能被GC掉，所以造成内存泄漏。</p>
<h1 id="正确使用Context"><a href="#正确使用Context" class="headerlink" title="正确使用Context"></a>正确使用Context</h1><p>一般Context造成的内存泄漏，几乎都是当Context销毁的时候，却因为被引用导致销毁失败，而Application的Context对象可以理解为随着进程存在的，所以我们总结出使用Context的正确姿势：</p>
<ol>
<li>当Application的Context能搞定的情况下，并且生命周期长的对象，优先使用Application的Context。</li>
<li>不要让生命周期长于Activity的对象持有到Activity的引用。</li>
<li>尽量不要在Activity中使用非静态内部类，因为非静态内部类会隐式持有外部类实例的引用，如果使用静态内部类，将外部实例引用作为弱引用持有。</li>
</ol>
<h1 id="获取全局Application"><a href="#获取全局Application" class="headerlink" title="获取全局Application"></a>获取全局Application</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyApplication app;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyApplication <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> app;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onCreate();  </div><div class="line">        app = <span class="keyword">this</span>;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Application全局只有一个，它本身就已经是单例了，无需再用单例模式去为它做多重实例保护了,getInstance()方法里面不要做任何逻辑判断，直接返回app对象就可以了，而app对象又是什么呢？在onCreate()方法中我们将app对象赋值成this，this就是当前Application的实例，那么app也就是当前Application的实例了。</p>
<p>参考文章：</p>
<p><a href="http://www.jianshu.com/p/94e0f9ab3f1d" target="_blank" rel="external">Context都没弄明白，还怎么做Android开发？</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list">
			 
        <li class="article-tag-list-item">
        	<a href="javascript:void(0)" class="article-tag-list-link color5">Android系统</a>
        </li>
      
		</ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book icon"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/06/02/Android Context详解/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Android-View的事件分发机制" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/26/Android-View的事件分发机制/">View的事件分发机制</a>
    </h1>
  

        
        <a href="/2016/04/26/Android-View的事件分发机制/" class="archive-article-date">
  	<time datetime="2016-04-26T13:22:52.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-04-26 21:22:52</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="点击事件的传递规则"><a href="#点击事件的传递规则" class="headerlink" title="点击事件的传递规则"></a>点击事件的传递规则</h1><p>首先明确我们这里要分析的对象就是MotionEvent，及点击事件。所谓点击事件的事件分发，其实就是对MotionEvent事件的分发过程，即当一个MotionEvent事件产生了以后，系统需要把这个事件传递给一个具体的View，而这个传递的过程就是分发过程。点击事件的分发过程由三个很重要的方法来共同完成：dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent。</p>
<ul>
<li><strong>public boolean dispatchTouchEvent(MotionEvent event)</strong></li>
</ul>
<p>用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级的dispatchTouchEvent方法的影响，表示是否消耗此事件</p>
<ul>
<li><strong>public boolean onInterceptTouchEvent(MotionEvent event)</strong> //view无此方法，存在于ViewGroup中</li>
</ul>
<p>用来判断是否拦截某个事件，如果当前View拦截某个事件，那么在同一个事件序列中，次方法将不会被再次调用，返回结果表示是否拦截某个事件。</p>
<ul>
<li><strong>public boolean onTouchEvent(MotionEvent event)</strong></li>
</ul>
<p>在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件</p>
<p>上述三个方法到底有什么区别呢？它们是什么关系呢？下面通过一段伪代码来表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> consume = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(onInterceptTouchEvent(ev)) &#123;</div><div class="line"></div><div class="line">		consume = onTouchEvent(ev);</div><div class="line"></div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">		consume = chiled.dispatchTouchEvent(ev);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> consume;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面的伪代码，我们可以大致了解点击事件的传递规则：对已一个跟ViewGroup来说，点击事件产生以后，首先会传递给它，这是它的dispatchTouchEvent就会被调用，如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup的onTouchEvent方法就会被调用；如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此反复直到事件被最终处理。</p>
<p>当一个View需要处理事件时，如果它设置了OnTouchListener，那么OnTouchListener中的OnTouch方法就会被回调，事件如何处理还要看onTouch的返回值，如果返回值为false，则当前View的OnTouchEvent方法会被调用；如果返回为true，则当前View的OnTouchEvent方法不会被调用。由此可见，给View设置的OnTouchListener，其优先级比onTouchEvent要高。在OnTouchEvent方法中，如果当前设置的有OnClickListener，那么它的onClick方法会被调用。可以看出，平时使用的OnClickListener其优先级最低，即处于事件的尾端。</p>
<p>当一个点击事件产生后，它的传递过程遵循如下顺序：Activity &gt; Window &gt; View，即事件总是先传递到Activity。Activity再传递给Window，最后Window再传递给顶级View，顶级View接收到事件后，就会按照事件分发机制去分发事件。</p>
<p>考虑一种情况，如果一个View的OnTouchEvent都返回false，那么它的父容器的OnTouchEvent将会被调用，依次类推，如果所有的子元素都不处理这个事件，那么这个事件将会最终传递给Activity处理，即Activity的OnTouchEvent将会被调用。我们可以用实际生活的例子来描述：假如点击事件是一个难题，这个难题最终被上级领导分给了一个程序员去处理（这是事件分发过程），结果这个程序员搞不定（OnTouchEvent返回false），现在该怎么办呢？程序员只能交给水平更高的程序员去解决（上级的OnTouchEvent被调用），如果上级再搞不定，那只能交给上级的上级去解决，这样就将难题一层层的向上抛，这是公司内部一种很常见的处理问题的过程。</p>
<p>关于事件传递的机制，这里给出一些结论，根据这些揭露可以更好地理解整个传递机制：</p>
<ul>
<li><p>（1）同一个事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束。在这个过程中产生了一系列事件，这个时间序列以down事件开始，中间含有数量不定的move事件，最终以up事件结束。</p>
</li>
<li><p>（2）正常情况下，一个事件序列只能被一个View拦截并且消耗。这一条的原因可以参考（3），因为一旦一个元素拦截了某此事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一个事件序列中的事件不能分别由两个View同时处理，但是通过特殊手段可以做到，比如一个View将本该自己处理的事件通过OnTouchEvent强行传递给其他View处理。</p>
</li>
<li><p>（3）某个View一旦决定拦截，那么这个事件的序列的搜只能由它来处理（如果事件序列能够传递给它的话），并且它的onInterceptTouchEvent方法不会再被调用。就是说当一个View决定拦截一个事件后，那么系统会把同一个事件序列的其他方法都直接交给它来处理，因此就不用再调用这个View的OnInterceptTouchEvent其询问它是否要拦截了。</p>
</li>
<li><p>（4）某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件（onTouchEvent返回了false），那么同一个事件序列中的其他事件都不会再交给它来处理。并且事件将重新交由它的父元素去处理，即父元素的OnTouchEvent会被调用。意思就是事件一旦交给一个View处理，那么它就必须消耗掉，否则同一事件序列中剩下的事件就不再交给它来处理了。</p>
</li>
<li><p>（5）如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件将会消失，此时父元素的OnTouchEvent并不会被调用，并且当前View可以持续受到后续的事件，最终这些消失的点击事件会传递给Activity处理。</p>
</li>
<li><p>（6）ViewGroup默认不拦截任何事件。Android源码中ViewGroup的OnInterceptTouchEvent方法默认返回false</p>
</li>
<li><p>（7）View没有OnInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的OnTouchEvent方法就会被调用</p>
</li>
<li><p>（8）View的OnTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable默认为true，而TextView的clickable属性默认为false。</p>
</li>
<li><p>（9）View的enable属性不影响OnTouchEvent的默认返回值，哪怕一个View是disable状态的，只要它的clickable和longClickable有一个为true，那么它的OnTouchEvent就返回true。</p>
</li>
<li><p>（10）onClick会发生的前提是当前View是可点击的，并且收到了down和up事件</p>
</li>
<li><p>（11）事件传递过程是由外向内的，即事件总是先传递给父元素，然后再有父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</p>
</li>
</ul>
<h1 id="事件分发的源码解析"><a href="#事件分发的源码解析" class="headerlink" title="事件分发的源码解析"></a>事件分发的源码解析</h1><h2 id="Activity对点击事件的分发过程"><a href="#Activity对点击事件的分发过程" class="headerlink" title="Activity对点击事件的分发过程"></a>Activity对点击事件的分发过程</h2><p>点击事件用MotionEvent来表示，当一个点击操作发生时，事件最先传递给当前Activity，由Activity的dispatchTouchEvent来进行事件分发，具体的工作是由Activity内部的Window来完成的。Window会将事件传递给decor view，decor view一般就是当前界面的底层容器（即setContentView所设置的View的父容器），通过Activity.getWindow。getDecorView()可以获得。先从Activity的dispatchTouchEvent开始分析。</p>
<p>源码：Activity#dispatchTouchEvent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">		onUserInteraction();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> onTouchEvent(ev);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析上面的代码。首先事件交给Activity所附属的Window进行分发，如果返回true，整个事件就循环结束了，返回false以为着事件没人处理，所有View的onTouchEvent都返回了false，那么Activity的onTouchEvent就会被调用</p>
<p>接下里看Window是如何将事件传递给ViewGroup的。Window是是个抽象类，而Window的superDispatchTouchEvent方法也是个抽象方法，因此我们必须找到Window的实现类才行</p>
<p>源码：Window#superDispatchTouchEvent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span></span>;</div></pre></td></tr></table></figure>
<p>到底Window的实现类是什么呢？其实是PhoneWindow，Window的唯一实现是android.policy.Window，接下来看一下PhoneWindow是如何处理点击事件的，</p>
<p>源码：PhoneWindow#superDispatchTouchEvent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> DecorView mDecor;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PhoneWindow将事件直接传递给了DecorView，这个DecorView是什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DecorView</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> <span class="keyword">implements</span> <span class="title">RootViewSurfaceTaker</span></span></div><div class="line"></div><div class="line">@<span class="title">Override</span></div><div class="line"><span class="title">public</span> <span class="title">final</span> <span class="title">View</span> <span class="title">getDecorView</span>() &#123;</div><div class="line">	<span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</div><div class="line">		installDecor();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> mDecor;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，这个mDecor就是通过getWindow().getDecor()返回的View，而我们通过setContentView设置的View是它的一个子View。目前事件传递到了DecorView这里，由于DecorView继承自FrameLayout且是父View，所有最终事件会传递到View。换句话说，事件肯定会传递到View，不然应用如何响应点击事件呢？重点是事件到了View以后该如何传递。从这里开始，事件已经传递到顶级View了，即在Activity中通过setContentView所设置的View，另外顶级View也叫根View，顶级View一般来说都是ViewGroup。</p>
<h2 id="顶级View对点击事件的分发过程"><a href="#顶级View对点击事件的分发过程" class="headerlink" title="顶级View对点击事件的分发过程"></a>顶级View对点击事件的分发过程</h2><p>点击事件达到顶级View以后，会调用ViewGroup的dispatchTouchEvent方法，然后逻辑是这样的：如果顶级ViewGroup拦截事件即OnInterceptTouchEvent返回true，则事件由ViewGroup处理，这时如果ViewGroup的OnTouchListener被设置，则onTouch被调用，否则onTouchEvent被调用，也就是说两者都设置的话，onTouch会屏蔽掉OnTouchEvent。在OnTouchEvent中如果设置了OnClickListener，则OnClick会被调用。如果顶级ViewGroup不拦截事件，则事件会传递给它所在的点击事件链上的子View，这时子View的dispatchTouchEvent会被调用。到此，事件已经从顶级View传递给下一层View，接下来的传递过程和顶级View是一致的，如此循环完成整个事件的分发。</p>
<p>首先看ViewGroup对点击事件的分发过程，其主要实现在ViewGroup的dispatchTouchEvent方法中，这个方法较长。先看下面一段，它描述的是View是否拦截点击事件这个逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Check for interception.</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</div><div class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">		|| mFirstTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span> (!disallowIntercept) &#123;</div><div class="line">		intercepted = onInterceptTouchEvent(ev);</div><div class="line">		ev.setAction(action); <span class="comment">// restore action in case it was changed</span></div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		intercepted = <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="comment">// There are no touch targets and this action is not an initial down</span></div><div class="line">	<span class="comment">// so this view group continues to intercept touches.</span></div><div class="line">	intercepted = <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line">`</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出，ViewGroup在如下两种情况下会判断是否要拦截当前事件：事件类为ACTION_DOWN或者mFirstTouchTarget ！= null，mFirstTouchTarget ！= null是什么意思了？当ViewGroup不拦截事件并将事件交由子元素处理时mFirstTouchTarget ！= null 。反过来，一旦事件由当前ViewGroup拦截时，mFirstTouchTarget ！= null就不成立，那么当ACTION_DWON和ACTION_UP事件到来时，由于(actionMasked == MotionEvent.ACTION_DOWN|| mFirstTouchTarget != null)为false，将导致ViewGroup的OnInterceptTouchEvent不会再调用，并且同一序列中的其他事件都会默认交由给它处理。</p>
<p>这里有一种特使情况，那就是FLAG_DISALLOW_INTERCEPT标记位，这个标记位是通过requestDisallowInterceptTouchEvent设置的，一般用于子View中。FLAG_DISALLOW_INTERCEPT一旦设置后，ViewGroup将无法拦截除了ACTION_DOWN以外的其他事件。为什么说是除了ACTION_DOWN意外的其他事件了？这是因为ViewGroup在分发事件时，如果是ACTION_DOWN就会重置FLAG_DISALLOW_INTERCEPT这个标记位，将导致子View中设置的这个标记位无效。因此，当面对ACTION_DOWN事件时，ViewGroup总是会调用自己的OnInterceptTouchEvent方法来询问自己是否要拦截事件。在下面的代码中，ViewGroup会在ACTION_DOWN事件到来时做重置状态的操作，而在resetTouchState方法中会对FLAG_DISALLOW_INTERCEPT进行重置，因此子View调用requestDisallowInterceptTouchEvent方法并不能影响ViewGroup对ACTION_DOWN的处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">	<span class="comment">// Throw away all previous state when starting a new touch gesture.</span></div><div class="line">	<span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></div><div class="line">	<span class="comment">// due to an app switch, ANR, or some other state change.</span></div><div class="line">	cancelAndClearTouchTargets(ev);</div><div class="line">	resetTouchState();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的源码分析，我们可以得出结论：当ViewGroup决定拦截事件后，那么后续的点击事件将会默认交给它处理，并且不再调用它的OnInterceptTouchEvent方法。FLAG_DISALLOW_INTERCEPT这个标志的作用是ViewGroup不再拦截事件，当前前提是ViewGroup不拦截ACTION_DOWN事件。那么这段分析有什么价值呢？总结起来有两点：第一，OnInterceptTouchEvent不是每次事件都会被调用的，如果我们想提前处理所有的点击事件，要选择dispatchTouchEvent方法，只有这个方法能确保每次都会调用，当然前提是事件能够传递到当前的ViewGroup；第二点：FLAG_DISALLOW_INTERCEPT标记位的作用给我们提供了一个思路，当面对滑动冲突时，我们可以是不是考虑用这种方法去解决问题？</p>
<p>接着再看当ViewGroup不拦截事件的时候，事件会向下分发交由它的子View进行处理，这段源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</div><div class="line"><span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</div><div class="line">	<span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</div><div class="line">	<span class="comment">// Find a child that can receive the event.</span></div><div class="line">	<span class="comment">// Scan children from front to back.</span></div><div class="line">	<span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();</div><div class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></div><div class="line">			&amp;&amp; isChildrenDrawingOrderEnabled();</div><div class="line">	<span class="keyword">final</span> View[] children = mChildren;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">		<span class="keyword">final</span> <span class="keyword">int</span> childIndex = customOrder</div><div class="line">				? getChildDrawingOrder(childrenCount, i) : i;</div><div class="line">		<span class="keyword">final</span> View child = (preorderedList == <span class="keyword">null</span>)</div><div class="line">				? children[childIndex] : preorderedList.get(childIndex);</div><div class="line"></div><div class="line">		<span class="comment">// If there is a view that has accessibility focus we want it</span></div><div class="line">		<span class="comment">// to get the event first and if not handled we will perform a</span></div><div class="line">		<span class="comment">// normal dispatch. We may do a double iteration but this is</span></div><div class="line">		<span class="comment">// safer given the timeframe.</span></div><div class="line">		<span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">			childWithAccessibilityFocus = <span class="keyword">null</span>;</div><div class="line">			i = childrenCount - <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (!canViewReceivePointerEvents(child)</div><div class="line">				|| !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</div><div class="line">			ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		newTouchTarget = getTouchTarget(child);</div><div class="line">		<span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="comment">// Child is already receiving touch within its bounds.</span></div><div class="line">			<span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></div><div class="line">			newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		resetCancelNextUpFlag(child);</div><div class="line">		<span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</div><div class="line">			<span class="comment">// Child wants to receive touch within its bounds.</span></div><div class="line">			mLastTouchDownTime = ev.getDownTime();</div><div class="line">			<span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="comment">// childIndex points into presorted list, find original index</span></div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</div><div class="line">					<span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</div><div class="line">						mLastTouchDownIndex = j;</div><div class="line">						<span class="keyword">break</span>;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				mLastTouchDownIndex = childIndex;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		mLastTouchDownX = ev.getX();</div><div class="line">		mLastTouchDownY = ev.getY();</div><div class="line">		newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">		alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先遍历ViewGroup的所有子元素，然后判断子元素是否能够接收到点击事件。是否能够接收到点击事件主要由两点来衡量：子元素是否在播动画和点击事件的坐标是否落在子元素的区域内。如果某个子元素满足这两个条件，那么事件就会传递给它来处理。可以看到dispatchTransformedTouchEvent实际上调用的就是子元素的dispatchTouchEvent方法，在它的内部有一段内容：而在上面的代码中child传递的不是null，因此它会直接调用子元素的dispatchTouchEvent，这样事件就交由子元素处理，从而完成了一轮事件分发。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">	handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	handled = child.dispatchTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果子元素的dispatchTouchEvent返回true，那么，FirstTouchTarget就会被赋值同时跳出for循环，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line"><span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<p>这几行代码就完成了mFirstTouchTarget的赋值并终止对子元素的遍历。如果子元素的dispatchTouchEvent返回false，ViewGroup就会把事件分发给下一个子元素。</p>
<p>其实mFirstTouchTarget真正的赋值过程是在addTouchTarget内部完成的，从下面的addTouchTarget方法的内部结构可以看出，mFirstTouchTarget其实是一种单链表结构。mFirstTouchTarget是否被赋值，将直接影响到ViewGroup对事件的拦截策略，如果mFirstTouchTarget为null，那么ViewGroup就默认拦截接下来同一序列中所有的点击事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> TouchTarget <span class="title">addTouchTarget</span><span class="params">(View child, <span class="keyword">int</span> pointerIdBits)</span> </span>&#123;</div><div class="line">	TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</div><div class="line">	target.next = mFirstTouchTarget;</div><div class="line">	mFirstTouchTarget = target;</div><div class="line">	<span class="keyword">return</span> target;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果遍历所有的子元素后事件都没有合适地处理，这包含两种情况：第一种是ViewGroup没有子元素；第二种是子元素处理了点击事件，但是再dispatchTouchEvent中返回了false，这一般式因为子元素在OnTouchEvent中返回了false。在这两种情况下ViewGroup会自己处理点击事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dispatch to touch targets.</span></div><div class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</div><div class="line">	<span class="comment">// No touch targets so treat this as an ordinary view.</span></div><div class="line">	handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</div><div class="line">			TouchTarget.ALL_POINTER_IDS);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第三个参数child为null，它会调用super.dispatchTouchEvent(event)，很显然，这里就转到了View（不包括ViewGroup）的dispatchTouchEvent方法，即点击事件开始交由View来处理。</p>
<h2 id="View对点击事件的处理过程"><a href="#View对点击事件的处理过程" class="headerlink" title="View对点击事件的处理过程"></a>View对点击事件的处理过程</h2><p>View点击事件的处理过程简单一些，这里的View不包含ViewGroup。先看它的dispatchTouchEvent方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">	<span class="comment">// If the event should be handled by accessibility focus first.</span></div><div class="line">	...</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</div><div class="line">		<span class="comment">//noinspection SimplifiableIfStatement</span></div><div class="line">		ListenerInfo li = mListenerInfo;</div><div class="line">		<span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></div><div class="line">				&amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class="line">				&amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</div><div class="line">			result = <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</div><div class="line">			result = <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	...</div><div class="line"></div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>View对点击事件的处理就比较简单了因为View是一个单独的元素，它没有子元素因此无法向下传递事件，所以它只能自己处理事件。从上面的源码可以看出View对点击事件的处理过程，首先会判断有没有设置OnTouchListener，如果OnTouchListener中的OnTouch方法返回true，那么OnTouchEvent就不会被调用，可见OnTouchListener的优先级高于OnTouchEvent。</p>
<p>接着再分析OnTouchEvent的实现。先看当View出于不可用状态下的点击事件的处理过程，如下所示，不可用状态下的View照样会消耗点击事件，尽管它看起来不可用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</div><div class="line">	<span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">		setPressed(<span class="keyword">false</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// A disabled view that is clickable still consumes the touch</span></div><div class="line">	<span class="comment">// events, it just doesn't respond to them.</span></div><div class="line">	<span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">			(viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着，如果View设置有代理，那么还会执行TouchDelegate的onTouchEvent方法，这个OnTouchEvent的工作机制看起来和OnTouchListener类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</div><div class="line">	<span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面再看一下OnTouchEvent中堆点击事件的具体处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">          (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;</div><div class="line">      <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">          <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">              <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</div><div class="line">              <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</div><div class="line">                  <span class="comment">// take focus if we don't have it already and we should in</span></div><div class="line">                  <span class="comment">// touch mode.</span></div><div class="line">                  <span class="keyword">boolean</span> focusTaken = <span class="keyword">false</span>;</div><div class="line">                  <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</div><div class="line">                      focusTaken = requestFocus();</div><div class="line">                  &#125;</div><div class="line">	</div><div class="line">                  <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                      <span class="comment">// The button is being released before we actually</span></div><div class="line">                      <span class="comment">// showed it as pressed.  Make it show the pressed</span></div><div class="line">                      <span class="comment">// state now (before scheduling the click) to ensure</span></div><div class="line">                      <span class="comment">// the user sees it.</span></div><div class="line">                      setPressed(<span class="keyword">true</span>, x, y);</div><div class="line">                 &#125;</div><div class="line">	</div><div class="line">                  <span class="keyword">if</span> (!mHasPerformedLongPress) &#123;</div><div class="line">                      <span class="comment">// This is a tap, so remove the longpress check</span></div><div class="line">                      removeLongPressCallback();</div><div class="line">	</div><div class="line">                      <span class="comment">// Only perform take click actions if we were in the pressed state</span></div><div class="line">                      <span class="keyword">if</span> (!focusTaken) &#123;</div><div class="line">                          <span class="comment">// Use a Runnable and post this rather than calling</span></div><div class="line">                          <span class="comment">// performClick directly. This lets other visual state</span></div><div class="line">                          <span class="comment">// of the view update before click actions start.</span></div><div class="line">                          <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</div><div class="line">                              mPerformClick = <span class="keyword">new</span> PerformClick();</div><div class="line">                          &#125;</div><div class="line">                          <span class="keyword">if</span> (!post(mPerformClick)) &#123;</div><div class="line">                              performClick();</div><div class="line">                          &#125;</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">	</div><div class="line">                  <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;</div><div class="line">                      mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();</div><div class="line">                  &#125;</div><div class="line">	</div><div class="line">                  <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                      postDelayed(mUnsetPressedState,</div><div class="line">                              ViewConfiguration.getPressedStateDuration());</div><div class="line">                  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!post(mUnsetPressedState)) &#123;</div><div class="line">                      <span class="comment">// If the post failed, unpress right now</span></div><div class="line">                      mUnsetPressedState.run();</div><div class="line">                  &#125;</div><div class="line">	</div><div class="line">                  removeTapCallback();</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">	</div><div class="line">          <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">              mHasPerformedLongPress = <span class="keyword">false</span>;</div><div class="line">	</div><div class="line">              <span class="keyword">if</span> (performButtonActionOnTouchDown(event)) &#123;</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line">              &#125;</div><div class="line">	</div><div class="line">              <span class="comment">// Walk up the hierarchy to determine if we're inside a scrolling container.</span></div><div class="line">              <span class="keyword">boolean</span> isInScrollingContainer = isInScrollingContainer();</div><div class="line">	</div><div class="line">              <span class="comment">// For views inside a scrolling container, delay the pressed feedback for</span></div><div class="line">              <span class="comment">// a short period in case this is a scroll.</span></div><div class="line">              <span class="keyword">if</span> (isInScrollingContainer) &#123;</div><div class="line">                  mPrivateFlags |= PFLAG_PREPRESSED;</div><div class="line">                  <span class="keyword">if</span> (mPendingCheckForTap == <span class="keyword">null</span>) &#123;</div><div class="line">                      mPendingCheckForTap = <span class="keyword">new</span> CheckForTap();</div><div class="line">                  &#125;</div><div class="line">                  mPendingCheckForTap.x = event.getX();</div><div class="line">                  mPendingCheckForTap.y = event.getY();</div><div class="line">                  postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</div><div class="line">              &#125; <span class="keyword">else</span> &#123;</div><div class="line">                  <span class="comment">// Not inside a scrolling container, so show the feedback right away</span></div><div class="line">                  setPressed(<span class="keyword">true</span>, x, y);</div><div class="line">                  checkForLongClick(<span class="number">0</span>);</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">	</div><div class="line">          <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</div><div class="line">              setPressed(<span class="keyword">false</span>);</div><div class="line">              removeTapCallback();</div><div class="line">              removeLongPressCallback();</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">	</div><div class="line">          <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">              drawableHotspotChanged(x, y);</div><div class="line">	</div><div class="line">              <span class="comment">// Be lenient about moving outside of buttons</span></div><div class="line">              <span class="keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</div><div class="line">                  <span class="comment">// Outside button</span></div><div class="line">                  removeTapCallback();</div><div class="line">                  <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">                      <span class="comment">// Remove any future long press/tap checks</span></div><div class="line">                      removeLongPressCallback();</div><div class="line">	</div><div class="line">                      setPressed(<span class="keyword">false</span>);</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">	</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>只要View的Clickable和longClickable有一个为true，那么就会消耗这个事件，即OnTouchEvent返回true，不管它是不是disable状态。然后就是当ACTION_UP事件发生时会触发performClick方法，如果View设置了OnClickListener，那么performClick方法内部会调用它的onClick方法，如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> result;</div><div class="line">	<span class="keyword">final</span> ListenerInfo li = mListenerInfo;</div><div class="line">	<span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</div><div class="line">		playSoundEffect(SoundEffectConstants.CLICK);</div><div class="line">		li.mOnClickListener.onClick(<span class="keyword">this</span>);</div><div class="line">		result = <span class="keyword">true</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		result = <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>View的LONG_CLICKABLE属性默认为false，而CLICKABLE属性是否为false和具体的View有关，确切来说是可点击的View其CLICKABLE为true，不可点击的View其CLICKABLE为false。通过setClickable和setLongClickable可以改变View的LONG_CLICKABLE、CLICKABLE属性。另外，setOnClickListener和setOnLongClickListener会自动将View的LONG_CLICKABLE、CLICKABLE属性设置为true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnClickListener</span><span class="params">(OnClickListener l)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (!isClickable()) &#123;</div><div class="line">		setClickable(<span class="keyword">true</span>);</div><div class="line">	&#125;</div><div class="line">	getListenerInfo().mOnClickListener = l;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnLongClickListener</span><span class="params">(OnLongClickListener l)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (!isLongClickable()) &#123;</div><div class="line">		setLongClickable(<span class="keyword">true</span>);</div><div class="line">	&#125;</div><div class="line">	getListenerInfo().mOnLongClickListener = l;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list">
			 
        <li class="article-tag-list-item">
        	<a href="javascript:void(0)" class="article-tag-list-link color5">Android系统</a>
        </li>
      
		</ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book icon"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/04/26/Android-View的事件分发机制/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Android-View的工作流程" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/26/Android-View的工作流程/">View的工作流程</a>
    </h1>
  

        
        <a href="/2016/04/26/Android-View的工作流程/" class="archive-article-date">
  	<time datetime="2016-04-26T13:22:34.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-04-26 21:22:34</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>View的工作流程主要指measure、layout、draw这三大流程，即测量、布局和绘制，其中measure确定View的测量宽/高，layout确定View的最终宽/高和四个顶点的位置（即View在父容器中的放置位置），draw则将View绘制到屏幕上。</p>
<h1 id="measure过程"><a href="#measure过程" class="headerlink" title="measure过程"></a>measure过程</h1><p>measure过程要分情况来看，如果只是一个原始的View，那么通过measure方法就完成了其测量的过程，如果是一个ViewGroup，除了完成自己的测量过程外，还会遍历去调用所有子元素的measure方法，各个子元素再递归去执行这个流程。</p>
<h2 id="View的测量过程"><a href="#View的测量过程" class="headerlink" title="View的测量过程"></a>View的测量过程</h2><p>View的measure过程是由其measure方法来完成，measure方法是一个final类型的方法，这意味着子类不能重写此方法，在View的measure方法中会去调用View的onMeasure方法，因此只需要看onMeasure的实现即可，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">	setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">			getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上所示，setMeasuredDimension方法会设置View宽/高的测量值，因此我们只需要看getDefaultSize这个方法即可：</p>
<h2 id="测量的三种模式"><a href="#测量的三种模式" class="headerlink" title="测量的三种模式"></a>测量的三种模式</h2><ol>
<li><p>EXACTLY：精确值模式<br>当我们将控件的layout_width或layout_height属性指定为具体的数值时，或指定为match_parent属性时，系统使用的是EXACTLY模式。</p>
</li>
<li><p>AT_MOST：最大值模式<br>当我们将控件的layout_width或layout_height属性指定为wrap_content时,系统使用的是AT_MOST模式  </p>
</li>
<li><p>UNSPECIFIED：<br>此模式不指定其大小测量模式，View想多大就多大，通常情况系统绘制自定义View时才会使用  </p>
</li>
</ol>
<p><strong>Note:: View类默认的onMeasure()方法只支持EXACTLY模式，而如果要让自定义View支持wrap_content属性时，那么必须重写onMeasure()方法来指定wrap_content的大小</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> result = size;</div><div class="line">	<span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec); <span class="comment">//测量模式</span></div><div class="line">	<span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec); <span class="comment">//绘制的大小</span></div><div class="line"></div><div class="line">	<span class="keyword">switch</span> (specMode) &#123;</div><div class="line">	<span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">		result = size;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="keyword">case</span> MeasureSpec.AT_MOST: <span class="comment">//重写指定AT_MOST模式的值</span></div><div class="line">	<span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">		result = specSize;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，其实getDefaultSize返回的大小就是measureSpec中的specSize，而这个specSize就是View测量后的大小，这里多次提到测量后的大小是因为View的最终大小是在layout阶段确定的，所以必须加以区分，但是几乎所有情况下View的测量大小和最终大小是相等的。</p>
<p>在上述情况下，View的大小为getDefaultSize的第一个参数size，及宽高分别为getSuggestedMinimumWidth和getSuggestedMinimumHeight的返回值，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="layout过程"><a href="#layout过程" class="headerlink" title="layout过程"></a>layout过程</h1><p>Layout的作用是ViewGroup用来确定子元素的位置，当ViewGroup的位置被确定后，它在onLayout中会遍历所有子元素并调用其layout方法，View的layout方法中onLayout方法又会被调用。layout方法确定View本身的位置，而onLayout方法则会确定所有子元素的位置，View的layout方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</div><div class="line">		onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class="line">		mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> oldL = mLeft;</div><div class="line">	<span class="keyword">int</span> oldT = mTop;</div><div class="line">	<span class="keyword">int</span> oldB = mBottom;</div><div class="line">	<span class="keyword">int</span> oldR = mRight;</div><div class="line"></div><div class="line">	<span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</div><div class="line">			setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">		onLayout(changed, l, t, r, b);</div><div class="line">		mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">		ListenerInfo li = mListenerInfo;</div><div class="line">		<span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</div><div class="line">			ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">					(ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">			<span class="keyword">int</span> numListeners = listenersCopy.size();</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">				listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class="line">	mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>layout方法大致流程如下：首先通过setFrame方法设定View的四个顶点的位置，即初始化mLeft、mTop、mBottom、mRight这四个值，View的四个顶点一旦确定，那么View在父容器的位置也就确定了；接着会调用onLayout方法，用途是父容器确定子元素的位置，和onMeasure方法类似，onLayout的具体实现同样和具体的布局有关，所以View和ViewGroup均没有真正的实现。我们可以看一下TextView的onLayout方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</div><div class="line">	<span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</div><div class="line">	<span class="keyword">if</span> (mDeferScroll &gt;= <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">int</span> curs = mDeferScroll;</div><div class="line">		mDeferScroll = -<span class="number">1</span>;</div><div class="line">		bringPointIntoView(Math.min(curs, mText.length()));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="draw过程"><a href="#draw过程" class="headerlink" title="draw过程"></a>draw过程</h1><p>Draw过程较简单，作用是将View绘制到屏幕上面。</p>
<p>当测量好一个View之后，我们就可以重写onDraw方法，并在Canvas对象上绘制所需要的图形，最终显示在屏幕上。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list">
			 
        <li class="article-tag-list-item">
        	<a href="javascript:void(0)" class="article-tag-list-link color5">Android系统</a>
        </li>
      
		</ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book icon"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/04/26/Android-View的工作流程/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Android的消息机制" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/26/Android的消息机制/">Android的消息机制</a>
    </h1>
  

        
        <a href="/2016/04/26/Android的消息机制/" class="archive-article-date">
  	<time datetime="2016-04-26T13:20:28.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-04-26 21:20:28</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android的消息机制概述"><a href="#Android的消息机制概述" class="headerlink" title="Android的消息机制概述"></a>Android的消息机制概述</h1><p>Android的消息机制主要是指Handler的运行机制，Handler的运行机制需要底层的MessageQueue和Looper的支撑。</p>
<p>MessageQueue的中文为消息队列，顾名思义，它的内部存储了一组消息，以队列的形式对外提供插入和删除的方法。虽然称为消息队列，但是它的<strong>内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息列表</strong>。</p>
<p>Looper的中文翻译是循环，这里可以理解为消息循环。由于MessageQueue只是一个消息的存储单元，它不能去处理消息，而Looper会以无限循环的形式其查询是否有新的消息，如果有的话就处理消息，否则就一直等待。</p>
<p>Looper中还有一个特殊的概念，那就是ThreadLocal，ThreadLocal并不是线程，它的作用是可以在每个线程中存储数据。我们知道，Handler创建的时候会采用当前线程的Looper来构造消息循环系统，那么Handler内部如何获取到当前线程的Looper呢？这就要使用ThreadLocal了，ThreadLocal可以在不同的线程中互不干扰地存储并提供数据，通过ThreadLocal就可以轻松地获取每个线程的Looper。</p>
<p>需要注意的是，线程是默认没有Looper的，如果需要使用Handler就必须为线程创建Looper。而主线程，即UI线程，它就是ActivityThread，ActivityThread被创建时就会初始化Looper，这也是在主线程中默认可以使用Handler的原因。</p>
<h1 id="Android消息机制分析"><a href="#Android消息机制分析" class="headerlink" title="Android消息机制分析"></a>Android消息机制分析</h1><p>Android消息机制主要是指Handler的运行机制以及Handler所附带的MessageQueue和Looper的工作过程，这三者实际上是一个整体。<strong>Handler的作用</strong>主要是将一个任务切换到某个指定的线程中去执行，那么Android为什么要提供这个功能呢？<strong>这是因为Android规定UI只能在主线程中进行，如果在子线程中访问UI，那么程序就会抛出运行时异常。</strong>ViewRootImp对UI操作做了验证，这个验证工作是由ViewRootImpl的checkThread方法来完成的，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(mThread != Thread.currentThread()) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(<span class="string">"Only the original thread that created a view hiearachy can touch its view"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Android建议我们不要在主线程中进行耗时的操作，否则会导致程序无法响应ANR。考虑一种情况，假如我们需要从服务器拉取一些信息并将其显示在UI上，这个时候必须在子线程中进行拉取工作，拉取完毕之后又不能在子线程中直接访问UI，如果没有Handler，那么我们确实没有办法将访问UI的工作切换到主线程中执行，因此，系统提供Handler的主要原因及时为了解决在子线程中无法访问UI的矛盾。</p>
<p><strong>系统为什么不允许在子线程中访问UI呢？</strong>这是 因为Android的UI控件不是线程安全的，如果在多线程中并发访问可能会导致UI控件处于不可预期的状态，而为什么系统不对UI控件的访问加上锁机制呢？缺点有两个：首先加上锁机制会让UI访问的逻辑变得复杂，其次锁机制会降低UI访问的效率，因为锁机制会阻塞某些线程的执行。因此最简单最高效的方法就是采用单线程模型来处理UI操作，对于开发者来说也不是很麻烦，只是需要通过Handler切换到UI访问的执行线程即可。</p>
<p>Handler的工作过程：Handler创建时会采用当前线程的Looper来构建内部的消息循环系统，如果当前线程没有Looper，那么就会报错；Handler创建完毕后，这个时候其内部的MessageQueue和Looper就可以协同工作了，然后通过Handler的post方法将一个Runnable传递到Handler内部的Looper中去处理，也可以通过Handler的send方法来发送一个消息，这个消息同样会在Looper中去处理。其实post方法最终也是在send方法中完成的。当Handler的send方法被调用时，它会调用MessageQueue的enqueueMessage方法将这个消息放入消息队列中，然后Looper发现有新消息到来时，就会处理这个消息，最终消息中的Runnable或者Handler的handleMessage方法就会被调用。</p>
<p>注意：Looper是运行在创建Handler所在的线程中的，这样一来Handler中的业务逻辑就被切换到创建Handler所在的线程中去执行了。</p>
<h2 id="ThreadLocal的工作原理"><a href="#ThreadLocal的工作原理" class="headerlink" title="ThreadLocal的工作原理"></a>ThreadLocal的工作原理</h2><p>ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。</p>
<p>下面通过实际的例子来演示ThreadLocal的作用。首先定义一个ThreadLocal对象，这里选择Boolean类型的，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ThreadLocal&lt;Boolean&gt; mThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Boolean&gt;();</div></pre></td></tr></table></figure></p>
<p>然后在主线程、子线程1和子线程2中设置和访问它的值，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">   mThreadLocal.set(<span class="keyword">true</span>);</div><div class="line">   System.out.println(<span class="string">"main thread: "</span> + mThreadLocal.get()); <span class="comment">//true</span></div><div class="line">   </div><div class="line">   <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		mThreadLocal.set(<span class="keyword">false</span>);</div><div class="line">		System.out.println(<span class="string">"thread 1: "</span> + mThreadLocal.get()); <span class="comment">//false</span></div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;).start();</div><div class="line">   </div><div class="line">   <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		</div><div class="line">		System.out.println(<span class="string">"thread 2: "</span> + mThreadLocal.get()); <span class="comment">//null，没有设置值</span></div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<p>上述代码中，根据对ThreadLocal的描述，主线中mThreadLocal.get()为true，子线程1中mThreadLocal.get()为false，子线程2中mThreadLocal.get()为null。代码运行打印如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">15</span>:54:55.478: I/System.out(11711): main thread: <span class="keyword">true</span></div><div class="line">01-09 15:54:55.479: I/System.out(11711): thread 1: <span class="keyword">false</span></div><div class="line">01-09 15:54:55.480: I/System.out(11711): thread 2: <span class="keyword">null</span></div></pre></td></tr></table></figure>
<p><strong>从上面的打印可以看出</strong>，虽然不同的线程访问的是同一个ThreadLocal对象，但是它们通过ThreadLocal获取的值却是不一样的，这就是ThreadLocal的特点。ThreadLocal之所以有如此特点，是因为不同线程访问同一个ThreadLocal的get方法，ThreadLocal内部会从各自的线程中取出一个数组，然后再从数组中根据当前的ThreadLocal索引去查找对应的value值。很显然，不同线程中的数组是不同的，这就是为什么通过ThreadLocal可以在不同的线程中维护一套数据的副本并且互不干扰。</p>
<p>上面描述的ThreadLocal的使用方法和工作过程，下面分析ThreadLocal的内部实现，ThreadLocal是一个泛型类，它的定义为<code>public class ThreadLocal&lt;T&gt;</code>，只要弄清楚ThreadLocal的get和set方法就可以明白它的工作原理。</p>
<p>首先看get和set方法，如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">    Thread currentThread = Thread.currentThread();</div><div class="line">    Values values = values(currentThread);</div><div class="line">    <span class="keyword">if</span> (values == <span class="keyword">null</span>) &#123;</div><div class="line">        values = initializeValues(currentThread);</div><div class="line">    &#125;</div><div class="line">    values.put(<span class="keyword">this</span>, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Values <span class="title">initializeValues</span><span class="params">(Thread current)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> current.localValues = <span class="keyword">new</span> Values();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Gets Values instance for this thread and variable type.</div><div class="line"> */</div><div class="line"><span class="function">Values <span class="title">values</span><span class="params">(Thread current)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> current.localValues;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的set方法中，首先会通过values方法来获取当前线程中的ThreadLocal数据，<strong>如何获取呢？</strong>在Thread内部有一个成员变量专门用于存储线程的ThreadLocal数据：ThreadLocal.Values localValues;因此获取当前线程的ThreadLocal数据就变得异常简单。如果localValues的值为null，那么久需要对其进行初始化化，初始化后再将ThreadLocal的值进行存储。</p>
<p>下面看一下ThreadLocal的值到底是如何在localValues中进行存储的。在localValues内部有一个数组：private Object[] table;ThreadLocal的值就存储在这个table数组中。下面看一下localValues是如何使用put方法将ThreadLocal的值存储到table数组中的，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Sets entry for given ThreadLocal to given value, creating an</div><div class="line"> * entry if necessary.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</div><div class="line">    cleanUp();</div><div class="line"></div><div class="line">    <span class="comment">// Keep track of first tombstone. That's where we want to go back</span></div><div class="line">    <span class="comment">// and add an entry if necessary.</span></div><div class="line">    <span class="keyword">int</span> firstTombstone = -<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = key.hash &amp; mask;; index = next(index)) &#123;</div><div class="line">        Object k = table[index];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (k == key.reference) &#123;</div><div class="line">            <span class="comment">// Replace existing entry.</span></div><div class="line">            table[index + <span class="number">1</span>] = value;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (firstTombstone == -<span class="number">1</span>) &#123;</div><div class="line">                <span class="comment">// Fill in null slot.</span></div><div class="line">                table[index] = key.reference;</div><div class="line">                table[index + <span class="number">1</span>] = value;</div><div class="line">                size++;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Go back and replace first tombstone.</span></div><div class="line">            table[firstTombstone] = key.reference;</div><div class="line">            table[firstTombstone + <span class="number">1</span>] = value;</div><div class="line">            tombstones--;</div><div class="line">            size++;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Remember first tombstone.</span></div><div class="line">        <span class="keyword">if</span> (firstTombstone == -<span class="number">1</span> &amp;&amp; k == TOMBSTONE) &#123;</div><div class="line">            firstTombstone = index;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码实现了数据的存储过程，我们可以由上可以得出一个存储规则，那就是ThreadLocal的值在table数组中的存储位置总是为ThreadLocal的reference字段所标识的对象的下一个位置，比如ThreadLocal的reference对在table数组中的索引为index，那么ThreadLocal的值在table数组中的索引就是index+1.最终ThreadLocal的值会被存储在table数组中：table[index + 1] = value;</p>
<p>接下来，分析get方法，如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Optimized for the fast path.</span></div><div class="line">    Thread currentThread = Thread.currentThread();</div><div class="line">    Values values = values(currentThread);</div><div class="line">    <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;</div><div class="line">        Object[] table = values.table;</div><div class="line">        <span class="keyword">int</span> index = hash &amp; values.mask;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.reference == table[index]) &#123;</div><div class="line">            <span class="keyword">return</span> (T) table[index + <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        values = initializeValues(currentThread);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (T) values.getAfterMiss(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现，ThreadLocal的get方法同样是取出当前线程的localValues对象，如果这个对象不为null，那就取出它的table数组并找出ThreadLocal的reference对象在table数组中的位置，然后table数组中下一个位置所存储的数据就是ThreadLocal的值。如果这个对象为null，则返回初始值，初始值由ThreadLocal的initialValue方法来描述，默认情况下为null，当然也可以重写这个方法，它的默认实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function">Object <span class="title">getAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</div><div class="line">    Object[] table = <span class="keyword">this</span>.table;</div><div class="line">    <span class="keyword">int</span> index = key.hash &amp; mask;</div><div class="line"></div><div class="line">    <span class="comment">// If the first slot is empty, the search is over.</span></div><div class="line">    <span class="keyword">if</span> (table[index] == <span class="keyword">null</span>) &#123;</div><div class="line">        Object value = key.initialValue();</div><div class="line"></div><div class="line">        <span class="comment">// If the table is still the same and the slot is still empty...</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.table == table &amp;&amp; table[index] == <span class="keyword">null</span>) &#123;</div><div class="line">            table[index] = key.reference;</div><div class="line">            table[index + <span class="number">1</span>] = value;</div><div class="line">            size++;</div><div class="line"></div><div class="line">            cleanUp();</div><div class="line">            <span class="keyword">return</span> value;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// The table changed during initialValue().</span></div><div class="line">        put(key, value);</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>从ThreadLocal的set和get方法可以看出，它们所操作的对象都是当前线程的Values对象的table数组，因此在不同的线程中访问同一个ThreadLocal的set和get方法，它们对ThreadLocal所在的读/写权限仅限各自线程的内部，这就是ThreadLocal可以在不同线程中互不干扰的储存和修改数据的原因，理解ThreadLocal的工作方式有助于理解Looper的工作原理。</p>
</blockquote>
<h2 id="MessageQueue的工作原理"><a href="#MessageQueue的工作原理" class="headerlink" title="MessageQueue的工作原理"></a>MessageQueue的工作原理</h2><p>消息队列在Android中指的是MessageQueue，MessageQueue主要包括两个操作：插入和读取，读取操作会伴随着删除操作，插入和读取的方法分别是enqueueMessage和next，其中enqueueMessage的作用往往是往消息队列中插入一条消息，而next的作用是往消息队列中取出一条消息并将其从消息队列中移除。尽管MessageQueue叫消息队列，但是它的内部实现不是用的队列，而是通过一个单链表的数据结构来维护消息列表，单链表在插入和删除上效率较高。enqueueMessage的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (msg.isInUse()) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">		<span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">			IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</div><div class="line">					msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</div><div class="line">			Log.w(<span class="string">"MessageQueue"</span>, e.getMessage(), e);</div><div class="line">			msg.recycle();</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		msg.markInUse();</div><div class="line">		msg.when = when;</div><div class="line">		Message p = mMessages;</div><div class="line">		<span class="keyword">boolean</span> needWake;</div><div class="line">		<span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</div><div class="line">			<span class="comment">// New head, wake up the event queue if blocked.</span></div><div class="line">			msg.next = p;</div><div class="line">			mMessages = msg;</div><div class="line">			needWake = mBlocked;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">// Inserted within the middle of the queue.  Usually we don not have to wake</span></div><div class="line">			<span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></div><div class="line">			<span class="comment">// and the message is the earliest asynchronous message in the queue.</span></div><div class="line"></div><div class="line">			needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</div><div class="line">			Message prev;</div><div class="line">			<span class="keyword">for</span> (;;) &#123;</div><div class="line">				prev = p;</div><div class="line">				p = p.next;</div><div class="line">				<span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">					needWake = <span class="keyword">false</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			msg.next = p; <span class="comment">// invariant: p == prev.next</span></div><div class="line">			prev.next = msg;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></div><div class="line">		<span class="keyword">if</span> (needWake) &#123;</div><div class="line">			nativeWake(mPtr);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从enqueueMessage的实现来看，它的主要操作就是单链表的插入和删除，下面看一下next方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"> <span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">// Return here if the message loop has already quit and been disposed.</span></div><div class="line">      <span class="comment">// This can happen if the application tries to restart a looper after quit</span></div><div class="line">      <span class="comment">// which is not supported.</span></div><div class="line">      <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</div><div class="line">      <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></div><div class="line">      <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line"><span class="comment">//死循环</span></div><div class="line">      <span class="keyword">for</span> (;;) &#123;</div><div class="line">          <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</div><div class="line">              Binder.flushPendingCommands();</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class="line"></div><div class="line">          <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">              <span class="comment">// Try to retrieve the next message.  Return if found.</span></div><div class="line">              <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">              Message prevMsg = <span class="keyword">null</span>;</div><div class="line">              Message msg = mMessages;</div><div class="line">              <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">                  <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></div><div class="line">                  <span class="keyword">do</span> &#123;</div><div class="line">                      prevMsg = msg;</div><div class="line">                      msg = msg.next;</div><div class="line">                  &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</div><div class="line">                  <span class="keyword">if</span> (now &lt; msg.when) &#123;</div><div class="line">                      <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></div><div class="line">                      nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                  &#125; <span class="keyword">else</span> &#123;</div><div class="line">                      <span class="comment">// Got a message.</span></div><div class="line">                      mBlocked = <span class="keyword">false</span>;</div><div class="line">                      <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</div><div class="line">                          prevMsg.next = msg.next;</div><div class="line">                      &#125; <span class="keyword">else</span> &#123;</div><div class="line">                          mMessages = msg.next;</div><div class="line">                      &#125;</div><div class="line">                      msg.next = <span class="keyword">null</span>;</div><div class="line">                      <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(<span class="string">"MessageQueue"</span>, <span class="string">"Returning message: "</span> + msg);</div><div class="line">                      <span class="keyword">return</span> msg;</div><div class="line">                  &#125;</div><div class="line">              &#125; <span class="keyword">else</span> &#123;</div><div class="line">                  <span class="comment">// No more messages.</span></div><div class="line">                  nextPollTimeoutMillis = -<span class="number">1</span>;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="comment">// Process the quit message now that all pending messages have been handled.</span></div><div class="line">              <span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">                  dispose();</div><div class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="comment">// If first time idle, then get the number of idlers to run.</span></div><div class="line">              <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></div><div class="line">              <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></div><div class="line">              <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></div><div class="line">                      &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</div><div class="line">                  pendingIdleHandlerCount = mIdleHandlers.size();</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</div><div class="line">                  <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></div><div class="line">                  mBlocked = <span class="keyword">true</span>;</div><div class="line">                  <span class="keyword">continue</span>;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</div><div class="line">                  mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</div><div class="line">              &#125;</div><div class="line">              mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="comment">// Run the idle handlers.</span></div><div class="line">          <span class="comment">// We only ever reach this code block during the first iteration.</span></div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</div><div class="line">              <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</div><div class="line">              mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></div><div class="line"></div><div class="line">              <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</div><div class="line">              <span class="keyword">try</span> &#123;</div><div class="line">                  keep = idler.queueIdle();</div><div class="line">              &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">                  Log.wtf(<span class="string">"MessageQueue"</span>, <span class="string">"IdleHandler threw exception"</span>, t);</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (!keep) &#123;</div><div class="line">                  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                      mIdleHandlers.remove(idler);</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></div><div class="line">          pendingIdleHandlerCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">          <span class="comment">// While calling an idle handler, a new message could have been delivered</span></div><div class="line">          <span class="comment">// so go back and look again for a pending message without waiting.</span></div><div class="line">          nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>可以发现next方法是一个无限循环的过程，如果消息队列中没有消息，那么next方法会一直阻塞在这里。当有新的消息到来时，next方法会返回这条消息并将其从单链表中移除。</p>
<h2 id="Looper的工作原理"><a href="#Looper的工作原理" class="headerlink" title="Looper的工作原理"></a>Looper的工作原理</h2><p>Looper在Android消息机制里面扮演着消息循环的角色，具体来说它会不停地从MessageQueue中查看是否有新消息，如有有新消息就会立刻处理，否则就会一直阻塞在那里。<br>首先看一下Looper的构造函数，在构造方法中它会创建一个MessageQueue即消息队列，然后将当前线程的对象存储起来，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">	&#125;</div><div class="line">	sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">	mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</div><div class="line">	mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Handler的工作需要Looper，没有Looper的线程就会报错，那么如何为一个线程创建Looper呢？通过Looper.prepare()即可为当前线程创建一个Looper，接着通过Looper.loop()来开启消息循环，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		Looper.prepare(); <span class="comment">//创建Looper</span></div><div class="line">		mHandler = <span class="keyword">new</span> Handler()&#123;</div><div class="line">			</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				<span class="keyword">super</span>.handleMessage(msg);</div><div class="line">				</div><div class="line">				<span class="keyword">if</span> (msg.what == <span class="number">0</span>) &#123;</div><div class="line">					</div><div class="line">					System.out.println(<span class="string">"msg: "</span> + <span class="string">"123456"</span>); </div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">		Looper.loop(); <span class="comment">//开启Looper循环</span></div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;).start();</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 发送消息</div><div class="line">    * <span class="doctag">@param</span> view</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">   	</div><div class="line">   	mHandler.sendEmptyMessage(<span class="number">0</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 退出Looper循环</div><div class="line">    * <span class="doctag">@param</span> view</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">   	mHandler.getLooper().quit();</div><div class="line">	mHandler.getLooper().quitSafely(); <span class="comment">//API18</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>Looper除了prepare方法外，还提供了prepareMainLooper()方法，这个方法主要是给主线程也就是ActivityThread创建Looper使用的，其本质也是通过prepare方法创建的。由于主线程的Looper比较特殊，所以Looper提供了一个getMainLooper方法，通过它可以在任何位置获取主线程Looper。</p>
<p>Looper也是可以退出的，Looper提供了quit和quitSafely来退出一个Looper，二者的区别在于：quit会直接退出Looper，而quitSafely只是设定一个退出标志，然后把消息队列中的已有消息处理完毕后才安全地退出。Looper退出后，提供Handler发送的消息会失败，这时Handler的send方法返回false。在子线程中，如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来终止消息循环，否则这个子线程会一直处于等待状态，而如果推出Looper以后，这个线程就会立刻终止，因此建议不需要的时候终止Looper。</p>
<p>Looper最重要的一个方法是loop方法，只有调用了loop后，消息循环系统才会真正的运行，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * Run the message queue in this thread. Be sure to call</div><div class="line">  * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">     <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">     <span class="comment">// Make sure the identity of this thread is that of the local process,</span></div><div class="line">     <span class="comment">// and keep track of what that identity token actually is.</span></div><div class="line">     Binder.clearCallingIdentity();</div><div class="line">     <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">     <span class="keyword">for</span> (;;) &#123;</div><div class="line">         Message msg = queue.next(); <span class="comment">// might bloc  退出时返回null</span></div><div class="line">         <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">             <span class="comment">// No message indicates that the message queue is quitting. </span></div><div class="line">             <span class="keyword">return</span>; <span class="comment">//位移跳出循环的方式</span></div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></div><div class="line">         Printer logging = me.mLogging;</div><div class="line">         <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">             logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</div><div class="line">                     msg.callback + <span class="string">": "</span> + msg.what);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         msg.target.dispatchMessage(msg); <span class="comment">//分发消息 msg.target = Handler</span></div><div class="line"></div><div class="line">         <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">             logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="comment">// Make sure that during the course of dispatching the</span></div><div class="line">         <span class="comment">// identity of the thread wasn't corrupted.</span></div><div class="line">         <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</div><div class="line">         <span class="keyword">if</span> (ident != newIdent) &#123;</div><div class="line">             Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></div><div class="line">                     + Long.toHexString(ident) + <span class="string">" to 0x"</span></div><div class="line">                     + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></div><div class="line">                     + msg.target.getClass().getName() + <span class="string">" "</span></div><div class="line">                     + msg.callback + <span class="string">" what="</span> + msg.what);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         msg.recycleUnchecked();</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>Looper的loop方法工作过程，loop方法是一个死循环，位移跳出循环的方式是MessageQueue的next方法返回null。当Looper的quit方法被调用时，Looper就会调用MessageQueue的quit或者quitSafely方法来通知消息队列退出，当消息队列表计为退出状态时，它的next方法就返回null。</p>
<p>Looper必须退出，否则loop方法会无线循环下去。loop方法会调用MessageQueue的next方法来获取新的消息，而next是一个阻塞操作，当没有消息时，next方法会一直阻塞在那里，这也导致loop方法一直阻塞在那里。如果MessageQueue的next方法返回了新的消息，Looper就会处理这条消息：msg.target.dispatchMessage(msg);这里的msg.target是发送这条消息的Handler对象，这样Handler的发送的消息最终在它的dispatchMessage中处理了。</p>
<h2 id="Handler的工作原理"><a href="#Handler的工作原理" class="headerlink" title="Handler的工作原理"></a>Handler的工作原理</h2><p>Handler的主要工作包含消息的发送和接收过程。消息的发送可以通过post的一系列方法以及send的一系列方法实现，post的一系列方法最终是通过send的一系列方法来实现的。发送一条消息典型过程如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</div><div class="line">			delayMillis = <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">	MessageQueue queue = mQueue;</div><div class="line">	<span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">		RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">				<span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">		Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//送入消息队列</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">	msg.target = <span class="keyword">this</span>;</div><div class="line">	<span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">		msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现，Handler发送消息的过程仅仅是向消息队列插入了一条消息，MessageQueue的next方法就会返回这条消息给Looper，Looper收到消息后就开始处理了，最终消息由Looper交由Handler处理，即Handler的dispatchMessage方法会被调用，这是Handler就进入了消息处理阶段。dispatchMessage实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">		handleCallback(msg);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		handleMessage(msg);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Handler处理消息的过程如下：</p>
<p>首先，检查Message的Callback是否为null，不为null则通过handleCallback来处理消息，Message的callback是一个Runnable对象，实际上就是Handler的post方法所传递的Runnable参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</div><div class="line">	message.callback.run();  <span class="comment">//messge.callback = Runnable对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其次，若Message的Callback是为null，则检查mCallback是否为null，不为null就调用mCallback的handleMessage方法来处理消息，Callback是个接口，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过Callback框图用如下方式创建Handler对象：Handler mHandler = new Handler(mCallback)。那么Callback的意义是什么了？可以用来创建一个Handler的实例但并不需要派生Handler的子类。</p>
<p>最后，若都为null，则直接调用Handler中的handlerMessage方法来处理消息。</p>
<p>Handler还有一种特使的构造函数，那就是通过一个特定的Looper来构造Handler，通过这个构造方法可以实现一些特殊的功能如IntentService，它的实现如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Handler的一个默认构造方法public Handler()，这个构造方法会调用下面的的构造方法。很明显，如果当前线程没有Looper的话，就会抛出异常，这也解释了在没有Looper的子线程创建Handler会引发程序异常的原因。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line"></div><div class="line">	...</div><div class="line"></div><div class="line">	mLooper = Looper.myLooper();</div><div class="line">	<span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">			<span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">	&#125;</div><div class="line">	mQueue = mLooper.mQueue;</div><div class="line">	mCallback = callback;</div><div class="line">	mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="主线程的消息循环"><a href="#主线程的消息循环" class="headerlink" title="主线程的消息循环"></a>主线程的消息循环</h1><p>Android的主线程就是ActivityThread，主线程的入口方法为main，在main方法中系统会通过Looper.prepareMainLooper()来创建主线程的Looper以及MessageQueue，并通过Looper.loop()开启主线程的消息循环，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	SamplingProfilerIntegration.start();</div><div class="line"></div><div class="line">	<span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></div><div class="line">	<span class="comment">// disable it here, but selectively enable it later (via</span></div><div class="line">	<span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></div><div class="line">	CloseGuard.setEnabled(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">	Environment.initForCurrentUser();</div><div class="line"></div><div class="line">	<span class="comment">// Set the reporter for event logging in libcore</span></div><div class="line">	EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</div><div class="line"></div><div class="line">	Security.addProvider(<span class="keyword">new</span> AndroidKeyStoreProvider());</div><div class="line"></div><div class="line">	Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</div><div class="line"></div><div class="line">	Looper.prepareMainLooper(); <span class="comment">//</span></div><div class="line"></div><div class="line">	ActivityThread thread = <span class="keyword">new</span> ActivityThread();</div><div class="line">	thread.attach(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</div><div class="line">		sMainThreadHandler = thread.getHandler();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	AsyncTask.init();</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</div><div class="line">		Looper.myLooper().setMessageLogging(<span class="keyword">new</span></div><div class="line">				LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	Looper.loop(); <span class="comment">//无限循环</span></div><div class="line"></div><div class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主线程的消息循环开始以后，ActivityThread需要一个Handler来和消息队列进行交互，这个Handler就是ActivityThread.H，它内部定义了一组消息类型，主要包含了四大组件的启动和停止等过程，如下所示</p>
<p>ActivityThread通过ApplicationThread和AMS进行进程间通信，AMS以进程间通信的方式完成ActivityThread的请求后回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程中执行，这个过程就是主线程的消息循环模型。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list">
			 
        <li class="article-tag-list-item">
        	<a href="javascript:void(0)" class="article-tag-list-link color5">Android系统</a>
        </li>
      
		</ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book icon"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/04/26/Android的消息机制/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Android的线程和线程池" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/25/Android的线程和线程池/">Android的线程和线程池</a>
    </h1>
  

        
        <a href="/2016/04/25/Android的线程和线程池/" class="archive-article-date">
  	<time datetime="2016-04-25T13:06:06.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-04-25 21:06:06</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>线程在Android中是一个很重要的概念，从用途上来说，线程分为主线程和子线程，主线程主要处理和界面相关的事情，而子线程则往往用于执行耗时操作。由于Android的特性，如果在主线程中执行耗时操作那么就会导致程序无法及时地响应，因此耗时操作必须放在子线程中去执行。</p>
<p>在操作系统中，线程是操作系统调度的最小单元，同时线程又是一种受限的系统资源，即线程不可能无限制的产生，并且线程的创建和销毁都会有相应的开销。档系统中存在大量的线程时，系统会通过时间片轮转的方式调度每个线程，因此线程不可能做到绝对的并行，除非线程数量小于等于CPU核心数，一般来说这是不可能的。正确的做法是采用线程池，一个线程池会缓存一定数量的线程，通过线程池就可以避免因为频繁创建和销毁线程所带来的系统开销。</p>
<h1 id="主线程和子线程"><a href="#主线程和子线程" class="headerlink" title="主线程和子线程"></a>主线程和子线程</h1><p>Android沿用了Java的线程模型，其中的线程也分为主线程和子线程，其中主线程也叫UI线程。主线程的作用是运行四大组件以及处理它们和用户的交互，而子线程的作用则是执行耗时任务，比如网络请求、I/O操作等。从Android3.0开始系统要求网络访问必须在子线程中进行，否则网络访问将会失败并抛出NetworkOnMainThreadException这个异常，这样做事为了避免主线程由于耗时操作所阻塞而出现ANR异常。</p>
<h1 id="Android中的线程形态"><a href="#Android中的线程形态" class="headerlink" title="Android中的线程形态"></a>Android中的线程形态</h1><p>除了传统的Thread线程外，Android还提供了AsyncTask、HandlerTask以及IntentService，这三者的底层实现也是线程，但它们具有特殊的表现形式，同时在使用上也各有优缺点。</p>
<h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><p>AsyncTask是一种轻量级的异步任务类，它可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程并在主线程上更新UI。是实现上来说，<strong>AsyncTask封装了Thread和Handler</strong>，通过AsyncTask可以更加方便地执行后台任务以及在主线程中访问UI，但是AsyncTask并不适合进行特别耗时的任务，对应特别耗时的任务来说，建议使用线程池。</p>
<h3 id="AsyncTask使用"><a href="#AsyncTask使用" class="headerlink" title="AsyncTask使用"></a>AsyncTask使用</h3><p>AsyncTask是一个抽象的泛型类，它提供了Params、Progress和Result这三个泛型参数，其中Params表示输入参数的类型，Progress表示后台任务的执行进度的类型，而Result则表示后台任务返回结果的类型，如果AsyncTask确实不需要传递具体的参数，那么这三个泛型可以用Void来代替。声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>,<span class="title">Progress</span>,<span class="title">Result</span>&gt;</span></div></pre></td></tr></table></figure>
<p>AsyncTask提供了4个核心方法，它们的含义如下图所示</p>
<ol>
<li><p>onPreExecute()，在主线程中执行，在异步任务执行之前会调用此方法，一般可以用于做一些准备工作。</p>
</li>
<li><p>doInBackground(Params…params)，在线程池中执行，用于执行异步任务，params表示异步任务的输入参数。在该方法中可以通过调用publishProgress方法来更新任务的进度，因为publishProgress会调用onProgressUpdate方法。</p>
</li>
<li><p>onProgressUpdate(Progress…values)，在主线程中执行，当后台任务的执行进度发生改变时此方法会被调用。</p>
</li>
<li><p>onPostExecute(Result result)，在主线程中执行，在异步任务执行之后，次方法会被调用，其中result参数是后台任务的返回值，即doInBackground的返回值。  </p>
</li>
</ol>
<p>上述方法中，onPreExecute先执行，然后是doInBackground，最后才是onPostExecute。此外AsyncTask还提供了onCancelled()方法，它同样在主线程中执行，当异步任务被取消时，onCancelled()方法会被调用，这个时候onPostExecute则不会被调用。</p>
<p>下面代码为AsyncTask的一个应用实例： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadRecordTask</span> <span class="keyword">extends</span></span></div><div class="line">		<span class="title">AsyncTask</span>&lt;<span class="title">Object</span>, <span class="title">VideoInfo</span>, <span class="title">List</span>&lt;<span class="title">VideoInfo</span>&gt;&gt; &#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.onPreExecute();</div><div class="line">		mDescLoad.setVisibility(View.VISIBLE);</div><div class="line">		mDescLoad.setText(R.string.refreshing);</div><div class="line">		mVideoRecords.setEnabled(<span class="keyword">false</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> List&lt;VideoInfo&gt; <span class="title">doInBackground</span><span class="params">(Object... params)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		videoInfos = (ArrayList&lt;VideoInfo&gt;) MediaContentResolverUtils</div><div class="line">				.getVideoInfoList(RecordVideoActivity.<span class="keyword">this</span>);</div><div class="line"></div><div class="line">		mVideoThumbnailMap = (HashMap&lt;String, String&gt;) mVideoThumbnailDao</div><div class="line">				.findAllToMap();</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (videoInfos == <span class="keyword">null</span> || videoInfos.size() == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> videoInfos;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 没有缩略图 获取缩略图</span></div><div class="line">		<span class="keyword">for</span> (VideoInfo info : videoInfos) &#123;</div><div class="line"></div><div class="line">			String md5Name = Md5Utils.encode(info.getFileTitle());</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (!mVideoThumbnailMap.containsKey(md5Name)) &#123;</div><div class="line">				<span class="comment">//数据处理</span></div><div class="line">			&#125;</div><div class="line"></div><div class="line">			publishProgress(info);</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (isCancelled()) &#123; <span class="comment">//异步任务取消时会调用</span></div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> videoInfos;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(VideoInfo... values)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.onProgressUpdate(values);</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (VideoInfo info : values) &#123;</div><div class="line">			<span class="comment">//UI更新进度</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(List&lt;VideoInfo&gt; result)</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="comment">//取得后台任务的结果，更新UI</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 运行在UI线程，调用cancel()方法后触发，在doInBackground()方法结束后执行</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancelled</span><span class="params">(List&lt;VideoInfo&gt; result)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.onCancelled(result);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行和取消该任务的代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mLoadRecordTask = <span class="keyword">new</span> LoadRecordTask();</div><div class="line">mLoadRecordTask.execute();</div><div class="line">mLoadRecordTask.cancel(<span class="keyword">true</span>); <span class="comment">//结束任务</span></div></pre></td></tr></table></figure>
<h3 id="AsyncTask条件限制"><a href="#AsyncTask条件限制" class="headerlink" title="AsyncTask条件限制"></a>AsyncTask条件限制</h3><ul>
<li>AsyncTask的类必须在主线程中加载</li>
<li>AsyncTask的对象必须在主线程中创建</li>
<li>execute方法必须在UI线程调用</li>
<li>不要在程序中直接调用onPreExecute()、onPostExecute()、doInBackgroud()和onProgressUpdate()</li>
<li>一个AsyncTask对象只能执行一次，即只能调用一次execute方法，否则会报运行时异常</li>
<li>在Android1.6之前，AsyncTask是串行执行任务的，Android1.6的时候AsyncTask开始采用线程池里处理并行任务，但从Android3.0开始，为了避免AsyncTask所带来的并发错误，AsyncTask又采用一个线程来串行执行任务。<strong>尽管如此，在Android3.0及以后版本中，我们仍然可以通过AsyncTask的executeOnExecutor方法（不能向下兼容）来并行的执行任务</strong></li>
</ul>
<h3 id="AsyncTask工作原理"><a href="#AsyncTask工作原理" class="headerlink" title="AsyncTask工作原理"></a>AsyncTask工作原理</h3><p>我们从AsyncTask的execute方法开始分析，execute方法又会调用ecuteOnExecutor方法，它们的实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></div><div class="line">        Params... params) &#123;</div><div class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</div><div class="line">        <span class="keyword">switch</span> (mStatus) &#123;</div><div class="line">            <span class="keyword">case</span> RUNNING:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span> <span class="comment">//异步任务执行一次</span></div><div class="line">                        + <span class="string">" the task is already running."</span>); </div><div class="line">            <span class="keyword">case</span> FINISHED:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span> <span class="comment">//异步任务执行一次</span></div><div class="line">                        + <span class="string">" the task has already been executed "</span></div><div class="line">                        + <span class="string">"(a task can be executed only once)"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mStatus = Status.RUNNING;</div><div class="line"></div><div class="line">    onPreExecute(); <span class="comment">//最先执行</span></div><div class="line"></div><div class="line">    mWorker.mParams = params;</div><div class="line">    exec.execute(mFuture); <span class="comment">//线程池开始执行</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中，sDefaultExecutor实际上是一个串行的线程池，<strong>一个进程中所有的AsyncTask全部在这个串行的线程池中排队执行</strong>。在executeOnExecutor方法中，AsyncTask的onPreExecute()最先执行，然后线程池开始执行。下面分析线程池的执行过程，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">       mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">           <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">               Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">               <span class="comment">//noinspection unchecked</span></div><div class="line">               <span class="keyword">return</span> postResult(doInBackground(mParams));</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line">	</div><div class="line">	<span class="comment">//将AsyncTask的Params参数封装到FutureTask对象中，FutureTask的run方法会调用mWorker的call方法</span></div><div class="line">       mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   postResultIfNotInvoked(get());</div><div class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                   android.util.Log.w(LOG_TAG, e);</div><div class="line">               &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occured while executing doInBackground()"</span>,</div><div class="line">                           e.getCause());</div><div class="line">               &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                   postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors(); <span class="comment">//CPU核心数</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = CPU_COUNT + <span class="number">1</span>; <span class="comment">//核心工作线程</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">//最多工作线程</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE = <span class="number">1</span>; <span class="comment">//空闲线程的超时时间为1秒</span></div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR</div><div class="line">           = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</div><div class="line">                   TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();  </div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</div><div class="line"></div><div class="line"><span class="comment">//实现一个线程池</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">       <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</div><div class="line">       Runnable mActive;</div><div class="line"></div><div class="line">	<span class="comment">//线程同步</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</div><div class="line">		<span class="comment">//将任务r插入mTasks任务队列中</span></div><div class="line">           mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                   <span class="keyword">try</span> &#123;</div><div class="line">                       r.run(); <span class="comment">//执行任务</span></div><div class="line">                   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                       scheduleNext(); <span class="comment">//继续执行下一个任务</span></div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;);</div><div class="line">		</div><div class="line">		<span class="comment">//没有真正活动的AsyncTask时调用</span></div><div class="line">           <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</div><div class="line">               scheduleNext(); </div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">               THREAD_POOL_EXECUTOR.execute(mActive); <span class="comment">//真正执行任务</span></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>从SerialExecutor的实现可以分析AsyncTask的排队执行情况。首先系统会将AsyncTask的Params参数封装到FutureTask对象中，FutureTask是一个并发类，在这里它充当了Runnable的作用(FutureTask实现了Runnable方法)。接着这个FutureTask即mFuture会交给SerialExecutor的execute方法去处理。SerialExecutor的execute方法首先会把FutureTask对象添加到任务队列mTasks中，如果当前没有正在活动的AsyncTask任务，那么就会调用SerialExecutor的scheduleNext方法来执行下一个AsyncTask任务，否则等待当前AsyncTask任务完成再继续执行新的AsyncTask任务，直到所有的AsyncTask任务执行完毕。<strong>从这可以看出，AsyncTask是串行执行任务的</strong></p>
<p>AsyncTask中有两个线程池（SerialExecutor和THREAD_POOL_EXECUTOR）和一个Handler（InternalHandler），其中线程池SerialExecutor用于执行任务的排队，线程池THREAD_POOL_EXECUTOR用于真正地执行AsyncTask任务，InternalHandler用于将执行环境从线程池切换到主线程。在AsyncTask的构造方法中有如下这么一段代码，由于FutureTask的run方法调用mWorker的call方法，因此mWorker的call方法最终会在线程池中执行。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            mTaskInvoked.set(<span class="keyword">true</span>); <span class="comment">//表示当前任务以及调用过了</span></div><div class="line"></div><div class="line">            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">            <span class="comment">//noinspection unchecked</span></div><div class="line">            <span class="keyword">return</span> postResult(doInBackground(mParams)); <span class="comment">//执行doInBackground方法</span></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">	</div><div class="line">	<span class="comment">//将AsyncTask的Params参数封装到FutureTask对象中，FutureTask的run方法会调用mWorker的call方法</span></div><div class="line">    mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                postResultIfNotInvoked(get());</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                android.util.Log.w(LOG_TAG, e);</div><div class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occured while executing doInBackground()"</span>,</div><div class="line">                        e.getCause());</div><div class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在mWorker的call方法中，首先将mTaskInvoked设为true，表示当前任务以及被调用了，然后执行AsyncTask的doInBackground方法，接着将其返回值传递给postResult方法，它的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</div><div class="line">    message.sendToTarget();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的代码中，postResult方法会通过sHandler发送一个MESSAGE_POST_RESULT的消息，这个sHandler的定义如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> InternalHandler sHandler;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">synchronized</span> (AsyncTask.class) &#123;</div><div class="line">           <span class="keyword">if</span> (sHandler == <span class="keyword">null</span>) &#123;</div><div class="line">               sHandler = <span class="keyword">new</span> InternalHandler();</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> sHandler;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(Looper.getMainLooper());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</div><div class="line">                <span class="comment">// There is only one result</span></div><div class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</div><div class="line">                result.mTask.onProgressUpdate(result.mData);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现，sHandler是一个静态的Handler类对象，为了能够将执行环境切换到主线程，这就sHandler这个对象必须在主线程中创建。<strong>由于静态成员会在加载类的时候进行初始化，因此这就变相要求AsyncTask的类必须在主线程中加载，否则同一进程中的AsyncTask都将无法正常工作</strong>。sHandler收到sHandlerMESSAGE_POST_PROGRESS会调用onProgressUpdate方法更新进度，收到MESSAGE_POST_RESULT这个消息后会调用AsyncTask的finish方法，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</div><div class="line">        onCancelled(result);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        onPostExecute(result);</div><div class="line">    &#125;</div><div class="line">    mStatus = Status.FINISHED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AsyncTask的finish方法会判断AsyncTask是否取消执行了，是则调用onCancelled方法，否则调用onPostExecute(result)，此时doInBackground的返回结果会传递给onPostExecute方法，最后将任务状态mStatus置为完成。至此AsyncTask的整个过程就分析完成了。</p>
<p><strong>通过分析AsyncTask的源码，可以进一步确定，从Android3.0开始，默认情况下AsyncTask的确是串行执行。</strong>我们仍然可以通过AsyncTask的executeOnExecutor方法（不能向下兼容）来并行的执行任务。</p>
<h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><p>HandlerThread继承了Thread，它是一种可以使用Handler的Thread，它的实现也很简单，就是在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许HandlerThread中创建Handler。HandlerThread的run方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">	mTid = Process.myTid();</div><div class="line">	Looper.prepare();</div><div class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">		mLooper = Looper.myLooper();</div><div class="line">		notifyAll();</div><div class="line">	&#125;</div><div class="line">	Process.setThreadPriority(mPriority);</div><div class="line">	onLooperPrepared();</div><div class="line">	Looper.loop();</div><div class="line">	mTid = -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从HandlerThread的实现来看，它和普通的Thread有显著的不同之处。普通Thread主要同于run方法中执行一个耗时任务，而HandlerThread在内部创建了消息队列，外界需要通过Handler的消息方式来通知HandlerThread执行一个具体任务。HandlerThread是个很有用的类，它在Android中的一个具体的使用场景是IntentService。由于HandlerThread的run方法是一个无限循环，因此当明确不需要再使用HandlerThread时，可以通过它的quit或者quitSafely方法来终止线程的执行，这是一个好的编程习惯。示例代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThreadDemo</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Looper mLooper;</div><div class="line">	<span class="keyword">private</span> MyHandlerThread mHandlerThread;</div><div class="line">	<span class="keyword">private</span> TextView mInfoTxt;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Handler mHandler;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_thread);</div><div class="line">		</div><div class="line">		mInfoTxt  = (TextView) findViewById(R.id.tv_info);</div><div class="line">		</div><div class="line">		mHandlerThread = <span class="keyword">new</span> MyHandlerThread(<span class="string">"mHandlerThread"</span>);</div><div class="line">		mHandlerThread.start(); <span class="comment">//先start</span></div><div class="line">		mLooper = mHandlerThread.getLooper();</div><div class="line">		</div><div class="line">		<span class="comment">//注册到Handler，通过Handler发送消息</span></div><div class="line">		mHandler = <span class="keyword">new</span> Handler(mLooper,mHandlerThread);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">		</div><div class="line">		mHandler.sendEmptyMessage(<span class="number">1</span>);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandlerThread</span> <span class="keyword">extends</span> <span class="title">HandlerThread</span> <span class="keyword">implements</span> <span class="title">Callback</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyHandlerThread</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">			<span class="keyword">super</span>(name);</div><div class="line">			<span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			</div><div class="line">			<span class="keyword">if</span> (msg.what == <span class="number">1</span>) &#123;</div><div class="line">				System.out.println(<span class="string">"mHandlerThread"</span>);</div><div class="line">				mInfoTxt.setText(<span class="string">"mHandlerThread"</span>);</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>IntentService是一种特殊的Service，它继承了Service并且它是一个抽象类，因此必须创建它的子类才能使用IntentService。IntentService可用于执行后台耗时的后台，当任务执行后它会自动停止，同时由于IntentService是服务的原因，这导致它的优先级比单纯的线程要高很多，所以IntentService比较适合执行一些高优先级的后台任务，因为它的优先级高不容易被系统杀死。在实现上，IntentService封装了HandlerThread和Handler，这一点可以在它的onCreate方法中看出来，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> It would be nice to have an option to hold a partial wakelock</span></div><div class="line">    <span class="comment">// during processing, and to have a static startService(Context, Intent)</span></div><div class="line">    <span class="comment">// method that would launch the service &amp; hand off a wakelock.</span></div><div class="line"></div><div class="line">    <span class="keyword">super</span>.onCreate();</div><div class="line">    HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</div><div class="line">    thread.start();</div><div class="line"></div><div class="line">    mServiceLooper = thread.getLooper();</div><div class="line">    mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当IntentService被第一次启动时，它的onCreate方法会被调用，onCreate方法会创建一个HandlerThread，然后使用它的Looper来构造一个Handler对象mServiceHandler，这样通过mServiceHandler发送的消息最终都会在HandlerThread中执行，从这个角度来看，IntentService也可以用于执行后台任务。<strong>每次启动IntentService，它的onStartCommand方法就会调用一次</strong>，IntentService在onStartCommand中处理每个后台任务的Intent。下面看一下onStartCommand方法是如何处理外界Intent的，onStartCommand调用了onStart，onStart方法的实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">	Message msg = mServiceHandler.obtainMessage();</div><div class="line">	msg.arg1 = startId;</div><div class="line">	msg.obj = intent;</div><div class="line">	mServiceHandler.sendMessage(msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，IntentService仅仅是通过mServiceHandler发送了一个消息，这个消息会在HandlerThread中去处理。mServiceHandler收到消息后，会将Intent对象对象传递给onHandleIntent方法去处理。注意这个Intent对象的内容和外界的startService(intent)中的intent的内容是完全一致的，通过这个Intent对象即可解析出外界启动IntentService时所传递的参数，通过这些参数就可以区分具体的后台任务，这样在onHandleIntent方法中就可以对不同的后台任务做处理了。当onHandleIntent方法执行结束后，IntentService会通过stopSelf（int startId）来尝试停止服务。<strong>这里之所以采用stopSelf（int startId）而不是stopSelf（）来停止服务，是因为stopSelf（）会立刻停止服务，而这个时候还可能有其他消息未处理，stopSelf（int startId）则会等待所有的消息都处理完毕后才终止服务</strong>。一般来说，stopSelf（int startId）在尝试停止服务之前会判断最近启动服务的次数是否和startId相等，如果相等就立刻停止服务，不相等则不停止服务，这个策略可以从AMS的stopServiceToken方法的实现中找到依据。ServiceHandler的实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(looper);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">		onHandleIntent((Intent)msg.obj);</div><div class="line">		stopSelf(msg.arg1);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>IntentService的onHandleIntent方法是一个抽象方法，它需要我们在子类中实现，它的作用是从Intent参数中区分具体的任务并执行这些任务。如果目前只存在一个后台任务，那么onHandleIntent(Intent)方法执行完这个任务后，stopSelf（int startId）就会直接停止服务；如果目前存在多个后台任务，那么当onHandleIntent方法执行完最后一个任务时，stopSelf（int startId）才会直接停止服务。另外，由于没执行一个后台任务就必须启动一次IntentService，而IntentService内部则通过消息的方式向HandlerThread请求执行任务，Handler中的Looper是顺序处理消息的，这就意味着IntentService也是顺序执行后台任务，当有多个后台任务同时存在时，这些后台任务会按照外界发起的顺序排队执行。</p>
<p>下面通过一个示例来说明IntentService的工作方式，首先派生一个IntentService的子类，它的实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LocalIntentService</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(<span class="string">"LocalIntentService"</span>);</div><div class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(<span class="string">"onStartCommand"</span>);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		String action = intent.getStringExtra(<span class="string">"task"</span>);</div><div class="line">		System.out.println(<span class="string">"action: "</span> + action);</div><div class="line">		SystemClock.sleep(<span class="number">3000</span>); <span class="comment">//休眠模拟耗时的后台任务</span></div><div class="line">		<span class="keyword">if</span> (action.equals(<span class="string">"task1"</span>)) &#123;</div><div class="line">			System.out.println(<span class="string">"handle action: "</span> + action);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (action.equals(<span class="string">"task2"</span>)) &#123;</div><div class="line">			System.out.println(<span class="string">"handle action: "</span> + action);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (action.equals(<span class="string">"task3"</span>)) &#123;</div><div class="line">			System.out.println(<span class="string">"handle action: "</span> + action);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(<span class="string">"onDestroy"</span>);</div><div class="line">		<span class="keyword">super</span>.onDestroy();</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LocalIntentService实现完成以后，就可以在外界请求执行后台任务了，下面在Activity中发起3个后台任务的请求，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Intent service = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, LocalIntentService.class);</div><div class="line">service.putExtra(<span class="string">"task"</span>, <span class="string">"task1"</span>);</div><div class="line">startService(service);</div><div class="line">service.putExtra(<span class="string">"task"</span>, <span class="string">"task2"</span>);</div><div class="line">startService(service);</div><div class="line">service.putExtra(<span class="string">"task"</span>, <span class="string">"task3"</span>);</div><div class="line">startService(service);</div></pre></td></tr></table></figure>
<p>运行程序，观察日记如下</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">22</span>:<span class="number">14</span>:<span class="number">19.407</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): onStartCommand</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">19.407</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): action: task1</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">19.407</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): onStartCommand</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">19.408</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): onStartCommand</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">22.407</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): handle action: task1</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">22.409</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): action: task2</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">25.410</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): handle action: task2</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">25.418</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): action: task3</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">28.418</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): handle action: task3</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">28.429</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): onDestroy</div></pre></td></tr></table></figure>
<p>从日志可以看出，三个后台任务是排队执行的，它们的执行顺序就是它们发起请求对的顺序。当task3执行完毕后，LocalIntentService才真正地停止，执行了onDestroy方法。</p>
<h1 id="Android中的线程池"><a href="#Android中的线程池" class="headerlink" title="Android中的线程池"></a>Android中的线程池</h1><p>线程池的有点主要有三点：</p>
<ul>
<li><p>重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销</p>
</li>
<li><p>能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致的阻塞现象。</p>
</li>
<li><p>能够对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。</p>
</li>
</ul>
<p>Android中的线程池概念来源于Java中的Executor，Executor是一个接口，真正的线程池的实现为ThreadPoolExecutor。ThreadPoolExecutor提供了一系列参数来配置线程池，通过不同的参数可以创建不同的线程池。由于Android中的线程池都是直接或者间接通过配置ThreadPoolExecutor来实现的，因此需要先介绍ThreadPoolExecutor。</p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>ThreadPoolExecutor是线程池的真正实现，它的构造方法提供了一系列参数来配置线程池，下面介绍ThreadPoolExecutor的构造方法中各个参数的含义，这些参数将会直接影响到线程池的功能特性，下面是ThreadPoolExecutor的一个比较常用的构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                          <span class="keyword">int</span> maximumPoolSize,</div><div class="line">                          <span class="keyword">long</span> keepAliveTime,</div><div class="line">                          TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                          ThreadFactory threadFactory) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>corePoolSize</strong>  </li>
</ul>
<p>线程池的核心线程数，默认情况下，核心线程会在线程池中一直存活，即使他们处于闲置状态。如果将ThreadPoolExecutor的allowCoreThreadTimeout属性设置为true，那么闲置的核心线程在等待新任务到来会有超时策略，这个时间间隔由keepAliveTime所指定，当等待时间超时keepAliveTime所指定的时长后，核心线程会被终止。</p>
<ul>
<li><strong>maximumPoolSize</strong></li>
</ul>
<p>线程池所能容纳的最大线程数，当活动线程达到这个数值后，后续的新任务将会被阻塞。</p>
<ul>
<li><strong>keepAliveTime</strong></li>
</ul>
<p>非核心线程闲置时的超时时长，超过这个时间，非核心线程就会被收回。当ThreadPoolExecutor的allowCoreThreadTimeout属性设置为true时，keepAliveTime同样会作用于核心线程。</p>
<ul>
<li><strong>unit</strong></li>
</ul>
<p>用于指定keepAliveTime参数的时间单位，这是一个枚举，常用的有TimeUnit.MILLISECONDS;TimeUnit.SECONDS;TimeUnit.MINUTES等</p>
<ul>
<li><strong>workQueue</strong></li>
</ul>
<p>线程池的任务队列，通过线程池的execute方法提交的Runnable对象会存储在这个参数中。</p>
<ul>
<li><strong>ThreadFactory</strong></li>
</ul>
<p>线程工厂，为线程池提供创建新线程的功能。ThreadFactory是一个接口，它只有一个方法：Thread newThread(Runnable r);</p>
<p>除上面的这些主要的参数外，ThreadPoolExecutor还有一个不常用的参数RejectedExecutionHandler。当线程池无法执行新的任务时，这可能是由于任务队列已满或者是无法成功执行任务，这个时候ThreadPoolExecutor回调用RejectedExecutionHandler的rejectedExecution(Runnable r, ThreadPoolExecutor executor)方法来通知调用者，默认情况下rejectedExecution会直接抛出一个RejectedExecutionException的运行时异常。ThreadPoolExecutor为RejectedExectutionHandler提供了几个可选值：CallerRunsPolicy、AbortPolicy、DiscardPolicy、DiscardOldestPolicy，其中AbortPolicy是默认值，但是RejectedExecutionHandler这个参数不常用。</p>
<p>ThreadPoolExecutor执行任务时大致遵循如下规则：</p>
<ul>
<li><p>如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务</p>
</li>
<li><p>如果线程池中的线程数量已经达到或超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行。</p>
</li>
<li><p>如果在步骤2中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务。</p>
</li>
<li><p>如果步骤3中线程数量已经达到线程池中规定的最大值，那么就拒绝执行此任务，ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution方法来通知调用者。</p>
</li>
</ul>
<p>ThreadPoolExecutor的参数配置在AsyncTask中有明显的体现，下面是AsyncTask中的线程池配置情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors();</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = CPU_COUNT + <span class="number">1</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AsyncTask #"</span> + mCount.getAndIncrement());</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =</div><div class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">128</span>);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * An &#123;<span class="doctag">@link</span> Executor&#125; that can be used to execute tasks in parallel.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR</div><div class="line">        = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</div><div class="line">                TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</div></pre></td></tr></table></figure>
<p>AsyncTask线程池配置后的规格如下：</p>
<ul>
<li>核心线程数等于CPU核心数+1</li>
<li>线程池的最大线程数为CPU的核心数的2倍 + 1</li>
<li>核心线程无超时机制，非核心线程在闲置时的超时时间为1秒</li>
<li>任务队列的容量为128</li>
</ul>
<h2 id="线程池的分类"><a href="#线程池的分类" class="headerlink" title="线程池的分类"></a>线程池的分类</h2><ul>
<li><strong>FixedThreadPool</strong></li>
</ul>
<p>通过Executors的newFixedThreadPool方法来创建。它是一种线程数量固定的线程池，当线程处于空闲状态时，它们并不会被收回，除非线程池关闭了。当所有的线程都处于活动状态时，新任务都会处于等待状态，直到有线程空闲出来。由于FixedThreadPool只有核心线程并且这些核心线程都不会被回收，<strong>这意味着它能够更加快速的响应外界的请求</strong>。实现如下，可以发现FixedThreadPool中只有核心线程并且这些核心线程没有超时机制，另外任务队列也是没有大小限制的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">    * @param nThreads the number of threads in the pool</div><div class="line">    * @return the newly created thread pool</div><div class="line">    * </div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                     <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                     <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>CachedThreadPool</strong></li>
</ul>
<p>通过Executors的newCachedThreadPool方法来创建。它是一种线程数量不定的线程池，它只有非核心线程，并且最大线程数为Integer.MAX_VALUE。由于Integer.MAX_VALUE是一个很大的数，实际上就相当于最大线程数可以任意大。当线程池中的线程都处于活动状态时，线程池会创建新的线程来处理新任务，否则就会利用空闲的线程来处理新的任务。线程池中的空闲线程都有超时机制，这个超时时长为60秒，超过60秒闲置线程就会被回收。和FixedThreadPool不同的是，CachedThreadPool的任务队列其实相当于一个空集合，这将导致任何任务都会立即被执行，因为这种情况下SynchronousQueue是无法插入任务的。SynchronousQueue是一个非常特殊的队列，很多情况下可以理解为一个无法存储元素的队列（实际中很少使用）。从CachedThreadPool的特性来看<strong>这类线程池比较适合执行大量的耗时较少的任务</strong>。当整个线程池都处于闲置状态时，线程池中的线程都会超时而被停止，这个时候CachedThreadPool之中是没有任何线程的，它几乎不占用任何系统资源的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</div><div class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>ScheduledThreadPoll</strong></li>
</ul>
<p>通过Executors的newScheduledThreadPool方法来创建。它的核心线程数量是固定的，而非核心线程数量是没有限制的，并且当核心线程闲置时会被立即收回。ScheduledThreadPoll这类线程<strong>主要用于执行定时任务和具有固定周期的重复任务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">								   ThreadFactory threadFactory) &#123;</div><div class="line">	<span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</div><div class="line">		  <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>SingleThreadExecutor</strong></li>
</ul>
<p>通过Executors的newSingleThreadExecutor方法来创建。这类线程池内部只有一个核心线程，它确保所有的任务都在同一个线程中顺序执行。SingleThreadExecutor的意义在于统一所有的外界任务到一个线程中，这使得在这些任务之间不需要处理线程同步的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</div><div class="line">		(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</div><div class="line">								<span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">								<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list">
			 
        <li class="article-tag-list-item">
        	<a href="javascript:void(0)" class="article-tag-list-link color5">Android系统</a>
        </li>
      
		</ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book icon"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/04/25/Android的线程和线程池/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Android的IPC方式" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/19/Android的IPC方式/">Android的IPC方式</a>
    </h1>
  

        
        <a href="/2016/04/19/Android的IPC方式/" class="archive-article-date">
  	<time datetime="2016-04-19T14:49:47.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-04-19 22:49:47</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h1><p>四大组件中的三大组件（Activity、Service、BroadcastReceiver）都是支持在Intent中传递Bundle数据的，由于Bundle实现了Parcelable接口，所以它可以方便地在不同的进程间传输，基于这一点，当我们在一个进程中启动了另一个进程的Activity、Service和BroadcastReceiver，我们就可以在Bundle中附加我们需要传输给远程进程的信息并通过Intent发送出去。当然，我们传输的数据必须能够被序列化，比如基本类型、实现了Parcelable接口的对象、实现了Serializable接口的对象以及一些Android所支持的特殊对象（如Bundle、Size、SizeF、IBinder）。</p>
<h1 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h1><p>共享文件也是一种不错的进程间通信方式，两个进程提供读/写同一个文件来交换数据，比如A进程把数据写入文件，B进程提供读取这个文件来获取数据。通过文件交换数据很好使用，除了可以交换一些文本信息外，我们还可以序列化一个对象到文件中，从另一进程中恢复这个对象。</p>
<p>通过文件共享方式来共享数据对文件格式是没有具体要求的，比如可以是文本文件，也可以是XML文件，只要读写双方约定数据格式即可。通过文件共享的方式是有局限性的，比如并发读/写的问题，因此我们要尽量避免并发写这种情况的发生或者考虑使用线程同步来限制多个线程的写操作。通过上面的分析可以知道，<strong>文件共享方式适合在对数据同步要求不高的进程之间进行通信</strong>，并且要妥善处理并发读/写的问题。</p>
<p>SharedPreference是个特例，SharedPreference是Android中提供的轻量级存储方案，它通过键值对的方式来存储数据，在底层实现上采用XML文件来存储键值对，每个应用的SharedPreference文件都可以在当前包所在的data目录下查到，一般来说，它的目录位于/data/data/package name/shared_prefs目录下。<strong>从本质上来说，</strong>SharedPreference属于文件的一种，但是由于系统对它的读/写有一定的缓存策略2，即在内存中会有一份SharedPreference文件的缓存。因此在多进程模式下，系统对它的读/写变得不可靠，当面对搞并发的读/写访问时，SharedPreference有很大几率会丢失数据，因此不建议在进程间通信中使用SharedPreference。</p>
<h1 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h1><p>Messenger可以翻译为信使，通过它可以在不同进程中传递Message对象，在Message中放入我们需要传递的数据，就可以轻松实现数据的进程间传递,也可以在同一个进程中使用。Messenger是一种轻量级的IPC方案，它的底层实现是AIDL。Messenger类的构造方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(Handler target)</span> </span>&#123;</div><div class="line">	mTarget = target.getIMessenger();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(IBinder target)</span> </span>&#123;</div><div class="line">	mTarget = IMessenger.Stub.asInterface(target);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Messenger使用简单，它对AIDL做了封装。同时，由于它一次处理一个请求，因此在服务端我们不用考虑线程同步的问题，这是因为服务端不存在并发执行的情形。实现一个Messenger由如下几个步骤，分为服务端和客户端。</p>
<ul>
<li><strong>1. 服务端进程</strong></li>
</ul>
<p>首先，我们需要在服务端创建一个Service来处理客户端的连接请求，同时创建一个Handler，并通过它来创建一个Messenger对象，然后在Service的onBind中返回这个Messenger对象底层的Binder即可。</p>
<ul>
<li><strong>2. 客户端进程</strong></li>
</ul>
<p>客户端进程中，首先要绑定服务端的Servcie，绑定成功后用服务端返回的IBinder对象创建一个Messenger，通过这个Messenger就可以向服务器发送消息了，发送消息类型为Message对象。如果需要服务端回应客户端蛮久和服务端一样，我们还需要创建一个Handler并创建一个新的Messenger，并把这个Messenger对象通过Messge的replyTo参数传递给服务端，服务端通过这个replyTo参数就可以回应客户端。</p>
<p>首先是服务端的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="comment">//1.创建Handler对象处理Message</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			<span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">			</div><div class="line">			<span class="keyword">case</span> Constants.MSG_FROM_CLIENT:</div><div class="line">				</div><div class="line">				System.out.println(<span class="string">"receiver msg from client: "</span> + msg.getData().get(<span class="string">"msg"</span>));</div><div class="line">				</div><div class="line">				<span class="comment">//返回信息到服务端</span></div><div class="line">				<span class="comment">//获取客户端接收消息的Messenger</span></div><div class="line">				Messenger client = msg.replyTo;</div><div class="line">				Message replyMessage = Message.obtain();</div><div class="line">				replyMessage.what = Constants.MSG_FROM_SERVER;</div><div class="line">				Bundle data = <span class="keyword">new</span> Bundle();</div><div class="line">				data.putString(<span class="string">"reply"</span>, <span class="string">"嗯，你的消息我已经收到!"</span>);</div><div class="line">				replyMessage.setData(data);</div><div class="line">				</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					client.send(replyMessage);</div><div class="line">				&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">					<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">				<span class="keyword">break</span>;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			</div><div class="line">			<span class="keyword">super</span>.handleMessage(msg);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//2.创建一个Messenger,将客户端发送的消息传递给MessengerHandler处理</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Messenger mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHandler());</div><div class="line"></div><div class="line">	<span class="comment">//3.返回Messenger对象底层Binder</span></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> mMessenger.getBinder();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，注册Service</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;service</div><div class="line">    android:name="com.ryg.chapter_2.messenger.MessengerService"</div><div class="line">    android:process=":remote" &gt;</div><div class="line">&lt;/service&gt;</div></pre></td></tr></table></figure>
<p>最后是客户端代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Messenger mService;</div><div class="line">	</div><div class="line">	<span class="comment">//将服务端返回的消息传递MessengerHandler处理</span></div><div class="line">	<span class="keyword">private</span> Messenger mGetReplyMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHandler());</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			</div><div class="line">			<span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">			</div><div class="line">			<span class="keyword">case</span> Constants.MSG_FROM_SERVER:</div><div class="line">				</div><div class="line">				System.out.println(<span class="string">"receiv msg from server: "</span> + msg.getData().getString(<span class="string">"reply"</span>));</div><div class="line">				</div><div class="line">				<span class="keyword">break</span>;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			<span class="keyword">super</span>.handleMessage(msg);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			<span class="comment">//2.创建一个Messenger</span></div><div class="line">			mService = <span class="keyword">new</span> Messenger(service);</div><div class="line">			</div><div class="line">	    	<span class="comment">//3.通过Messenger发送Message消息到服务端</span></div><div class="line">	    	<span class="keyword">if</span> (mService != <span class="keyword">null</span>) &#123;</div><div class="line">				Message msg = Message.obtain();</div><div class="line">				msg.what = Constants.MSG_FROM_CLIENT;</div><div class="line">				Bundle data = <span class="keyword">new</span> Bundle();</div><div class="line">				data.putString(<span class="string">"msg"</span>, <span class="string">"hello,this is client"</span>);</div><div class="line">				msg.setData(data);</div><div class="line">				</div><div class="line">				<span class="comment">//将接收服务端回复的Messenger传递给服务端，必须要传递过去，否则收不到回复</span></div><div class="line">				msg.replyTo = mGetReplyMessenger;</div><div class="line">				</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					mService.send(msg);</div><div class="line">				&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">					<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        </div><div class="line">        <span class="comment">//1.绑定服务</span></div><div class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MessengerService.class);</div><div class="line">        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    	<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">    	<span class="keyword">if</span> (mConnection != <span class="keyword">null</span>) &#123;</div><div class="line">			</div><div class="line">    		unbindService(mConnection);</div><div class="line">		&#125;</div><div class="line">    	<span class="keyword">super</span>.onDestroy();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> <span class="number">13</span>:<span class="number">20</span>:<span class="number">43.218</span>: I/System.<span class="keyword">out</span>(<span class="number">3280</span>): receiver msg <span class="keyword">from</span> client: hello,<span class="keyword">this</span> <span class="keyword">is</span> client</div><div class="line"><span class="number">01</span><span class="number">-11</span> <span class="number">13</span>:<span class="number">20</span>:<span class="number">43.234</span>: I/System.<span class="keyword">out</span>(<span class="number">3222</span>): receiv msg <span class="keyword">from</span> server: 嗯，你的消息我已经收到!</div></pre></td></tr></table></figure>
<p>通过上面的例子可以看出，在Messenger中进行数据传递必须将数据放入Message中，而Messenger和Message都实现了Parcelable接口，因此可以跨进程传输。简单来说，Message中所支持的数据类型就是Messenger中所支持的传输类型。实际上，通过Messenger来传输Message，Message中能使用的载体只有what、arg1、arg2、Bundle以及reply。Message中的另一个字段object在同一进程中的很实用的，但是再进程间通信的时候，在Android2.2以前object字段不支持跨进程传输，即便是android2.2以后，也仅仅是系统提供的实现了Parcelable接口的对象才能通过它来传输，这就意味着我们自定义的Parcelable对象无法通过object字段来传输。因此使用Bundle可以支持大量的数据类型。</p>
<h1 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h1><p>Messenger是以串行的方式处理客户端发来的消息，如果大量的消息同时发送到服务器，服务端仍然只能一个一个处理,（1）如果有大量的并发请求，那么用Messenger就不太合适了。同时，Messenger的作用仅仅是为了传递消息，（2）很多时候我们可能需要跨进程调用服务端的方法，这种情形用Messenger就无法做到了，但是我们可以使用AIDL来实现跨进程的方法调用。</p>
<p>下面介绍使用AIDL来进行进程间通信的流畅，分为服务端和客户端两个方面</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>服务端要首先创建一个Service用来监听客户端的连接，然后创建一个AIDL文件，将暴露给客户端的接口再这个AIDL文件中声明，最后在Service中实现这个AIDL接口。</p>
<p>（1）AIDL接口的创建<br>创建一个后缀为aidl的文件，在里面声明了一个接口和两个接口方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//IBookManager.aidl</span></div><div class="line"></div><div class="line"><span class="keyword">package</span> com.ryg.chapter_2.aidl;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.ryg.chapter_2.aidl.Book;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在AIDL文件中，并不是所有的数据类型都是可以使用的，AIDL到底支持哪些数据类型呢？如下所示</p>
<ul>
<li>基本数据类型</li>
<li>String和CharSequence</li>
<li>List：只支持ArrayList，并且里面的每个元素必须能够被AIDL支持</li>
<li>Map： 只支持HashMap，并且里面的每个元素都必须能够被AIDL文件支持，包括key和value</li>
<li>Parcelable：所有实现了Parcelable接口的对象</li>
<li>AIDL：所有的AIDL接口本身也可以在AIDL文件中使用</li>
</ul>
<p>以上6中就是AIDL支持的数据类型，其中自定义的Parcelable对象和AIDL对象必须要显示的import进来，不管它们是否和当前的AIDL文件位于同一个文件夹内。</p>
<p>IBookManager.aidl文件中引用了Book这个类，Book类是一个自定义的Parcelable对象，所以必须新建一个与它同名的AIDL文件，并在其中声明它为Parcelable，如下所示：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//Book.aidl</div><div class="line"></div><div class="line">package com.ryg.chapter_2.aidl<span class="comment">;</span></div><div class="line"></div><div class="line">parcelable Book<span class="comment">;</span></div></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>除此之外，AIDL中除了基本数据类型，其他类型的参数必须标上方向：in、out或者inout，in表示输入型参数，out表示输出型参数，inout表示输入输出型参数。</p>
<p>AIDL的包结构在客户端工程和服务端工程中要保持一致，否则会运行出错，这是因为客户端需要反序列化服务端中和AIDL接口相关的所有类，如果类的完整路径不一致，就无法成功反序列化，程序也就无法正常运行。</p>
<p>（2）远程服务端service的实现  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookManagerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> CopyOnWriteArrayList&lt;Book&gt; mBookList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;Book&gt;();</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Binder mBinder = <span class="keyword">new</span> IBookManager.Stub() &#123;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			<span class="keyword">return</span> mBookList;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			<span class="keyword">if</span> (!mBookList.contains(book)) &#123;</div><div class="line">				mBookList.add(book);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.onCreate();</div><div class="line">		</div><div class="line">		mBookList.add(<span class="keyword">new</span> Book(<span class="number">1</span>, <span class="string">"Android"</span>));</div><div class="line">		mBookList.add(<span class="keyword">new</span> Book(<span class="number">2</span>, <span class="string">"IOS"</span>));</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> mBinder;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是一个服务端Service的典型实现，首先在onCreate中初始化添加两本书的信息，然后创建一个Binder对象并在Binder中返回次对象，这个对象继承自IBookManager.Stub并实现了内部的AIDL方法。这里采用了CopyOnWriteArrayList，这个CopyOnWriteArrayList支持并发读/写。AIDL方法是在服务端的Binder线程池中执行的，因此当多个客户端同时连接的时候，会存在多个线程同时访问的情形，所以我们要在AISL方法中处理线程的同步，这里使用CopyOnWriteArrayList来进行自动的线程同步。</p>
<p>AIDL中能够使用的List只有ArrayList，但是我们这里使用的CopyOnWriteArrayList不是继承自ArrayList，为什么能够正常工作呢？这是因为AIDL所支持的是抽象的List，而List只是一个接口，因此虽然服务端返回的是CopyOnWriteArrayList，但在Binder中会按照List的规范去访问数据并最终形成一个ArrayList传递给客户端。所以，在服务端采用CopyOnWriteArrayList是完全可行的，与此类似的类还有ConCureentHashMap。</p>
<p>注册Service</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">service</span></span></div><div class="line">    <span class="attr">android:name</span>=<span class="string">"com.ryg.chapter_2.aidl.BookManagerService"</span></div><div class="line">    <span class="attr">android:process</span>=<span class="string">":remote1"</span> &gt;</div><div class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端首先要绑定远程服务，绑定成功后将服务端返回的Binder对象转换成AIDL接口，然后就可以通过这个接口去调用服务端的远程方法了，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		IBookManager bookManager = IBookManager.Stub.asInterface(service);</div><div class="line">		</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			List&lt;Book&gt; list = bookManager.getBookList();</div><div class="line">			System.out.println(<span class="string">"query book list type: "</span> + list.getClass().getCanonicalName());</div><div class="line">			System.out.println(<span class="string">"query book list: "</span> + list.toString());</div><div class="line">			</div><div class="line">			bookManager.addBook(<span class="keyword">new</span> Book(<span class="number">3</span>, <span class="string">"Windows Phone"</span>));</div><div class="line">			list = bookManager.getBookList();</div><div class="line">			System.out.println(<span class="string">"query book list: "</span> + list.toString());</div><div class="line">			</div><div class="line">		&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">	<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">	<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">	setContentView(R.layout.activity_main);</div><div class="line">	Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, BookManagerService.class);</div><div class="line">	bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> <span class="number">14</span>:<span class="number">51</span>:<span class="number">36</span>.<span class="number">937</span>: I/System.out(<span class="number">24841</span>): query <span class="keyword">book </span>list type: java.util.ArrayList  //CopyOnWriteArrayList转为Arraylist</div><div class="line"><span class="number">01</span>-<span class="number">11</span> <span class="number">14</span>:<span class="number">51</span>:<span class="number">36</span>.<span class="number">937</span>: I/System.out(<span class="number">24841</span>): query <span class="keyword">book </span>list: [<span class="keyword">Book </span>[<span class="keyword">bookId=1, </span><span class="keyword">bookName=Android], </span><span class="keyword">Book </span>[<span class="keyword">bookId=2, </span><span class="keyword">bookName=IOS]]</span></div><div class="line"><span class="number">01</span>-<span class="number">11</span> <span class="number">14</span>:<span class="number">51</span>:<span class="number">36</span>.<span class="number">939</span>: I/System.out(<span class="number">24841</span>): query <span class="keyword">book </span>list: [<span class="keyword">Book </span>[<span class="keyword">bookId=1, </span><span class="keyword">bookName=Android], </span><span class="keyword">Book </span>[<span class="keyword">bookId=2, </span><span class="keyword">bookName=IOS], </span><span class="keyword">Book </span>[<span class="keyword">bookId=3, </span><span class="keyword">bookName=Windows </span>Phone]]</div></pre></td></tr></table></figure>
<h2 id="Binder意外死亡的处理办法"><a href="#Binder意外死亡的处理办法" class="headerlink" title="Binder意外死亡的处理办法"></a>Binder意外死亡的处理办法</h2><p>（1）给Binder设置DeathRecipinent监听，当Binder死亡时，会收到binderDied的回调，在此回调中重新连接远程服务，次方法在客户端的Binder线程池中调用，不能直接访问UI  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> IBinder.DeathRecipient mDeathRecipient = <span class="keyword">new</span> IBinder.DeathRecipient() &#123;</div><div class="line">	</div><div class="line">	<span class="comment">//Binder死亡时的回调方法</span></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">if</span> (bookManager == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		bookManager.asBinder().unlinkToDeath(mDeathRecipient, <span class="number">0</span>);</div><div class="line">		bookManager = <span class="keyword">null</span>;</div><div class="line">		</div><div class="line">		<span class="comment">//重新绑定远程服务</span></div><div class="line">		Intent intent = <span class="keyword">new</span> Intent(BookManagerActivity.<span class="keyword">this</span>, BookManagerService.class);</div><div class="line">		bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		bookManager = IBookManager.Stub.asInterface(service);</div><div class="line">		<span class="comment">//给binder设置死亡代理</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			service.linkToDeath(mDeathRecipient, <span class="number">0</span>);</div><div class="line">		&#125; <span class="keyword">catch</span> (RemoteException e1) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			e1.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>（2）在onServiceDisconnected中重连远程服务，此方法在客户端的UI线程中调用  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="comment">//重新绑定远程服务</span></div><div class="line">		Intent intent = <span class="keyword">new</span> Intent(BookManagerActivity.<span class="keyword">this</span>, BookManagerService.class);</div><div class="line">		bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		bookManager = IBookManager.Stub.asInterface(service);</div><div class="line">		<span class="comment">//给binder设置死亡代理</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			service.linkToDeath(mDeathRecipient, <span class="number">0</span>);</div><div class="line">		&#125; <span class="keyword">catch</span> (RemoteException e1) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			e1.printStackTrace();</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="AIDL中使用权限验证功能"><a href="#AIDL中使用权限验证功能" class="headerlink" title="AIDL中使用权限验证功能"></a>AIDL中使用权限验证功能</h2><p>默认情况下，我们的远程服务任何人都可以连接，所以我们必须给服务加入权限验证功能，权限验证失败则无法调用服务的方法，这里介绍两种常用的方法。</p>
<ul>
<li><strong>onBind中验证</strong></li>
</ul>
<p>早onBind中进行验证，验证不通过就直接返回null，这样验证失败的客户端无法绑定服务，比如使用permission验证。首先，在Manifest.xml中声明所需要的权限，比如：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;permission </div><div class="line">    android:<span class="built_in">name</span>=<span class="string">"com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE"</span></div><div class="line">    android:protectionLevel=<span class="string">"normal"</span>&gt;</div></pre></td></tr></table></figure>
<p>然后在BookManagerService的onBind做权限验证，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">	<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">	<span class="keyword">int</span> check = checkCallingOrSelfPermission(<span class="string">"com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE"</span>);</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (check == PackageManager.PERMISSION_DENIED) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//客户端就无法绑定到此服务</span></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> mBinder;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方法同样适用于Messenger中。如果我们自己内部的应用想绑定到我们的服务中，只需要在它的AndroidManifest文件中使用permission即可</p>
<uses-permission android:name="com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE">

<ul>
<li><strong>服务端的onTransact方法中验证</strong></li>
</ul>
<p>在服务端的onTransact方法中进行权限验证，验证失败就返回false，这样服务端就不会终止执行AIDL中的方法从而达到保护服务端的效果。至于验证的方式有很多，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Binder mBinder = <span class="keyword">new</span> IBookManager.Stub() &#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> mBookList;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">if</span> (!mBookList.contains(book)) &#123;</div><div class="line">			mBookList.add(book);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></div><div class="line">			<span class="keyword">throws</span> RemoteException &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		</div><div class="line">		<span class="comment">//1.通过permission验证</span></div><div class="line">		<span class="keyword">int</span> check = checkCallingOrSelfPermission(<span class="string">"com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE"</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (check == PackageManager.PERMISSION_DENIED) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="comment">//2.验证包名</span></div><div class="line">		String packageName = <span class="keyword">null</span>;</div><div class="line">		String[] packages = getPackageManager().getPackagesForUid(getCallingUid());</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (packages != <span class="keyword">null</span> &amp;&amp; packages.length &gt; <span class="number">0</span>) &#123;</div><div class="line">			packageName = packages[<span class="number">0</span>];</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (!packageName.startsWith(<span class="string">"com.ryg"</span>)) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面介绍了常用的两种权限验证方式，但是还有其他方式做权限验证，比如为Service指定android:permission属性等。</p>
<h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><p>ContentProvider是Android中专门用于不同应用间进行数据共享的方式，从这一点来看，它天生适合进程间通信。和Messenger一样，ContentProvider的底层实现同样是Binder。</p>
<p>系统预置了许多ContentProvider，比如通讯录信息<br>日程表信息等，要跨进程访问这些信息，只需要通过ContentResolver的query、update、insert和delete方法。下面我们演示实现一个自定义的ContentProvider，并演示如何在其他应用中获取ContentProvider中的数据从而实现进行间通信的目的。首先，创建一个ContentProvider的类，叫BookProvider，并实现6个抽象方法即可onCreate、query、delete、update、insert和getType。onCreate代表ContentProvider的创建，需要做一些初始化的工作；getType用来返回一个Uri请求所对应的MIME类型，比如视频、图片、等，如果应用不关心这个选项，可以直接在方法中返回null或者“*/*”剩下的四个方法对应于CRUD操作，对数据表的增删改查功能。</p>
<p>根据Binder的工作原理，这留个方法均运行在ContentProvider的进程中，除了onCreate有系统回调运行在主线程里，其他无非方法由外界回调并运行在Binder线程池中。</p>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//BookProvider.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(<span class="string">"onCreate current thread:"</span> + Thread.currentThread().getName());</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection,</span></span></div><div class="line">			String[] selectionArgs, String sortOrder) &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(<span class="string">"query current thread:"</span> + Thread.currentThread().getName());</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection,</span></span></div><div class="line">			String[] selectionArgs) &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们需要注册这个BookProvider，如下所示。其中android:anthorities是ContentProvider的唯一标识，通过这个属性外部应用就可以访问我们的BookProvide。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;provider</div><div class="line">    android:name=<span class="string">"com.ryg.chapter_2.provider.BookProvider"</span></div><div class="line">    android:authorities=<span class="string">"com.ryg.chapter_2.provider.book.provider"</span> <span class="regexp">//</span>标识</div><div class="line">    android:permission=<span class="string">"com.ryg.PROVIDER"</span> <span class="regexp">//</span>权限</div><div class="line">    android:process=<span class="string">":provider"</span></div><div class="line">    <span class="regexp">//</span>ndroid:readPermission=<span class="string">"com.ryg.PROVIDER.READ"</span> <span class="regexp">//</span>读权限</div><div class="line">    <span class="regexp">//</span>android:writePermission=<span class="string">"com.ryg.PROVIDER.WRITE"</span> &gt;  <span class="regexp">//</span>写权限</div><div class="line">&lt;<span class="regexp">/provider&gt;</span></div></pre></td></tr></table></figure>
<p>然后声明权限和加入权限</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:<span class="built_in">name</span>=<span class="string">"com.ryg.PROVIDER"</span> /&gt;</div><div class="line"></div><div class="line">  &lt;permission</div><div class="line">      android:<span class="built_in">name</span>=<span class="string">"com.ryg.PROVIDER"</span></div><div class="line">      android:protectionLevel=<span class="string">"normal"</span> /&gt;</div></pre></td></tr></table></figure>
<p>创建BookActivity.java访问这个ContentProvider，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		</div><div class="line">		Uri uri = Uri.parse(<span class="string">"content://com.ryg.chapter_2.provider.book.provider"</span>);</div><div class="line">		getContentResolver().query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">		getContentResolver().query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">		getContentResolver().query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">		getContentResolver().query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码中，我们提供ContentResolver对象的query方法查询BookProvider中的数据，其中”content://com.ryg.chapter_2.provider.book.provider”位移标识了BookProvider，这个标识正式为BookProvider的android:authorities属性所指定的值。</p>
<p>运行结果如下</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> 16:50:31.678: I/System.<span class="keyword">out</span>(22482): onCreate current thread:main        <span class="comment">//主线程</span></div><div class="line">01-11 16:50:31.680: I/System.<span class="keyword">out</span>(22482): <span class="keyword">query</span> current thread:Binder_2  <span class="comment">//Binder线程池中</span></div><div class="line">01-11 16:50:31.681: I/System.<span class="keyword">out</span>(22482): <span class="keyword">query</span> current thread:Binder_1</div><div class="line">01-11 16:50:31.682: I/System.<span class="keyword">out</span>(22482): <span class="keyword">query</span> current thread:Binder_2</div><div class="line">01-11 16:50:31.682: I/System.<span class="keyword">out</span>(22482): <span class="keyword">query</span> current thread:Binder_1</div></pre></td></tr></table></figure>
<p>从结果可以看出，onCreate运行于主线程中，所以不能在onCreate中做耗时操作，query方法的四次调用不在同一个线程中，但是在同一个Binder线程池中。</p>
<p>接下来，我们继续完善BookProvider，从而使其对外界的应用提供数据。为了完成上述功能，我们需要一个数据库来管理图示和用户信息，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookOpenHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DB_NAME = <span class="string">"book_provider.db"</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BOOK_TABLE_NAME = <span class="string">"book"</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_TABLE_NAME = <span class="string">"user"</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DB_VERSION = <span class="number">1</span>;</div><div class="line">	</div><div class="line">	<span class="comment">//图书列表</span></div><div class="line">	<span class="keyword">private</span> String CREATE_BOOK_TABLE = <span class="string">"CREATE TABLE IF NOT EXISTS "</span> + BOOK_TABLE_NAME +<span class="string">"(_id INTEGER PRIMARY KEY, name TEXT)"</span>;</div><div class="line">	<span class="comment">//用户列表</span></div><div class="line">	<span class="keyword">private</span> String CREATE_USER_TABLE = <span class="string">"CREATE TABLE IF NOT EXISTS "</span> + USER_TABLE_NAME +<span class="string">"(_id INTEGER PRIMARY KEY, name TEXT, sex INT)"</span>;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BookOpenHelper</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(context, DB_NAME, <span class="keyword">null</span>, DB_VERSION);</div><div class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		db.execSQL(CREATE_BOOK_TABLE);</div><div class="line">		db.execSQL(CREATE_USER_TABLE);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，分别为book表和user表指定Uri，并关联对应的uri——code</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookOpenHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DB_NAME = <span class="string">"book_provider.db"</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BOOK_TABLE_NAME = <span class="string">"book"</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_TABLE_NAME = <span class="string">"user"</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DB_VERSION = <span class="number">1</span>;</div><div class="line">	</div><div class="line">	<span class="comment">//图书列表</span></div><div class="line">	<span class="keyword">private</span> String CREATE_BOOK_TABLE = <span class="string">"CREATE TABLE IF NOT EXISTS "</span> + BOOK_TABLE_NAME +<span class="string">"(_id INTEGER PRIMARY KEY, name TEXT)"</span>;</div><div class="line">	<span class="comment">//用户列表</span></div><div class="line">	<span class="keyword">private</span> String CREATE_USER_TABLE = <span class="string">"CREATE TABLE IF NOT EXISTS "</span> + USER_TABLE_NAME +<span class="string">"(_id INTEGER PRIMARY KEY, name TEXT, sex INT)"</span>;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BookOpenHelper</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(context, DB_NAME, <span class="keyword">null</span>, DB_VERSION);</div><div class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	.......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们就可以通过如下方式获取外界要访问点饿数据源，根据Uri取出Uri_code，根据Uri_code得到数据表的名称</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span> </span>&#123;</div><div class="line"></div><div class="line">	String tableName = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="keyword">switch</span> (sUriMatcher.match(uri)) &#123;</div><div class="line"></div><div class="line">	<span class="keyword">case</span> BOOK_URI_CODE:</div><div class="line"></div><div class="line">		tableName = BookOpenHelper.BOOK_TABLE_NAME;</div><div class="line">		</div><div class="line">		<span class="keyword">break</span>;</div><div class="line"></div><div class="line">	<span class="keyword">case</span> USER_URI_CODE:</div><div class="line">		</div><div class="line">		tableName = BookOpenHelper.USER_TABLE_NAME;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line"></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> tableName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，我们就实现query、update、insert、delete方法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORITY = <span class="string">"com.ryg.chapter_2.provider.book.provider"</span>;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri BOOK_CONTENT_URI = Uri.parse(<span class="string">"content://"</span></div><div class="line">			+ AUTHORITY + <span class="string">"/book"</span>);</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOOK_URI_CODE = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri USER_CONTENT_URI = Uri.parse(<span class="string">"content://"</span></div><div class="line">			+ AUTHORITY + <span class="string">"/user"</span>);</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> USER_URI_CODE = <span class="number">1</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> UriMatcher sUriMatcher = <span class="keyword">new</span> UriMatcher(</div><div class="line">			UriMatcher.NO_MATCH);</div><div class="line"></div><div class="line">	<span class="keyword">static</span> &#123;</div><div class="line">		<span class="comment">// 将Uri和Uri_Code关联起来</span></div><div class="line">		sUriMatcher.addURI(AUTHORITY, <span class="string">"book"</span>, <span class="number">0</span>);</div><div class="line">		sUriMatcher.addURI(AUTHORITY, <span class="string">"book"</span>, <span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Context mContext;</div><div class="line">	<span class="keyword">private</span> SQLiteDatabase db;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">		mContext = getContext();</div><div class="line">		initData();</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		db = <span class="keyword">new</span> BookOpenHelper(mContext).getWritableDatabase();</div><div class="line">		db.execSQL(<span class="string">"delete from "</span> + BookOpenHelper.BOOK_TABLE_NAME);</div><div class="line">		db.execSQL(<span class="string">"delete from "</span> + BookOpenHelper.USER_TABLE_NAME);</div><div class="line">		db.execSQL(<span class="string">"insert into book values(2,'Android');"</span>);</div><div class="line">		db.execSQL(<span class="string">"insert into book values(3,'IOS');"</span>);</div><div class="line">		db.execSQL(<span class="string">"insert into book values(4,'Window Phone');"</span>);</div><div class="line">		db.execSQL(<span class="string">"insert into user values(6,'lee',1);"</span>);</div><div class="line">		db.execSQL(<span class="string">"insert into book values(7,'lau',0);"</span>);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection,</span></span></div><div class="line">			String[] selectionArgs, String sortOrder) &#123;</div><div class="line">		</div><div class="line">		String table = getTableName(uri);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported URI: "</span> + uri);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> db.query(table, projection, selection, selectionArgs, <span class="keyword">null</span>, <span class="keyword">null</span>, sortOrder, <span class="keyword">null</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		String table = getTableName(uri);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported URI: "</span> + uri);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		db.insert(table, <span class="keyword">null</span>, values);</div><div class="line">		mContext.getContentResolver().notifyChange(uri, <span class="keyword">null</span>); <span class="comment">//通过数据源变化</span></div><div class="line">		</div><div class="line">		<span class="keyword">return</span> uri;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		String table = getTableName(uri);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported URI: "</span> + uri);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> count = db.delete(table, selection, selectionArgs);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (count &gt;<span class="number">0</span>) &#123;</div><div class="line">			mContext.getContentResolver().notifyChange(uri, <span class="keyword">null</span>);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> count;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection,</span></span></div><div class="line">			String[] selectionArgs) &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		</div><div class="line">		String table = getTableName(uri);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported URI: "</span> + uri);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> row = db.update(table, values, selection, selectionArgs);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (row &gt; <span class="number">0</span>) &#123;</div><div class="line">			mContext.getContentResolver().notifyChange(uri, <span class="keyword">null</span>);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> row;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span> </span>&#123;</div><div class="line"></div><div class="line">		String tableName = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">		<span class="keyword">switch</span> (sUriMatcher.match(uri)) &#123;</div><div class="line"></div><div class="line">		<span class="keyword">case</span> BOOK_URI_CODE:</div><div class="line"></div><div class="line">			tableName = BookOpenHelper.BOOK_TABLE_NAME;</div><div class="line">			</div><div class="line">			<span class="keyword">break</span>;</div><div class="line"></div><div class="line">		<span class="keyword">case</span> USER_URI_CODE:</div><div class="line">			</div><div class="line">			tableName = BookOpenHelper.USER_TABLE_NAME;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line"></div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> tableName;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>访问BookProvider</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> ContentObserver mObserver = <span class="keyword">new</span> ContentObserver(<span class="keyword">new</span> Handler()) &#123;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange, Uri uri)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			System.out.println(uri);</div><div class="line">			<span class="keyword">super</span>.onChange(selfChange, uri);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		</div><div class="line">		</div><div class="line">		Uri uri = Uri.parse(<span class="string">"content://com.ryg.chapter_2.provider.book.provider/book"</span>);</div><div class="line">		getContentResolver().registerContentObserver(uri, <span class="keyword">false</span>, mObserver);</div><div class="line">		ContentValues values = <span class="keyword">new</span> ContentValues();</div><div class="line">		values.put(<span class="string">"_id"</span>, <span class="number">7</span>);</div><div class="line">		values.put(<span class="string">"name"</span>, <span class="string">"Html"</span>);</div><div class="line">		getContentResolver().insert(uri, values);</div><div class="line">		</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是，query、update、insert、delete四大方法是存在多线程并发访问的，因此方法内部要做好线程同步本例中，由于采用的是SQLite并且只有一个SQLiteDataBase的连接，所以可以正确应对多线程的情况。具体原因是SQLiteDatabase内部对数据库的操作是有同步处理的，但是如果通过多个SQLiteDatabase对象来操作数据库就无法保证线程同步，因为SQLiteDatabase对象之间无法进行线程同步。如果ContentProvider的底层数据是一块内存的话，比如List，在这种情况下同List的遍历、插入、删除操作就需要进行线程同步，否则就会引起并发错误。</p>
<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p>Socket又称为套接字，是网络通信的概念，它分为流式套接字和用户数据报套接字，分别对应于网络传输层的TCP和UDP协议。TCP是面向连接的协议，提供稳定的双向通信功能，TCP连接的建立需要经过“三次握手”才能完成，为了提供稳定的数据传输功能，其本身提供了超时重传机制，因此具有很高的稳定性；而UDP是面向无连接的协议，提供不稳定的单向通信功能，当然UDP也可以实现双向通信功能。在性能上，UDP具有更高的效率，其缺点是不能保证数据一定能够正确传输，尤其是在网络拥塞的情况下。</p>
<p>下面示例一个聊天室程序，首先是服务端的设计，当Service启动时，会在线程中建立TCP服务，这里监听的是8688端口，然后就可以等待客户端的连接请求。当有客户端连接时，就会生成一个新的Socket，通过每次新创建的Socket就可以分别和不同的客户端通信了。当客户端断开连接时，服务端这边也会关闭对应Socket并结束通话线程。这点是如何做到的呢？这里是通过判断服务端输入流的返回值来确定的，当客户端断开连接后，服务端这边的输入流会返回null，这个时候我们就知道客户端退出了。服务端代码如下：</p>
<h1 id="选用合适的IPC方式"><a href="#选用合适的IPC方式" class="headerlink" title="选用合适的IPC方式"></a>选用合适的IPC方式</h1><table>
<thead>
<tr>
<th>名称</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bundle</td>
<td>简单易用</td>
<td>只能传输Bundle支持的数据类型</td>
<td>四大组件间的进程间通信</td>
</tr>
<tr>
<td>文件共享</td>
<td>简单易用</td>
<td>不适合高并发场景，并且无法做到进程间的即时通信</td>
<td>无并发访问情形，交换简单的数据实时性不高的场景</td>
</tr>
<tr>
<td>AIDL</td>
<td>功能强大，支持一对多并发通信，支持实时通信</td>
<td>使用稍复杂，需要处理好现场同步</td>
<td>一对多通信且有RPC需求</td>
</tr>
<tr>
<td>Messenger</td>
<td>功能一般，支持一对多串行通信，支持实时通信</td>
<td>不能很好地处理搞并发情形，不支持RPC，数据通过Messenger进行传输，因此只能传输Bundle支持的数据类型</td>
<td>低并发的一对多即时通信，无RPC需求，或者无需要返回结果的RPC需求</td>
</tr>
<tr>
<td>ContentProvider</td>
<td>在数据源访问方面功能强大，支持一对多并发数据共享，可通过Call方法扩展其他操作</td>
<td>可以理解为受约束的AIDL，主要提供数据源的CRUD操作</td>
<td>一对多的进程间的数据共享</td>
</tr>
<tr>
<td>Socket</td>
<td>功能强大，可通过网络传输字节流，支持一对多并发实时通信</td>
<td>实现细节稍微有些烦琐，不支持直接的RPC</td>
<td>网络数据交换</td>
</tr>
</tbody>
</table>
</uses-permission>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list">
			 
        <li class="article-tag-list-item">
        	<a href="javascript:void(0)" class="article-tag-list-link color5">Android系统</a>
        </li>
      
		</ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book icon"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/04/19/Android的IPC方式/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Android的IPC机制" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/19/Android的IPC机制/">Android的IPC机制</a>
    </h1>
  

        
        <a href="/2016/04/19/Android的IPC机制/" class="archive-article-date">
  	<time datetime="2016-04-19T14:39:32.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-04-19 22:39:32</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Android-IPC简介"><a href="#Android-IPC简介" class="headerlink" title="Android IPC简介"></a>Android IPC简介</h2><p>IPC是Inter-Process Communication的缩写，含义为进程间通信，是指两个进程之间进行数据交换的过程。</p>
<p>Android中IPC的使用情况分为两种：</p>
<ul>
<li><p>第一种情况是一个应用因为某些原因自身需要采用多进程模式来实现，至于原因，可能有很多，比如有些模块由于特殊的原因需要运行在单独的进程中，又或者为了加大一个应用可使用的内存所以需要通过多进行来获取多分内存空间。</p>
</li>
<li><p>第二种情况是当前应用需要向其他应用获取数据，由于是两个应用，所以必须采用跨进程的方式来获取所需要的数据，甚至我们系统提供的ContentProvider去查询数据的时候，其实也是一种进程间通信，只不过通信细节被系统内部屏蔽了。</p>
</li>
</ul>
<h2 id="Android中的多进程模式"><a href="#Android中的多进程模式" class="headerlink" title="Android中的多进程模式"></a>Android中的多进程模式</h2><h3 id="开启多进行模式"><a href="#开启多进行模式" class="headerlink" title="开启多进行模式"></a>开启多进行模式</h3><p>正常情况下，在Android中多进程是指一个应用中存在多个进程的情况，因此这里不讨论两个应用之间的多进程情况。首先，在Android中使用多进程只有一种方法，就是给四大组件在AndroidManifest中指定android:process属性，除此之外没有其他办法。其实还有另一种非常规的多进程方法，那就是通过JNI在native层其fork一个新的进程，这种方法属于特殊情况，也不是常用的创建多进程的方式。下面示例，描述如何在Android中创建多进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;activity</div><div class="line">    android:name=<span class="string">"com.example.demo.AActivity"</span></div><div class="line">    android:process=<span class="string">":remote"</span> /&gt;</div><div class="line"></div><div class="line">&lt;activity</div><div class="line">    android:name=<span class="string">"com.example.demo.BActivity"</span></div><div class="line">    android:process=<span class="string">"com.example.demo.BaseActivity.remote"</span> /&gt;</div></pre></td></tr></table></figure>
<p>上面示例分为为AActivity和BActivity指定了process属性，并且他们的属性值不同，意味着当前应用又增加了两个进程。当AActivity启动时，系统会为它创建一个单独的进程，进程名为”com.example.demo.BaseActivity:remote”；当BActivity启动时，系统也会为它创建一个单独的进程，进程名为”com.example.demo.BaseActivity.remote”。</p>
<p>“:remote”和”com.example.demo.BaseActivity.remote”这两种命名方式的区别？</p>
<ul>
<li><p>首先“:”的含义是指要在当前的进程名前面附加当前的包名，而”com.example.demo.BaseActivity.remote”是完整的命名方式不会附加包名信息</p>
</li>
<li><p>其次，进程名以“:”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中，而进程名不易“：”开头的进程属于全局进程，其他应用通过ShareUID方式可以和它跑在同一个进程中。</p>
</li>
</ul>
<h3 id="多进程模式的运行机制"><a href="#多进程模式的运行机制" class="headerlink" title="多进程模式的运行机制"></a>多进程模式的运行机制</h3><p>Android为你每个应用分配了一个独立的虚拟机，或者说为每个进程都分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就会导致在不同的虚拟机中访问同一个类对象会产生多份副本。</p>
<p>所有运行在不同进程中的四大组件，只要它们之间需要通过内存来共享数据，都会共享失败，这也是多线程所带来的主要影响。</p>
<p>一般来说，使用多线程会造成如下四个方面的问题：</p>
<ul>
<li>（1）静态成员和单例模式完全失效</li>
</ul>
<p>Android为你每个应用分配了一个独立的虚拟机，或者说为每个进程都分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就会导致在不同的虚拟机中访问同一个类对象会产生多份副本。</p>
<ul>
<li>（2）线程同步机制完全失效</li>
</ul>
<p>本质上和第一个问题是类似的，既然都不是一块内存了，那么不管锁对象还是锁全局类都无法保证线程同步，因为不同进程锁的不是同一个对象。</p>
<ul>
<li>（3）SharedPreference的可靠性下降</li>
</ul>
<p>是因为SharedPreference不支持两个进程同步去执行写操作，否则会导致一定几率的丢失，这是因为SharedPreference底层是通过读/写XML文件实现的，并发写文件显然是可能出问题的，甚至并发读/写都有可能出问题。</p>
<ul>
<li>（4）Application会多次创建</li>
</ul>
<p>当一个组件跑在一个新的进程中的时候，<strong>由于系统要在创建新的进程同时分配独立的虚拟机，所以这个过程其实就是启动一个新应用的过程</strong>。因此，相当于系统又把这个应用重新启动了一遍，既然重新启动了，那么自然会创建新的Application。</p>
<p>在多进程模式中，不同进程的组件的确会拥有独立的虚拟机、Application和内存空间。</p>
<p>为了解决这个问题，Android系统提供了很多跨进程通信方法实现数据交互。如Intent来传递数据，共享文件和SharedPreference，基于Binder的Messenger和AIDL，Socket等。</p>
<h2 id="IPC基础概念介绍"><a href="#IPC基础概念介绍" class="headerlink" title="IPC基础概念介绍"></a>IPC基础概念介绍</h2><h3 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h3><p>Serializable是Java所提供的一个序列化接口，它是一个空接口，为对象提供标准的序列化和反序列化操作。使用Serializable来实现序列化相当简单只需要在类的声明中指定一个类似下面的标志即可自动实现默认的序列化过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5123020951483359287L</span>; <span class="comment">//系统生成的hash值</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>; <span class="comment">//指定为1L</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * </div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5123020951483359287L</span>; <span class="comment">//系统生成的hash值</span></div><div class="line">	</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> 		userId;</div><div class="line">	<span class="keyword">public</span> String 	userName;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> 	isMale;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"User [userId="</span> + userId + <span class="string">", userName="</span> + userName</div><div class="line">				+ <span class="string">", isMale="</span> + isMale + <span class="string">"]"</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过Serializable接口来实现对象的序列化过程非常简单，几乎所有的工作都被系统自动完成了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//序列化存储</span></div><div class="line">User user = <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">"liuguoquan"</span>, <span class="keyword">true</span>);</div><div class="line">	ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(Environment.getExternalStorageDirectory()+<span class="string">"/cache.txt"</span>));</div><div class="line">	out.writeObject(user);</div><div class="line">	out.close();</div><div class="line"></div><div class="line"><span class="comment">//反序列化</span></div><div class="line">	ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(Environment.getExternalStorageDirectory()+<span class="string">"/cache.txt"</span>));</div><div class="line">	User newUser = (User) in.readObject();</div><div class="line">	in.close();</div></pre></td></tr></table></figure>
<p>上述代码描述了采用Serializable方式序列化对象的典型过程，很简单，只需要把实现了Serializable接口的User对象写到文件中就可以快速恢复了，恢复后的对象newUser和user的内容完全一样，但是两者并不是同一个对象。</p>
<p>其实，不指定serialVersionUID也可以实现序列化，那到底要不要指定呢？系统既然提供了这个serialVersionUID，那么它必须是有用的，原则上序列化的数据中的serialVersionUID只有和当前类的serialVersionUID相同时才能够正常地被反序列化。</p>
<p>serialVersionUID的详细工作机制是这样的：序列化的时候系统会把当前类的serialVersionUID写入序列化的文件中，当反序列化的时候系统会去检查文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，如果一致说明序列化的类版本与当前类的版本是相同的则可以成功反序列化；否则就说明当前类和序列化的类相比发生了某些变化，比如成员变量的数量、类型可能发生了改变，这个时候是无法正常反序列化的。</p>
<p>给serialVersionUID指定为1L或者采用系统当前类结构去生成的hash值，这两者并没有什么区别，效果完全一样。以下两点需要注意：</p>
<ul>
<li>静态成员变量属于类不属于对象，所以不会参与序列化过程</li>
<li>用transient关键字标记的成员变量不参与序列化过程</li>
</ul>
<h3 id="Parcalable接口"><a href="#Parcalable接口" class="headerlink" title="Parcalable接口"></a>Parcalable接口</h3><p>Parcelable也是一个也是一个接口，只要实现这个接口，一个类的对象就要就可以实现序列化并可以通过Intent和Binder传递。下面的示例是一个典型的用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> sex;</div><div class="line">	<span class="keyword">private</span> User user;</div><div class="line">	</div><div class="line">	</div><div class="line"></div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//序列化</span></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		dest.writeInt(id);</div><div class="line">		dest.writeString(name);</div><div class="line">		dest.writeInt(sex);</div><div class="line">		dest.writeSerializable(user);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//反序列化</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Person&gt; CREATOR = <span class="keyword">new</span> Parcelable.Creator&lt;Person&gt;() &#123;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> Person <span class="title">createFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			</div><div class="line">			Person person = <span class="keyword">new</span> Person();</div><div class="line">			<span class="comment">//必须要按照成员变量的初始化顺序</span></div><div class="line">			person.id = source.readInt();</div><div class="line">			person.name = source.readString();</div><div class="line">			person.sex = source.readInt();</div><div class="line">			person.user = (User) source.readSerializable();</div><div class="line">			<span class="keyword">return</span> person;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="keyword">public</span> Person[] newArray(<span class="keyword">int</span> size) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Person[size];</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>系统已经为我们提供了许多实现了Parcelable接口的类，它们逗死可以直接序列化的，比如Intent、Bundle、Bitmap等，同时List和Map也可以序列化，前提是他们里面的每个元素都可以序列化。</p>
<p>既然Parcelable和Serializable都能实现序列化并且都可用于Intent间的数据传递，那么二者该如何选取呢？Serializable是Java中的序列化接口，其使用起来非常简单但是开销很大，序列化和反序列化过程需要大量的I/O操作。而Parcelable是Android中的序列化方式，因此更适合在Android平台上，它的缺点就是使用起来稍微麻烦点，但是它的效率很高，这是Android推荐的序列化方式。因此首选Parcelable。Parcelable主要用在内存序列化上，通过Parcelable将对象序列化到存储设备中或者将对象序列化后通过网络传输也都是可以的，但这个过程显得复杂，因此这两种情况下建议使用Serializable。</p>
<p>Binder是Android中的一个类，它实现了IBinder接口。从IPC角度来说，Binder是Android中的一种跨进程通信方式，Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在Linux中没有；从Android Framework角度来说，Binder是ServiceManager连接各种Manager（ActivityManager、WindowManager，等待）和相应的ManagerService的桥梁；从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindservice时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或数据，这里的服务包括普通的服务和基于AIDL的服务。</p>
<p>Android开发中，Binder主要用在service中，包括AIDL和Messenger，其中普通Service中的Binder不涉及进程间通信，而Messenger的底层其实是AIDL，所以这里选用AIDL来分析Binder的工作机制。</p>
<p>下面新建一个AIDL示例，新建三个文件Book.java、Book.aidl、IBookManager.aidl，代码如下所示：</p>
<p>Book.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">	<span class="keyword">package</span> com.ryg.chapter_2.aidl;</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="keyword">import</span> android.os.Parcel;</div><div class="line">	<span class="keyword">import</span> android.os.Parcelable;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> <span class="keyword">int</span> bookId;</div><div class="line">		<span class="keyword">public</span> String bookName;</div><div class="line">	</div><div class="line">		</div><div class="line">		</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">int</span> bookId, String bookName)</span> </span>&#123;</div><div class="line">			<span class="keyword">this</span>.bookId = bookId;</div><div class="line">			<span class="keyword">this</span>.bookName = bookName;</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			dest.writeInt(bookId);</div><div class="line">			dest.writeString(bookName);</div><div class="line">	</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Book&gt; CREATOR = <span class="keyword">new</span> Parcelable.Creator&lt;Book&gt;() &#123;</div><div class="line">	</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> Book <span class="title">createFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				</div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Book(source);</div><div class="line">			&#125;</div><div class="line">	</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="keyword">public</span> Book[] newArray(<span class="keyword">int</span> size) &#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Book[size];</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">		</div><div class="line">		</div><div class="line">		<span class="function"><span class="keyword">private</span> <span class="title">Book</span><span class="params">(Parcel in)</span> </span>&#123;</div><div class="line">			</div><div class="line">			bookId = in.readInt();</div><div class="line">			bookName = in.readString();</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">Book.aidl</div><div class="line"></div><div class="line">	<span class="keyword">package</span> com.ryg.chapter_2.aidl;</div><div class="line">	</div><div class="line">	parcelable Book;</div><div class="line"></div><div class="line">IBookManager.aidl</div><div class="line"></div><div class="line">	<span class="keyword">package</span> com.ryg.chapter_2.aidl;</div><div class="line">	</div><div class="line">	<span class="keyword">import</span> com.ryg.chapter_2.aidl.Book;</div><div class="line">	</div><div class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</div><div class="line">	</div><div class="line">		<span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</div><div class="line">		</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>Book.java是一个图书信息的类，它实现了Parcelable接口。Book.aidl是Book类在AIDL的声明。IBookManager.aidl是我们定义的一个接口，里面有两个方法，其中getBookList用于从远程服务端获取图书列表，而addBook用于向图书列表中添加一本书。尽管Book类已经和IBookManager位于相同的包中，但是IBookManager中仍然要导入Book类，接下来系统会在gen目录自动生成一个IBookManager的类。如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * This file is auto-generated.  DO NOT MODIFY.</div><div class="line"> * Original file: D:\\liuguoquan\\workspace\\chapter_2\\src\\com\\ryg\\chapter_2\\aidl\\IBookManager.aidl</div><div class="line"> */</div><div class="line"><span class="keyword">package</span> com.ryg.chapter_2.aidl;</div><div class="line"></div><div class="line"><span class="comment">//在Binder传输的接口都要实现IInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</div><div class="line">	<span class="comment">/** Local-side IPC implementation stub class. */</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span></span></div><div class="line">			<span class="title">com</span>.<span class="title">ryg</span>.<span class="title">chapter_2</span>.<span class="title">aidl</span>.<span class="title">IBookManager</span> &#123;</div><div class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.ryg.chapter_2.aidl.IBookManager"</span>;</div><div class="line"></div><div class="line">		<span class="comment">//内部类，这个Stub就是一个Binder类</span></div><div class="line">		<span class="comment">/** Construct the stub at attach it to the interface. */</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">/**</span></div><div class="line">		 * Cast an IBinder object into an com.ryg.chapter_2.aidl.IBookManager</div><div class="line">		 * interface, generating a proxy if needed.</div><div class="line">		 */</div><div class="line">		<span class="keyword">public</span> <span class="keyword">static</span> com.ryg.chapter_2.aidl.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(</span></span></div><div class="line">				android.os.IBinder obj) &#123;</div><div class="line">			<span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">			&#125;</div><div class="line">			android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</div><div class="line">			<span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.ryg.chapter_2.aidl.IBookManager))) &#123;</div><div class="line">				<span class="keyword">return</span> ((com.ryg.chapter_2.aidl.IBookManager) iin);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> com.ryg.chapter_2.aidl.IBookManager.Stub.Proxy(obj);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data,</span></span></div><div class="line">				android.os.Parcel reply, <span class="keyword">int</span> flags)</div><div class="line">				<span class="keyword">throws</span> android.os.RemoteException &#123;</div><div class="line">			<span class="keyword">switch</span> (code) &#123;</div><div class="line">			<span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</div><div class="line">				reply.writeString(DESCRIPTOR);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">case</span> TRANSACTION_getBookList: &#123;  <span class="comment">//用于标识方法</span></div><div class="line">				data.enforceInterface(DESCRIPTOR);</div><div class="line">				java.util.List&lt;com.ryg.chapter_2.aidl.Book&gt; _result = <span class="keyword">this</span></div><div class="line">						.getBookList();</div><div class="line">				reply.writeNoException();</div><div class="line">				reply.writeTypedList(_result);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">case</span> TRANSACTION_addBook: &#123;</div><div class="line">				data.enforceInterface(DESCRIPTOR);</div><div class="line">				com.ryg.chapter_2.aidl.Book _arg0;</div><div class="line">				<span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</div><div class="line">					_arg0 = com.ryg.chapter_2.aidl.Book.CREATOR</div><div class="line">							.createFromParcel(data);</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					_arg0 = <span class="keyword">null</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">this</span>.addBook(_arg0);</div><div class="line">				reply.writeNoException();</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span></span></div><div class="line">				<span class="title">com</span>.<span class="title">ryg</span>.<span class="title">chapter_2</span>.<span class="title">aidl</span>.<span class="title">IBookManager</span> &#123;</div><div class="line">			<span class="keyword">private</span> android.os.IBinder mRemote;</div><div class="line"></div><div class="line">			Proxy(android.os.IBinder remote) &#123;</div><div class="line">				mRemote = remote;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">return</span> mRemote;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">return</span> DESCRIPTOR;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="keyword">public</span> java.util.List&lt;com.ryg.chapter_2.aidl.Book&gt; getBookList()</div><div class="line">					<span class="keyword">throws</span> android.os.RemoteException &#123;</div><div class="line">				android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">				android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">				java.util.List&lt;com.ryg.chapter_2.aidl.Book&gt; _result;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					_data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">					mRemote.transact(Stub.TRANSACTION_getBookList, _data,</div><div class="line">							_reply, <span class="number">0</span>);</div><div class="line">					_reply.readException();</div><div class="line">					_result = _reply</div><div class="line">							.createTypedArrayList(com.ryg.chapter_2.aidl.Book.CREATOR);</div><div class="line">				&#125; <span class="keyword">finally</span> &#123;</div><div class="line">					_reply.recycle();</div><div class="line">					_data.recycle();</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">return</span> _result;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.ryg.chapter_2.aidl.Book book)</span></span></div><div class="line">					<span class="keyword">throws</span> android.os.RemoteException &#123;</div><div class="line">				android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">				android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					_data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">					<span class="keyword">if</span> ((book != <span class="keyword">null</span>)) &#123;</div><div class="line">						_data.writeInt(<span class="number">1</span>);</div><div class="line">						book.writeToParcel(_data, <span class="number">0</span>);</div><div class="line">					&#125; <span class="keyword">else</span> &#123;</div><div class="line">						_data.writeInt(<span class="number">0</span>);</div><div class="line">					&#125;</div><div class="line">					mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</div><div class="line">					_reply.readException();</div><div class="line">				&#125; <span class="keyword">finally</span> &#123;</div><div class="line">					_reply.recycle();</div><div class="line">					_data.recycle();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>); <span class="comment">//标识方法的id</span></div><div class="line">		<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> java.util.List&lt;com.ryg.chapter_2.aidl.Book&gt; getBookList()</div><div class="line">			<span class="keyword">throws</span> android.os.RemoteException;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.ryg.chapter_2.aidl.Book book)</span></span></div><div class="line">			<span class="keyword">throws</span> android.os.RemoteException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码实现的功能：<br>（1）IBookManager类继承IInterface接口，同时它自己也是个接口，所有可以在Binder中传输的接口都需要继承IInterface接口<br>（2）首先，它声明了两个方法getBookList和addBook，就是我们自IBookManager.aidl中定义的方法，同时还声明了两个整形id分别用于标识这两个方法，这两个id用于标识在transact中客户端所请求的到底是哪个方法<br>（3）接着，它声明了一个内部类Stub，这个Stub就是一个Binder类，当客户端和服务端都位于一个进程时，方法调用不会走跨进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由Stub的内部代理类Proxy来完成。这个接口的核心实现就是<strong>内部了Stub和Stub的内部代理类Proxy</strong></p>
<p><strong>说明：</strong>首先，当客户端发起远程请求时，由于当前线程会被挂起直至服务器进程返回数据，所以如果一个远程方法是很耗时的，那么不能在UI线程中发起次远程请求；其次，由于服务器的Binder方法运行在Binder线程池中，所以Binder方法不管是否耗时都应该采用同步的方式去实现，因为它已经运行在一个线程中了。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list">
			 
        <li class="article-tag-list-item">
        	<a href="javascript:void(0)" class="article-tag-list-link color5">Android系统</a>
        </li>
      
		</ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book icon"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/04/19/Android的IPC机制/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Android EventBus3.0源码解析" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/18/Android EventBus3.0源码解析/">Android EventBus3.0源码解析</a>
    </h1>
  

        
        <a href="/2016/04/18/Android EventBus3.0源码解析/" class="archive-article-date">
  	<time datetime="2016-04-18T15:05:06.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-04-18 23:05:06</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前面已经介绍了EventBus3.0开源库的详细使用，下面我们开始进入其源代码的学习，先看看EventBus3.0与2.x版本之间的区别。</p>
<blockquote>
<p>项目地址<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">https://github.com/greenrobot/EventBus</a><br>EventBus版本是3.0</p>
</blockquote>
<h1 id="EventBus-3-0与2-x的区别"><a href="#EventBus-3-0与2-x的区别" class="headerlink" title="EventBus 3.0与2.x的区别"></a>EventBus 3.0与2.x的区别</h1><h2 id="注册订阅者"><a href="#注册订阅者" class="headerlink" title="注册订阅者"></a>注册订阅者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//3.0版本的注册</span></div><div class="line">EventBus.getDefault().register(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"><span class="comment">//2.x版本的注册</span></div><div class="line">EventBus.getDefault().register(<span class="keyword">this</span>);</div><div class="line">EventBus.getDefault().register(<span class="keyword">this</span>, <span class="number">100</span>);</div><div class="line">EventBus.getDefault().registerSticky(<span class="keyword">this</span>, <span class="number">100</span>);</div><div class="line">EventBus.getDefault().registerSticky(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<p>2.x版本中有四种注册方法，区分了普通注册和粘性事件注册，并且在注册时可以选择接受事件的优先级；</p>
<p>3.0版本中将粘性事件以及订阅事件的优先级用注解的方式实现，所以3.0版本中的注册就变得只有一个register()方法注册。</p>
<h2 id="事件订阅方法"><a href="#事件订阅方法" class="headerlink" title="事件订阅方法"></a>事件订阅方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//3.0版本</span></div><div class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.BACKGROUND, sticky = <span class="keyword">true</span>, priority = <span class="number">100</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String str)</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//2.x版本</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(String str)</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventMainThread</span><span class="params">(String str)</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventBackgroundThread</span><span class="params">(String str)</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.x版本中只有通过onEvent开头的方法会被注册，而且响应事件方法触发的线程通过onEventMainThread或onEventBackgroundThread这些方法名区分；</p>
<p>3.0版本中，通过@Subscribe注解来确定运行的线程threadMode，是否接收粘性事件sticky以及事件优先级priority，而且方法名不再需要使用onEvent开头，所以3.0提高了简单性和灵活性。</p>
<h2 id="发送事件"><a href="#发送事件" class="headerlink" title="发送事件"></a>发送事件</h2><p>发送事件和发送粘性事件在2.x和3.0版本中是相同的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().post(<span class="string">"str"</span>);</div><div class="line">EventBus.getDefault().postSticky(<span class="string">"str"</span>);</div></pre></td></tr></table></figure>
<h2 id="解除注册"><a href="#解除注册" class="headerlink" title="解除注册"></a>解除注册</h2><p>2.x和3.0版本的解除注册的方法也是相同的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().unregister(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<h1 id="类关系图"><a href="#类关系图" class="headerlink" title="类关系图"></a>类关系图</h1><p>类图引用自<a href="http://a.codekk.com/detail/Android/Trinea/EventBus%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">CodeKK的EventBus源代码分析</a></p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/eventbus-%E7%B1%BB%E5%9B%BE.png" alt="类图"></p>
<p>从类图可以看出，上部分主要是订阅相关信息，中间是EventBus，下面部分是发布者发布事件后的调用。下面开始进入源码分析:</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>通过EventBus的使用流程来分析它的调用流程及实现原理。</p>
<h2 id="创建EventBus"><a href="#创建EventBus" class="headerlink" title="创建EventBus"></a>创建EventBus</h2><p>一般都是通过<code>EventBus.getDefault()</code>静态方法获取到EventBus对象，先来看看getDefault()方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">synchronized</span> (EventBus.class) &#123;</div><div class="line">			<span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">				defaultInstance = <span class="keyword">new</span> EventBus();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> defaultInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用<strong>单例模式</strong>获取EventBus对象，目的是保证getDefault方法得到的是同一个EventBus对象。第一次创建实例，会调用EventBus的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>(DEFAULT_BUILDER);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//key:订阅的事件 value：订阅这个事件的所有订阅者集合</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</div><div class="line"></div><div class="line"><span class="comment">//key:订阅者对象， value：这个订阅者订阅的事件集合</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</div><div class="line"></div><div class="line"><span class="comment">//粘性事件 key：粘性事件的class对象， value：事件对象</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</div><div class="line"></div><div class="line">EventBus(EventBusBuilder builder) &#123;</div><div class="line">	subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">	typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">	stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="comment">//事件主线程处理</span></div><div class="line">	mainThreadPoster = <span class="keyword">new</span> HandlerPoster(<span class="keyword">this</span>, Looper.getMainLooper(), <span class="number">10</span>);</div><div class="line">	<span class="comment">//事件Background处理</span></div><div class="line">	backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);</div><div class="line">	<span class="comment">//事件异步线程处理</span></div><div class="line">	asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);</div><div class="line">	indexCount = builder.subscriberInfoIndexes != <span class="keyword">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;</div><div class="line">	<span class="comment">//订阅者想要方法信息存储和查找</span></div><div class="line">	subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,</div><div class="line">			builder.strictMethodVerification, builder.ignoreGeneratedIndex);</div><div class="line">	logSubscriberExceptions = builder.logSubscriberExceptions;</div><div class="line">	logNoSubscriberMessages = builder.logNoSubscriberMessages;</div><div class="line">	sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</div><div class="line">	sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</div><div class="line">	throwSubscriberException = builder.throwSubscriberException;</div><div class="line">	<span class="comment">//是否支持事件继承</span></div><div class="line">	eventInheritance = builder.eventInheritance;</div><div class="line">	executorService = builder.executorService;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="注册事件过程"><a href="#注册事件过程" class="headerlink" title="注册事件过程"></a>注册事件过程</h2><h3 id="register-方法的实现"><a href="#register-方法的实现" class="headerlink" title="register()方法的实现"></a>register()方法的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</div><div class="line">	<span class="comment">//首先获取订阅者的class对象</span></div><div class="line">	Class&lt;`?&gt; subscriberClass = subscriber.getClass();</div><div class="line">	<span class="comment">//1 获取订阅者订阅的事件集合</span></div><div class="line">	List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</div><div class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">		<span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</div><div class="line">			<span class="comment">//2 订阅</span></div><div class="line">			subscribe(subscriber, subscriberMethod);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SubscriberMethod</span><span class="params">(Method method, Class&lt;?&gt; eventType, ThreadMode threadMode, <span class="keyword">int</span> priority, <span class="keyword">boolean</span> sticky)</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>.method = method; <span class="comment">//事件处理方法的Method对象</span></div><div class="line">	<span class="keyword">this</span>.threadMode = threadMode; <span class="comment">//线程的ThreadMode</span></div><div class="line">	<span class="keyword">this</span>.eventType = eventType; <span class="comment">//订阅的事件类型</span></div><div class="line">	<span class="keyword">this</span>.priority = priority; <span class="comment">//事件优先级</span></div><div class="line">	<span class="keyword">this</span>.sticky = sticky; <span class="comment">//是否接收粘性事件</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过subscriberMethodFinder.findSubscriberMethods(subscriberClass)方法可以返回一个SubscriberMethod对象的集合，下面来看看findSubscriberMethods()方法的实现</p>
<h3 id="SubscriberMethodFinder的实现"><a href="#SubscriberMethodFinder的实现" class="headerlink" title="SubscriberMethodFinder的实现"></a>SubscriberMethodFinder的实现</h3><p>SubscriberMethodFinder类就是用来查找和缓存订阅者响应方法的信息的类。那么怎么能获得订阅者响应函数的相关信息呢？在3.0版本中,EventBus提供了一个EventBusAnnotationProcessor注解处理器来在编译期通过读取@Subscribe注解并解析，然后生成java类来保存所有订阅者关于订阅的信息，这样就比在运行时使用反射来获得这些订阅者的信息速度要快。我们可以参考EventBus项目里的EventBusPerformance这个例子，编译后我们可以在build文件夹里找到这个类，MyEventBusIndex类，当然类名是可以自定义的，下面看一下生成的MyEventBusIndex类的组成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * This class is generated by EventBus, do not edit.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventBusIndex</span> <span class="keyword">implements</span> <span class="title">SubscriberInfoIndex</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        SUBSCRIBER_INDEX = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();</div><div class="line"></div><div class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(org.greenrobot.eventbusperf.testsubject.PerfTestEventBus.SubscriberClassEventBusAsync.class,</div><div class="line">                <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[]&#123;</div><div class="line">                <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventAsync"</span>, TestEvent.class, ThreadMode.ASYNC),</div><div class="line">        &#125;));</div><div class="line"></div><div class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(TestRunnerActivity.class, <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[]&#123;</div><div class="line">                <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventMainThread"</span>, TestFinishedEvent.class, ThreadMode.MAIN),</div><div class="line">        &#125;));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putIndex</span><span class="params">(SubscriberInfo info)</span> </span>&#123;</div><div class="line">        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);</div><div class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> info;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出是使用一个静态HashMap即：SUBSCRIBER_INDEX来保存订阅类的信息，其中包括了订阅类的Class对象，是否需要检查父类，以及订阅方法的信息SubscriberMethodInfo的数组，SubscriberMethodInfo中又保存了订阅方法的方法名、订阅的事件类型、触发线程，是否接收sticky事件以及优先级priority。这其中就保存了register()的所有需要的信息，如果再配置EventBus的时候通过EventBuilder配置：<code>eventBus=EventBus.builder().addIndex(new MyEventBusIndex()).build()</code>；来将编译生成的MyEventBusIndex配置进去，这样能在SubscriberMethodFinder类中直接查找出订阅类的信息，就不需要再利用注解判断了，这种方法是作为EventBus的可选配置存在的。</p>
<p>SubscriberMethodFinder同样提供了通过注解来获得订阅类信息的方法，下面来看看findSubscriberMethods()到底是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//先从Method_CACHE取看是否有缓存，key：保存订阅类的类名，value:保存类中订阅的方法名</span></div><div class="line">	List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</div><div class="line">	<span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">return</span> subscriberMethods;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//是否忽略注解器生成的MyEventIndex类，默认false</span></div><div class="line">	<span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</div><div class="line">		<span class="comment">//利用反射来读取订阅类中的订阅方法</span></div><div class="line">		subscriberMethods = findUsingReflection(subscriberClass);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">//从注解器生成的MyEventBusIndex类中获得订阅类的订阅方法</span></div><div class="line">		subscriberMethods = findUsingInfo(subscriberClass);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass</div><div class="line">				+ <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">//保存到缓存中</span></div><div class="line">		METHOD_CACHE.put(subscriberClass, subscriberMethods);</div><div class="line">		<span class="keyword">return</span> subscriberMethods;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>findUsingInfo()方法就是通过查找MyEventBusIndex类中的信息来转换成List<subscribermethod>从而获得订阅类的相关订阅方法的信息集合。</subscribermethod></p>
<p>下面来看看findUsingReflection()的实现过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingReflection</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">	<span class="comment">//FindState用来做订阅方法的校验和保存</span></div><div class="line">	FindState findState = prepareFindState();</div><div class="line">	findState.initForSubscriber(subscriberClass);</div><div class="line">	<span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">//通过反射获得订阅方法信息</span></div><div class="line">		findUsingReflectionInSingleClass(findState);</div><div class="line">		<span class="comment">//查找父类的订阅方法</span></div><div class="line">		findState.moveToSuperclass();</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//获取findState中的SubscriberMethod(也就是订阅方法List)并返回</span></div><div class="line">	<span class="keyword">return</span> getMethodsAndRelease(findState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里通过FindState类来做订阅方法的校验和保存，并通过FIND_STATE_POOL静态数组来保存FindState对象，可以使FindState复用，避免重复创建过多的对象，最终是通过findUsingReflectionSingleClass()来具体获得相关订阅方法的信息的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</div><div class="line">	Method[] methods;</div><div class="line">	<span class="comment">//通过反射得到方法数组</span></div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></div><div class="line">		methods = findState.clazz.getDeclaredMethods();</div><div class="line">	&#125; <span class="keyword">catch</span> (Throwable th) &#123;</div><div class="line">		<span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></div><div class="line">		methods = findState.clazz.getMethods();</div><div class="line">		findState.skipSuperClasses = <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//遍历Method</span></div><div class="line">	<span class="keyword">for</span> (Method method : methods) &#123;</div><div class="line">		<span class="keyword">int</span> modifiers = method.getModifiers();</div><div class="line">		<span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</div><div class="line">			Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</div><div class="line">			<span class="comment">//保证必须只有一个事件参数</span></div><div class="line">			<span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</div><div class="line">				<span class="comment">//得到注解</span></div><div class="line">				Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</div><div class="line">				<span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</div><div class="line">					Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</div><div class="line">					<span class="comment">//校验是否添加该方法</span></div><div class="line">					<span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</div><div class="line">						ThreadMode threadMode = subscribeAnnotation.threadMode();</div><div class="line">						<span class="comment">//实例化SubscriberMethod对象并添加</span></div><div class="line">						findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</div><div class="line">								subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</div><div class="line">				String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</div><div class="line">						<span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</div><div class="line">			String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</div><div class="line">					<span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码运行后，订阅类的所有SubscriberMethod都已经被保存了，最后在通过getMethodsAndRelease方法返回List<subscribermethod>集合。</subscribermethod></p>
<p>下面接着来看subscribe()是如何实现的</p>
<h3 id="subsribe-方法的实现"><a href="#subsribe-方法的实现" class="headerlink" title="subsribe()方法的实现"></a>subsribe()方法的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 必须在同步代码块中调用</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//获取订阅事件的事件类型</span></div><div class="line">	Class&lt;?&gt; eventType = subscriberMethod.eventType;</div><div class="line">	<span class="comment">//创建SubScription对象</span></div><div class="line">	Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</div><div class="line">	<span class="comment">//检查是否已经添加过该SubScription对象，添加过则抛出异常</span></div><div class="line">	CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line">	<span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</div><div class="line">		subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</div><div class="line">		subscriptionsByEventType.put(eventType, subscriptions);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></div><div class="line">					+ eventType);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//根据优先级来添加SubScription对象</span></div><div class="line">	<span class="keyword">int</span> size = subscriptions.size();</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</div><div class="line">		<span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</div><div class="line">			subscriptions.add(i, newSubscription);</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//将订阅者对象以及订阅的事件保存到typesBySubscriber中</span></div><div class="line">	List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</div><div class="line">	<span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</div><div class="line">		subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">		typesBySubscriber.put(subscriber, subscribedEvents);</div><div class="line">	&#125;</div><div class="line">	subscribedEvents.add(eventType);</div><div class="line">	<span class="comment">//如果接受sticky事件则立即分发sticky事件</span></div><div class="line">	<span class="keyword">if</span> (subscriberMethod.sticky) &#123;</div><div class="line">		<span class="comment">//eventInheritance表示是否分发订阅了响应事件类及父类事件的方法</span></div><div class="line">		<span class="keyword">if</span> (eventInheritance) &#123;</div><div class="line">			<span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></div><div class="line">			<span class="comment">// <span class="doctag">Note:</span> Iterating over all events may be inefficient with lots of sticky events,</span></div><div class="line">			<span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></div><div class="line">			<span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></div><div class="line">			Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</div><div class="line">			<span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</div><div class="line">				Class&lt;?&gt; candidateEventType = entry.getKey();</div><div class="line">				<span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</div><div class="line">					Object stickyEvent = entry.getValue();</div><div class="line">					checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			Object stickyEvent = stickyEvents.get(eventType);</div><div class="line">			checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一下结合一张图来理解整个注册过程：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/eventbus-%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.png" alt="注册过程"></p>
<h2 id="事件分发过程"><a href="#事件分发过程" class="headerlink" title="事件分发过程"></a>事件分发过程</h2><p>EventBus通过post方法来发送一个事件，首先看看post方法的实现过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</div><div class="line">	<span class="comment">//得到当前线程的Posting状态</span></div><div class="line">	PostingThreadState postingState = currentPostingThreadState.get();</div><div class="line">	<span class="comment">//获取当前线程的事件队列</span></div><div class="line">	List&lt;Object&gt; eventQueue = postingState.eventQueue;</div><div class="line">	<span class="comment">//加入事件到队列</span></div><div class="line">	eventQueue.add(event);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!postingState.isPosting) &#123;</div><div class="line">		postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</div><div class="line">		postingState.isPosting = <span class="keyword">true</span>;</div><div class="line">		<span class="keyword">if</span> (postingState.canceled) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">//发送知道队列为空</span></div><div class="line">			<span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</div><div class="line">				<span class="comment">//发送单个事件</span></div><div class="line">				postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">finally</span> &#123;</div><div class="line">			postingState.isPosting = <span class="keyword">false</span>;</div><div class="line">			postingState.isMainThread = <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先是通过currentPostingThreadState.get()方法来得到当前线程PostingThreadState的对象，为什么是说当前线程？我们来看看currentPostingThreadState的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = <span class="keyword">new</span> ThreadLocal&lt;PostingThreadState&gt;() &#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> PostingThreadState <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> PostingThreadState();</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>currentPostingThreadState的实现是一个包含了PostingThreadState的ThreadLocal对象。</p>
<p>ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储线程，而这段数据是不会与其他线程共享的，其内部原理是通过生成一个它包裹的泛型对象的数组，在不同的线程会有不同的数组索引值，这样就可以做到每个线程通过get()方法获取的时候，取到的只能是自己线程所对应的数据，所以这里取到的就是每个线程的PostingThreadState状态。</p>
<p>接下来我们来看postingSingleEvent()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</div><div class="line">	Class&lt;?&gt; eventClass = event.getClass();</div><div class="line">	<span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</div><div class="line">	<span class="comment">//是否触发订阅了该事件（eventClass）的父类，以及接口的类的响应方法</span></div><div class="line">	<span class="keyword">if</span> (eventInheritance) &#123;</div><div class="line">		<span class="comment">////查找eventClass类所有的父类以及接口</span></div><div class="line">		List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</div><div class="line">		<span class="keyword">int</span> countTypes = eventTypes.size();</div><div class="line">		<span class="comment">//循环postSingleEventForEventType</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</div><div class="line">			Class&lt;?&gt; clazz = eventTypes.get(h);</div><div class="line">			subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="comment">//post单个事件</span></div><div class="line">		subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//如果没有发现</span></div><div class="line">	<span class="keyword">if</span> (!subscriptionFound) &#123;</div><div class="line">		<span class="keyword">if</span> (logNoSubscriberMessages) &#123;</div><div class="line">			Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</div><div class="line">				eventClass != SubscriberExceptionEvent.class) &#123;</div><div class="line">				<span class="comment">//发送一个NoSubscriberEvent事件，如果我们需要处理这种状态，接收这个事件就可以了</span></div><div class="line">			post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面可知，实际上事件分发是在postSingleEventForEventType()方法里进行的，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</div><div class="line">	CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</div><div class="line">	<span class="comment">//获取订阅了这个事件的Subscription列表.</span></div><div class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">		subscriptions = subscriptionsByEventType.get(eventClass);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</div><div class="line">		<span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</div><div class="line">			postingState.event = event;</div><div class="line">			postingState.subscription = subscription;</div><div class="line">			<span class="comment">//是否被中断</span></div><div class="line">			<span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="comment">//分发给订阅者</span></div><div class="line">				postToSubscription(subscription, event, postingState.isMainThread);</div><div class="line">				aborted = postingState.canceled;</div><div class="line">			&#125; <span class="keyword">finally</span> &#123;</div><div class="line">				postingState.event = <span class="keyword">null</span>;</div><div class="line">				postingState.subscription = <span class="keyword">null</span>;</div><div class="line">				postingState.canceled = <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (aborted) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</div><div class="line">	<span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</div><div class="line">		<span class="keyword">case</span> POSTING:</div><div class="line">			invokeSubscriber(subscription, event);</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> MAIN:</div><div class="line">			<span class="keyword">if</span> (isMainThread) &#123;</div><div class="line">				invokeSubscriber(subscription, event);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				mainThreadPoster.enqueue(subscription, event);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> BACKGROUND:</div><div class="line">			<span class="keyword">if</span> (isMainThread) &#123;</div><div class="line">				backgroundPoster.enqueue(subscription, event);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				invokeSubscriber(subscription, event);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> ASYNC:</div><div class="line">			asyncPoster.enqueue(subscription, event);</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先从subscriptionsByEventType里获得所有订阅了这个事件的Subscription列表，然后在通过postToSubScription()方法来分发事件，在postToSubScription()通过不同的threadMode在不同的线程里invoke()订阅者的方法，ThreadMode共有四类：</p>
<ul>
<li><p>PostThread：默认的 ThreadMode，表示在执行 Post 操作的线程直接调用订阅者的事件响应方法，不论该线程是否为主线程（UI 线程）。当该线程为主线程时，响应方法中不能有耗时操作，否则有卡主线程的风险。适用场景：对于是否在主线程执行无要求，但若 Post 线程为主线程，不能耗时的操作；</p>
</li>
<li><p>MainThread：在主线程中执行响应方法。如果发布线程就是主线程，则直接调用订阅者的事件响应方法，否则通过主线程的 Handler 发送消息在主线程中处理——调用订阅者的事件响应函数。显然，MainThread类的方法也不能有耗时操作，以避免卡主线程。适用场景：必须在主线程执行的操作；</p>
</li>
<li><p>BackgroundThread：在后台线程中执行响应方法。如果发布线程不是主线程，则直接调用订阅者的事件响应函数，否则启动唯一的后台线程去处理。由于后台线程是唯一的，当事件超过一个的时候，它们会被放在队列中依次执行，因此该类响应方法虽然没有PostThread类和MainThread类方法对性能敏感，但最好不要有重度耗时的操作或太频繁的轻度耗时操作，以造成其他操作等待。适用场景：操作轻微耗时且不会过于频繁，即一般的耗时操作都可以放在这里；</p>
</li>
<li><p>Async：不论发布线程是否为主线程，都使用一个空闲线程来处理。和BackgroundThread不同的是，Async类的所有线程是相互独立的，因此不会出现卡线程的问题。适用场景：长耗时操作，例如网络访问。</p>
</li>
</ul>
<p>下面我们来看看invokeSubscriber(subscription, event)是如何实现的，关于不同线程的Poster使用可以参考这篇文章<a href="http://kymjs.com/code/2015/12/12/01" target="_blank" rel="external">http://kymjs.com/code/2015/12/12/01</a></p>
<p>invokeSubscriber(subscription, event)代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</div><div class="line">	&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">		handleSubscriberException(subscription, event, e.getCause());</div><div class="line">	&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上就是通过反射调用了订阅者的订阅函数并把event对象作为参数传入，至此post()流程如上述所示。整体流程图如下：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/eventbus-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B.png" alt="Post流程"></p>
<h2 id="解除注册过程"><a href="#解除注册过程" class="headerlink" title="解除注册过程"></a>解除注册过程</h2><p>解除注册只要调用unregister()方法即可，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</div><div class="line">	<span class="comment">//通过typesBySubscriber来取出这个subscriber订阅者订阅的事件类型,</span></div><div class="line">	List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</div><div class="line">	<span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">//分别解除每个订阅了的事件类型</span></div><div class="line">		<span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</div><div class="line">			unsubscribeByEventType(subscriber, eventType);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//从typesBySubscriber移除subscriber</span></div><div class="line">		typesBySubscriber.remove(subscriber);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		Log.w(TAG, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>&#123;</div><div class="line">	<span class="comment">//subscriptionsByEventType里拿出这个事件类型的订阅者列表.</span></div><div class="line">	List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line">	<span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">int</span> size = subscriptions.size();</div><div class="line">		<span class="comment">//取消订阅</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">			Subscription subscription = subscriptions.get(i);</div><div class="line">			<span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</div><div class="line">				subscription.active = <span class="keyword">false</span>;</div><div class="line">				subscriptions.remove(i);</div><div class="line">				i--;</div><div class="line">				size--;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终分别从typesBySubscriber和subscriptions里分别移除订阅者以及相关信息即可</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式是对象的行为模式，又叫发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者模式。观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。EventBus并不是标准的观察者模式的实现，但是它的整体就是一个发布/订阅框架，也拥有观察者模式的有点，比如：发布者和订阅者的解耦。</p>
<p>参考文章:</p>
<p><a href="http://www.jianshu.com/p/f057c460c77e" target="_blank" rel="external">EventBus 3.0 源码分析</a><br><a href="http://kymjs.com/code/2015/12/12/01" target="_blank" rel="external">EventBus源码研读</a><br><a href="http://a.codekk.com/detail/Android/Trinea/EventBus%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">EventBus 源码解析</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list">
			 
        <li class="article-tag-list-item">
        	<a href="javascript:void(0)" class="article-tag-list-link color5">源码分析</a>
        </li>
      
		</ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book icon"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/04/18/Android EventBus3.0源码解析/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Android Otto源码解析" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/18/Android Otto源码解析/">Otto源码解析</a>
    </h1>
  

        
        <a href="/2016/04/18/Android Otto源码解析/" class="archive-article-date">
  	<time datetime="2016-04-18T15:04:06.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-04-18 23:04:06</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前面介绍了<a href="http://liuguoquan727.github.io/2016/04/17/Android_Otto%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">Otto的使用情况</a>，下面开始进入Otto的源码分析之旅。</p>
<p>首先来看看构造函数：</p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> String identifier;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadEnforcer enforcer;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> HandlerFinder handlerFinder;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bus</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(DEFAULT_IDENTIFIER);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bus</span><span class="params">(String identifier)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(ThreadEnforcer.MAIN, identifier);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bus</span><span class="params">(ThreadEnforcer enforcer, String identifier)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(enforcer, identifier, HandlerFinder.ANNOTATED);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Bus(ThreadEnforcer enforcer, String identifier, HandlerFinder handlerFinder) &#123;</div><div class="line">    <span class="keyword">this</span>.enforcer =  enforcer;</div><div class="line">    <span class="keyword">this</span>.identifier = identifier;</div><div class="line">    <span class="keyword">this</span>.handlerFinder = handlerFinder;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认参数enforcer=ThreadEnforcer.MAIN，identifier=DEFAULT_IDENTIFIER，handlerFinder=HandlerFinder.ANNOTATED。下面来看看这些参数是什么意思：</p>
<h2 id="ThreadEnforce"><a href="#ThreadEnforce" class="headerlink" title="ThreadEnforce"></a>ThreadEnforce</h2><p>ThreadEnforce是一个接口，enforce()方法用于检查当前的线程是否为指定的线程类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadEnforcer</span> </span>&#123;</div><div class="line"></div><div class="line">    ThreadEnforcer ANY = <span class="keyword">new</span> ThreadEnforcer() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enforce</span><span class="params">(Bus bus)</span> </span>&#123;</div><div class="line">                <span class="comment">// Allow any thread.</span></div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    ThreadEnforcer MAIN = <span class="keyword">new</span> ThreadEnforcer() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enforce</span><span class="params">(Bus bus)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span> (Looper.myLooper() != Looper.getMainLooper()) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Event bus "</span> + bus +</div><div class="line">                        <span class="string">" accessed from non-main thread "</span> + Looper.myLooper());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enforce</span><span class="params">(Bus bus)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不带参数的构造函数默认使用ThreadEnforcer.MAIN，表示enforce()方法必须在主线程上执行。</p>
<h2 id="identifier"><a href="#identifier" class="headerlink" title="identifier"></a>identifier</h2><p>identifier为Bus对象的名字，debug用</p>
<h2 id="HandlerFinder"><a href="#HandlerFinder" class="headerlink" title="HandlerFinder"></a>HandlerFinder</h2><p>HandlerFinder用于在注册/反注册的时候查找Subscriber和Produce，后文会对其展开源码级别的解析。默认使用HandlerANNOTATED，表示使用注解来进行查找。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>除上述以外，Bus类还有两个成员变量handlersByType和producersByType:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">** 通过event的类型（class类型）来查找event handle。</div><div class="line">*	键为 event类型  值为 事件订阅者集合</div><div class="line">*	一个事件类型可以有多个事件订阅者</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; handlersByType =</div><div class="line">	  <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt;();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">** 通过event的类型（class类型）来查找event producer。</div><div class="line">*	键为 event类型  值为 事件生产者</div><div class="line">*	一个事件类型，只能有一个事件生产者</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, EventProducer&gt; producersByType =</div><div class="line">	  <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, EventProducer&gt;();</div></pre></td></tr></table></figure>
<h1 id="注册-反注册事件"><a href="#注册-反注册事件" class="headerlink" title="注册/反注册事件"></a>注册/反注册事件</h1><p>如下所示要成为订阅者HandlerEvent，只需将其注册到bus，然后使用@Subscribe注解标记回调处理方法即可。回调方法要求可见性为public，有且仅有一个参数，类型为订阅的event。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</div><div class="line">        bus.register(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Subscribe</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">answerAvailable</span><span class="params">(HandlerEvent event)</span> </span>&#123;</div><div class="line">        <span class="comment">// process event</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Subsrible"><a href="#Subsrible" class="headerlink" title="@Subsrible"></a>@Subsrible</h2><p>首先看一下@Subscribe注解:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(ElementType.METHOD)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Subscribe &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RetentionPolicy.RUNTIME表示它是运行时的注解，ElementType.METHOD表示用于注解方法。</p>
<h2 id="register"><a href="#register" class="headerlink" title="register()"></a>register()</h2><p>register流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object object)</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//1.检查当前线程是否符合ThreadEnforcer的设置</span></div><div class="line">	<span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</div><div class="line">	  <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Object to register must not be null."</span>);</div><div class="line">	&#125;</div><div class="line">	enforcer.enforce(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">	<span class="comment">//2.默认情况下，通过@Producer注解找到所有的事件生产者Producers</span></div><div class="line">	Map&lt;Class&lt;?&gt;, EventProducer&gt; foundProducers = handlerFinder.findAllProducers(object);</div><div class="line">	<span class="keyword">for</span> (Class&lt;?&gt; type : foundProducers.keySet()) &#123;</div><div class="line"></div><div class="line">	  <span class="comment">//2-1 判断object上的produce注册的event是否已经被别人注册过</span></div><div class="line">	  <span class="keyword">final</span> EventProducer producer = foundProducers.get(type);</div><div class="line"></div><div class="line">	  <span class="comment">//type存在则返回type对应的值 type不存在则将type的键值设为producer</span></div><div class="line">	  EventProducer previousProducer = producersByType.putIfAbsent(type, producer);</div><div class="line">	  <span class="comment">//checking if the previous producer existed</span></div><div class="line">	  <span class="keyword">if</span> (previousProducer != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Producer method for type "</span> + type</div><div class="line">		  + <span class="string">" found on type "</span> + producer.target.getClass()</div><div class="line">		  + <span class="string">", but already registered by type "</span> + previousProducer.target.getClass() + <span class="string">"."</span>);</div><div class="line">	  &#125;</div><div class="line"></div><div class="line"></div><div class="line">	  <span class="comment">//2-2 如果没有被注册过，那么找出对应event的handler，触发一次回调</span></div><div class="line">	  Set&lt;EventHandler&gt; handlers = handlersByType.get(type);</div><div class="line">	  <span class="keyword">if</span> (handlers != <span class="keyword">null</span> &amp;&amp; !handlers.isEmpty()) &#123;</div><div class="line">		<span class="keyword">for</span> (EventHandler handler : handlers) &#123;</div><div class="line">		  dispatchProducerResultToHandler(handler, producer);</div><div class="line">		&#125;</div><div class="line">	  &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//3. 找出object上用@Subscribe注解的方法</span></div><div class="line">	Map&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; foundHandlersMap = handlerFinder.findAllSubscribers(object);</div><div class="line">	<span class="keyword">for</span> (Class&lt;?&gt; type : foundHandlersMap.keySet()) &#123;</div><div class="line">	  Set&lt;EventHandler&gt; handlers = handlersByType.get(type);</div><div class="line">	  </div><div class="line">	  </div><div class="line">	  <span class="keyword">if</span> (handlers == <span class="keyword">null</span>) &#123;</div><div class="line">		</div><div class="line">		<span class="comment">//3-1，该event是第一次注册，那么新建一个CopyOnWriteArraySet用来保存handler和event的对应关系</span></div><div class="line">		</div><div class="line">		Set&lt;EventHandler&gt; handlersCreation = <span class="keyword">new</span> CopyOnWriteArraySet&lt;EventHandler&gt;();</div><div class="line">		handlers = handlersByType.putIfAbsent(type, handlersCreation);</div><div class="line">		<span class="keyword">if</span> (handlers == <span class="keyword">null</span>) &#123;</div><div class="line">			handlers = handlersCreation;</div><div class="line">		&#125;</div><div class="line">	  &#125;</div><div class="line">	  </div><div class="line">	  <span class="comment">//3-2,保存object中新增的event-handler对应关系</span></div><div class="line">	  <span class="keyword">final</span> Set&lt;EventHandler&gt; foundHandlers = foundHandlersMap.get(type);</div><div class="line">	  <span class="keyword">if</span> (!handlers.addAll(foundHandlers)) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Object already registered."</span>);</div><div class="line">	  &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//4.检查object上的event是否存在对应的Producer，有则触发一次调用</span></div><div class="line">	<span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; entry : foundHandlersMap.entrySet()) &#123;</div><div class="line">	  Class&lt;?&gt; type = entry.getKey();</div><div class="line">	  EventProducer producer = producersByType.get(type);</div><div class="line">	  <span class="keyword">if</span> (producer != <span class="keyword">null</span> &amp;&amp; producer.isValid()) &#123;</div><div class="line">		Set&lt;EventHandler&gt; foundHandlers = entry.getValue();</div><div class="line">		<span class="keyword">for</span> (EventHandler foundHandler : foundHandlers) &#123;</div><div class="line">		  <span class="keyword">if</span> (!producer.isValid()) &#123;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		  &#125;</div><div class="line">		  <span class="keyword">if</span> (foundHandler.isValid()) &#123;</div><div class="line">			dispatchProducerResultToHandler(foundHandler, producer);</div><div class="line">		  &#125;</div><div class="line">		&#125;</div><div class="line">	  &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>register方法主要做了三件事情：触发新的Producer；注册新的event-handler关系；触发旧的Producer。另外有两点要注意：</p>
<ul>
<li>在保证线程安全的情况下，使用CopyOnWriteArraySet作为保存event和handler的容器，可以大大提高效率。</li>
<li>由于register方法没有加锁，所有在3-1中，尽管已经检查了handlers是否存在，但仍需使用putIfAbsent来保存handler。</li>
</ul>
<h2 id="HandlerFinder-1"><a href="#HandlerFinder-1" class="headerlink" title="HandlerFinder"></a>HandlerFinder</h2><p>注意到Bus通过HandlerFinder来查找object上的producer和subscriber，接下来看一下HanderFinder的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HandlerFinder</span> </span>&#123;</div><div class="line"></div><div class="line">  Map&lt;Class&lt;?&gt;, EventProducer&gt; findAllProducers(Object listener);</div><div class="line"></div><div class="line">  Map&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; findAllSubscribers(Object listener);</div><div class="line"></div><div class="line"></div><div class="line">  HandlerFinder ANNOTATED = <span class="keyword">new</span> HandlerFinder() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Map&lt;Class&lt;?&gt;, EventProducer&gt; findAllProducers(Object listener) &#123;</div><div class="line">      <span class="keyword">return</span> AnnotatedHandlerFinder.findAllProducers(listener);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Map&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; findAllSubscribers(Object listener) &#123;</div><div class="line">      <span class="keyword">return</span> AnnotatedHandlerFinder.findAllSubscribers(listener);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中findAllProducers方法返回某event type对应的EventProducers，findAllSubscribers返回某event type对应的EventHandler集合。</p>
<h2 id="EventProducer"><a href="#EventProducer" class="headerlink" title="EventProducer"></a>EventProducer</h2><p>EventProducer是producer方法的包装类，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventProducer</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Object target;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hashCode;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    EventProducer(Object target, Method method) &#123;</div><div class="line">        <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(</div><div class="line">                <span class="string">"EventProducer target cannot be null."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(</div><div class="line">                <span class="string">"EventProducer method cannot be null."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.target = target;</div><div class="line">        <span class="keyword">this</span>.method = method;</div><div class="line">        method.setAccessible(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 提前计算hashcode，以防每次调用hash()时消耗资源</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</div><div class="line">        hashCode = ((prime + method.hashCode()) * prime) + target.hashCode();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> valid;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 应在object unregister时调用</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span> </span>&#123;</div><div class="line">        valid = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">produceEvent</span><span class="params">()</span> <span class="keyword">throws</span> InvocationTargetException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!valid) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(toString() +</div><div class="line">                <span class="string">" has been invalidated and can no longer produce events."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> method.invoke(target);</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e);</div><div class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">            <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> Error) &#123;</div><div class="line">                <span class="keyword">throw</span> (Error) e.getCause();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 produceEvent方法用于获得event。可以看出Otto要求produce方法不能有参数。</p>
<h2 id="EventHandler"><a href="#EventHandler" class="headerlink" title="EventHandler"></a>EventHandler</h2><p>EventHandler是一个event handler方法（事件回调）的包装类，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hashCode;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    EventHandler(Object target, Method method) &#123;</div><div class="line">        <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(</div><div class="line">                <span class="string">"EventHandler target cannot be null."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(</div><div class="line">                <span class="string">"EventHandler method cannot be null."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.target = target;</div><div class="line">        <span class="keyword">this</span>.method = method;</div><div class="line">        method.setAccessible(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Compute hash code eagerly since we know it will be used frequently and we cannot estimate the runtime of the</span></div><div class="line">        <span class="comment">// target's hashCode call.</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</div><div class="line">        hashCode = ((prime + method.hashCode()) * prime) + target.hashCode();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> valid;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span> </span>&#123;</div><div class="line">        valid = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">(Object event)</span> <span class="keyword">throws</span> InvocationTargetException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!valid) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(toString() +</div><div class="line">                <span class="string">" has been invalidated and can no longer handle events."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            method.invoke(target, event);</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e);</div><div class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">            <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> Error) &#123;</div><div class="line">                <span class="keyword">throw</span> (Error) e.getCause();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中handlEvent方法用于在object上调用handle方法（事件回调），传入event对象。Otto要求event handler方法只能有一个参数就是event handler类。</p>
<h2 id="dispatchProducerResultToHandler"><a href="#dispatchProducerResultToHandler" class="headerlink" title="dispatchProducerResultToHandler()"></a>dispatchProducerResultToHandler()</h2><p>dispatchProducerResultToHandler方法用于将Producer产生的event分发给对应的handler，源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchProducerResultToHandler</span><span class="params">(EventHandler handler, EventProducer producer)</span> </span>&#123;</div><div class="line">    Object event = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        event = producer.produceEvent();</div><div class="line">    &#125; <span class="keyword">catch</span>(InvocationTargetException e) &#123;</div><div class="line">        throwRuntimeException(<span class="string">"Producer "</span> + producer + <span class="string">" threw an exception."</span>, e);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    dispatch(event, handler);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Object event, EventHandler wrapper)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        wrapper.handleEvent(event);</div><div class="line">    &#125; <span class="keyword">catch</span>(InvocationTargetException e) &#123;</div><div class="line">        throwRuntimeException(<span class="string">"Could not dispatch event: "</span> + event.getClass() + <span class="string">" to handler "</span> + wrapper, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要使用了Producer的produceEvent()获取event对象后，调用EventHandler的handleEvent（）方法处理事件。</p>
<h2 id="unregister"><a href="#unregister" class="headerlink" title="unregister()"></a>unregister()</h2><p>Bus类的unregister()方法用于解除目标对象和Bus之间的关联关系，包括对象上的producer方法，subscriber方法，源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object object)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Object to unregister must not be null."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//1. 检查当前线程是否符合ThreadEnforcer的设置</span></div><div class="line">    enforcer.enforce(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="comment">//2. 默认情况下，通过注解在object上找出所有Producer，将其从producersByType中删除并标记为invalidate</span></div><div class="line">    Map&lt;Class&lt;?&gt;, EventProducer&gt; producersInListener = handlerFinder.findAllProducers(object);</div><div class="line">    <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, EventProducer&gt; entry : producersInListener.entrySet()) &#123;</div><div class="line">        <span class="keyword">final</span> Class&lt;?&gt; key = entry.getKey();</div><div class="line">        EventProducer producer = getProducerForEventType(key);</div><div class="line">        EventProducer value = entry.getValue();</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span> || !value.equals(producer)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">            <span class="string">"Missing event producer for an annotated method. Is "</span> + object.getClass() + <span class="string">" registered?"</span>);</div><div class="line">        &#125;</div><div class="line">        producersByType.remove(key).invalidate();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//3. 默认情况下，找出object上用@Subscribe注解了的handler，将其从event集合中删除并标记为invalidate</span></div><div class="line">    Map&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; handlersInListener = handlerFinder.findAllSubscribers(object);</div><div class="line">    <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; entry : handlersInListener.entrySet()) &#123;</div><div class="line">        Set&lt;EventHandler&gt; currentHandlers = getHandlersForEventType(entry.getKey());</div><div class="line">        Collection&lt;EventHandler&gt; eventMethodsInListener = entry.getValue();</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (currentHandlers == <span class="keyword">null</span> || !currentHandlers.containsAll(eventMethodsInListener)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">            <span class="string">"Missing event handler for an annotated method. Is "</span> + object.getClass() + <span class="string">" registered?"</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (EventHandler handler : currentHandlers) &#123;</div><div class="line">            <span class="keyword">if</span> (eventMethodsInListener.contains(handler)) &#123;</div><div class="line">                handler.invalidate();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        currentHandlers.removeAll(eventMethodsInListener);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="投递事件"><a href="#投递事件" class="headerlink" title="投递事件"></a>投递事件</h1><h2 id="post"><a href="#post" class="headerlink" title="post()"></a>post()</h2><p>简单的事件投递过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">bus.post(<span class="keyword">new</span> HandlerEvent(<span class="number">42</span>));</div><div class="line"></div><div class="line">或者</div><div class="line"></div><div class="line">bus.post(getEvent);</div><div class="line"></div><div class="line"><span class="meta">@Producer</span></div><div class="line"><span class="function"><span class="keyword">public</span> HandlerEvent <span class="title">getEvent</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> HandlerEvent(<span class="number">42</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面来看下post方法实现的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function">ublic <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Event to post must not be null."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//1. 检查当前线程是否符合ThreadEnforcer的设置</span></div><div class="line">    enforcer.enforce(<span class="keyword">this</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//2. 向上追溯event的所有父类</span></div><div class="line">    Set&lt;Class&lt;?&gt;&gt;dispatchTypes = flattenHierarchy(event.getClass());</div><div class="line">    </div><div class="line">    <span class="comment">//3. 当前event没有注册handler，则发送一个DeadEvent事件</span></div><div class="line">    <span class="keyword">boolean</span> dispatched = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">for</span> (Class&lt;?&gt;eventType: dispatchTypes) &#123;</div><div class="line">        Set&lt;EventHandler&gt; wrappers = getHandlersForEventType(eventType);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (wrappers != <span class="keyword">null</span> &amp;&amp; !wrappers.isEmpty()) &#123;</div><div class="line">            dispatched = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">for</span> (EventHandler wrapper: wrappers) &#123;</div><div class="line">                <span class="comment">//3-1 将事件和handler放到分发队列里</span></div><div class="line">                enqueueEvent(event, wrapper);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//4. 当前event没有注册handler，则发送一个DeadEvent事件</span></div><div class="line">    <span class="keyword">if</span> (!dispatched &amp;&amp; !(event <span class="keyword">instanceof</span> DeadEvent)) &#123;</div><div class="line">        post(<span class="keyword">new</span> DeadEvent(<span class="keyword">this</span>, event));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//5. 通知队列进行分发操作</span></div><div class="line">    dispatchQueuedEvents();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意两点：</p>
<ul>
<li>发送一个Event时，订阅了Event父类的Subscriber方法也会被调用</li>
<li>事件被放到调用者所在线程的队列里依次分发</li>
</ul>
<h2 id="flattenHierarchy"><a href="#flattenHierarchy" class="headerlink" title="flattenHierarchy()"></a>flattenHierarchy()</h2><p>进行post操作时，首先会通过flattenHierarchy方法获得event的所有父类或接口的集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"> Set&lt;Class&lt;?&gt;&gt; flattenHierarchy(Class&lt;?&gt; concreteClass) &#123;</div><div class="line">   Set&lt;Class&lt;?&gt;&gt; classes = flattenHierarchyCache.get(concreteClass);</div><div class="line">   <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</div><div class="line">     Set&lt;Class&lt;?&gt;&gt; classesCreation = getClassesFor(concreteClass);</div><div class="line">     classes = flattenHierarchyCache.putIfAbsent(concreteClass, classesCreation);</div><div class="line">     <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</div><div class="line">       classes = classesCreation;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">return</span> classes;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="comment">//利用深度优先遍历导出了concreteClass的所有父类</span></div><div class="line"> <span class="keyword">private</span> Set&lt;Class&lt;?&gt;&gt; getClassesFor(Class&lt;?&gt; concreteClass) &#123;</div><div class="line">   List&lt;Class&lt;?&gt;&gt; parents = <span class="keyword">new</span> LinkedList&lt;Class&lt;?&gt;&gt;();</div><div class="line">   Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;();</div><div class="line"></div><div class="line">   parents.add(concreteClass);</div><div class="line"></div><div class="line"><span class="comment">//深度优先遍历</span></div><div class="line">   <span class="keyword">while</span> (!parents.isEmpty()) &#123;</div><div class="line">     Class&lt;?&gt; clazz = parents.remove(<span class="number">0</span>);</div><div class="line">     classes.add(clazz);</div><div class="line"></div><div class="line">     Class&lt;?&gt; parent = clazz.getSuperclass();</div><div class="line">     <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">       parents.add(parent);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> classes;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="Dispatch-Queue"><a href="#Dispatch-Queue" class="headerlink" title="Dispatch Queue"></a>Dispatch Queue</h2><p>通过post方法投递的event首先会放到当前线程所在的Dispatch Queue中，然后依次分发。Bus类有如下成员属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;ConcurrentLinkedQueue&lt;EventWithHandler&gt;&gt; eventsToDispatch =</div><div class="line">    <span class="keyword">new</span> ThreadLocal&lt;ConcurrentLinkedQueue&lt;EventWithHandler&gt;&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> ConcurrentLinkedQueue&lt;EventWithHandler&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcurrentLinkedQueue&lt;EventWithHandler&gt;();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>eventsToDispatch是一个ThreadLocal对象，通过initialValue()方法，eventsToDispatch每次在新的线程上调用的时候都会生成新的ConcurrentLinkedQueue实例。event是通过enqueueEvent方法放到queue中的，下面看看equeueEvent()的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">enqueueEvent</span><span class="params">(Object event, EventHandler handler)</span> </span>&#123;</div><div class="line">	eventsToDispatch.get().offer(<span class="keyword">new</span> EventWithHandler(event, handler));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>offer()方法会将EventWithHandler对象放到当前线程的queue的尾部。offer方法和add方法的区别在于，当无法插入（例如空间不够）情况下会返回false，而不是抛出异常。EventWithHandler类对event和handler的关系进行了简单的包装，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EventWithHandler</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> Object event;</div><div class="line">	<span class="keyword">final</span> EventHandler handler;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">EventWithHandler</span><span class="params">(Object event, EventHandler handler)</span> </span>&#123;</div><div class="line">	  <span class="keyword">this</span>.event = event;</div><div class="line">	  <span class="keyword">this</span>.handler = handler;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来看看dispatchQueuedEvents方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchQueuedEvents</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// don't dispatch if we're already dispatching, that would allow reentrancy and out-of-order events. Instead, leave</span></div><div class="line">    <span class="comment">// the events to be dispatched after the in-progress dispatch is complete.</span></div><div class="line">    <span class="comment">//1. 不能重复分发，否则会导致event的分发次序混乱</span></div><div class="line">    <span class="keyword">if</span> (isDispatching.get()) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    isDispatching.set(<span class="keyword">true</span>);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="comment">//2. 依次取出EventWithHandler，并通过dispatch方法进行分发。</span></div><div class="line">            EventWithHandler eventWithHandler = eventsToDispatch.get().poll();</div><div class="line">            <span class="keyword">if</span> (eventWithHandler == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (eventWithHandler.handler.isValid()) &#123;</div><div class="line">                dispatch(eventWithHandler.event, eventWithHandler.handler);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        isDispatching.set(<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Object event, EventHandler wrapper)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      wrapper.handleEvent(event);</div><div class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">      throwRuntimeException(</div><div class="line">          <span class="string">"Could not dispatch event: "</span> + event.getClass() + <span class="string">" to handler "</span> + wrapper, e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>值得注意的是，所有subscrible方法抛出的异常都会在这里捕获，捕获到异常以后event分发过程即停止，直到下一次在该线程上调用post为止。</p>
<h1 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h1><p>Otto的总体结构如下表示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">            +-------------------------+</div><div class="line">            |Bus(ThreadLocal)         |</div><div class="line">            |     +--------------+    |</div><div class="line">            |     |EventProducers|    |</div><div class="line">            |     |  +-------+   |  register  +-------+</div><div class="line">            |     |  |Produce|   &lt;----+-------+Produce|</div><div class="line">            |     |  +-------+   |    |       +-------+</div><div class="line">            |     |  +-------+   |    |</div><div class="line">            |     |  |Produce|   |    |</div><div class="line">            |     |  +-------+   |    |</div><div class="line">            |     +--------------+    |</div><div class="line">            |            |            |</div><div class="line">            |          event          |</div><div class="line">            |            |            |</div><div class="line"> post(event)|    +-------v--------+   |</div><div class="line">+----------------&gt; Dispatch Queue |   |</div><div class="line">            |    +-------+--------+   |</div><div class="line">            |            |            |</div><div class="line">            |          event          |</div><div class="line">            |            |            |</div><div class="line">            |     +------v------+     |</div><div class="line">            |     |EventHandlers|     |</div><div class="line">            |     | +---------+ |     |</div><div class="line">            |     | |Subscribe| |   register  +---------+</div><div class="line">            |     | +---------+ &lt;-----+-------+Subscribe|</div><div class="line">            |     | +---------+ |     |       +---------+</div><div class="line">            |     | |Subscribe| |     |</div><div class="line">            |     | +---------+ |     |</div><div class="line">            |     +-------------+     |</div><div class="line">            |                         |</div><div class="line">            +-------------------------+</div></pre></td></tr></table></figure>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list">
			 
        <li class="article-tag-list-item">
        	<a href="javascript:void(0)" class="article-tag-list-link color5">源码分析</a>
        </li>
      
		</ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book icon"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/04/18/Android Otto源码解析/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Android Okhttp使用详解" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/Android Okhttp使用详解/">Okhttp使用详解</a>
    </h1>
  

        
        <a href="/2016/04/17/Android Okhttp使用详解/" class="archive-article-date">
  	<time datetime="2016-04-17T14:04:06.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-04-17 22:04:06</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Okhttp是高性能的http库，支持同步、异步，而且实现了spdy、http2、websocket协议，api很简洁易用，和volley一样实现了http协议的缓存。Okhttp已经被Android官方采用，实现了几乎和Java.net.HttpURLConnection一样的功能。</p>
<h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="http://square.github.io/okhttp/" target="_blank" rel="external">官方介绍：http://square.github.io/okhttp/</a><br><a href="https://github.com/square/okhttp" target="_blank" rel="external">Github源代码：https://github.com/square/okhttp</a></p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ul>
<li>一般的Get请求</li>
<li>一般的Post请求</li>
<li>基于Http的文件上传</li>
<li>文件下载</li>
<li>加载图片</li>
<li>支持请求回调，直接返回对象、对象集合</li>
<li>支持session的保持</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="Http-Get"><a href="#Http-Get" class="headerlink" title="Http Get"></a>Http Get</h2><p>对于网络加载库，最常用的就是http get请求，比如获取一个网页的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">//1.创建OkHttpClient对象</span></div><div class="line">    OkHttpClient mOkHttpClient = <span class="keyword">new</span> OkHttpClient();</div><div class="line"></div><div class="line">    <span class="comment">//2.创建一个Request</span></div><div class="line">    <span class="keyword">final</span> Request mRequest = <span class="keyword">new</span> Request.Builder().url(<span class="string">"https://www.baidu.com"</span>).build();</div><div class="line"></div><div class="line">    <span class="comment">//3.创建Call对象</span></div><div class="line">    Call mCall = mOkHttpClient.newCall(mRequest);</div><div class="line"></div><div class="line">    <span class="comment">//4.请求加入调度</span></div><div class="line">    mCall.enqueue(<span class="keyword">new</span> Callback() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</div><div class="line"></div><div class="line">            runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    mMsgTxt.setText(<span class="string">"failure"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, <span class="keyword">final</span> Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"></div><div class="line">            <span class="comment">//字符串</span></div><div class="line">            <span class="keyword">final</span> String msg = response.body().string();</div><div class="line">            <span class="comment">//字节数组</span></div><div class="line">            <span class="keyword">byte</span>[] msgBytes = response.body().bytes();</div><div class="line">            <span class="comment">//流</span></div><div class="line">            InputStream inputStream = response.body().byteStream();</div><div class="line"></div><div class="line">            runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    mMsgTxt.setText(msg);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就是发送一个Get请求的步骤</p>
<ol>
<li>首先构造一个Request对象，参数最少有个url，可以通过Request.Builder设置更多的参数，比如：header、method等。</li>
<li>然后通过Request的对象去够着一个Call对象，类似于将你的请求封装成任务。</li>
<li>最后，我们希望以异步的方式去执行请求，所以我们调用的是call.equeue，将call加入调度队列，然后等待任务执行完成，在Callback中即可得到结果。注意，回调方法都是运行在子线程中，如果需要操作控件，需要使用Handler切换到主线程。</li>
</ol>
<p>上面是异步的方式执行get请求，当然也支持阻塞的方式，直接调用call.execute()方法返回一个Response。如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//阻塞调用</span></div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Response response = mCall.execute();</div><div class="line">			System.out.println(response.body().string());</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<h2 id="Http-post请求"><a href="#Http-post请求" class="headerlink" title="Http post请求"></a>Http post请求</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Request request = buildMultipartFormRequest(</div><div class="line">        url, <span class="keyword">new</span> File[]&#123;file&#125;, <span class="keyword">new</span> String[]&#123;fileKey&#125;, <span class="keyword">null</span>);</div><div class="line">FormEncodingBuilder builder = <span class="keyword">new</span> FormEncodingBuilder();   </div><div class="line">builder.add(<span class="string">"username"</span>,<span class="string">"liuguoquan"</span>);</div><div class="line"></div><div class="line">Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">                   .url(url)</div><div class="line">                .post(builder.build())</div><div class="line">                .build();</div><div class="line"> mOkHttpClient.newCall(request).enqueue(<span class="keyword">new</span> Callback()&#123;&#125;);</div></pre></td></tr></table></figure>
<p>Post请求时，参数是包含在请求体中的，所以我们通过FormEncodingBuilder，添加多个String键值对，然后去构造RequestBody，最后完成Request的构造。</p>
<h2 id="基于Http的文件上传"><a href="#基于Http的文件上传" class="headerlink" title="基于Http的文件上传"></a>基于Http的文件上传</h2><p>接下来构造一个RequestBody的Builder叫做MultipartBuilder。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">File file = new File(Environment.getExternalStorageDirectory(), "balabala.mp4");</div><div class="line"></div><div class="line">RequestBody fileBody = RequestBody.create(MediaType.parse("application/octet-stream"), file);</div><div class="line"></div><div class="line">RequestBody requestBody = new MultipartBuilder()</div><div class="line">     .type(MultipartBuilder.FORM)</div><div class="line">     .addPart(Headers.of(</div><div class="line">          "Content-Disposition", </div><div class="line">              "form-data; name=\"username\""), </div><div class="line">          RequestBody.create(null, "liu"))</div><div class="line">     .addPart(Headers.of(</div><div class="line">         "Content-Disposition", </div><div class="line">         "form-data; name=\"mFile\"; </div><div class="line">         filename=\"wjd.mp4\""), fileBody)</div><div class="line">     .build();</div><div class="line"></div><div class="line">Request request = new Request.Builder()</div><div class="line">    .url("http://192.168.1.103:8080/okHttpServer/fileUpload")</div><div class="line">    .post(requestBody)</div><div class="line">    .build();</div><div class="line"></div><div class="line">Call call = mOkHttpClient.newCall(request);</div><div class="line">call.enqueue(new Callback()</div><div class="line">&#123;</div><div class="line">    //...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上述代码向服务器传递了一个键值对username：liu和一个文件。通过MultipartBuilder的addPart方法可以添加键值对或者文件。</p>
<h2 id="图片下载"><a href="#图片下载" class="headerlink" title="图片下载"></a>图片下载</h2><p>图片下载和文件下载，这两个是通过回调的Response拿到byte[]然后解码成图片；文件下载就是拿到InputStream后做写文件操作。</p>
<p>参考文章：</p>
<p><a href="http://blog.csdn.net/lmj623565791/article/details/23781773" target="_blank" rel="external">从原理角度解析Android （Java） http 文件上传</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0106/2275.html" target="_blank" rel="external">泡网：OkHttp使用教程</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list">
			 
        <li class="article-tag-list-item">
        	<a href="javascript:void(0)" class="article-tag-list-link color3">实战</a>
        </li>
      
		</ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book icon"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/04/17/Android Okhttp使用详解/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Android_Otto使用详解" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/Android_Otto使用详解/">Otto使用详解</a>
    </h1>
  

        
        <a href="/2016/04/17/Android_Otto使用详解/" class="archive-article-date">
  	<time datetime="2016-04-17T12:04:06.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-04-17 20:04:06</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Otto是Square推出的基于Guava项目的Android支持库，otto是一个事件总线，用于应用程序的不同组件之间进行有效的通信。OTTO是基于Observer的设计模式。它有发布者，订阅者这两个主要对象。OTTO的最佳实践就是通过反射牺牲了微小的性能，同时极大的降低了程序的耦合度。</p>
<p>Otto官网: <a href="http://square.github.io/otto/" target="_blank" rel="external">http://square.github.io/otto/</a></p>
<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>Otto框架的主要功能是帮助我们来降低多个组件通信之间的耦合度（解耦）。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>比如：由界面A跳转至界面B，然后点击B中的Button发送消息更新界面A的视图；<br>比如：界面有一个界面A，A里面有个Fragment，点击Fragment中的一个Button，跳转至界面B，点击界面B的Button来更新界面A的Fragment视图，等等。</p>
<p>上面列出的两种场景，以前可以用startActivityForResult和interface的方式实现的话会比较麻烦，并且产生了很多的状态判断和逻辑判断，并且可能产生很多不必要的bug，代码量也比较大和繁琐，使用Otto就可以容易的避免这些问题。</p>
<h1 id="基本用法实例"><a href="#基本用法实例" class="headerlink" title="基本用法实例"></a>基本用法实例</h1><h2 id="添加Otto"><a href="#添加Otto" class="headerlink" title="添加Otto"></a>添加Otto</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">dependencies</span> &#123;</div><div class="line">  <span class="keyword">compile</span> <span class="string">'com.squareup:otto:1.3.8'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="实现一个Bus的单例"><a href="#实现一个Bus的单例" class="headerlink" title="实现一个Bus的单例"></a>实现一个Bus的单例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  单例Bus对象</div><div class="line"> * Created by Michael on 2016/4/25.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BusProvider</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Bus bus = <span class="keyword">new</span> Bus();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bus <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> bus;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BusProvider</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自定义一个Event事件，封装消息"><a href="#自定义一个Event事件，封装消息" class="headerlink" title="自定义一个Event事件，封装消息"></a>自定义一个Event事件，封装消息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义一个Event事件，用来封装信息</div><div class="line"> * Created by Michael on 2016/4/25.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventFirst</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> String msg;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventFirst</span><span class="params">(String msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.msg = msg;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="MainActivity，订阅事件"><a href="#MainActivity，订阅事件" class="headerlink" title="MainActivity，订阅事件"></a>MainActivity，订阅事件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Button mBtn1;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        <span class="comment">//订阅事件</span></div><div class="line">        BusProvider.getInstance().register(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">        mBtn1 = (Button) findViewById(R.id.btn_1);</div><div class="line"></div><div class="line">        mBtn1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,BActivity.class));</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 处理事件EventFirst</div><div class="line">     * <span class="doctag">@param</span> event</div><div class="line">     */</div><div class="line">    <span class="meta">@Subscribe</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventFirst</span><span class="params">(EventFirst event)</span> </span>&#123;</div><div class="line"></div><div class="line">        mBtn1.setText(event.msg);</div><div class="line">        System.out.println(<span class="string">"onEventFirst:"</span> + event.msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Subscribe</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventSecond</span><span class="params">(EventFirst event)</span> </span>&#123;</div><div class="line"></div><div class="line">        mBtn1.setText(event.msg);</div><div class="line">        System.out.println(<span class="string">"onEventFirst:"</span> + event.msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        <span class="comment">//取消订阅</span></div><div class="line">        BusProvider.getInstance().register(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>@Subscrible这个注解在调用了register之后有效，表示订阅一个事件，并且方法用public修饰，方法名可以任意取，参数为自定义的事件类，Otto根据事件对象的类名来判断和处理对应的事件。</p>
<h2 id="BActivity发送订阅事件"><a href="#BActivity发送订阅事件" class="headerlink" title="BActivity发送订阅事件"></a>BActivity发送订阅事件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Button mBtn;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_b);</div><div class="line"></div><div class="line"><span class="comment">//        BusProvider.getInstance().register(this);</span></div><div class="line"></div><div class="line">        mBtn = (Button) findViewById(R.id.btn_1);</div><div class="line"></div><div class="line">        mBtn.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line"> <span class="comment">//               BusProvider.getInstance().post(new EventFirst("Event First"));</span></div><div class="line">                BusProvider.getInstance().post(produceEventFirst());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 产生事件</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Produce</span></div><div class="line">    <span class="function"><span class="keyword">public</span> EventFirst <span class="title">produceEventFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EventFirst(<span class="string">"Event First"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line"><span class="comment">//        BusProvider.getInstance().unregister(this);</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>@Produce注解告诉Bus该函数是一个事件产生者，产生的事件类型为该函数的返回值。</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>点击BActivity中的按钮发送消息，然后返回至MainActivity中，打印如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">04</span>-<span class="number">25</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">13.179</span> <span class="number">24744</span>-<span class="number">24744</span>/com<span class="selector-class">.example</span><span class="selector-class">.michael</span><span class="selector-class">.ottodemo</span> I/System<span class="selector-class">.out</span>: onEventSecond:Event First</div><div class="line"><span class="number">04</span>-<span class="number">25</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">13.179</span> <span class="number">24744</span>-<span class="number">24744</span>/com<span class="selector-class">.example</span><span class="selector-class">.michael</span><span class="selector-class">.ottodemo</span> I/System<span class="selector-class">.out</span>: onEventFirst:Event First</div></pre></td></tr></table></figure>
<p>结果说明：@Subscrible注解的消息处理函数时根据事件对象的类名来确定事件类型，这里的两个方法的参数都是EventFirst类型，所以两个方法都处理了EventFirst事件消息。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过例子我们可以发现，其实事件发布者不用@Produce注解和注册事件也可以发布消息。但是你要Subscribe订阅事件就一定要register这个类了,否则是接受不到事件的。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list">
			 
        <li class="article-tag-list-item">
        	<a href="javascript:void(0)" class="article-tag-list-link color3">实战</a>
        </li>
      
		</ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book icon"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/04/17/Android_Otto使用详解/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Android_EventBus使用详解" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/Android_EventBus使用详解/">EventBus使用详解</a>
    </h1>
  

        
        <a href="/2016/04/17/Android_EventBus使用详解/" class="archive-article-date">
  	<time datetime="2016-04-17T11:22:20.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-04-17 19:22:20</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>EventBus是一个Android事件发布/订阅框架，通过解耦发布者和订阅者简化Android事件传递，这里的事件可以理解为消息。事件传递既可以用于Android四大组件间通讯，也可以用于异步线程和主线程间通讯等。<br>传统的事件传递方式包括：Handler、BroadcastReceiver、Interface回调，相比之下EventBus的有点是代码简洁，使用简单，并将事件发布和 订阅充分解耦。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>事件Event： </strong>又可成为消息，其实就是一个对象，可以是网络请求返回的字符串，也可以是某个开关状态等等。事件类型EventType是指事件所属的Class。</p>
<p>事件分为一般事件和Sticky事件，相对于一般事件，Sticky事件不同之处在于，当事件发布后，再有订阅者开始订阅该类型事件，依然能收到该类型事件的最近一个Sticky事件。</p>
<p><strong>订阅者Subscriber： </strong>订阅某种事件类型的对象，当有发布者发布这类事件后，EventBus会执行订阅者的onEvent函数，这个函数叫事件响应函数。订阅者通过register接口订阅某个事件类型，unregister接口退订。订阅者存在优先级，优先级高的订阅者可以取消事件继续向优先级低的订阅者分发，默认所有订阅者优先级都为0。</p>
<p><strong>发布者Publisher： </strong>发布某事件的对象，通过post接口发布事件。</p>
<h2 id="GitHub地址"><a href="#GitHub地址" class="headerlink" title="GitHub地址"></a>GitHub地址</h2><p><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus源码：https://github.com/greenrobot/EventBus</a></p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="自定义一个事件类"><a href="#自定义一个事件类" class="headerlink" title="自定义一个事件类"></a>自定义一个事件类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnyEventType</span> </span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="title">AnyEventType</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="在要接受消息的页面注册"><a href="#在要接受消息的页面注册" class="headerlink" title="在要接受消息的页面注册"></a>在要接受消息的页面注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().register(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<h3 id="接收消息的方法"><a href="#接收消息的方法" class="headerlink" title="接收消息的方法"></a>接收消息的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Subscribe</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(AnyEventType event)</span> </span>&#123;<span class="comment">/* Do something */</span>&#125;;</div></pre></td></tr></table></figure>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().post(event);</div></pre></td></tr></table></figure>
<h3 id="取消注册"><a href="#取消注册" class="headerlink" title="取消注册"></a>取消注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().unregister(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面我们来实现一个具体的例子来介绍EventBus的基本使用。</p>
<p>需求如下：在MainActivity中注册EventBus事件，并实现事件响应方法，当点击MainActivity中的按钮时跳转到SecondActivity，当点击SecondActivity中的按钮时向MainActivity发送Event事件，当MainActivity收到事件后，将事件内容显示在TextView中。</p>
<ol>
<li><p>MainActivity<br><img src="http://7xs7a3.com1.z0.glb.clouddn.com/EventBus_before.png" alt="MainActivity"></p>
</li>
<li><p>SecondActivity<br><img src="http://7xs7a3.com1.z0.glb.clouddn.com/EnventBus_middle.png" alt=""></p>
</li>
<li><p>事件处理<br><img src="http://7xs7a3.com1.z0.glb.clouddn.com/EventBus_Afer.png" alt=""></p>
</li>
</ol>
<h3 id="事件类Event"><a href="#事件类Event" class="headerlink" title="事件类Event"></a>事件类Event</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String messgae;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Event</span><span class="params">(String messgae)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.messgae = messgae;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessgae</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> messgae;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h3><p>在OnCreate()函数中注册EventBus，在Ondestroy()函数中反注册。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bind</span>(R.id.btn_open)</div><div class="line">    Button mOpenBtn;</div><div class="line"></div><div class="line">    <span class="meta">@Bind</span>(R.id.tv_showinfo)</div><div class="line">    TextView mInfoTxt;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        ButterKnife.bind(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">//注册</span></div><div class="line">        EventBus.getDefault().register(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事件响应方法</div><div class="line">     * 接收消息</div><div class="line">     * <span class="doctag">@param</span> event</div><div class="line">     */</div><div class="line">    <span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event)</span> </span>&#123;</div><div class="line"></div><div class="line">        String msg = event.getMessgae();</div><div class="line">        mInfoTxt.setText(msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//绑定点击事件</span></div><div class="line">    <span class="meta">@OnClick</span>(R.id.btn_open)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openSecondActivity</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">            Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, SecondActivity.class);</div><div class="line">            startActivity(intent);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        <span class="comment">//反注册</span></div><div class="line">        EventBus.getDefault().unregister(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="SecondActivity"><a href="#SecondActivity" class="headerlink" title="SecondActivity"></a>SecondActivity</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bind</span>(R.id.btn_post)</div><div class="line">    Button mPostBtn;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_second);</div><div class="line"></div><div class="line">        ButterKnife.bind(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"></div><div class="line">        mPostBtn.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line"></div><div class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="comment">//发送事件</span></div><div class="line">                        EventBus.getDefault().post(<span class="keyword">new</span> Event(<span class="string">"Just do it"</span>));</div><div class="line">                    &#125;</div><div class="line">                &#125;).start();</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="EventBus的事件订阅函数"><a href="#EventBus的事件订阅函数" class="headerlink" title="EventBus的事件订阅函数"></a>EventBus的事件订阅函数</h2><h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><p>在上面的例子中，我们再注解<code>@Subscribe(threadMode = ThreadMode.MAIN)</code>中使用了ThreadMode.MAIN这个模式，表示该函数在主线程即UI线程中执行，实际上EventBus总共有四种线程模式，分别是：</p>
<ul>
<li><p>ThreadMode.MAIN：表示无论事件是在哪个线程发布出来的，该事件订阅方法onEvent都会在UI线程中执行，这个在Android中是非常有用的，因为在Android中只能在UI线程中更新UI，所有在此模式下的方法是不能执行耗时操作的。</p>
</li>
<li><p>ThreadMode.POSTING：表示事件在哪个线程中发布出来的，事件订阅函数onEvent就会在这个线程中运行，也就是说发布事件和接收事件在同一个线程。使用这个方法时，在onEvent方法中不能执行耗时操作，如果执行耗时操作容易导致事件分发延迟。</p>
</li>
<li><p>ThreadMode.BACKGROUND：表示如果事件在UI线程中发布出来的，那么订阅函数onEvent就会在子线程中运行，如果事件本来就是在子线程中发布出来的，那么订阅函数直接在该子线程中执行。</p>
</li>
<li><p>ThreadMode.AYSNC：使用这个模式的订阅函数，那么无论事件在哪个线程发布，都会创建新的子线程来执行订阅函数。</p>
</li>
</ul>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="如何调用不同的订阅函数"><a href="#如何调用不同的订阅函数" class="headerlink" title="如何调用不同的订阅函数"></a>如何调用不同的订阅函数</h3><p>要调用四种不同模式的订阅函数，我们首先要用清楚EventBus是如何指定调用的函数的？</p>
<p>先回顾一下上一节中的例子是如何调用订阅函数onEvent的，首先新建一个事件类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String messgae;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Event</span><span class="params">(String messgae)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.messgae = messgae;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessgae</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> messgae;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>发布事件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().post(<span class="keyword">new</span> Event(<span class="string">"Just do it"</span>));</div></pre></td></tr></table></figure></p>
<p>订阅事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 事件响应方法</div><div class="line"> * <span class="doctag">@param</span> event</div><div class="line"> */</div><div class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventMain</span><span class="params">(Event event)</span> </span>&#123;</div><div class="line"></div><div class="line">    String msg = event.getMessgae();</div><div class="line">    mInfoTxt.setText(msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>观察可以发现：发布事件中的参数是Event的实例，而订阅函数中的参数也是Event的实例，可以推断EventBus是通过post函数传进去的类的实例来确定调用哪个订阅函数的，是哪个就调用哪个，如果有多个订阅函数呢，那么这些函数都会被调用！</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面我们来验证这个推断：</p>
<p>我们在基本使用章节的例子上进行扩展，首先建立四个类：FirstEvent、SecondEvent、ThirdEvent、FourthEvent。</p>
<p>FirstEvent.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstEvent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String messgae;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FirstEvent</span><span class="params">(String messgae)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.messgae = messgae;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessgae</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> messgae;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SecondEvent.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondEvent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String messgae;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecondEvent</span><span class="params">(String messgae)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.messgae = messgae;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessgae</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> messgae;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThirdEvent.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdEvent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String messgae;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThirdEvent</span><span class="params">(String messgae)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.messgae = messgae;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessgae</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> messgae;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>FourthEvent.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FourthEvent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String messgae;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FourthEvent</span><span class="params">(String messgae)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.messgae = messgae;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessgae</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> messgae;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在MainActivity中，增加四种模式的订阅函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Bind</span>(R.id.btn_open)</div><div class="line">    Button mOpenBtn;</div><div class="line"></div><div class="line">    <span class="meta">@Bind</span>(R.id.tv_showinfo)</div><div class="line">    TextView mInfoTxt;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        ButterKnife.bind(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">//注册</span></div><div class="line">        EventBus.getDefault().register(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事件响应方法</div><div class="line">     * <span class="doctag">@param</span> event</div><div class="line">     */</div><div class="line">    <span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventMain</span><span class="params">(FirstEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">        String msg = event.getMessgae();</div><div class="line">        Log.i(TAG, <span class="string">"onEventMain: "</span> + event.getMessgae());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Subscribe</span>(threadMode = ThreadMode.POSTING)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventPosting</span><span class="params">(SecondEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">        String msg = event.getMessgae();</div><div class="line">        Log.i(TAG, <span class="string">"onEventPosting: "</span>+ event.getMessgae());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Subscribe</span>(threadMode = ThreadMode.BACKGROUND)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventBackgroud</span><span class="params">(ThirdEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">        String msg = event.getMessgae();</div><div class="line">        Log.i(TAG, <span class="string">"onEventBackgroud: "</span> + event.getMessgae());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Subscribe</span>(threadMode = ThreadMode.ASYNC)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventAsync</span><span class="params">(FourthEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">        String msg = event.getMessgae();</div><div class="line">        Log.i(TAG, <span class="string">"onEventAsync: "</span> + event.getMessgae());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//绑定点击事件</span></div><div class="line">    <span class="meta">@OnClick</span>(R.id.btn_open)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openSecondActivity</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">            Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, SecondActivity.class);</div><div class="line">            startActivity(intent);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        <span class="comment">//反注册</span></div><div class="line">        EventBus.getDefault().unregister(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来在SecondActivity中增加四个按钮，分别发送不同类别的事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_second);</div><div class="line"></div><div class="line">        ButterKnife.bind(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@OnClick</span>(R.id.btn_post)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPostA</span><span class="params">()</span> </span>&#123;</div><div class="line">        EventBus.getDefault().post(<span class="keyword">new</span> FirstEvent(<span class="string">"FirstEvent"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@OnClick</span>(R.id.btn_post2)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPostB</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        EventBus.getDefault().post(<span class="keyword">new</span> SecondEvent(<span class="string">"SecondEvent"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@OnClick</span>(R.id.btn_post3)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPostC</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        EventBus.getDefault().post(<span class="keyword">new</span> ThirdEvent(<span class="string">"ThirdEvent"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@OnClick</span>(R.id.btn_post4)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPostD</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        EventBus.getDefault().post(<span class="keyword">new</span> FourthEvent(<span class="string">"FourthEvent"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行后，分别顺序点击SecondActivity的四个按钮，打印信息如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">03</span>-<span class="number">31</span> <span class="number">02</span>:<span class="number">53</span>:<span class="number">45.950</span> <span class="number">4779</span>-<span class="number">4779</span>/com<span class="selector-class">.example</span><span class="selector-class">.michael</span><span class="selector-class">.eventbusdemo</span> I/MainActivity: onEventMain: FirstEvent</div><div class="line"><span class="number">03</span>-<span class="number">31</span> <span class="number">02</span>:<span class="number">53</span>:<span class="number">47.528</span> <span class="number">4779</span>-<span class="number">4779</span>/com<span class="selector-class">.example</span><span class="selector-class">.michael</span><span class="selector-class">.eventbusdemo</span> I/MainActivity: onEventPosting: SecondEvent</div><div class="line"><span class="number">03</span>-<span class="number">31</span> <span class="number">02</span>:<span class="number">53</span>:<span class="number">48.882</span> <span class="number">4779</span>-<span class="number">4940</span>/com<span class="selector-class">.example</span><span class="selector-class">.michael</span><span class="selector-class">.eventbusdemo</span> I/MainActivity: onEventBackgroud: ThirdEvent</div><div class="line"><span class="number">03</span>-<span class="number">31</span> <span class="number">02</span>:<span class="number">53</span>:<span class="number">50.462</span> <span class="number">4779</span>-<span class="number">4940</span>/com<span class="selector-class">.example</span><span class="selector-class">.michael</span><span class="selector-class">.eventbusdemo</span> I/MainActivity: onEventAsync: FourthEvent</div></pre></td></tr></table></figure>
<blockquote>
<p>由此可见，通过发布不同的事件类的实例，EventBus根据类的实例分别调用了不同的订阅函数来处理事件。</p>
</blockquote>
<p>那么，当同一个类的实例有多个函数订阅时，结果会是怎样呢？答案是，这些函数都会执行。下面我们来验证一下，将MainActivity中订阅函数的参数都改为FirstEvent，代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * 事件响应方法</div><div class="line">  * <span class="doctag">@param</span> event</div><div class="line">  */</div><div class="line"> <span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN)</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventMain</span><span class="params">(FirstEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">     String msg = event.getMessgae();</div><div class="line">     Log.i(TAG, <span class="string">"onEventMain: "</span> + event.getMessgae());</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="meta">@Subscribe</span>(threadMode = ThreadMode.POSTING)</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventPosting</span><span class="params">(FirstEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">     String msg = event.getMessgae();</div><div class="line">     Log.i(TAG, <span class="string">"onEventPosting: "</span>+ event.getMessgae());</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="meta">@Subscribe</span>(threadMode = ThreadMode.BACKGROUND)</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventBackgroud</span><span class="params">(FirstEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">     String msg = event.getMessgae();</div><div class="line">     Log.i(TAG, <span class="string">"onEventBackgroud: "</span> + event.getMessgae());</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="meta">@Subscribe</span>(threadMode = ThreadMode.ASYNC)</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventAsync</span><span class="params">(FirstEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">     String msg = event.getMessgae();</div><div class="line">     Log.i(TAG, <span class="string">"onEventAsync: "</span> + event.getMessgae());</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>运行程序，点击SecondActivity的FirstEvent按钮，打印信息如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">03</span>-<span class="number">31</span> <span class="number">03</span>:<span class="number">14</span>:<span class="number">07.032</span> <span class="number">23611</span>-<span class="number">23746</span>/com<span class="selector-class">.example</span><span class="selector-class">.michael</span><span class="selector-class">.eventbusdemo</span> I/MainActivity: onEventAsync: FirstEvent</div><div class="line"><span class="number">03</span>-<span class="number">31</span> <span class="number">03</span>:<span class="number">14</span>:<span class="number">07.033</span> <span class="number">23611</span>-<span class="number">23611</span>/com<span class="selector-class">.example</span><span class="selector-class">.michael</span><span class="selector-class">.eventbusdemo</span> I/MainActivity: onEventMain: FirstEvent</div><div class="line"><span class="number">03</span>-<span class="number">31</span> <span class="number">03</span>:<span class="number">14</span>:<span class="number">07.033</span> <span class="number">23611</span>-<span class="number">23611</span>/com<span class="selector-class">.example</span><span class="selector-class">.michael</span><span class="selector-class">.eventbusdemo</span> I/MainActivity: onEventPosting: FirstEvent</div><div class="line"><span class="number">03</span>-<span class="number">31</span> <span class="number">03</span>:<span class="number">14</span>:<span class="number">07.034</span> <span class="number">23611</span>-<span class="number">23748</span>/com<span class="selector-class">.example</span><span class="selector-class">.michael</span><span class="selector-class">.eventbusdemo</span> I/MainActivity: onEventBackgroud: FirstEvent</div></pre></td></tr></table></figure>
<blockquote>
<p>分析可知，当SecondActivity发送FirstEvent事件过来的时候，这个四个订阅函数会同时接收到这个事件并执行。</p>
</blockquote>
<p><strong>总结： </strong>订阅函数的执行是根据参数中的事件类的类名来决定的。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list">
			 
        <li class="article-tag-list-item">
        	<a href="javascript:void(0)" class="article-tag-list-link color3">实战</a>
        </li>
      
		</ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book icon"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/04/17/Android_EventBus使用详解/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Android开发模式之MVP" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/Android开发模式之MVP/">Android开发模式之MVP</a>
    </h1>
  

        
        <a href="/2016/04/17/Android开发模式之MVP/" class="archive-article-date">
  	<time datetime="2016-04-17T07:28:06.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-04-17 15:28:06</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在开发Android App时，越到最后肯定会发现，Activity的负担非常重，既要初始化控件，又要写一些逻辑操作的展示等等，很多Activity中的代码都充当了Controller和Model的角色，因而发现Activity违背了单一职责原则，负担过重。所以，MVP架构模式应运而生。</p>
<h2 id="MVP架构是什么"><a href="#MVP架构是什么" class="headerlink" title="MVP架构是什么"></a>MVP架构是什么</h2><p>MVP就是Model-View-Presenter，MVP是从经典的MVC演变而来，它们的基本思想有相通的地方：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。作为一种新的模式，MVP与MVC有着一个重大的区别：在MVP中View并不会直接使用Model，它们之间的通信是通过Presenter（MVC中是Controller）来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过Controller。</p>
<p>在MVC里，View是可以直接访问Model的，从而View里会包含Model信息，不可避免的还要包括一些业务逻辑。在MVC模型里，更关注的是Model的不变，而同时有多个对Model的不同显示的View。所有在MVC模型里，Model不依赖于View，但是View依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。</p>
<p>用流程图的方式解释就更清楚了：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/mvp-mvp%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="MVP流程图"></p>
<h2 id="MVC与MVP的区别"><a href="#MVC与MVP的区别" class="headerlink" title="MVC与MVP的区别"></a>MVC与MVP的区别</h2><h3 id="MVP架构"><a href="#MVP架构" class="headerlink" title="MVP架构"></a>MVP架构</h3><blockquote>
<p>View：对应于Activity，负责View的绘制以及与用户交互、<br>Model：业务逻辑和实体模型<br>Presenter：负责完成View与Model间的交互</p>
</blockquote>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/mvp-mvp.png" alt="MVP示意图"></p>
<ul>
<li>View不直接与Model交互，而是通过Presenter交互来与Model间接交互</li>
<li>Presenter与View的交互是通过接口来进行的</li>
<li>通过View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑</li>
</ul>
<h3 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h3><blockquote>
<p>View：对应于布局文件<br>Model：业务逻辑和实体模型<br>Controller：对应于Activity</p>
</blockquote>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/mvp-mvc.png" alt="mvc示意图"></p>
<ul>
<li>View可以和Model直接交互</li>
<li>Controller是基于行为的，并且可以被多个View共享。</li>
<li>可以复杂决定显示哪个View</li>
</ul>
<p>总的就是说：从MVC到MVP的一个转变，就是减少了Activity的职责，减轻了它的负担，简化了Activity中的代码和一些操作，将逻辑代码提取到了Presenter中进行处理，降低其耦合度。</p>
<p>在MVP里，Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现。而且，Presenter与具体的View是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变，即重用！ 不仅如此，我们还可以编写测试用的View，模拟用户的各种操作，从而实现对Presenter的测试–而不需要使用自动化的测试工具。 我们甚至可以在Model和View都没有完成时候，就可以通过编写Mock Object（即实现了Model和View的接口，但没有具体的内容的）来测试Presenter的逻辑。 在MVP里，应用程序的逻辑主要在Presenter来实现，其中的View是很薄的一层。因此就有人提出了Presenter First的设计模式，就是根据User Story来首先设计和开发Presenter。在这个过程中，View是很简单的，能够把信息显示清楚就可以了。在后面，根据需要再随便更改View，而对Presenter没有任何的影响了。 如果要实现的UI比较复杂，而且相关的显示逻辑还跟Model有关系，就可以在View和Presenter之间放置一个Adapter。由这个 Adapter来访问Model和View，避免两者之间的关联。而同时，因为Adapter实现了View的接口，从而可以保证与Presenter之间接口的不变。这样就可以保证View和Presenter之间接口的简洁，又不失去UI的灵活性。 在MVP模式里，View只应该有简单的Set/Get的方法，用户输入和设置界面显示的内容，除此就不应该有更多的内容，绝不容许直接访问Model–这就是与MVC很大的不同之处。</p>
<h3 id="MVP的优点"><a href="#MVP的优点" class="headerlink" title="MVP的优点"></a>MVP的优点</h3><ul>
<li>降低耦合度，隐藏数据，Activity中代码更简洁</li>
<li>模块职责划分明显</li>
<li>方便测试驱动开发</li>
<li>代码复用度较高</li>
<li>代码灵活性增强</li>
</ul>
<h2 id="MVP架构模式示例"><a href="#MVP架构模式示例" class="headerlink" title="MVP架构模式示例"></a>MVP架构模式示例</h2><p>这个示例是根据用户id获取用户信息并展示的一个过程，其中获取信息用了一个线程进行了模拟获取。</p>
<p>先看一下MVP包结构图：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/mvp-mvp%E5%8C%85%E7%BB%93%E6%9E%84.png" alt=""></p>
<h3 id="1-Model层"><a href="#1-Model层" class="headerlink" title="1.Model层"></a>1.Model层</h3><p>首先是建一个JavaBean User实体类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.deason.mvpdemo.bean;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> String id;</div><div class="line">	<span class="keyword">private</span> String sex;</div><div class="line">	<span class="keyword">private</span> String age;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> id;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.id = id;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> sex;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.sex = sex;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> age;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>新建Model层抽象接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGetUser</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserInfo</span><span class="params">(<span class="keyword">int</span> id,OnUserInfoListener listener)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnUserInfoListener</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserInfoSuccess</span><span class="params">(User user)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserInfoFailed</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Model层抽象接口实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetUserInfo</span> <span class="keyword">implements</span> <span class="title">IGetUser</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserInfo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> id, <span class="keyword">final</span> OnUserInfoListener listener)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				SystemClock.sleep(<span class="number">5000</span>); <span class="comment">//模拟子线程耗时操作</span></div><div class="line"></div><div class="line">				<span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</div><div class="line">					User user = <span class="keyword">new</span> User();</div><div class="line">					user.setName(<span class="string">"liu"</span>);</div><div class="line">					user.setAge(<span class="string">"27"</span>);</div><div class="line">					user.setSex(<span class="string">"男"</span>);</div><div class="line">					user.setId(<span class="string">"1"</span>);</div><div class="line">					listener.getUserInfoSuccess(user);</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					listener.getUserInfoFailed();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-View层"><a href="#2-View层" class="headerlink" title="2.View层"></a>2.View层</h3><p>Presenter和View交互是通过接口，所有我们需要定义一个IShowUserView的接口，这个接口封装的方法基本都跟视图展示有关。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IShowUserView</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showLoading</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hideLoading</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toMainActivity</span><span class="params">(User user)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showFailedError</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-Presenter层"><a href="#3-Presenter层" class="headerlink" title="3.Presenter层"></a>3.Presenter层</h3><p>Presenter是Model和View之间交互的桥梁，里面有一些业务逻辑的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoPresenter</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> IGetUser iGetUser;</div><div class="line">	<span class="keyword">private</span> IShowUserView iShowUserView;</div><div class="line">	<span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler();</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UserInfoPresenter</span><span class="params">(IShowUserView iShowUserView)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.iShowUserView = iShowUserView;</div><div class="line">		<span class="keyword">this</span>.iGetUser = <span class="keyword">new</span> GetUserInfo();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserInfoToShow</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">		iShowUserView.showLoading();</div><div class="line">		iGetUser.getUserInfo(id, <span class="keyword">new</span> OnUserInfoListener() &#123;</div><div class="line">			</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserInfoSuccess</span><span class="params">(<span class="keyword">final</span> User user)</span> </span>&#123;</div><div class="line">				<span class="comment">// UI线程执行</span></div><div class="line">				mHandler.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">					</div><div class="line">					<span class="meta">@Override</span></div><div class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">						<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">						iShowUserView.toMainActivity(user);</div><div class="line">						iShowUserView.hideLoading();</div><div class="line">					&#125;</div><div class="line">				&#125;);</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserInfoFailed</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				mHandler.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">					</div><div class="line">					<span class="meta">@Override</span></div><div class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">						<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">						iShowUserView.showFailedError();</div><div class="line">						iShowUserView.hideLoading();</div><div class="line">					&#125;</div><div class="line">				&#125;);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-Activity中调用"><a href="#4-Activity中调用" class="headerlink" title="4.Activity中调用"></a>4.Activity中调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">IShowUserView</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> TextView mNameTxt;</div><div class="line">	<span class="keyword">private</span> TextView mAgeTxt;</div><div class="line">	<span class="keyword">private</span> TextView mSexTxt;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Button mLoadBtn;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> ProgressDialog mDialog;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> UserInfoPresenter mPresenter;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		</div><div class="line">		mPresenter = <span class="keyword">new</span> UserInfoPresenter(<span class="keyword">this</span>);</div><div class="line">		</div><div class="line">		mDialog = <span class="keyword">new</span> ProgressDialog(<span class="keyword">this</span>);</div><div class="line">		</div><div class="line">		mNameTxt = (TextView) findViewById(R.id.tv_name);</div><div class="line">		mAgeTxt = (TextView) findViewById(R.id.tv_age);</div><div class="line">		mSexTxt = (TextView) findViewById(R.id.tv_sex);</div><div class="line">		mLoadBtn = (Button) findViewById(R.id.btn_load);</div><div class="line">		mLoadBtn.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				mPresenter.getUserInfoToShow(<span class="number">1</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showLoading</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		mDialog.show();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hideLoading</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		mDialog.dismiss();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toMainActivity</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		mNameTxt.setText(user.getName());</div><div class="line">		mAgeTxt.setText(user.getAge());</div><div class="line">		mSexTxt.setText(user.getSex());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showFailedError</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		Toast.makeText(<span class="keyword">this</span>, <span class="string">"Load failed"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>可以看出，虽说是代码量增加了，但是Activity中的代码变得简洁起来，程序也清晰明了，好处还是很多的。好记性不如烂笔头，勤加练习和实践。</p>
</blockquote>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list">
			 
        <li class="article-tag-list-item">
        	<a href="javascript:void(0)" class="article-tag-list-link color3">架构</a>
        </li>
      
		</ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book icon"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a><a class="article-category-link" href="/categories/Android/架构/">架构</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/04/17/Android开发模式之MVP/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
    <article id="post-Android-Universal-Image-Loader源码分析" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/Android-Universal-Image-Loader源码分析/">Android-Universal-Image-Loader源码分析</a>
    </h1>
  

        
        <a href="/2016/04/17/Android-Universal-Image-Loader源码分析/" class="archive-article-date">
  	<time datetime="2016-04-17T07:25:31.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2016-04-17 15:25:31</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><h2 id="Android-Universal-Image-Loader"><a href="#Android-Universal-Image-Loader" class="headerlink" title="Android-Universal-Image-Loader"></a>Android-Universal-Image-Loader</h2><p>Android-Universal-Image-Loader是一个强大的、可高度定制的开源图片缓存框架，简称UIL。简单的说UIL就做了一件事–获取图片并显示在相应的控件上。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>添加完依赖后再Application或Activity中初始化ImageLoader，一般式在Application中初始化，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UILApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">		<span class="keyword">super</span>.onCreate();</div><div class="line"></div><div class="line">		initImageLoader(getApplicationContext());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initImageLoader</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="comment">//缓存目录</span></div><div class="line">		File cacheDir = StorageUtils.getCacheDirectory(context);</div><div class="line">		<span class="comment">//添加配置需求</span></div><div class="line">		ImageLoaderConfiguration config = <span class="keyword">new</span> ImageLoaderConfiguration.Builder(context)</div><div class="line">		  .memoryCacheExtraOptions(<span class="number">480</span>, <span class="number">800</span>) <span class="comment">// default = device screen dimensions</span></div><div class="line">		  .diskCacheExtraOptions(<span class="number">480</span>, <span class="number">800</span>, CompressFormat.JPEG, <span class="number">75</span>, <span class="keyword">null</span>)</div><div class="line">		  .taskExecutor(...)</div><div class="line">		  .taskExecutorForCachedImages(...)</div><div class="line">		  .threadPoolSize(<span class="number">3</span>) <span class="comment">// default 线程池大小</span></div><div class="line">		  .threadPriority(Thread.NORM_PRIORITY - <span class="number">1</span>) <span class="comment">// default 线程优先级</span></div><div class="line">		  .tasksProcessingOrder(QueueProcessingType.FIFO) <span class="comment">// default 任务队列模式</span></div><div class="line">		  .denyCacheImageMultipleSizesInMemory()</div><div class="line">		  .memoryCache(<span class="keyword">new</span> LruMemoryCache(<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>)) <span class="comment">//</span></div><div class="line">		  .memoryCacheSize(<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>)</div><div class="line">		  .memoryCacheSizePercentage(<span class="number">13</span>) <span class="comment">// default</span></div><div class="line">		  .diskCache(<span class="keyword">new</span> UnlimitedDiscCache(cacheDir)) <span class="comment">// default</span></div><div class="line">		  .diskCacheSize(<span class="number">50</span> * <span class="number">1024</span> * <span class="number">1024</span>)</div><div class="line">		  .diskCacheFileCount(<span class="number">100</span>)</div><div class="line">		  .diskCacheFileNameGenerator(<span class="keyword">new</span> HashCodeFileNameGenerator()) <span class="comment">// default</span></div><div class="line">		  .imageDownloader(<span class="keyword">new</span> BaseImageDownloader(context)) <span class="comment">// default</span></div><div class="line">		  .imageDecoder(<span class="keyword">new</span> BaseImageDecoder()) <span class="comment">// default</span></div><div class="line">		  .defaultDisplayImageOptions(DisplayImageOptions.createSimple()) <span class="comment">// default</span></div><div class="line">		  .writeDebugLogs()</div><div class="line">		  .build();</div><div class="line"></div><div class="line">		<span class="comment">// 初始化ImageLoader配置</span></div><div class="line">		ImageLoader.getInstance().init(config);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ImageLoaderConfiguration表示ImageLoader的配置信息，可包括图片最大尺寸、线程池、下载器、缓存等参数的配置。</p>
<h3 id="Manifest配置"><a href="#Manifest配置" class="headerlink" title="Manifest配置"></a>Manifest配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.INTERNET"</span> /&gt;</div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span> /&gt;</div><div class="line"></div><div class="line">&lt;application</div><div class="line">	android:name=<span class="string">".UILApplication"</span></div><div class="line">	``</div><div class="line">	``</div><div class="line">	``</div><div class="line">/application&gt;</div></pre></td></tr></table></figure>
<p>添加网络权限和添加读写外部存储权限</p>
<h3 id="下载显示图片"><a href="#下载显示图片" class="headerlink" title="下载显示图片"></a>下载显示图片</h3><p>下载图片，解析为Bitmap并在ImageView中显示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ImageLoadingListener animateFirstListener = <span class="keyword">new</span> AnimateFirstDisplayListener();</div><div class="line"></div><div class="line"><span class="keyword">private</span> DisplayImageOptions options;</div><div class="line"></div><div class="line">ImageAdapter(Context context) &#123;</div><div class="line">		inflater = LayoutInflater.from(context);</div><div class="line">		</div><div class="line">		<span class="comment">//下载图片选项</span></div><div class="line">options = <span class="keyword">new</span> DisplayImageOptions.Builder()</div><div class="line">		.showImageOnLoading(R.drawable.ic_stub) <span class="comment">//下载中</span></div><div class="line">		.showImageForEmptyUri(R.drawable.ic_empty) <span class="comment">//空URL</span></div><div class="line">		.showImageOnFail(R.drawable.ic_error) <span class="comment">//失败</span></div><div class="line">		.cacheInMemory(<span class="keyword">true</span>)</div><div class="line">		.cacheOnDisk(<span class="keyword">true</span>)</div><div class="line">		.considerExifParams(<span class="keyword">true</span>)</div><div class="line">		.displayer(<span class="keyword">new</span> CircleBitmapDisplayer(Color.WHITE, <span class="number">5</span>))</div><div class="line">		.build();</div><div class="line"><span class="comment">//显示图片</span></div><div class="line">ImageLoader.getInstance().displayImage(imageUrl, holder.image, options, animateFirstListener);	</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">*监听下载图片，传递Bitmap给回调接口</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimateFirstDisplayListener</span> <span class="keyword">extends</span> <span class="title">SimpleImageLoadingListener</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; displayedImages = Collections.synchronizedList(<span class="keyword">new</span> LinkedList&lt;String&gt;());</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadingComplete</span><span class="params">(String imageUri, View view, Bitmap loadedImage)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (loadedImage != <span class="keyword">null</span>) &#123;</div><div class="line">			ImageView imageView = (ImageView) view;</div><div class="line">			<span class="keyword">boolean</span> firstDisplay = !displayedImages.contains(imageUri);</div><div class="line">			<span class="keyword">if</span> (firstDisplay) &#123;</div><div class="line">				FadeInBitmapDisplayer.animate(imageView, <span class="number">500</span>);</div><div class="line">				displayedImages.add(imageUri);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>可配置度高。支持任务线程池、下载器、解码器、内存及磁盘缓存、显示选项等的配置。</li>
<li>包含内存缓存和磁盘缓存两级缓存。</li>
<li>支持多线程，支持异步和同步加载</li>
<li>支持多种缓存算法、下载进度监听、ListView图片错乱解决等。</li>
</ul>
<h1 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h1><h2 id="总体设计框图"><a href="#总体设计框图" class="headerlink" title="总体设计框图"></a>总体设计框图</h2><p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/uil-overall-design.png" alt="UIL框架图"></p>
<p>上面是UIL的总体框架图。整个库主要分为ImageLoader、ImageLoaderEngine、Cache、ImageDownloader、ImageDecoder、BitmapDisplayer、BitmapProcessor七大模块，其中Cache分为Memory Cache和DiskCache两部分。</p>
<p>简单的讲就是ImageLoader收到加载及显示图片的任务，并将它交给ImageLoaderEngine，ImageLoaderEngine分发任务到具体线程池去执行，任务通过Cache及ImageDownloader获取图片，中间可能经过BitmapProcessor和ImageDecoder处理，最终转换为Bitmap交给BitmapDisplayer在ImageAware中显示。</p>
<h2 id="UIL中的概念"><a href="#UIL中的概念" class="headerlink" title="UIL中的概念"></a>UIL中的概念</h2><ul>
<li><strong>ImageLoaderEngine</strong></li>
</ul>
<p>任务分发器，负责分发LoadAndDisplayImageTask和ProcessAndDisplayImageTask给具体的线程去执行。</p>
<ul>
<li><strong>LoadAndDisplayImageTask</strong></li>
</ul>
<p>用于加载并显示图片的任务。</p>
<ul>
<li><strong>ProcessAndDisplayImageTask</strong></li>
</ul>
<p>用于处理并显示图片的任务。</p>
<ul>
<li><strong>DisplayBitmapTask</strong></li>
</ul>
<p>用于显示图片的任务</p>
<ul>
<li><strong>ImageAware</strong></li>
</ul>
<p>显示图片的对象，可以是ImageView等。</p>
<ul>
<li><strong>BitmapDisplayer</strong></li>
</ul>
<p>将Bitmap对象显示在相应的控件ImageAware上。</p>
<ul>
<li><strong>ImageDownloader</strong></li>
</ul>
<p>图片下载器，负责从图片的各个来源获取输入流</p>
<ul>
<li><strong>MemoryCache</strong></li>
</ul>
<p>内存图片缓存，可向内存缓存图片或从内存读取图片</p>
<ul>
<li><strong>DiskCache</strong></li>
</ul>
<p>本地图片缓存，可向本地磁盘缓存保存图片或从本地磁盘读取图片</p>
<ul>
<li><strong>ImageDecoder</strong></li>
</ul>
<p>图片解码器，负责将图片输入流InputStream转换为Bitmap对象。</p>
<ul>
<li><strong>BitmapProcessor</strong></li>
</ul>
<p>图片处理器，负责从缓存读取或写入前对图片进行处理</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/uil-flow.png" alt="图片加载及显示流程图"></p>
<p>上图为图片加载及显示流程图,可知有三种情况:</p>
<ul>
<li>[ 1 ] - 图片没有缓存</li>
</ul>
<p>先下载图片，然后显示图片，同时异步将图片缓存到磁盘和内存中。</p>
<ul>
<li>[ 2 ] - 图片缓存在磁盘上</li>
</ul>
<p>若图片不在缓存中，则从磁盘缓存中查找图片，然后将图片解码为Bitmap对象并显示在控件上。</p>
<ul>
<li>[ 3 ] - Bitmap对象缓存在内存里</li>
</ul>
<p>直接从内存缓存取出相应的Bitmap对象并显示在控件上。</p>
<h1 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h1><h2 id="类关系图"><a href="#类关系图" class="headerlink" title="类关系图"></a>类关系图</h2><p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/uil-relation-class.png" alt="类关系图"></p>
<h2 id="核心类介绍"><a href="#核心类介绍" class="headerlink" title="核心类介绍"></a>核心类介绍</h2><h3 id="ImageLoader-java"><a href="#ImageLoader-java" class="headerlink" title="ImageLoader.java"></a>ImageLoader.java</h3><p>图片加载器，对外的主要API，采用了<strong>单例设计模式</strong>，用于图片的加载和显示。</p>
<p>主要函数：</p>
<ul>
<li>getInstance()</li>
</ul>
<p>得到ImageLoader单例，通过双层是否为null判断提高性能。</p>
<ul>
<li>init(ImageLoaderConfiguration configuration)</li>
</ul>
<p>初始化配置参数，参数为configuration为ImageLoader的配置信息，包括图片最大尺寸、任务线程池、磁盘缓存、下载器、解码器等等。实现中会初始化ImageLoaderEngine engine属性，该属性为任务分发器。</p>
<ul>
<li>displayImage(String uri, ImageAware imageAware, DisplayImageOptions options, ImageLoadingListener listener, ImageLoadingProgressListener progressListener)</li>
</ul>
<p>加载并显示图片或加载并执行回调接口。ImageLoader加载图片主要分为三类接口：</p>
<ol>
<li>displayImage()表示异步加载并显示图片到对应的ImageAware上。</li>
<li>loadImage()表示异步加载图片并执行回调接口。</li>
<li>loadImageSync()表示同步加载图片。</li>
</ol>
<p>以上三类接口最终都会调用到这个函数进行图片加载。函数参数解释如下：</p>
<p>Uri: 图片的uri，uri支持多种来源的图片，包括http、https、file、content、assets、drawable及自定义<br>ImageAware： 一个接口，表示需要加载图片的对象，可包装View。<br>Options： 图片显示的配置项。比如加载前、加载中、加载失败应该显示的占位图片，图片是否需要在磁盘缓存，是否需要在内存缓存等。<br>listener： 图片加载各种时刻的回调接口，包括开始加载、加载失败、加载成功、取消加载四个时刻的回调函数。<br>progressListener： 图片加载进度的回调接口。</p>
<p>函数流程图如下：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/uil-display-image-flow-chart.png" alt=""></p>
<h3 id="ImageLoaderConfiguration-java"><a href="#ImageLoaderConfiguration-java" class="headerlink" title="ImageLoaderConfiguration.java"></a>ImageLoaderConfiguration.java</h3><p>ImageLoader的配置信息，包括图片最大尺寸、线程池、缓存、下载器、解码器等等。</p>
<p>主要属性：</p>
<ul>
<li><p>Resources resources 程序本地资源访问器，用于加载DisplayImageOptions中设置的一些App中图片资源。</p>
</li>
<li><p>int maxImageWidthForMemoryCache 内存缓存的图片最大宽度。</p>
</li>
<li><p>int maxImageHeightForMemoryCache 内存缓存的图片最大高度。</p>
</li>
<li><p>int maxImageWidthForDiskCache 磁盘缓存的图片最大宽度。</p>
</li>
<li><p>int maxImageHeightForDiskCache 磁盘缓存的图片最大高度。</p>
</li>
<li><p>BitmapProcessor processorForDiskCache 图片处理器，用于处理从磁盘缓存中读取到的图片。</p>
</li>
<li><p>Executor taskExecutor  ImageLoaderEngine中用于执行从源获取图片的任务</p>
</li>
<li><p>Executor taskExecutorForCachedImages ImageLoaderEngine中用于执行从缓存获取图片任务的Executor。</p>
</li>
<li><p>boolean customExecutor 用户是否自定义了上面的taskExecutor</p>
</li>
<li><p>boolean customExecutorForCachedImages 用户是否自定义了上面的taskExecutorForCachedImages</p>
</li>
<li><p>int threadPoolSize 上面两个默认线程池的核心池大小，即最大并发数</p>
</li>
<li><p>int threadPriority 上面默认线程池的线程优先级。</p>
</li>
<li><p>QueueProcessingType tasksProcessingType 上面两个默认线程池的线程队列类型，目前只有FIFO，LIFO两种选择</p>
</li>
<li><p>MemoryCache MemoryCache 图片内存缓存</p>
</li>
<li><p>DiskCache diskCache 图片磁盘缓存，一般放在SD卡</p>
</li>
<li><p>ImageDownloader downloader 图片下载器</p>
</li>
<li><p>ImageDecoder decoder 图片解码器，内部可使用我们常见的BitmapFactory.decode()将图片资源解码成Bitmap对象</p>
</li>
<li><p>DisplayImageOptions defaultDisplayImageOptions 图片显示的配置项。比如加载前、加载中、加载失败应该显示的占位图片，图片是否需要在磁盘缓存，是否需要在内存缓存等。</p>
</li>
<li><p>ImageDownloader networkDeniedDownloader 不允许访问网络的图片下载器</p>
</li>
<li><p>ImageDownloader slowNetworkDownloader 慢网络情况下的图片下载器</p>
</li>
</ul>
<h3 id="ImageLoaderConfiguration-Builder-java-静态内部类"><a href="#ImageLoaderConfiguration-Builder-java-静态内部类" class="headerlink" title="ImageLoaderConfiguration.Builder.java 静态内部类"></a>ImageLoaderConfiguration.Builder.java 静态内部类</h3><p><strong>Builder模式</strong>，用于构造参数繁多的ImageLoaderConfiguration。其属性与ImageLoaderConfiguration类似，函数多是属性设置函数。</p>
<p>主要函数及含义：</p>
<ul>
<li>builder()</li>
</ul>
<p>按照配置，生成ImageLoaderConfiguration。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ImageLoaderConfiguration <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">	initEmptyFieldsWithDefaultValues();</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ImageLoaderConfiguration(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>initEmptyFieldsWithDefaultValues()</li>
</ul>
<p>初始化值为null的属性。若用户没有配置相关项，UIL会通过调用DefaultConfigurationFactory中的函数返回一个默认值当配置。</p>
<p>taskExecutorForCacheImages、taskExecutor及ImageLoaderEngine的taskDistributor的默认值如下：</p>
<table>
<thead>
<tr>
<th>parameters</th>
<th>taskDistributor</th>
<th>taskExecutorForCacheImages/taskExecutor</th>
</tr>
</thead>
<tbody>
<tr>
<td>corePoolSize</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>Integer.MAX_VALUE</td>
<td>3</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>60</td>
<td>3</td>
</tr>
<tr>
<td>unit</td>
<td>SECONDS</td>
<td>MILLISECONDS</td>
</tr>
<tr>
<td>workQueue</td>
<td>SynchronousQueue</td>
<td>LIFOLinkedBlockingDequeu/LinkedBlockingQueue</td>
</tr>
<tr>
<td>priority</td>
<td>5</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>diskCacheFileNameGenerator默认值为HashCodeFileNameGenerator</p>
<p>memoryCache默认值为LruMemoryCache。如果内存缓存不允许缓存一张图片的多个尺寸，则用FuzzyKeyMemoryCache做封装，同一个图片新的尺寸会覆盖缓存中该图片老的尺寸。</p>
<p>diskCache默认值与diskCacheSize和diskCacheFileCount值有关，如果他们有一个大于0，则默认为LruDiskCache，否则使用无大小限制的UnlimitedDiskCache。</p>
<p>downloader默认值为BaseImageDownloader。</p>
<p>decoder默认值为BaseImageDecoder</p>
<p>defaultDisplayImageOptions为Builder().build()</p>
<ul>
<li>denyCacheImageMultipleSizeInMemory()</li>
</ul>
<p>设置内存缓存不允许缓存一张图片的多个尺寸，默认允许。后面会讲到的View的getWidth()在初始化前后的不同值与这个设置的关系。</p>
<ul>
<li>diskCacheSize(int maxCacheSize)</li>
</ul>
<p>设置磁盘缓存的最大字节数，如果大于0或者下面的maxFileCount大于0，默认的DiskCache会用LruDiskCache，否则使用无大小限制的UnlimitedDiskCache。</p>
<ul>
<li>diskCacheFileCount(int maxFileCount)</li>
</ul>
<p>设置磁盘缓存的最大文件数，如果大于0或者上面的maxCacheSize大于0，默认的DiskCache会用LruDiskCache，否则使用无大小限制的UnlimitedDiskCache。</p>
<h3 id="ImageLoaderConfiguration-NetworkDeniedDownloader-java-静态内部类"><a href="#ImageLoaderConfiguration-NetworkDeniedDownloader-java-静态内部类" class="headerlink" title="ImageLoaderConfiguration.NetworkDeniedDownloader.java 静态内部类"></a>ImageLoaderConfiguration.NetworkDeniedDownloader.java 静态内部类</h3><p>不允许访问网络的图片下载器，实现了ImageDownloader接口。实现也比较简单，包装了一个ImageDownloader对象，通过getStream()函数中禁止Http和Https Scheme禁止网络访问，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkDeniedImageDownloader</span> <span class="keyword">implements</span> <span class="title">ImageDownloader</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ImageDownloader wrappedDownloader;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NetworkDeniedImageDownloader</span><span class="params">(ImageDownloader wrappedDownloader)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.wrappedDownloader = wrappedDownloader;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> InputStream <span class="title">getStream</span><span class="params">(String imageUri, Object extra)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">		<span class="keyword">switch</span> (Scheme.ofUri(imageUri)) &#123;</div><div class="line">			<span class="keyword">case</span> HTTP:</div><div class="line">			<span class="keyword">case</span> HTTPS:</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">			<span class="keyword">default</span>:</div><div class="line">				<span class="keyword">return</span> wrappedDownloader.getStream(imageUri, extra);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ImageLoaderConfiguration-SlowNetworkingImageDownloader-java-静态内部类"><a href="#ImageLoaderConfiguration-SlowNetworkingImageDownloader-java-静态内部类" class="headerlink" title="ImageLoaderConfiguration.SlowNetworkingImageDownloader.java 静态内部类"></a>ImageLoaderConfiguration.SlowNetworkingImageDownloader.java 静态内部类</h3><p>慢网络情况下的图片下载器，实现了ImageDownloader接口。<br>通过包装一个ImageDownloader对象实现，在getStream()函数中当Scheme为Http和Https时，用FlushedInputStream代替InputStream处理慢网络情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SlowNetworkImageDownloader</span> <span class="keyword">implements</span> <span class="title">ImageDownloader</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ImageDownloader wrappedDownloader;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SlowNetworkImageDownloader</span><span class="params">(ImageDownloader wrappedDownloader)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.wrappedDownloader = wrappedDownloader;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> InputStream <span class="title">getStream</span><span class="params">(String imageUri, Object extra)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">		InputStream imageStream = wrappedDownloader.getStream(imageUri, extra);</div><div class="line">		<span class="keyword">switch</span> (Scheme.ofUri(imageUri)) &#123;</div><div class="line">			<span class="keyword">case</span> HTTP:</div><div class="line">			<span class="keyword">case</span> HTTPS:</div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> FlushedInputStream(imageStream);</div><div class="line">			<span class="keyword">default</span>:</div><div class="line">				<span class="keyword">return</span> imageStream;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ImageLoaderEngine-java"><a href="#ImageLoaderEngine-java" class="headerlink" title="ImageLoaderEngine.java"></a>ImageLoaderEngine.java</h3><p>LoadAndDisplayImageTask和ProcessAndDisplayImageTask任务分发器，负责分发任务给具体的线程池。</p>
<p>主要属性：</p>
<ul>
<li>ImageLoaderConfiguration configuration</li>
</ul>
<p>ImageLoader的配置信息，可包括图片最大尺寸、线程池、缓存、下载器、解码器等等。</p>
<ul>
<li>Executor taskExecutor</li>
</ul>
<p>用于执行从源执行获取图片任务的Executor，为configuration中的taskExecutor，如果为null，则会调用DefaultConfigurationFactory.createExecutor()根据配置返回一个默认的线程池。</p>
<ul>
<li>Executor taskExecutorForCachedImages</li>
</ul>
<p>用于执行从缓存获取图片任务的Executor，为configuration中的taskExecutorForCachedImages，如果为null，则会调用DefaultConfigurationFactory.createExecutor()根据配置返回一个默认的线程池。</p>
<ul>
<li>Executor taskDistributor</li>
</ul>
<p>任务分发线程池，任务指LoadAndDisplayImageTask和ProcessAndDisplayImageTask，因为需要分发给上面的两个Executor去执行任务，不存在较耗时或阻塞操作，所以无并发数（Int最大值）限制的线程池即可。</p>
<ul>
<li>Map cacheKeysForImageAwares</li>
</ul>
<p>ImageAware与内存缓存key对应的map，key为ImageAware的id，value为内存缓存的key。</p>
<ul>
<li>Map uriLocks</li>
</ul>
<p>图片正在加锁的重入锁map，key为图片的uri，value为标识其正在加载的重入锁。</p>
<ul>
<li>AtomicBoolean pause</li>
</ul>
<p>是否被暂停。如果为true，则所有新的加载或显示任务都会等待直到取消暂停（为false）</p>
<ul>
<li>AtomicBooleannetWorkDenied</li>
</ul>
<p>是否不允许访问网络，如果为true，通过回调ImageLoadingListener.onLoadingFailed()获取图片，则所有不在缓存中需要网络访问的请求都会失败，返回失败的原因为：网络访问被禁止。</p>
<ul>
<li>AtomicBoolean slowNetwork</li>
</ul>
<p>是否是慢网络情况，如果未true，则自动调用SlowNetworkImageDownloader下载图片</p>
<ul>
<li>Object pauseLock</li>
</ul>
<p>暂停的等待锁，可在engine被暂停后调用这个锁等待</p>
<p>主要函数：</p>
<ul>
<li>void submit(final LoadAndDisplayImageTask task)</li>
</ul>
<p>传入一个LoadAndDisplayImageTask，直接用taskDistributor执行一个Runnable，在Runnable内部根据图片是否被磁盘缓存过确定使用taskExecutorForCachedImages还是taskExecutor执行该task。</p>
<ul>
<li>void submit(ProcessAndDisplayImageTask task)</li>
</ul>
<p>传入一个ProcessAndDisplayImageTask，直接用taskExecutorForCachedImages执行该task，从缓存中去图片。</p>
<ul>
<li>void pause()</li>
</ul>
<p>暂停图片加载任务，所有新的加载或显示任务都会等待直到取消暂停为止。</p>
<ul>
<li>void resume()</li>
</ul>
<p>继续图片加载任务</p>
<ul>
<li>stop()</li>
</ul>
<p>暂停所有加载和显示图片任务并清除这里的内部属性值。</p>
<ul>
<li>fireCallBack(Runnable r)</li>
</ul>
<p>taskDistributor立即执行某个任务</p>
<ul>
<li>getLockForUri(String uri)</li>
</ul>
<p>得到某个uri的重入锁，如果不存在则新建一个</p>
<ul>
<li>private Executor createTaskExecutor()</li>
</ul>
<p>调用DefaultConfigurationFactor.createExecutor()创建一个线程池</p>
<ul>
<li>String getLoadingUriForView(ImageAware imageAware)</li>
</ul>
<p>得到某个ImageAware正在加载的图片uri</p>
<ul>
<li>prepareDisplayTaskFor(ImageAware imageAware, String memoryCacheKey)</li>
</ul>
<p>准备开始一个Task。向cacheKeysForImageAwares中插入ImageAware的id和图片在内存缓存中的key</p>
<ul>
<li>void cancelDisplayTaskFor(ImageAware imageAware)</li>
</ul>
<p>取消一个显示任务。从cacheKeysForImageAwares中删除ImageAware对应元素</p>
<ul>
<li>void denyNetworkDownloads(boolean denyNetworkDownloads)</li>
</ul>
<p>设置是否不允许网络访问</p>
<ul>
<li>void handleSlowNetwork(boolean handleSlowNetwork)</li>
</ul>
<p>设置是否慢网络情况</p>
<h3 id="DefaultConfigurationFactory-java"><a href="#DefaultConfigurationFactory-java" class="headerlink" title="DefaultConfigurationFactory.java"></a>DefaultConfigurationFactory.java</h3><p>为ImageLoaderConfiguration及ImageLoaderEngine提供一些默认配置</p>
<p>主要函数：</p>
<ul>
<li>Executor createExecutor(int threadPoolSize, int threadPriority,QueueProcessingType tasksProcessingType)</li>
</ul>
<p>创建线程池：<br>threadPoolSize表示核心线程池大小（最大并发数）<br>threadPriority表示线程优先级<br>tasksProcessingType表示线程队列类型，目前只有FIFO，LIFO两种可选择</p>
<p>内部实现会调用createThreadFactory(…)返回一个支持线程优先级设置，并且以固定规则命名新建的线程的线程工厂类DefaultConfigurationFactory.DefaultThreadFactory。</p>
<ul>
<li>Executor createTaskDistributor()</li>
</ul>
<p>为ImageLoaderEngine中的任务分发器taskDistributor提供线程池，该线程池为normal优先级的无并发大小限制的线程池。</p>
<ul>
<li>FileNameGenerator createFileNameGenerator()</li>
</ul>
<p>返回一个HashCodeFileNameGenerator对象，即以uri HashCode为文件名的文件名生成器。</p>
<ul>
<li>DiskCache createDiskCache(Context context, FileNameGenerator diskCacheFileNameGenerator,long diskCacheSize, int diskCacheFileCount)</li>
</ul>
<p>创建一个 Disk Cache。如果 diskCacheSize 或者 diskCacheFileCount 大于 0，返回一个LruDiskCache，否则返回无大小限制的UnlimitedDiskCache。</p>
<ul>
<li>MemoryCache createMemoryCache(Context context, int memoryCacheSize)</li>
</ul>
<p>创建一个 Memory Cache。返回一个LruMemoryCache，若 memoryCacheSize 为 0，则设置该内存缓存的最大字节数为App最大可用内存的1/8。这里的App的最大可用内存也支持系统在Honeycomb之后（Api Level &gt;= 11)application中android:largeHeap=”true”的设置。</p>
<ul>
<li>ImageDownloader createImageDownloader(Context context)</li>
</ul>
<p>创建图片下载器，返回一个BaseImageDownloader。</p>
<ul>
<li>ImageDecoder createImageDecoder(boolean loggingEnabled)</li>
</ul>
<p>创建图片解码器，返回一个BaseImageDecoder。</p>
<ul>
<li>BitmapDisplayer createBitmapDisplayer()</li>
</ul>
<p>创建图片显示器，返回一个SimpleBitmapDisplayer。</p>
<h3 id="DefaultConfigurationFactory-DefaultThreadFactory"><a href="#DefaultConfigurationFactory-DefaultThreadFactory" class="headerlink" title="DefaultConfigurationFactory.DefaultThreadFactory"></a>DefaultConfigurationFactory.DefaultThreadFactory</h3><p>默认的线程工厂类，为</p>
<p>DefaultConfigurationFactory.createExecutor(…)<br>和<br>DefaultConfigurationFactory.createTaskDistributor(…)<br>提供线程工厂。支持线程优先级设置，并且以固定规则命名新建的线程。</p>
<h3 id="ImageAware"><a href="#ImageAware" class="headerlink" title="ImageAware"></a>ImageAware</h3><p>需要显示图片的对象的接口，可包装View表示某个需要显示图片的View。</p>
<p>主要函数：</p>
<ul>
<li>View getWrappedView()</li>
</ul>
<p>得到被包装的View，图片显示在该View上</p>
<ul>
<li>int getWidth()和int getHeight()</li>
</ul>
<p>得到宽度高度，在计算图片缩放比例时会用到</p>
<ul>
<li>int getId()</li>
</ul>
<p>得到唯一标识id。ImageLoaderEngine中用这个id标识正在加载图片的ImageAware和图片内存缓存key的对应关系，图片请求前会将内存缓存key与新的内存缓存key进行比较，如果不相等，则之前的图片请求会被取消。这样当ImageAware被复用时就不会因异步加载（前面任务未取消）而造成错乱了。</p>
<h3 id="ViewAware-java"><a href="#ViewAware-java" class="headerlink" title="ViewAware.java"></a>ViewAware.java</h3><p>封装Android View来显示图片的抽象类，实现类ImageAware接口，利用Reference来Wrap View防止内存泄露。</p>
<p>主要函数：</p>
<ul>
<li>ViewAware(View view, boolean checkActualViewSize)</li>
</ul>
<p>构造函数：<br>view表示需要显示图片的对象<br>checkActualViewSize表示通过getWidth()和getHeight()获取图片宽高时返回真实的宽和高，还是LayoutParams的宽高，true表示返回真实宽和高。</p>
<p>如果为true会导致一个问题，view在还没有初始化完成时加载图片，这是它的真实宽高为0，会取它LayoutParams的宽高，而图片缓存的key与这个宽高有关，所以当view的初始化完成再次需要加载该图片时，getWidth()和getHeight()返回的宽高都已经变化了，缓存key不一样，从而导致缓存读取失败会再次从网络下载一次图片。可通过ImageLoaderConfiguration.Builder.denyCacheImageMultipleSizesInMemory()设置不允许内存缓存缓存一张图片的多个尺寸。</p>
<ul>
<li>boolean setImageDrawable(Drawable drawable)</li>
</ul>
<p>如果当前操作在主线程并且View没有被回收，则调用抽象函数setImageDrawableInto(Drawable drawable, View view)去向view设置图片。</p>
<ul>
<li>boolean setImageBitmap(Bitmap bitmap)</li>
</ul>
<p>如果当前操作在主线程并且View没有被回收，则调用抽象函数setImageBitmapInto(Bitmap bitmap, View view)去向view设置图片。</p>
<h3 id="ImageViewAware-java"><a href="#ImageViewAware-java" class="headerlink" title="ImageViewAware.java"></a>ImageViewAware.java</h3><p>封装Android ImageView来显示图片的ImageAware，继承了viewAware，利用Reference来Wrap View防止内存泄露。</p>
<p>如果getWidth()函数小于等于0，会利用反射获取mMaxWidth的值作为宽。<br>如果getHeight()函数小于等于0，会利用反射获取mMaxHeight的值作为高。</p>
<h3 id="NonViewAware"><a href="#NonViewAware" class="headerlink" title="NonViewAware"></a>NonViewAware</h3><p>仅包含处理图片相关信息却没有需要显示图片的View的ImageAware，实现了ImageAware接口。常用于加载图片后调用回调接口而不是显示的情况。</p>
<h3 id="DisplayImagesOptions-java"><a href="#DisplayImagesOptions-java" class="headerlink" title="DisplayImagesOptions.java"></a>DisplayImagesOptions.java</h3><p>图片显示的配置项。比如加载前、加载中、加载失败应该显示的占位图片，图片是否需要在磁盘缓存，是否需要在memory缓存等。</p>
<p>主要属性及含义：</p>
<ul>
<li>int imageResOnLoading</li>
</ul>
<p>图片正在加载中的占位图片的resource id，优先级比下面的imageOnLoading高，当存在时，imageOnLoading不起作用。</p>
<ul>
<li>int imageResForEmptyUri</li>
</ul>
<p>空uri时的占位图片的resource id，优先级比下面的imageForEmptyUri高，当存在时，imageForEmptyUri不起作用。</p>
<ul>
<li>int imageResOnFail</li>
</ul>
<p>加载失败时的占位图片的resource id，优先级比下面的imageOnFail高，当存在时，imageOnFail不起作用。</p>
<ul>
<li>Drawable imageOnLoading</li>
</ul>
<p>加载中的占位图片的Drawable对象，默认为null</p>
<ul>
<li>Drawable imageForEmptyUri</li>
</ul>
<p>空uri时的占位图片drawable对象，默认为null</p>
<ul>
<li>boolean resetViewBeforeLoading</li>
</ul>
<p>在加载前是否重置view，通过Builder构建的对象默认为false</p>
<ul>
<li>boolean cacheInMemory</li>
</ul>
<p>是否缓存在内存中，通过Builder构建的对象默认为false。</p>
<ul>
<li>boolean cacheOnDisk</li>
</ul>
<p>是否缓存在磁盘中，通过Builder构建的对象默认为false。</p>
<ul>
<li>ImageScaleType imageScaleType</li>
</ul>
<p>图片的缩放类型，通过Builder构建的对象默认为IN_SAMPLE_POWER_OF_2</p>
<ul>
<li>Options decodingOptions</li>
</ul>
<p>为BitmapFactory.Options，用于BitmapFactory.decodeStream(imageStream, null, decodingOptions)得到图片尺寸等信息。</p>
<ul>
<li>int delayBeforeLoading</li>
</ul>
<p>设置在开始加载前的延迟时间，单位为毫秒，通过Builder构建的对象默认为0。</p>
<ul>
<li>boolean considerExitParams</li>
</ul>
<p>是否考虑图片的EXIF信息，通过Builder构建的对象默认为false。</p>
<ul>
<li>Object extraForDownloader</li>
</ul>
<p>下载器需要的辅助信息。下载时传入ImageDownloader.getStream(String,Object)的对象，方面用户自己扩展，默认为null</p>
<ul>
<li>BitmapProcessor preProcessor;</li>
</ul>
<p>缓存在内存之前的处理程序，默认为null</p>
<ul>
<li>BitmapProcessor postProcessor</li>
</ul>
<p>缓存在内存之后的处理程序，默认为null</p>
<ul>
<li>BitmapDisplayer displayer;</li>
</ul>
<p>图片的显示方式，通过Builder构建的对象默认为SimpleBitmapDisplayer</p>
<ul>
<li>Handler handler;</li>
</ul>
<p>handler对象，默认为null</p>
<ul>
<li>boolean isSyncLoading;</li>
</ul>
<p>是否同步加载，通过Builder构建的对象默认为false。</p>
<h3 id="DisplayImageOptions-Builder-java-静态内部类"><a href="#DisplayImageOptions-Builder-java-静态内部类" class="headerlink" title="DisplayImageOptions.Builder.java 静态内部类"></a>DisplayImageOptions.Builder.java 静态内部类</h3><p>Builder模式，用于构造参数繁多的DisplayImageOptions。</p>
<h3 id="ImageLoadingListener"><a href="#ImageLoadingListener" class="headerlink" title="ImageLoadingListener"></a>ImageLoadingListener</h3><p>图片加载各种时刻的回调接口，可在图片加载的某些点做监听。<br>包括开始加载（onLoadingStarted）、加载失败（onLoadingFailed）、加载成功（onLoadingComplete）、取消加载（onLoadingCancelled）四个回调函数。</p>
<h3 id="SimpleImageLoadingListener"><a href="#SimpleImageLoadingListener" class="headerlink" title="SimpleImageLoadingListener"></a>SimpleImageLoadingListener</h3><p>实现ImageLoadingListener接口，不过各个函数都是空实现，表示不在Image加载过程中做任何回调监听实现。ImageLoader.displayImage()函数中当listener传入值为null时的默认值。</p>
<h3 id="ImageLoadingProgressListener-java"><a href="#ImageLoadingProgressListener-java" class="headerlink" title="ImageLoadingProgressListener.java"></a>ImageLoadingProgressListener.java</h3><p>Image加载进度的回调接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageLoadingProgressListener</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Is called when image loading progress changed.</div><div class="line">	 *</div><div class="line">	 * <span class="doctag">@param</span> imageUri Image URI</div><div class="line">	 * <span class="doctag">@param</span> view     View for image. Can be &lt;b&gt;null&lt;/b&gt;.</div><div class="line">	 * <span class="doctag">@param</span> current  Downloaded size in bytes</div><div class="line">	 * <span class="doctag">@param</span> total    Total size in bytes</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(String imageUri, View view, <span class="keyword">int</span> current, <span class="keyword">int</span> total)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会在获取图片存储到文件系统时被调用，其中total表示图片总大小，为网络请求结果Response Header中content-length字段，如果不存在则为-1。</p>
<h3 id="DisplayBitmapTask-java"><a href="#DisplayBitmapTask-java" class="headerlink" title="DisplayBitmapTask.java"></a>DisplayBitmapTask.java</h3><p>显示图片的Task，实现类Runnable接口，必须在主线程调用。</p>
<p>主要函数：</p>
<ul>
<li>run()</li>
</ul>
<p>首先判断ImageAware是否被GC回收，如果是直接调用取消加载回调接口listener.onLoadingCancelled()；<br>否则判断ImageAware是否被复用，如果是直接调用取消加载回调接口listener.onLoadingCancelled()；<br>否则调用diaplay显示图片，并将ImageAware从正在加载的map中移除。调用加载成功回调接口listener.onLoadingComplete()；</p>
<p>对于ListView或是GridView这里缓存item的View来说，单个Item中如果含有ImageView，在滑动过程中可能因为异步加载及View复用导致图片错乱，这里对ImageAware是否被复用的判断就能很好的解决这个问题。原因类似：<a href="http://www.trinea.cn/android/android-listview-display-error-image-when-scroll/" target="_blank" rel="external"><br>Android ListView滑动过程中图片显示重复错位闪烁问题解决</a></p>
<h3 id="ProcessAndDisplayImageTask-java"><a href="#ProcessAndDisplayImageTask-java" class="headerlink" title="ProcessAndDisplayImageTask.java"></a>ProcessAndDisplayImageTask.java</h3><p>处理并显示图片的Task，实现了Runnable接口。</p>
<p>主要函数：</p>
<ul>
<li>run()</li>
</ul>
<p>主要通过imageLoadingInfo得到BitmapProcessor处理图片，并且处理后的图片和配置新建一个DisplayBitmapTask在ImageAware中显示图片。</p>
<h3 id="LoadAndDisplayImageTask-java"><a href="#LoadAndDisplayImageTask-java" class="headerlink" title="LoadAndDisplayImageTask.java"></a>LoadAndDisplayImageTask.java</h3><p>加载并显示图片的Task，实现了Runnable接口，用于从网络、文件系统或内存获取图片并解析，然后调用DisplayBitmapTask在ImageAware中显示图片。</p>
<p>主要函数：</p>
<ul>
<li>run()</li>
</ul>
<p>获取图片并显示，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">bmp = configuration.memoryCache.get(memoryCacheKey);</div><div class="line"><span class="keyword">if</span> (bmp == <span class="keyword">null</span> || bmp.isRecycled()) &#123;</div><div class="line">	bmp = tryLoadBitmap();</div><div class="line">	<span class="keyword">if</span> (bmp == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// listener callback already was fired</span></div><div class="line"></div><div class="line"></div><div class="line">	<span class="keyword">if</span> (bmp != <span class="keyword">null</span> &amp;&amp; options.isCacheInMemory()) &#123;</div><div class="line">		L.d(LOG_CACHE_IMAGE_IN_MEMORY, memoryCacheKey);</div><div class="line">		configuration.memoryCache.put(memoryCacheKey, bmp);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (bmp != <span class="keyword">null</span> &amp;&amp; options.shouldPostProcess()) &#123;</div><div class="line">		L.d(LOG_POSTPROCESS_IMAGE, memoryCacheKey);</div><div class="line">		bmp = options.getPostProcessor().process(bmp);</div><div class="line">		<span class="keyword">if</span> (bmp == <span class="keyword">null</span>) &#123;</div><div class="line">			L.e(ERROR_POST_PROCESSOR_NULL, memoryCacheKey);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">DisplayBitmapTask displayBitmapTask = <span class="keyword">new</span> DisplayBitmapTask(bmp, imageLoadingInfo, engine, loadedFrom);</div><div class="line">runTask(displayBitmapTask, syncLoading, handler, engine);</div></pre></td></tr></table></figure>
<p>从上面代码可以看到显示从内存缓存中去读bitmap对象，若bitmap对象不存在，则调用tryLoadBitma()函数获取bitmap对象，获取成功后若在DisplayImageOptions.Builder中设置类cacheInMemory(true),同时将Bitmap对象缓存到内存中。最后新建DisplayBitmapTask对象显示图片。</p>
<p>函数流程图如下：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/uil-load-display-flow-chart.png" alt=""></p>
<ol>
<li>判断图片的内存缓存是否存在，若存在直接执行步骤8；</li>
<li>判断图片的内存缓存是否存在，若存在直接执行步骤5；</li>
<li>从网络上下载图片</li>
<li>将图片缓存在磁盘上</li>
<li>将图片decode成bitmap对象；</li>
<li>根据DisplayImageOptions配置对图片进行预处理；</li>
<li>将Bitmap对象缓存到内存中；</li>
<li>根据DisplayImageOptions配置对图片进行后处理；</li>
<li>执行DisplayBitmapTask将图片显示在相应的控件上；</li>
</ol>
<ul>
<li>tryLoadBitmap()</li>
</ul>
<p>从磁盘缓存或网络获取图片，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Bitmap <span class="title">tryLoadBitmap</span><span class="params">()</span> <span class="keyword">throws</span> TaskCancelledException </span>&#123;</div><div class="line">	Bitmap bitmap = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		File imageFile = configuration.diskCache.get(uri);</div><div class="line">		<span class="keyword">if</span> (imageFile != <span class="keyword">null</span> &amp;&amp; imageFile.exists() &amp;&amp; imageFile.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">			</div><div class="line">			...</div><div class="line">			</div><div class="line">			bitmap = decodeImage(Scheme.FILE.wrap(imageFile.getAbsolutePath()));</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (bitmap == <span class="keyword">null</span> || bitmap.getWidth() &lt;= <span class="number">0</span> || bitmap.getHeight() &lt;= <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">			...</div><div class="line"></div><div class="line">			String imageUriForDecoding = uri;</div><div class="line">			<span class="keyword">if</span> (options.isCacheOnDisk() &amp;&amp; tryCacheImageOnDisk()) &#123;</div><div class="line">				imageFile = configuration.diskCache.get(uri);</div><div class="line">				<span class="keyword">if</span> (imageFile != <span class="keyword">null</span>) &#123;</div><div class="line">					imageUriForDecoding = Scheme.FILE.wrap(imageFile.getAbsolutePath());</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			checkTaskNotActual();</div><div class="line">			bitmap = decodeImage(imageUriForDecoding);</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> bitmap;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先根据uri看磁盘中是不是已经缓存了这个文件，如果已经缓存，调用decodeImage函数，将图片文件decode成Bitmap对象；如果Bitmap对象不合法或缓存文件不存在，判断是否需要缓存在磁盘，需要则调用tryCacheImageOnDisk()函数去下载并缓存图片到本地磁盘，再通过decodeImage(imageUri)函数将图片文件decode成bitmap对象，否则直接通过decodeImage(imageUriForDecoding)下载图片并解析。</p>
<h3 id="tryCacheImageOnDisk"><a href="#tryCacheImageOnDisk" class="headerlink" title="tryCacheImageOnDisk()"></a>tryCacheImageOnDisk()</h3><p>下载图片并存储在磁盘内，根据磁盘缓存图片最长宽高的配置处理图片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryCacheImageOnDisk</span><span class="params">()</span> <span class="keyword">throws</span> TaskCancelledException </span>&#123;</div><div class="line">	L.d(LOG_CACHE_IMAGE_ON_DISK, memoryCacheKey);</div><div class="line"></div><div class="line">	<span class="keyword">boolean</span> loaded;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		loaded = downloadImage(); <span class="comment">//调用下载器并保存图片</span></div><div class="line">		<span class="keyword">if</span> (loaded) &#123;</div><div class="line">			<span class="keyword">int</span> width = configuration.maxImageWidthForDiskCache;</div><div class="line">			<span class="keyword">int</span> height = configuration.maxImageHeightForDiskCache;</div><div class="line">			<span class="keyword">if</span> (width &gt; <span class="number">0</span> || height &gt; <span class="number">0</span>) &#123;</div><div class="line">				L.d(LOG_RESIZE_CACHED_IMAGE_FILE, memoryCacheKey);</div><div class="line">				resizeAndSaveImage(width, height); <span class="comment">// TODO : process boolean result</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">		L.e(e);</div><div class="line">		loaded = <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> loaded;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你在ImageLoaderConfiguration中配置了maxImageWidthForDiskCache或者maxImageHeightForDiskCache，还会调用resizeAndSaveImage()函数，调整图片尺寸，并保存新的图片文件。</p>
<h3 id="downloadImage"><a href="#downloadImage" class="headerlink" title="downloadImage()"></a>downloadImage()</h3><p>下载图片并存储在磁盘内。调用getDownloader()得到ImageDownloader其下载图片。</p>
<h3 id="resizeAndSaveImage-int-maxWidth-int-maxHeight"><a href="#resizeAndSaveImage-int-maxWidth-int-maxHeight" class="headerlink" title="resizeAndSaveImage(int maxWidth,int maxHeight)"></a>resizeAndSaveImage(int maxWidth,int maxHeight)</h3><p>从磁盘缓存中得到图片，重新设置大小及进行一些处理后保存。</p>
<h3 id="geDownloader"><a href="#geDownloader" class="headerlink" title="geDownloader()"></a>geDownloader()</h3><p>根据ImageLoaderEngine配置得到下载器。<br>如果不允许访问网络，则使用不允许访问网络的图片下载器NetWorkDeniedImageDownloader；如果是慢网络情况，则使用慢网络情况下的图片下载器SlowNetworkImageDownloader；否则直接使用ImageLoaderConfiguration中的downloader。</p>
<h3 id="ImageLoadingInfo-java"><a href="#ImageLoadingInfo-java" class="headerlink" title="ImageLoadingInfo.java"></a>ImageLoadingInfo.java</h3><p>加载和显示图片任务需要的信息。成员变量如下：</p>
<p>String uri  图片url<br>String memoryCacheKey  图片缓存key<br>ImageAware imageAware  需要加载图片的对象<br>ImageSize targetSize  图片的显示尺寸<br>DisplayImageOptions options; 图片显示的配置项<br>ImageLoadingListener listener; 图片加载时状态的回调接口<br>ImageLoadingProgressListener progressListener; 图片加载进度的回调接口<br>ReentrantLock loadFromUriLock; 图片加载中的重入锁</p>
<h3 id="ImageDownloader-java"><a href="#ImageDownloader-java" class="headerlink" title="ImageDownloader.java"></a>ImageDownloader.java</h3><p>图片下载接口，待实现函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getString(String imageUri, Object extra)</div></pre></td></tr></table></figure>
<p>表示通过uri得到InputStream<br>通过内部定义的枚举Scheme，可以看出UIL支持哪些图片来源。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">HTTP</span>(<span class="string">"http"</span>), <span class="selector-tag">HTTPS</span>(<span class="string">"https"</span>), <span class="selector-tag">FILE</span>(<span class="string">"file"</span>), <span class="selector-tag">CONTENT</span>(<span class="string">"content"</span>), <span class="selector-tag">ASSETS</span>(<span class="string">"assets"</span>), <span class="selector-tag">DRAWABLE</span>(<span class="string">"drawable"</span>), <span class="selector-tag">UNKNOWN</span>(<span class="string">""</span>);</div></pre></td></tr></table></figure>
<h3 id="BaseImageDownloader-java"><a href="#BaseImageDownloader-java" class="headerlink" title="BaseImageDownloader.java"></a>BaseImageDownloader.java</h3><p>ImageDownloader的具体实现类。得到上面各种Scheme对应的图片InputStream。</p>
<p>主要函数：</p>
<ul>
<li>InputStream getStream(String imageUri, Object extra)</li>
</ul>
<p>函数内根据不同Scheme类型获取图片输入流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getStream</span><span class="params">(String imageUri, Object extra)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="keyword">switch</span> (Scheme.ofUri(imageUri)) &#123;</div><div class="line">		<span class="keyword">case</span> HTTP:</div><div class="line">		<span class="keyword">case</span> HTTPS:</div><div class="line">			<span class="keyword">return</span> getStreamFromNetwork(imageUri, extra);</div><div class="line">		<span class="keyword">case</span> FILE:</div><div class="line">			<span class="keyword">return</span> getStreamFromFile(imageUri, extra);</div><div class="line">		<span class="keyword">case</span> CONTENT:</div><div class="line">			<span class="keyword">return</span> getStreamFromContent(imageUri, extra);</div><div class="line">		<span class="keyword">case</span> ASSETS:</div><div class="line">			<span class="keyword">return</span> getStreamFromAssets(imageUri, extra);</div><div class="line">		<span class="keyword">case</span> DRAWABLE:</div><div class="line">			<span class="keyword">return</span> getStreamFromDrawable(imageUri, extra);</div><div class="line">		<span class="keyword">case</span> UNKNOWN:</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			<span class="keyword">return</span> getStreamFromOtherSource(imageUri, extra);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>InputStream getStreamFromNetwork(String imageUri, Object extra)</li>
</ul>
<p>通过HttpURLConnection从网络获取图片的InputStream，支持response code为3xx的重定向。这里有个小细节代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">InputStream imageStream;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">	imageStream = conn.getInputStream();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">	<span class="comment">// Read all data to allow reuse connection (http://bit.ly/1ad35PY)</span></div><div class="line">	IoUtils.readAndCloseStream(conn.getErrorStream());</div><div class="line">	<span class="keyword">throw</span> e;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (!shouldBeProcessed(conn)) &#123;</div><div class="line">	IoUtils.closeSilently(imageStream);</div><div class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Image request failed with response code "</span> + conn.getResponseCode());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在发生异常时会调用<code>conn.getErrorStream()</code>继续读取Error Stream，这是为了利用网络连接回收及复用，但有意思的是在2.2之前，HttpURLConnection有个重大Bug，调用close()函数会影响连接池，导致连接复用失效，不过2.3以后已经解决了此went。</p>
<ul>
<li>InputStream getStreamFromFile(String imageUri, Object extra)</li>
</ul>
<p>从文件系统获取图片的InputStream。如果uri的类型是Video，则得到video的缩略图返回，否则按照一般文件操作返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> InputStream <span class="title">getStreamFromFile</span><span class="params">(String imageUri, Object extra)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	String filePath = Scheme.FILE.crop(imageUri);</div><div class="line">	<span class="keyword">if</span> (isVideoFileUri(imageUri)) &#123;</div><div class="line">		<span class="keyword">return</span> getVideoThumbnailStream(filePath); <span class="comment">//缩略图</span></div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		BufferedInputStream imageStream = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(filePath), BUFFER_SIZE);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ContentLengthInputStream(imageStream, (<span class="keyword">int</span>) <span class="keyword">new</span> File(filePath).length());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>InputStream getStreamFromContent(String imageUri, Object extra)</li>
</ul>
<p>从ContentProvider获取图片的InputStream。<br>如果是video类型，则先从MediaStore得到video的缩略图返回；<br>如果是联系人类型，则通过<code>ContactsContract.Contacts.openContactPhotoInputStream(res, uri, true)</code>读取内容返回；<br>否则通过<code>ContentResolver..openInputStream(uri)</code>读取内容返回</p>
<ul>
<li>InputStream getStreamFromAssets(String imageUri, Object extra)</li>
</ul>
<p>从Assets文件夹中获取图片的InputStream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> InputStream <span class="title">getStreamFromAssets</span><span class="params">(String imageUri, Object extra)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	String filePath = Scheme.ASSETS.crop(imageUri);</div><div class="line">	<span class="keyword">return</span> context.getAssets().open(filePath);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>InputStream getStreamFromDrawable(String imageUri, Object extra)</li>
</ul>
<p>从Drawable资源中获取图片的InputStream。</p>
<ul>
<li>InputStream getStreamFromOtherSource(String imageUri, Object extra)</li>
</ul>
<p>UNKNOWN类型的处理，目前直接抛出不支持的异常</p>
<h3 id="MemoryCache-java"><a href="#MemoryCache-java" class="headerlink" title="MemoryCache.java"></a>MemoryCache.java</h3><p>Bitmap内存缓存接口，需要实现的接口包括get()、put()、remove()、clear()、keys()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemoryCache</span> </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Puts value into cache by key</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/** Returns value by key. If there is no value for key then null will be returned. */</span></div><div class="line">	<span class="function">Bitmap <span class="title">get</span><span class="params">(String key)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/** Removes item by key */</span></div><div class="line">	<span class="function">Bitmap <span class="title">remove</span><span class="params">(String key)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/** Returns all keys of cache */</span></div><div class="line">	<span class="function">Collection&lt;String&gt; <span class="title">keys</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/** Remove all items from cache */</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="BaseMemoryCache-java"><a href="#BaseMemoryCache-java" class="headerlink" title="BaseMemoryCache.java"></a>BaseMemoryCache.java</h3><p>实现了MemoryCache主要函数的抽象类，以<code>Map&lt;String, Reference&lt;Bitmap&gt;&gt; softMap</code>作为缓存池，利于虚拟机在内存不足是回收缓存对象。提供抽象函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Reference&lt;Bitmap&gt; <span class="title">createReference</span><span class="params">(Bitmap value)</span></span>;</div></pre></td></tr></table></figure>
<p>表示根据Bitmap创建一个Reference作为缓存对象。Reference可以是WeakReference、SoftReference等。</p>
<h3 id="WeakMemoryCache-java"><a href="#WeakMemoryCache-java" class="headerlink" title="WeakMemoryCache.java"></a>WeakMemoryCache.java</h3><p>以<code>WeakReference&lt;Bitmap&gt;</code>作为缓存value的内存缓存，实现了BaseMemoryCache的<code>createReference(Bitmap value)</code>函数，直接返回一个<code>new WeakReference&lt;Bitmap&gt;(value)</code>作为缓存value。</p>
<h3 id="LimitedMemoryCache-java"><a href="#LimitedMemoryCache-java" class="headerlink" title="LimitedMemoryCache.java"></a>LimitedMemoryCache.java</h3><p>限制总字节大小的内存缓存，继承自BaseMemoryCache抽象类。<br>会在put(…)函数中判断总体大小是否超出上限，超出则循环删除缓存对象直到小于上限。删除顺序由抽象函数<code>protected abstract Bitmap removeNext()</code>决定。抽象函数<code>protected abstract int getSize(Bitmap value)</code>表示每个元素大小。</p>
<h3 id="LargestLimitedMemoryCache-java"><a href="#LargestLimitedMemoryCache-java" class="headerlink" title="LargestLimitedMemoryCache.java"></a>LargestLimitedMemoryCache.java</h3><p>限制总字节大小的内存缓存，会在缓存满时优先删除size最大的元素，继承自LimitedMemoryCache。实现了LimitedMemoryCache的removeNext()函数，总是返回当前缓存中size最大的元素。</p>
<h3 id="UsingFreqLimitedMemoryCache-java"><a href="#UsingFreqLimitedMemoryCache-java" class="headerlink" title="UsingFreqLimitedMemoryCache.java"></a>UsingFreqLimitedMemoryCache.java</h3><p>限制总字节大小的内存缓存，会在缓存满时优先删除使用次数最少的元素，继承自LimitedMemoryCache。实现了LimitedMemoryCache的removeNext()函数，总是返回当前缓存中使用次数最少的元素。</p>
<h3 id="LRULimitedMemoryCache-java"><a href="#LRULimitedMemoryCache-java" class="headerlink" title="LRULimitedMemoryCache.java"></a>LRULimitedMemoryCache.java</h3><p>限制总字节大小的内存缓存，会在缓存满时优先删除最近最少使用的元素，继承自LimitedMemoryCache。通过<code>new LinkedHashMap&lt;String, Bitmap&gt;(10, 1.1f, true)</code>作为缓存池。LinkedHashMap第三个参数表示是否需要根据访问顺序(accessOrder)排序，true表示根据accessOrder排序，最近访问的跟最新加入的一样放到最后面，false表示根据插入顺序排序。这里为true且缓存满时始终删除第一个元素，即始终删除最近最少访问的元素。实现了LimitedMemoryCache的removeNext()函数，总是返回当前缓存中最近最少使用的元素。</p>
<h3 id="FIFOLimitedMemoryCache-java"><a href="#FIFOLimitedMemoryCache-java" class="headerlink" title="FIFOLimitedMemoryCache.java"></a>FIFOLimitedMemoryCache.java</h3><p>限制总字节大小的内存缓存，会在缓存满的时优先删除进入缓存的元素，继承自LimitedMemoryCache。实现了LimitedMemoryCache的removeNext()函数，总是返回当前缓存中最先进入缓存的元素。</p>
<blockquote>
<p><strong>以上所有LimitedMemoryCache子类都有个问题，就是Bitmap虽然通过WeakReference<bitmap>包装，但实际根本不会被虚拟机回收，因为他们子类中同时都保留了Bitmap的强引用。这些大都是UIL早期实现的版本，不推荐使用</bitmap></strong></p>
</blockquote>
<h3 id="LruMemoryCache-java"><a href="#LruMemoryCache-java" class="headerlink" title="LruMemoryCache.java"></a>LruMemoryCache.java</h3><p>限制总字节大小的内存缓存，会在缓存满时优先删除最近最少使用的元素，实现了MemoryCache。LRU(Least Recently Used)为最少使用算法。</p>
<p>通过<code>new LinkedHashMap&lt;String, Bitmap&gt;(0, 0.75f, true)</code>作为缓存池。LinkedHashMap第三个参数表示是否需要根据访问顺序(accessOrder)排序，true表示根据accessOrder排序，最近访问的跟最新加入的一样放到最后面，false表示根据插入顺序排序。这里为true且缓存满时始终删除第一个元素，即始终删除最近最少访问的元素。</p>
<p>在put(..)函数中通过trimToSize(int maxtSize)函数判断总体大小是否超出了上限，是则删除缓存池中第一个元素，即最近最少使用的元素，指导总体大小小于上限。</p>
<p>LruMemory功能上谕LRULimitedMemoryCache类似，不过在实现上更加优雅，用简单的实现接口方式，而不是不断继承的方式。</p>
<h3 id="LimitedAgeMemoryCache-java"><a href="#LimitedAgeMemoryCache-java" class="headerlink" title="LimitedAgeMemoryCache.java"></a>LimitedAgeMemoryCache.java</h3><p>限制类对象最长存活周期的内存缓存。<br>MemoryCache的装饰者，相当于为MemoryCache添加一个特性，以一个MemoryCache内存缓存和一个maxAge作为构造函数参数。在get()中判断如果对象存活时间已经超过设置的最长时间，则删除。</p>
<h3 id="FuzzyKeyMemoryCache-java"><a href="#FuzzyKeyMemoryCache-java" class="headerlink" title="FuzzyKeyMemoryCache.java"></a>FuzzyKeyMemoryCache.java</h3><p>可以将某些原本不同的key看做相等，在put时删除这些相等的key。<br>MemoryCache的装饰者，相当于为MemoryCache添加一个特性，以一个MemoryCache内存缓存和一个 keyComparator作为构造函数参数。在put()函数中判断如果key与缓存中已有key经过Comparator比较后相等，则删除之前的元素。</p>
<h3 id="FileNameGenerator-java"><a href="#FileNameGenerator-java" class="headerlink" title="FileNameGenerator.java"></a>FileNameGenerator.java</h3><p>根据uri得到文件名的接口</p>
<h3 id="HashCodeFileNameGenerator-java"><a href="#HashCodeFileNameGenerator-java" class="headerlink" title="HashCodeFileNameGenerator.java"></a>HashCodeFileNameGenerator.java</h3><p>以uri的hashCode值作为文件名</p>
<h3 id="Md5FileNameGenerator-java"><a href="#Md5FileNameGenerator-java" class="headerlink" title="Md5FileNameGenerator.java"></a>Md5FileNameGenerator.java</h3><p>以uri的MD5值作为文件名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Md5FileNameGenerator</span> <span class="keyword">implements</span> <span class="title">FileNameGenerator</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HASH_ALGORITHM = <span class="string">"MD5"</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RADIX = <span class="number">10</span> + <span class="number">26</span>; <span class="comment">// 10 digits + 26 letters</span></div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">generate</span><span class="params">(String imageUri)</span> </span>&#123;</div><div class="line">		<span class="keyword">byte</span>[] md5 = getMD5(imageUri.getBytes());</div><div class="line">		BigInteger bi = <span class="keyword">new</span> BigInteger(md5).abs();</div><div class="line">		<span class="keyword">return</span> bi.toString(RADIX);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">byte</span>[] getMD5(<span class="keyword">byte</span>[] data) &#123;</div><div class="line">		<span class="keyword">byte</span>[] hash = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			MessageDigest digest = MessageDigest.getInstance(HASH_ALGORITHM);</div><div class="line">			digest.update(data);</div><div class="line">			hash = digest.digest();</div><div class="line">		&#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</div><div class="line">			L.e(e);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> hash;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="DiskCache-java"><a href="#DiskCache-java" class="headerlink" title="DiskCache.java"></a>DiskCache.java</h3><p>图片的磁盘缓存接口。</p>
<p>主要函数：</p>
<ul>
<li>File getDirectory()</li>
</ul>
<p>得到磁盘缓存的根目录</p>
<ul>
<li>File get(String imageUri)</li>
</ul>
<p>根据原始图片uri去获取缓存图片的文件</p>
<ul>
<li>boolean save(String imageUri, InputStream imageStream, IoUtils.CopyListener listener)</li>
</ul>
<p>保存imageStream到磁盘中，listener表示保存进度且可在其中取消某些段的保存。</p>
<ul>
<li>boolean save(String imageUri, Bitmap bitmap)</li>
</ul>
<p>保存图片到磁盘</p>
<ul>
<li>boolean remove(String imageUri)</li>
</ul>
<p>根据图片uri删除缓存图片</p>
<ul>
<li>void close()</li>
</ul>
<p>关闭磁盘缓存，并释放资源</p>
<ul>
<li>void clear()</li>
</ul>
<p>清空磁盘缓存</p>
<h3 id="BaseDiskCache-java"><a href="#BaseDiskCache-java" class="headerlink" title="BaseDiskCache.java"></a>BaseDiskCache.java</h3><p>一个无大小限制的本地图片缓存，实现了DiskCache主要函数的抽象类。<br>图片缓存在cacheDir文件夹内，当cacheDir不可用时，则使用备用库reserveCacheDir。</p>
<p>主要函数：</p>
<ul>
<li>boolean save(String imageUri, InputStream imageStream, IoUtils.CopyListener listener)</li>
</ul>
<p>先根据imageUri得到目标文件，将imageStream先写入与目标文件同一文件夹的.tmp结尾的临时文件内，若未被listener取消且写入成功则将临时文件重命名为目标文件并返回true，否则删除临时文件并返回false。</p>
<ul>
<li>boolean save(String imageUri, Bitmap bitmap)</li>
</ul>
<p>先根据imageUri得到目标文件，通过Bitmap.compress(..)函数将bitmap先写入与目标文件同一文件夹的.tmp结尾的临时文件内，若写入成功则将临时文件名重命名为目标文件并返回true，否则删除临时文件并返回false。</p>
<ul>
<li>File getFile(String imageUri)</li>
</ul>
<p>根据imageUri和fileNameGenerator得到文件名，返回cacheDir文件夹内该文件，若cacheDir不可用，则使用备用库reserveCacheDir。</p>
<h3 id="LimitedAgeDiskCache-java"><a href="#LimitedAgeDiskCache-java" class="headerlink" title="LimitedAgeDiskCache.java"></a>LimitedAgeDiskCache.java</h3><p>限制缓存对象最长存活周期的磁盘缓存，继承自BaseDiskCache。<br>在get()函数判断如果缓存对象存活时间已经超过设置的最长时间，则删除。在save()中保存当前时间作为对象的创建时间。</p>
<h3 id="UnLimitedDiskCache-java"><a href="#UnLimitedDiskCache-java" class="headerlink" title="UnLimitedDiskCache.java"></a>UnLimitedDiskCache.java</h3><p>一个无大小限制的本地图片缓存。与BaseDiskCache无异，只是用了个意思明确的类名。</p>
<h3 id="DiskLruCache-java"><a href="#DiskLruCache-java" class="headerlink" title="DiskLruCache.java"></a>DiskLruCache.java</h3><p>限制总字节大小的磁盘缓存，会在缓存满时优先删除最近最少使用的元素。</p>
<p>通过缓存目录下名为journal的文件记录缓存的所有操作，并在缓存open时读取journal的文件内容存储到<code>LinkedHashMap&lt;String, Bitmap&gt; lruEntries</code>，后面<code>get(String key)</code>获取缓存内容时，会先从lruEntries中得到图片文件名返回文件。</p>
<p>通过<code>new LinkedHashMap&lt;String, Entry&gt;(0, 0.75f, true)</code>作为缓存池。LinkedHashMap第三个参数表示是否需要根据访问顺序(accessOrder)排序，true表示根据accessOrder排序，最近访问的跟最新加入的一样放到最后面，false表示根据插入顺序排序。这里为true且缓存满时trimToSize()函数始终删除第一个元素，即始终删除最近最少访问的元素。</p>
<h3 id="LruDiskCache-java"><a href="#LruDiskCache-java" class="headerlink" title="LruDiskCache.java"></a>LruDiskCache.java</h3><p>限制总字节大小的本地缓存，会在缓存满时优先删除最近最少使用的元素，实现了DiskCache。内部有个DiskLruCache cache、属性，缓存的存、取操作基本都是由该属性代理完成。</p>
<h3 id="StrictLineReader-java"><a href="#StrictLineReader-java" class="headerlink" title="StrictLineReader.java"></a>StrictLineReader.java</h3><p>通过readLine()函数从InputStream中读取一行，目前仅用于磁盘缓存操作记录文件journal的解析。</p>
<h3 id="Util-java"><a href="#Util-java" class="headerlink" title="Util.java"></a>Util.java</h3><p>工具类：</p>
<p>String readFully(Reader reader)读取 reader 中内容。<br>deleteContents(File dir)递归删除文件夹内容。</p>
<h3 id="ContentLengthInputStream-java"><a href="#ContentLengthInputStream-java" class="headerlink" title="ContentLengthInputStream.java"></a>ContentLengthInputStream.java</h3><p>InputStream的装饰者，可通过available()函数得到 InputStream 对应数据源的长度(总字节数)。主要用于计算文件存储进度即图片下载进度时的总进度。</p>
<h3 id="FailReason-java"><a href="#FailReason-java" class="headerlink" title="FailReason.java"></a>FailReason.java</h3><p>图片下载及显示时的错误原因，目前包括：<br>IO_ERROR 网络连接或是磁盘存储错误。<br>DECODING_ERROR decode image 为 Bitmap 时错误。<br>NETWORK_DENIED 当图片不在缓存中，且设置不允许访问网络时的错误。<br>OUT_OF_MEMORY 内存溢出错误。<br>UNKNOWN 未知错误。</p>
<h3 id="FlushedInputStream-java"><a href="#FlushedInputStream-java" class="headerlink" title="FlushedInputStream.java"></a>FlushedInputStream.java</h3><p>为了解决早期 Android 版本BitmapFactory.decodeStream(…)在慢网络情况下 decode image 异常的 Bug。<br>主要通过重写FilterInputStream的 skip(long n) 函数解决，确保 skip(long n) 始终跳过了 n 个字节。如果返回结果即跳过的字节数小于 n，则不断循环直到 skip(long n) 跳过 n 字节或到达文件尾。</p>
<h3 id="ImageScaleType-java"><a href="#ImageScaleType-java" class="headerlink" title="ImageScaleType.java"></a>ImageScaleType.java</h3><p>Image 的缩放类型，目前包括：<br>NONE不缩放。<br>NONE_SAFE根据需要以整数倍缩小图片，使得其尺寸不超过 Texture 可接受最大尺寸。<br>IN_SAMPLE_POWER_OF_2根据需要以 2 的 n 次幂缩小图片，使其尺寸不超过目标大小，比较快的缩小方式。<br>IN_SAMPLE_INT根据需要以整数倍缩小图片，使其尺寸不超过目标大小。<br>EXACTLY根据需要缩小图片到宽或高有一个与目标尺寸一致。<br>EXACTLY_STRETCHED根据需要缩放图片到宽或高有一个与目标尺寸一致。</p>
<h3 id="ViewScaleType-java"><a href="#ViewScaleType-java" class="headerlink" title="ViewScaleType.java"></a>ViewScaleType.java</h3><p>ImageAware的 ScaleType。<br>将 ImageView 的 ScaleType 简化为两种FIT_INSIDE和CROP两种。FIT_INSIDE表示将图片缩放到至少宽度和高度有一个小于等于 View 的对应尺寸，CROP表示将图片缩放到宽度和高度都大于等于 View 的对应尺寸。</p>
<h3 id="ImageSize-java"><a href="#ImageSize-java" class="headerlink" title="ImageSize.java"></a>ImageSize.java</h3><p>表示图片宽高的类。<br>scaleDown(…) 等比缩小宽高。<br>scale(…) 等比放大宽高。</p>
<h3 id="LoadedFrom-java"><a href="#LoadedFrom-java" class="headerlink" title="LoadedFrom.java"></a>LoadedFrom.java</h3><p>图片来源枚举类，包括网络、磁盘缓存、内存缓存。</p>
<h3 id="ImageDecoder-java"><a href="#ImageDecoder-java" class="headerlink" title="ImageDecoder.java"></a>ImageDecoder.java</h3><p>将图片转换为 Bitmap 的接口，抽象函数：<br>Bitmap decode(ImageDecodingInfo imageDecodingInfo) throws IOException;<br>表示根据ImageDecodingInfo信息得到图片并根据参数将其转换为 Bitmap。</p>
<h3 id="BaseImageDecoder-java"><a href="#BaseImageDecoder-java" class="headerlink" title="BaseImageDecoder.java"></a>BaseImageDecoder.java</h3><p>实现类ImageDecoder。调用ImageDownloader获取图片，然后根据ImageDecodingInfo或图片Exif信息处理图片转换为Bitmap。</p>
<p>主要函数：</p>
<ul>
<li>decode(ImageDecodingInfo decodingInfo)</li>
</ul>
<p>调用ImageDownloader获取图片，再调用defineImageSizeAndRotation()函数得到图片的相关信息，调用preparedDecodingOptions()得到图片缩放的比例，调用BitmapFactory.decodeStream()将InputStream转换为Bitmap，最后调用considerExactScaleAndOrientatiton()根据参数将图片放大、翻转、旋转为合适的样子返回。</p>
<ul>
<li>ImageFileInfo defineImageSizeAndRotation(InputStream imageStream, ImageDecodingInfo decodingInfo)</li>
</ul>
<p>得到图片真实大小以及Exif信息（设置考虑Exif的条件下）</p>
<ul>
<li>ExifInfo defineExifOrientation(String imageUri)</li>
</ul>
<p>得到图片Exif信息中的翻转以及旋转角度信息。</p>
<ul>
<li>Options prepareDecodingOptions(ImageSize imageSize, ImageDecodingInfo decodingInfo)</li>
</ul>
<p>得到图片缩放的比例：</p>
<ol>
<li>如果scaleType等于ImageScaleType.NONE，则缩放比例为1；</li>
<li>如果scaleType等于ImageScaleType.NONE_SAFE，则缩放比例为ImageSizeUtils.computeImageSampleSize.computeMinImageSampleSize()的返回值。</li>
<li>否则，调用ImageSizeUtils.computeImageSampleSize()计算返回值。</li>
</ol>
<p>在computeImageSampleSize()中</p>
<ol>
<li><p>如果viewScaleType等于FIT_INSIDE：<br> 1.1 如果scaleType等于ImageScaleType.IN_SAMPLE_POWER_OF_2，则缩放比例从1开始不断*2直到宽或高小于最大尺寸。<br> 1.2 否则，取宽和高分别与最大尺寸比例中较大值，即Math.max(srcWidth / targetWidth, srcHeight / targetHeight)。</p>
</li>
<li><p>如果viewScaleType等于CROP；<br> 2.1 如果scaleType等于ImageScaleType.IN_SAMPLE_POWER_OF_2，则缩放比例从1开始不断*2直到宽或高小于最大尺寸。<br> 2.2 否则，取宽和高分别与最大尺寸比例中较小值，即Math.min(srcWidth / targetWidth, srcHeight / targetHeight)</p>
</li>
<li><p>最后，在considerMaxTextureSize()中判断宽和高是否超过最大值，如果是则*2或是+1缩放。</p>
</li>
</ol>
<ul>
<li>Bitmap considerExactScaleAndOrientatiton(Bitmap subsampledBitmap, ImageDecodingInfo decodingInfo,int rotation, boolean flipHorizontal)</li>
</ul>
<p>根据参数将图片放大、翻转、旋转为合适的样子返回。</p>
<h3 id="ImageDownloadingInfo-java"><a href="#ImageDownloadingInfo-java" class="headerlink" title="ImageDownloadingInfo.java"></a>ImageDownloadingInfo.java</h3><p>Image Decode 需要的信息。<br>String imageKey 图片。<br>String imageUri 图片 uri，可能是缓存文件的 uri。<br>String originalImageUri 图片原 uri。<br>ImageSize targetSize 图片的显示尺寸。<br>imageScaleType 图片的 ScaleType。<br>ImageDownloader downloader 图片的下载器。<br>Object extraForDownloader 下载器需要的辅助信息。<br>boolean considerExifParams 是否需要考虑图片 Exif 信息。<br>Options decodingOptions 图片的解码信息，为 BitmapFactory.Options。</p>
<h3 id="BitmapDisplayer-java"><a href="#BitmapDisplayer-java" class="headerlink" title="BitmapDisplayer.java"></a>BitmapDisplayer.java</h3><p>在ImageAware中显示 bitmap 对象的接口。可在实现中对 bitmap 做一些额外处理，比如加圆角、动画效果。</p>
<h3 id="FadeInBitmapDisplayer-java"><a href="#FadeInBitmapDisplayer-java" class="headerlink" title="FadeInBitmapDisplayer.java"></a>FadeInBitmapDisplayer.java</h3><p>图片淡入方式显示在ImageAware中，实现了BitmapDisplayer接口。</p>
<h3 id="RoundedBitmapDisplayer-java"><a href="#RoundedBitmapDisplayer-java" class="headerlink" title="RoundedBitmapDisplayer.java"></a>RoundedBitmapDisplayer.java</h3><p>为图片添加圆角显示在ImageAware中，实现了BitmapDisplayer接口。主要通过BitmapShader实现。</p>
<h3 id="RoundedVignetteBitmapDisplayer-java"><a href="#RoundedVignetteBitmapDisplayer-java" class="headerlink" title="RoundedVignetteBitmapDisplayer.java"></a>RoundedVignetteBitmapDisplayer.java</h3><p>为图片添加渐变效果的圆角显示在ImageAware中，实现了BitmapDisplayer接口。主要通过RadialGradient实现。</p>
<h3 id="SimpleBitmapDisplayer-java"><a href="#SimpleBitmapDisplayer-java" class="headerlink" title="SimpleBitmapDisplayer.java"></a>SimpleBitmapDisplayer.java</h3><p>直接将图片显示在ImageAware中，实现了BitmapDisplayer接口。</p>
<h3 id="BitmapProcessor-java"><a href="#BitmapProcessor-java" class="headerlink" title="BitmapProcessor.java"></a>BitmapProcessor.java</h3><p>图片处理接口。可用于对图片预处理(Pre-process Bitmap）和后处理(Post-process Bitmap)。抽象函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BitmapProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function">Bitmap <span class="title">process</span><span class="params">(Bitmap bitmap)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用户可以根据自己的需要去实现它。比如你想要为你的图片添加一个水印，那么可以自己去实现BitmapProcessor接口。在DisplayImageOptions中配置Pre-process阶段预处理图片，这样设置后存储在文件系统以及内存缓存中的图片都是加了水印的。如果只希望在显示时改变不动原图片，可以在BitmapDisplayer中处理。</p>
<h3 id="PauseOnScrollListener-java"><a href="#PauseOnScrollListener-java" class="headerlink" title="PauseOnScrollListener.java"></a>PauseOnScrollListener.java</h3><p>可以在View滚动过程中暂停图片加载的Listener，实现了OnScrollListener接口。<br>它的好处是防止滚动中不必要的图片加载，在ListView或GridView中item加载图片最好使用它，简单的一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gridView.setOnScrollListener(<span class="keyword">new</span> PauseOnScrollListener(ImageLoader.getInstance(), <span class="keyword">false</span>, <span class="keyword">true</span>));</div></pre></td></tr></table></figure>
<p>主要成员变量：</p>
<p>pauseOnScroll; 触摸(手指依然在屏幕上)滑动过程中是否暂停图片加载<br>pauseOnFling;  甩指(手指已离开屏幕)过程中是否暂停图片加载<br>externalListener; 自定义的OnScrollListener接口，适用于View原来就有自定义OnScrollListener情况设置</p>
<p>实现原理：重写onScrollStateChanged(…)函数判断不同的状态下暂停或继续图片加载。</p>
<p>OnScrollListener.SCROLL_STATE_IDLE表示 View 处于空闲状态，没有在滚动，这时候会加载图片。</p>
<p>OnScrollListener.SCROLL_STATE_TOUCH_SCROLL表示 View 处于触摸滑动状态，手指依然在屏幕上，通过pauseOnScroll变量确定是否需要暂停图片加载。这种时候大都属于慢速滚动浏览状态，所以建议继续图片加载。</p>
<p>OnScrollListener.SCROLL_STATE_FLING表示 View 处于甩指滚动状态，手指已离开屏幕，通过pauseOnFling变量确定是否需要暂停图片加载。这种时候大都属于快速滚动状态，所以建议暂停图片加载以节省资源。</p>
<h3 id="QueueProcessingType-java"><a href="#QueueProcessingType-java" class="headerlink" title="QueueProcessingType.java"></a>QueueProcessingType.java</h3><p>任务队列的处理类型，包括FIFO先进先出、LIFO后进先出。</p>
<h3 id="LIFOLinkedBlockingDeque-java"><a href="#LIFOLinkedBlockingDeque-java" class="headerlink" title="LIFOLinkedBlockingDeque.java"></a>LIFOLinkedBlockingDeque.java</h3><p>后进先出阻塞队列。重写LinkedBlockingDeque的offer()函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(T e)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.offerFirst(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>让LinkedBlockingDeque插入总在最前，而remove()本身始终删除第一个元素，所以就变为了后进先出阻塞队列。实际一般情况只重写offer(…)函数是不够的，但因为ThreadPoolExecutor默认只用到了BlockingQueue的offer(…)函数，所以这种简单重写后做为ThreadPoolExecutor的任务队列没问题。</p>
<p>LIFOLinkedBlockingDeque.java包下的LinkedBlockingDeque.java、BlockingDeque.java、Deque.java都是 Java 1.6 源码中的，这里不做分析。</p>
<h3 id="DiskCacheUtils-java"><a href="#DiskCacheUtils-java" class="headerlink" title="DiskCacheUtils.java"></a>DiskCacheUtils.java</h3><p>磁盘缓存工具类，可用于查找或删除某个 uri 对应的磁盘缓存。</p>
<h3 id="MemoryCacheUtils-java"><a href="#MemoryCacheUtils-java" class="headerlink" title="MemoryCacheUtils.java"></a>MemoryCacheUtils.java</h3><p>内存缓存工具类。可用于根据 uri 生成内存缓存 key，缓存 key 比较，根据 uri 得到所有相关的 key 或图片，删除某个 uri 的内存缓存。<br>generateKey(String imageUri, ImageSize targetSize)<br>根据 uri 生成内存缓存 key，key 规则为[imageUri]_[width]x[height]。</p>
<h3 id="StorageUtils-java"><a href="#StorageUtils-java" class="headerlink" title="StorageUtils.java"></a>StorageUtils.java</h3><p>得到图片 SD 卡缓存目录路径。<br>缓存目录优先选择/Android/data/[app_package_name]/cache；若无权限或不可用，则选择 App 在文件系统的缓存目录context.getCacheDir()；若无权限或不可用，则选择/data/data/[app_package_name]/cache。<br>如果缓存目录选择了/Android/data/[app_package_name]/cache，则新建.nomedia文件表示不允许类似 Galley 这些应用显示此文件夹下图片。不过在 4.0 系统有 Bug 这种方式不生效。</p>
<h3 id="ImageSizeUtils-java"><a href="#ImageSizeUtils-java" class="headerlink" title="ImageSizeUtils.java"></a>ImageSizeUtils.java</h3><p>用于计算图片尺寸、缩放比例相关的工具类。</p>
<h3 id="IoUtils-java"><a href="#IoUtils-java" class="headerlink" title="IoUtils.java"></a>IoUtils.java</h3><p>IO 相关工具类，包括 stream 拷贝，关闭等。</p>
<h3 id="L-java"><a href="#L-java" class="headerlink" title="L.java"></a>L.java</h3><p>Log 工具类。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>UIL的内存缓存默认使用了LRU算法，即近期最少使用算法，选用了基于链表结构的LinkedHashMap作为存储结构。</p>
<p>假设情景：内存缓存设置的阈值只够存储两个bitmap对象，当put第三个bitmap对象时，将近期最少使用的bitmap对象移除。</p>
<ol>
<li>初始化LinkedHashMap，并按使用顺序来排序，accessOrder = true</li>
<li>向缓存池中放入bitmap1和bitmap2两个对象</li>
<li>继续放入第三个bitmap3，根据假设情景，将会超过设定缓存池阈值</li>
<li>释放对bitmap1对象的引用</li>
<li>bitmap1对象被GC回收</li>
</ol>
<p>UIL的磁盘缓存默认使用了UnlimitedDiskCache</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list">
			 
        <li class="article-tag-list-item">
        	<a href="javascript:void(0)" class="article-tag-list-link color5">源码分析</a>
        </li>
      
		</ul>
	</div>

      
	<div class="article-category tagcloud">
	<i class="icon-book icon"></i>
	<a class="article-category-link" href="/categories/Android/">Android</a>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/2016/04/17/Android-Universal-Image-Loader源码分析/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>








  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 刘涤生
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true,
		root: "/",
		innerArchive: true,
		showTags: true
	}
</script>

<script>
!function(t){function n(r){if(e[r])return e[r].exports;var o=e[r]={exports:{},id:r,loaded:!1};return t[r].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var e={};return n.m=t,n.c=e,n.p="/",n(0)}([function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,n){var e=/\/|index.html/g;return t.replace(e,"")===n.replace(e,"")}function i(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,e=0,r=t.length;e<r;e++){var i=t[e];o(n,i.getAttribute("href"))&&(0,d.default)(i,"active")}}function u(t){for(var n=t.offsetLeft,e=t.offsetParent;null!==e;)n+=e.offsetLeft,e=e.offsetParent;return n}function f(t){for(var n=t.offsetTop,e=t.offsetParent;null!==e;)n+=e.offsetTop,e=e.offsetParent;return n}function c(t,n,e,r,o){var i=u(t),c=f(t)-n;if(c-e<=o){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,h.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(e||c)+"px",a.style.left=i+"px",a.style.zIndex=r||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");c(t,document.body.scrollTop,-63,2,0),c(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}function l(){x.default.versions.mobile&&window.screen.width<800&&(i(),s())}var p=e(71),d=r(p),v=e(72),y=(r(v),e(84)),h=r(y),b=e(69),x=r(b),m=e(75),g=r(m),w=e(70);l(),(0,w.addLoadEvent)(function(){g.default.init()}),t.exports={}},function(t,n){var e=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=e)},function(t,n){var e={}.hasOwnProperty;t.exports=function(t,n){return e.call(t,n)}},function(t,n,e){var r=e(49),o=e(15);t.exports=function(t){return r(o(t))}},function(t,n,e){t.exports=!e(8)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,e){var r=e(6),o=e(12);t.exports=e(4)?function(t,n,e){return r.f(t,n,o(1,e))}:function(t,n,e){return t[n]=e,t}},function(t,n,e){var r=e(10),o=e(30),i=e(24),u=Object.defineProperty;n.f=e(4)?Object.defineProperty:function(t,n,e){if(r(t),n=i(n,!0),r(e),o)try{return u(t,n,e)}catch(t){}if("get"in e||"set"in e)throw TypeError("Accessors not supported!");return"value"in e&&(t[n]=e.value),t}},function(t,n,e){var r=e(22)("wks"),o=e(13),i=e(1).Symbol,u="function"==typeof i,f=t.exports=function(t){return r[t]||(r[t]=u&&i[t]||(u?i:o)("Symbol."+t))};f.store=r},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,e){var r=e(35),o=e(16);t.exports=Object.keys||function(t){return r(t,o)}},function(t,n,e){var r=e(11);t.exports=function(t){if(!r(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var e=0,r=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++e+r).toString(36))}},function(t,n){var e=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=e)},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,e){var r=e(6).f,o=e(2),i=e(7)("toStringTag");t.exports=function(t,n,e){t&&!o(t=e?t:t.prototype,i)&&r(t,i,{configurable:!0,value:n})}},function(t,n,e){var r=e(22)("keys"),o=e(13);t.exports=function(t){return r[t]||(r[t]=o(t))}},function(t,n,e){var r=e(1),o="__core-js_shared__",i=r[o]||(r[o]={});t.exports=function(t){return i[t]||(i[t]={})}},function(t,n){var e=Math.ceil,r=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?r:e)(t)}},function(t,n,e){var r=e(11);t.exports=function(t,n){if(!r(t))return t;var e,o;if(n&&"function"==typeof(e=t.toString)&&!r(o=e.call(t)))return o;if("function"==typeof(e=t.valueOf)&&!r(o=e.call(t)))return o;if(!n&&"function"==typeof(e=t.toString)&&!r(o=e.call(t)))return o;throw TypeError("Can't convert object to primitive value")}},function(t,n,e){var r=e(1),o=e(14),i=e(18),u=e(26),f=e(6).f;t.exports=function(t){var n=o.Symbol||(o.Symbol=i?{}:r.Symbol||{});"_"==t.charAt(0)||t in n||f(n,t,{value:u.f(t)})}},function(t,n,e){n.f=e(7)},function(t,n,e){var r=e(1),o=e(14),i=e(46),u=e(5),f="prototype",c=function(t,n,e){var a,s,l,p=t&c.F,d=t&c.G,v=t&c.S,y=t&c.P,h=t&c.B,b=t&c.W,x=d?o:o[n]||(o[n]={}),m=x[f],g=d?r:v?r[n]:(r[n]||{})[f];d&&(e=n);for(a in e)s=!p&&g&&void 0!==g[a],s&&a in x||(l=s?g[a]:e[a],x[a]=d&&"function"!=typeof g[a]?e[a]:h&&s?i(l,r):b&&g[a]==l?function(t){var n=function(n,e,r){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,e)}return new t(n,e,r)}return t.apply(this,arguments)};return n[f]=t[f],n}(l):y&&"function"==typeof l?i(Function.call,l):l,y&&((x.virtual||(x.virtual={}))[a]=l,t&c.R&&m&&!m[a]&&u(m,a,l)))};c.F=1,c.G=2,c.S=4,c.P=8,c.B=16,c.W=32,c.U=64,c.R=128,t.exports=c},function(t,n){var e={}.toString;t.exports=function(t){return e.call(t).slice(8,-1)}},function(t,n,e){var r=e(11),o=e(1).document,i=r(o)&&r(o.createElement);t.exports=function(t){return i?o.createElement(t):{}}},function(t,n,e){t.exports=!e(4)&&!e(8)(function(){return 7!=Object.defineProperty(e(29)("div"),"a",{get:function(){return 7}}).a})},function(t,n,e){"use strict";var r=e(18),o=e(27),i=e(36),u=e(5),f=e(2),c=e(17),a=e(51),s=e(20),l=e(58),p=e(7)("iterator"),d=!([].keys&&"next"in[].keys()),v="@@iterator",y="keys",h="values",b=function(){return this};t.exports=function(t,n,e,x,m,g,w){a(e,n,x);var O,S,_,j=function(t){if(!d&&t in A)return A[t];switch(t){case y:return function(){return new e(this,t)};case h:return function(){return new e(this,t)}}return function(){return new e(this,t)}},P=n+" Iterator",E=m==h,M=!1,A=t.prototype,T=A[p]||A[v]||m&&A[m],L=T||j(m),N=m?E?j("entries"):L:void 0,C="Array"==n?A.entries||T:T;if(C&&(_=l(C.call(new t)),_!==Object.prototype&&(s(_,P,!0),r||f(_,p)||u(_,p,b))),E&&T&&T.name!==h&&(M=!0,L=function(){return T.call(this)}),r&&!w||!d&&!M&&A[p]||u(A,p,L),c[n]=L,c[P]=b,m)if(O={values:E?L:j(h),keys:g?L:j(y),entries:N},w)for(S in O)S in A||i(A,S,O[S]);else o(o.P+o.F*(d||M),n,O);return O}},function(t,n,e){var r=e(10),o=e(55),i=e(16),u=e(21)("IE_PROTO"),f=function(){},c="prototype",a=function(){var t,n=e(29)("iframe"),r=i.length,o="<",u=">";for(n.style.display="none",e(48).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write(o+"script"+u+"document.F=Object"+o+"/script"+u),t.close(),a=t.F;r--;)delete a[c][i[r]];return a()};t.exports=Object.create||function(t,n){var e;return null!==t?(f[c]=r(t),e=new f,f[c]=null,e[u]=t):e=a(),void 0===n?e:o(e,n)}},function(t,n,e){var r=e(35),o=e(16).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return r(t,o)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,e){var r=e(2),o=e(3),i=e(45)(!1),u=e(21)("IE_PROTO");t.exports=function(t,n){var e,f=o(t),c=0,a=[];for(e in f)e!=u&&r(f,e)&&a.push(e);for(;n.length>c;)r(f,e=n[c++])&&(~i(a,e)||a.push(e));return a}},function(t,n,e){t.exports=e(5)},function(t,n,e){var r=e(15);t.exports=function(t){return Object(r(t))}},function(t,n,e){t.exports={default:e(41),__esModule:!0}},function(t,n,e){t.exports={default:e(42),__esModule:!0}},function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var o=e(39),i=r(o),u=e(38),f=r(u),c="function"==typeof f.default&&"symbol"==typeof i.default?function(t){return typeof t}:function(t){return t&&"function"==typeof f.default&&t.constructor===f.default&&t!==f.default.prototype?"symbol":typeof t};n.default="function"==typeof f.default&&"symbol"===c(i.default)?function(t){return"undefined"==typeof t?"undefined":c(t)}:function(t){return t&&"function"==typeof f.default&&t.constructor===f.default&&t!==f.default.prototype?"symbol":"undefined"==typeof t?"undefined":c(t)}},function(t,n,e){e(65),e(63),e(66),e(67),t.exports=e(14).Symbol},function(t,n,e){e(64),e(68),t.exports=e(26).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,e){var r=e(3),o=e(61),i=e(60);t.exports=function(t){return function(n,e,u){var f,c=r(n),a=o(c.length),s=i(u,a);if(t&&e!=e){for(;a>s;)if(f=c[s++],f!=f)return!0}else for(;a>s;s++)if((t||s in c)&&c[s]===e)return t||s||0;return!t&&-1}}},function(t,n,e){var r=e(43);t.exports=function(t,n,e){if(r(t),void 0===n)return t;switch(e){case 1:return function(e){return t.call(n,e)};case 2:return function(e,r){return t.call(n,e,r)};case 3:return function(e,r,o){return t.call(n,e,r,o)}}return function(){return t.apply(n,arguments)}}},function(t,n,e){var r=e(9),o=e(34),i=e(19);t.exports=function(t){var n=r(t),e=o.f;if(e)for(var u,f=e(t),c=i.f,a=0;f.length>a;)c.call(t,u=f[a++])&&n.push(u);return n}},function(t,n,e){t.exports=e(1).document&&document.documentElement},function(t,n,e){var r=e(28);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==r(t)?t.split(""):Object(t)}},function(t,n,e){var r=e(28);t.exports=Array.isArray||function(t){return"Array"==r(t)}},function(t,n,e){"use strict";var r=e(32),o=e(12),i=e(20),u={};e(5)(u,e(7)("iterator"),function(){return this}),t.exports=function(t,n,e){t.prototype=r(u,{next:o(1,e)}),i(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,e){var r=e(9),o=e(3);t.exports=function(t,n){for(var e,i=o(t),u=r(i),f=u.length,c=0;f>c;)if(i[e=u[c++]]===n)return e}},function(t,n,e){var r=e(13)("meta"),o=e(11),i=e(2),u=e(6).f,f=0,c=Object.isExtensible||function(){return!0},a=!e(8)(function(){return c(Object.preventExtensions({}))}),s=function(t){u(t,r,{value:{i:"O"+ ++f,w:{}}})},l=function(t,n){if(!o(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!i(t,r)){if(!c(t))return"F";if(!n)return"E";s(t)}return t[r].i},p=function(t,n){if(!i(t,r)){if(!c(t))return!0;if(!n)return!1;s(t)}return t[r].w},d=function(t){return a&&v.NEED&&c(t)&&!i(t,r)&&s(t),t},v=t.exports={KEY:r,NEED:!1,fastKey:l,getWeak:p,onFreeze:d}},function(t,n,e){var r=e(6),o=e(10),i=e(9);t.exports=e(4)?Object.defineProperties:function(t,n){o(t);for(var e,u=i(n),f=u.length,c=0;f>c;)r.f(t,e=u[c++],n[e]);return t}},function(t,n,e){var r=e(19),o=e(12),i=e(3),u=e(24),f=e(2),c=e(30),a=Object.getOwnPropertyDescriptor;n.f=e(4)?a:function(t,n){if(t=i(t),n=u(n,!0),c)try{return a(t,n)}catch(t){}if(f(t,n))return o(!r.f.call(t,n),t[n])}},function(t,n,e){var r=e(3),o=e(33).f,i={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],f=function(t){try{return o(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==i.call(t)?f(t):o(r(t))}},function(t,n,e){var r=e(2),o=e(37),i=e(21)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=o(t),r(t,i)?t[i]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,e){var r=e(23),o=e(15);t.exports=function(t){return function(n,e){var i,u,f=String(o(n)),c=r(e),a=f.length;return c<0||c>=a?t?"":void 0:(i=f.charCodeAt(c),i<55296||i>56319||c+1===a||(u=f.charCodeAt(c+1))<56320||u>57343?t?f.charAt(c):i:t?f.slice(c,c+2):(i-55296<<10)+(u-56320)+65536)}}},function(t,n,e){var r=e(23),o=Math.max,i=Math.min;t.exports=function(t,n){return t=r(t),t<0?o(t+n,0):i(t,n)}},function(t,n,e){var r=e(23),o=Math.min;t.exports=function(t){return t>0?o(r(t),9007199254740991):0}},function(t,n,e){"use strict";var r=e(44),o=e(52),i=e(17),u=e(3);t.exports=e(31)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,e=this._i++;return!t||e>=t.length?(this._t=void 0,o(1)):"keys"==n?o(0,e):"values"==n?o(0,t[e]):o(0,[e,t[e]])},"values"),i.Arguments=i.Array,r("keys"),r("values"),r("entries")},function(t,n){},function(t,n,e){"use strict";var r=e(59)(!0);e(31)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,e=this._i;return e>=n.length?{value:void 0,done:!0}:(t=r(n,e),this._i+=t.length,{value:t,done:!1})})},function(t,n,e){"use strict";var r=e(1),o=e(2),i=e(4),u=e(27),f=e(36),c=e(54).KEY,a=e(8),s=e(22),l=e(20),p=e(13),d=e(7),v=e(26),y=e(25),h=e(53),b=e(47),x=e(50),m=e(10),g=e(3),w=e(24),O=e(12),S=e(32),_=e(57),j=e(56),P=e(6),E=e(9),M=j.f,A=P.f,T=_.f,L=r.Symbol,N=r.JSON,C=N&&N.stringify,k="prototype",F=d("_hidden"),q=d("toPrimitive"),I={}.propertyIsEnumerable,B=s("symbol-registry"),D=s("symbols"),W=s("op-symbols"),H=Object[k],K="function"==typeof L,R=r.QObject,J=!R||!R[k]||!R[k].findChild,U=i&&a(function(){return 7!=S(A({},"a",{get:function(){return A(this,"a",{value:7}).a}})).a})?function(t,n,e){var r=M(H,n);r&&delete H[n],A(t,n,e),r&&t!==H&&A(H,n,r)}:A,G=function(t){var n=D[t]=S(L[k]);return n._k=t,n},$=K&&"symbol"==typeof L.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof L},z=function(t,n,e){return t===H&&z(W,n,e),m(t),n=w(n,!0),m(e),o(D,n)?(e.enumerable?(o(t,F)&&t[F][n]&&(t[F][n]=!1),e=S(e,{enumerable:O(0,!1)})):(o(t,F)||A(t,F,O(1,{})),t[F][n]=!0),U(t,n,e)):A(t,n,e)},Y=function(t,n){m(t);for(var e,r=b(n=g(n)),o=0,i=r.length;i>o;)z(t,e=r[o++],n[e]);return t},Q=function(t,n){return void 0===n?S(t):Y(S(t),n)},X=function(t){var n=I.call(this,t=w(t,!0));return!(this===H&&o(D,t)&&!o(W,t))&&(!(n||!o(this,t)||!o(D,t)||o(this,F)&&this[F][t])||n)},V=function(t,n){if(t=g(t),n=w(n,!0),t!==H||!o(D,n)||o(W,n)){var e=M(t,n);return!e||!o(D,n)||o(t,F)&&t[F][n]||(e.enumerable=!0),e}},Z=function(t){for(var n,e=T(g(t)),r=[],i=0;e.length>i;)o(D,n=e[i++])||n==F||n==c||r.push(n);return r},tt=function(t){for(var n,e=t===H,r=T(e?W:g(t)),i=[],u=0;r.length>u;)!o(D,n=r[u++])||e&&!o(H,n)||i.push(D[n]);return i};K||(L=function(){if(this instanceof L)throw TypeError("Symbol is not a constructor!");var t=p(arguments.length>0?arguments[0]:void 0),n=function(e){this===H&&n.call(W,e),o(this,F)&&o(this[F],t)&&(this[F][t]=!1),U(this,t,O(1,e))};return i&&J&&U(H,t,{configurable:!0,set:n}),G(t)},f(L[k],"toString",function(){return this._k}),j.f=V,P.f=z,e(33).f=_.f=Z,e(19).f=X,e(34).f=tt,i&&!e(18)&&f(H,"propertyIsEnumerable",X,!0),v.f=function(t){return G(d(t))}),u(u.G+u.W+u.F*!K,{Symbol:L});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),et=0;nt.length>et;)d(nt[et++]);for(var nt=E(d.store),et=0;nt.length>et;)y(nt[et++]);u(u.S+u.F*!K,"Symbol",{for:function(t){return o(B,t+="")?B[t]:B[t]=L(t)},keyFor:function(t){if($(t))return h(B,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){J=!0},useSimple:function(){J=!1}}),u(u.S+u.F*!K,"Object",{create:Q,defineProperty:z,defineProperties:Y,getOwnPropertyDescriptor:V,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),N&&u(u.S+u.F*(!K||a(function(){var t=L();return"[null]"!=C([t])||"{}"!=C({a:t})||"{}"!=C(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!$(t)){for(var n,e,r=[t],o=1;arguments.length>o;)r.push(arguments[o++]);return n=r[1],"function"==typeof n&&(e=n),!e&&x(n)||(n=function(t,n){if(e&&(n=e.call(this,t,n)),!$(n))return n}),r[1]=n,C.apply(N,r)}}}),L[k][q]||e(5)(L[k],q,L[k].valueOf),l(L,"Symbol"),l(Math,"Math",!0),l(r.JSON,"JSON",!0)},function(t,n,e){e(25)("asyncIterator")},function(t,n,e){e(25)("observable")},function(t,n,e){e(62);for(var r=e(1),o=e(5),i=e(17),u=e(7)("toStringTag"),f=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],c=0;c<5;c++){var a=f[c],s=r[a],l=s&&s.prototype;l&&!l[u]&&o(l,u,a),i[a]=i.Array}},function(t,n){"use strict";var e={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&t.indexOf("KHTML")==-1,mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:t.indexOf("Safari")==-1,weixin:t.indexOf("MicroMessenger")==-1}}()};t.exports=e},function(t,n,e){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}var o=e(40),i=r(o),u=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):o[t]||t}function n(t){return l[t]}var e=/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,r=/['<> "&]/g,o={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},f=/\u00a0/g,c=/<br\s*\/?>/gi,a=/\r?\n/g,s=/\s/g,l={};for(var p in o)l[o[p]]=p;return o["&apos;"]="'",l["'"]="&#39;",{encode:function(t){return t?(""+t).replace(r,n).replace(a,"<br/>").replace(s,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(c,"\n").replace(e,t).replace(f," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],e=0,r=t.length;r>e;e++)n.push(t.charCodeAt(e).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],e=0,r=t.length;r>e;e++)n.push(t.charCodeAt(e).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],e=0,r=t.length;r>e;e+=2)n.push(String.fromCharCode("0x"+t.slice(e,e+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,e=t.length;e>n;n++)t[n]=u.encodeObject(t[n]);else if("object"==("undefined"==typeof t?"undefined":(0,i.default)(t)))for(var r in t)t[r]=u.encodeObject(t[r]);else if("string"==typeof t)return u.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=u},function(t,n){function e(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=e},function(t,n){function e(t,n){if(t.classList)t.classList.remove(n);else{var e=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(e," ")}}t.exports=e},,,function(t,n){"use strict";function e(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){var n=document.querySelectorAll(".article-entry a:not(.article-more-a)");n.forEach(function(t){t.setAttribute("target","_blank")})}var e=document.querySelector("#js-aboutme");e&&0!==e.length&&(e.innerHTML=e.innerText)}t.exports={init:e}},,,,,,,,,function(t,n){function e(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var e=t.nextSibling;return e?t.parentNode.insertBefore(n,e):t.parentNode.appendChild(n)}t.exports=e}]);
</script>
<script src="/main.68ab53.js"></script>
<script>
(function() {
	var loadScript = function(path) {
	    var $script = document.createElement('script')
	    document.getElementsByTagName('body')[0].appendChild($script)
	    $script.setAttribute('src', path)
	}
	loadScript("/slider.fa3fc2.js")
})();
</script>




    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="color1">Android5.X</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="color5">Android系统</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="color3">实战</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="color5">源码分析</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="color4">NDK</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="color5">Android动画</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="color3">架构</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="color5">设计模式</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="color5">网络通信</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="color5">http</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="color5">Java</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="color3">面试</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="color5">并发编程</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="color1">Collection</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="color2">TCP/IP</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="color4">ios</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="color1">swift</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="color1">xcode</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="color3">记录</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="color5">读书札记</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            2、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: true
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接1</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接2</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接3</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接4</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接5</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接6</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>
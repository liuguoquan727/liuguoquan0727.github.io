<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>再读斋</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="像外行一样思考,像专家一样实践。">
<meta property="og:type" content="website">
<meta property="og:title" content="再读斋">
<meta property="og:url" content="http://liuguoquan727.github.io/page/2/index.html">
<meta property="og:site_name" content="再读斋">
<meta property="og:description" content="像外行一样思考,像专家一样实践。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="再读斋">
<meta name="twitter:description" content="像外行一样思考,像专家一样实践。">
  
    <link rel="alternate" href="/atom.xml" title="再读斋" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Søk"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liuguoquan727.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/categories">分类</a>
        
          <a class="main-nav-link" href="/tags">标签</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">再读斋</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">MICHAEL</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Go 标准库④path" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/15/Go 标准库④path/" class="article-date">
  <time datetime="2017-05-15T13:50:53.000Z" itemprop="datePublished">2017-05-15 21:50:53</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/15/Go 标准库④path/">Go 标准库介绍④path</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="path-包"><a href="#path-包" class="headerlink" title="path 包"></a>path 包</h1><p>path实现了对斜杠分隔的路径进行操作的函数。</p>
<ul>
<li>func IsAbs(path string) bool // 判断是否是一个绝对路径</li>
<li>func Split(path string) (dir, file string) // 将路径分割为路径和文件名</li>
<li>func Join(elem …string) string // 将多个字符串合并为一个路径</li>
<li>func Ext(path string) string // 返回路径中扩展部分</li>
<li>func Base(path string) string // 返回路径的最后一个元素</li>
<li>func Dir(path string) string // 返回路径中目录部分</li>
<li>func Clean(path string) string // 返回同目录的最短路径</li>
<li>func Match(pattern, name string) (matched bool, err error) // 正则是否匹配路径（shell 文件名匹配）</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// go 标准库 path</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"> </div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"path"</span></div><div class="line">)</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    pt := <span class="string">"~/gocode/src/go_note/package/path"</span></div><div class="line"> </div><div class="line">    <span class="comment">// 判断是否是一个绝对路径</span></div><div class="line">    is_abs := path.IsAbs(pt)</div><div class="line">    fmt.Println(is_abs) <span class="comment">// false</span></div><div class="line"> </div><div class="line">    <span class="comment">// 将路径分割为路径和文件名</span></div><div class="line">    pf := <span class="string">"~gocode/src/go_note/package/path/path.go"</span></div><div class="line">    dir, file := path.Split(pf)</div><div class="line">    fmt.Println(dir, file) <span class="comment">// ~gocode/src/go_note/package/path/ path.go</span></div><div class="line"> </div><div class="line">    <span class="comment">// 将多个字符串合并为一个路径</span></div><div class="line">    dir_join := path.Join(<span class="string">"usr"</span>, <span class="string">"local"</span>, <span class="string">"bin"</span>)</div><div class="line">    fmt.Println(dir_join) <span class="comment">// usr/local/bin</span></div><div class="line"> </div><div class="line">    <span class="comment">// 返回路径中扩展</span></div><div class="line">    file_ext := path.Ext(pf)</div><div class="line">    fmt.Println(file_ext) <span class="comment">// .go</span></div><div class="line"> </div><div class="line">    <span class="comment">// 返回路径的最后一个元素</span></div><div class="line">    dir_base := path.Base(pf)</div><div class="line">    fmt.Println(dir_base) <span class="comment">// path.go</span></div><div class="line"> </div><div class="line">    <span class="comment">// 返回路径中目录部分</span></div><div class="line">    dir = path.Dir(pf)</div><div class="line">    fmt.Println(dir) <span class="comment">// ~gocode/src/go_note/package/path</span></div><div class="line"> </div><div class="line">    <span class="comment">// 返回同目录的最短路径</span></div><div class="line">    dir_a := <span class="string">"/usr/../etc/../etc/ssh"</span></div><div class="line">    fmt.Println(path.Clean(dir_a)) <span class="comment">// /etc/ssh</span></div><div class="line"> </div><div class="line">    <span class="comment">// 正则是否匹配路径</span></div><div class="line">    is_match, err := path.Match(<span class="string">"*.xml"</span>, <span class="string">"a.xml"</span>)</div><div class="line">    fmt.Println(is_match, err) <span class="comment">// true &amp;lt;nil&amp;gt;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="path-filepath-包"><a href="#path-filepath-包" class="headerlink" title="path/filepath 包"></a>path/filepath 包</h1><p>filepath 包实现了兼容各操作系统的文件路径操作函数。</p>
<ul>
<li>filepath.Separator // 预定义变量，表示路径分隔符 /</li>
<li>filepath.ListSeparator // 预定义变量，表示环境变量分隔符 :</li>
<li>func Abs(path string) (string, error) // 返回path 相对当前路径的绝对路径</li>
<li>func Clean(path string) string // 返回path 的最短路径</li>
<li>func Rel(basepath, targpath string) (string, error) // 返回targpath 相对 basepath路径</li>
<li>func EvalSymlinks(path string) (string, error) // 返回软链指向的路径</li>
<li>func VolumeName(path string) string // 返回路径最前面的卷名</li>
<li>func ToSlash(path string) string // 路径分隔符替换为 /</li>
<li>func FromSlash(path string) string // / 替换为路径分隔符</li>
<li>func SplitList(path string) []string // 分隔环境变量里面的路径</li>
<li>func Walk(root string, walkFn WalkFunc) error // 遍历 root 目录下的文件树，并调用 walkFn</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// go 标准库 path/filepath</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"> </div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"os"</span></div><div class="line">    <span class="string">"path/filepath"</span></div><div class="line">)</div><div class="line"> </div><div class="line"><span class="comment">// 打印路径名称</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathName</span><span class="params">(path <span class="keyword">string</span>, info os.FileInfo, err error)</span> <span class="title">error</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">return</span> err</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        fmt.Println(path)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 预定义变量</span></div><div class="line">    fmt.Println(<span class="keyword">string</span>(filepath.Separator), <span class="keyword">string</span>(filepath.ListSeparator))</div><div class="line"> </div><div class="line">    <span class="comment">// 返回path 相对当前路径的绝对路径</span></div><div class="line">    dir := <span class="string">"~/gocode/src/go_note/package/filepath"</span></div><div class="line">    real_dir, err := filepath.Abs(dir)</div><div class="line">    fmt.Println(real_dir, err)</div><div class="line"> </div><div class="line">    <span class="comment">// 返回path 的最短路径</span></div><div class="line">    dir = <span class="string">"/usr/../etc/../tmp"</span></div><div class="line">    clear_dir := filepath.Clean(dir)</div><div class="line">    fmt.Println(clear_dir) <span class="comment">// /tmp</span></div><div class="line"> </div><div class="line">    <span class="comment">// 返回targpath 相对 basepath路径</span></div><div class="line">    basepath, targpath := <span class="string">"/usr/local"</span>, <span class="string">"/usr/local/go/bin"</span></div><div class="line">    rel_dir, err := filepath.Rel(basepath, targpath)</div><div class="line">    fmt.Println(rel_dir, err) <span class="comment">// go/bin &amp;lt;nil&amp;gt;</span></div><div class="line"> </div><div class="line">    <span class="comment">// 返回软链指向的路径</span></div><div class="line">    symlink := <span class="string">"/usr/local"</span></div><div class="line">    real_dir, err = filepath.EvalSymlinks(symlink)</div><div class="line">    fmt.Println(real_dir, err) <span class="comment">// /usr/local &amp;lt;nil&amp;gt;</span></div><div class="line"> </div><div class="line">    <span class="comment">// 返回路径最前面的卷名</span></div><div class="line">    root := <span class="string">"/usr/local/go"</span></div><div class="line">    vol := filepath.VolumeName(root)</div><div class="line">    fmt.Println(vol) <span class="comment">// ''</span></div><div class="line"> </div><div class="line">    <span class="comment">// 路径分隔符替换为 `/`</span></div><div class="line">    slash_dir := filepath.ToSlash(root)</div><div class="line">    fmt.Println(slash_dir) <span class="comment">// /usr/local/go</span></div><div class="line"> </div><div class="line">    <span class="comment">//  `/` 替换为路径分隔符</span></div><div class="line">    from_slash := filepath.FromSlash(slash_dir)</div><div class="line">    fmt.Println(from_slash) <span class="comment">// /usr/local/go</span></div><div class="line"> </div><div class="line">    <span class="comment">// 分隔环境变量里面的路径</span></div><div class="line">    env_path := <span class="string">"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/usr/local/go/bin"</span></div><div class="line">    env_slice := filepath.SplitList(env_path)</div><div class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> env_slice &#123;</div><div class="line">        fmt.Println(k, v)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 0 /usr/local/bin</span></div><div class="line">    <span class="comment">// 1 /usr/bin</span></div><div class="line">    <span class="comment">// 2 /bin</span></div><div class="line">    <span class="comment">// 3 /usr/sbin</span></div><div class="line">    <span class="comment">// 4 /sbin</span></div><div class="line">    <span class="comment">// 5 /opt/X11/bin</span></div><div class="line">    <span class="comment">// 6 /usr/local/go/bin</span></div><div class="line"> </div><div class="line">    <span class="comment">// 遍历 root 目录下的文件树，并调用 walkFn</span></div><div class="line">    root_dir, err := os.Getwd()</div><div class="line">    err = filepath.Walk(root_dir, pathName)</div><div class="line">    fmt.Println(err)</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2017/05/15/Go 标准库④path/" data-id="cj6er1fva003d6y19trpype6r" class="article-share-link">Share</a>
      
        <a href="http://liuguoquan727.github.io/2017/05/15/Go 标准库④path/#ds-thread" class="article-comment-link">Kommentarer</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go基础/">Go基础</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Go 标准库③os" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/14/Go 标准库③os/" class="article-date">
  <time datetime="2017-05-14T13:50:53.000Z" itemprop="datePublished">2017-05-14 21:50:53</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/14/Go 标准库③os/">Go 标准库介绍③os</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>os 包提供了不依赖平台的操作系统函数接口。错误处理设计为go 风格，失败的调用会返回错误值而非错误码。通常错误值里包含更多信息。</p>
<h1 id="os-常用导出函数"><a href="#os-常用导出函数" class="headerlink" title="os 常用导出函数"></a>os 常用导出函数</h1><ul>
<li>func Hostname() (name string, err error) // Hostname返回内核提供的主机名</li>
<li>func Environ() []string // Environ返回表示环境变量的格式为”key=value”的字符串的切片拷贝</li>
<li>func Getenv(key string) string // Getenv检索并返回名为key的环境变量的值</li>
<li>func Getpid() int // Getpid返回调用者所在进程的进程ID</li>
<li>func Exit(code int) // Exit让当前程序以给出的状态码code退出。一般来说，状态码0表示成功，非0表示出错。程序会立刻终止，defer的函数不会被执行</li>
<li>func Stat(name string) (fi FileInfo, err error) // 获取文件信息</li>
<li>func Getwd() (dir string, err error) // Getwd返回一个对应当前工作目录的根路径</li>
<li>func Mkdir(name string, perm FileMode) error // 使用指定的权限和名称创建一个目录</li>
<li>func MkdirAll(path string, perm FileMode) error // 使用指定的权限和名称创建一个目录，包括任何必要的上级目录，并返回nil，否则返回错误</li>
<li>func Remove(name string) error // 删除name指定的文件或目录</li>
<li>func TempDir() string // 返回一个用于保管临时文件的默认目录</li>
<li>var Args []string Args保管了命令行参数，第一个是程序名。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// go 标准库 os</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"> </div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"os"</span></div><div class="line">)</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 预定义变量, 保存命令行参数</span></div><div class="line">    fmt.Println(os.Args)</div><div class="line"> </div><div class="line">    <span class="comment">// 获取host name</span></div><div class="line">    fmt.Println(os.Hostname())</div><div class="line">    fmt.Println(os.Getpid())</div><div class="line"> </div><div class="line">    <span class="comment">// 获取全部环境变量</span></div><div class="line">    env := os.Environ()</div><div class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> env &#123;</div><div class="line">        fmt.Println(k, v)</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">// 终止程序</span></div><div class="line">    <span class="comment">// os.Exit(1)</span></div><div class="line"> </div><div class="line">    <span class="comment">// 获取一条环境变量</span></div><div class="line">    fmt.Println(os.Getenv(<span class="string">"PATH"</span>))</div><div class="line"> </div><div class="line">    <span class="comment">// 获取当前目录</span></div><div class="line">    dir, err := os.Getwd()</div><div class="line">    fmt.Println(dir, err)</div><div class="line"> </div><div class="line">    <span class="comment">// 创建目录</span></div><div class="line">    err = os.Mkdir(dir+<span class="string">"/new_file"</span>, <span class="number">0755</span>)</div><div class="line">    fmt.Println(err)</div><div class="line"> </div><div class="line">    <span class="comment">// 创建目录</span></div><div class="line">    err = os.MkdirAll(dir+<span class="string">"/new"</span>, <span class="number">0755</span>)</div><div class="line">    fmt.Println(err)</div><div class="line"> </div><div class="line">    <span class="comment">// 删除目录</span></div><div class="line">    err = os.Remove(dir + <span class="string">"/new_file"</span>)</div><div class="line">    err = os.Remove(dir + <span class="string">"/new"</span>)</div><div class="line">    fmt.Println(err)</div><div class="line"> </div><div class="line">    <span class="comment">// 创建临时目录</span></div><div class="line">    tmp_dir := os.TempDir()</div><div class="line">    fmt.Println(tmp_dir)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="File-结构体"><a href="#File-结构体" class="headerlink" title="File 结构体"></a>File 结构体</h1><ul>
<li>func Create(name string) (file *File, err error) // Create采用模式0666（任何人都可读写，不可执行）创建一个名为name的文件，如果文件已存在会截断它（为空文件）</li>
<li>func Open(name string) (file *File, err error) // Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式</li>
<li>func (f *File) Stat() (fi FileInfo, err error) // Stat返回描述文件f的FileInfo类型值</li>
<li>func (f *File) Readdir(n int) (fi []FileInfo, err error) // Readdir读取目录f的内容，返回一个有n个成员的[]FileInfo，这些FileInfo是被Lstat返回的，采用目录顺序</li>
<li>func (f *File) Read(b []byte) (n int, err error) // Read方法从f中读取最多len(b)字节数据并写入b</li>
<li>func (f *File) WriteString(s string) (ret int, err error) // 向文件中写入字符串</li>
<li>func (f *File) Sync() (err error) // Sync递交文件的当前内容进行稳定的存储。一般来说，这表示将文件系统的最近写入的数据在内存中的拷贝刷新到硬盘中稳定保存</li>
<li>func (f *File) Close() error // Close关闭文件f，使文件不能用于读写</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// go 标准库 os.File</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"> </div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"os"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 获取当前目录</span></div><div class="line">    dir, err := os.Getwd()</div><div class="line">    fmt.Println(dir, err)</div><div class="line"> </div><div class="line">    file := dir + <span class="string">"/new"</span></div><div class="line">    <span class="keyword">var</span> fh *os.File</div><div class="line"> </div><div class="line">    fi, _ := os.Stat(file)</div><div class="line">    <span class="keyword">if</span> fi == <span class="literal">nil</span> &#123;</div><div class="line">        fh, _ = os.Create(file) <span class="comment">// 文件不存在就创建</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        fh, _ = os.OpenFile(file, os.O_RDWR, <span class="number">0666</span>) <span class="comment">// 文件存在就打开</span></div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    w := []<span class="keyword">byte</span>(<span class="string">"hello go language"</span> + time.Now().String())</div><div class="line">    n, err := fh.Write(w)</div><div class="line">    fmt.Println(n, err)</div><div class="line"> </div><div class="line">    <span class="comment">// 设置下次读写位置</span></div><div class="line">    ret, err := fh.Seek(<span class="number">0</span>, <span class="number">0</span>)</div><div class="line">    fmt.Println(<span class="string">"当前文件指针位置"</span>, ret, err)</div><div class="line"> </div><div class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">128</span>)</div><div class="line">    n, err = fh.Read(b)</div><div class="line">    fmt.Println(n, err, <span class="keyword">string</span>(b))</div><div class="line"> </div><div class="line">    fh.Close()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="FileInfo-结构体"><a href="#FileInfo-结构体" class="headerlink" title="FileInfo 结构体"></a>FileInfo 结构体</h1><p>FileInfo用来描述一个文件对象</p>
<p>结构体定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span> &#123;</div><div class="line">    Name() <span class="keyword">string</span>       <span class="comment">// base name of the file</span></div><div class="line">    Size() <span class="keyword">int64</span>        <span class="comment">// length in bytes for regular files; system-dependent for others</span></div><div class="line">    Mode() FileMode     <span class="comment">// file mode bits</span></div><div class="line">    ModTime() time.Time <span class="comment">// modification time</span></div><div class="line">    IsDir() <span class="keyword">bool</span>        <span class="comment">// abbreviation for Mode().IsDir()</span></div><div class="line">    Sys() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// underlying data source (can return nil)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>func Stat(name string) (fi FileInfo, err error) // Stat 返回描述文件的FileInfo。如果指定的文件对象是一个符号链接，返回的FileInfo描述该符号链接指向的文件的信息，本函数会尝试跳转该链接</li>
<li>func Lstat(name string) (fi FileInfo, err error) // Lstat 返回描述文件对象的FileInfo。如果指定的文件对象是一个符号链接，返回的FileInfo描述该符号链接的信息，本函数不会试图跳转该链接。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fi, _ := os.Stat(file)</div><div class="line"><span class="keyword">if</span> fi == <span class="literal">nil</span> &#123;</div><div class="line">    fh, _ = os.Create(file) <span class="comment">// 文件不存在就创建</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    fh, _ = os.OpenFile(file, os.O_RDWR, <span class="number">0666</span>) <span class="comment">// 文件存在就打开</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2017/05/14/Go 标准库③os/" data-id="cj6er1fv900386y197b9bb8tb" class="article-share-link">Share</a>
      
        <a href="http://liuguoquan727.github.io/2017/05/14/Go 标准库③os/#ds-thread" class="article-comment-link">Kommentarer</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go基础/">Go基础</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Go 标准库②time" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/13/Go 标准库②time/" class="article-date">
  <time datetime="2017-05-13T13:50:53.000Z" itemprop="datePublished">2017-05-13 21:50:53</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/13/Go 标准库②time/">Go 标准库介绍②time</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="时间处理类型"><a href="#时间处理类型" class="headerlink" title="时间处理类型"></a>时间处理类型</h1><p>Go 中时间处理依赖的数据类型: time.Time, time.Month, time.Weekday, time.Duration, time.Location。</p>
<h2 id="time-Time时间点"><a href="#time-Time时间点" class="headerlink" title="time.Time时间点"></a>time.Time时间点</h2><p>time.Time 代表一个纳秒精度的时间点。Time结构体定义如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Time <span class="keyword">struct</span> &#123;</div><div class="line">    sec <span class="keyword">int64</span> <span class="comment">// 从1年1月1日 00:00:00 UTC 至今过去的秒数</span></div><div class="line">    nsec <span class="keyword">int32</span> <span class="comment">// 最近一秒到下一秒过去的纳秒数</span></div><div class="line">    loc *Location <span class="comment">// 时区</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> t time.Time <span class="comment">// 定义 time.Time 类型变量</span></div><div class="line">t = time.Now()  <span class="comment">// 获取当前时间</span></div><div class="line">fmt.Printf(<span class="string">"时间: %v, 时区:  %v,  时间类型: %T\n"</span>, t, t.Location(), t)</div><div class="line"><span class="comment">// 时间: 2017-02-22 09:06:05.816187261 +0800 CST, 时区:  Local,  时间类型: time.Time</span></div><div class="line"> </div><div class="line"><span class="comment">// time.UTC() time 返回UTC 时区的时间</span></div><div class="line">fmt.Printf(<span class="string">"时间: %v, 时区:  %v,  时间类型: %T\n"</span>, t.UTC(), t.UTC().Location(), t)</div><div class="line"><span class="comment">// 时间: 2017-02-22 01:07:15.179280004 +0000 UTC, 时区:  UTC,  时间类型: time.Time</span></div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"year: %d "</span>,t.Year())</div><div class="line">fmt.Printf(<span class="string">"month: %d "</span>,t.Month())</div><div class="line">fmt.Printf(<span class="string">"day: %d\n"</span>,t.Day())</div><div class="line"></div><div class="line">fmt.Printf(<span class="string">"hour: %d "</span>,t.Hour())</div><div class="line">fmt.Printf(<span class="string">"minute: %d "</span>,t.Minute())</div><div class="line">fmt.Printf(<span class="string">"second: %d \n"</span>,t.Second())</div></pre></td></tr></table></figure>
<p>代码中应使用time.Time 类型值来保存和传递时间，而不能用指针。表示时间的变量和字段，应为time.Time类型，而不是*time.Time类型。</p>
<h2 id="time-Month月份"><a href="#time-Month月份" class="headerlink" title="time.Month月份"></a>time.Month月份</h2><p>time.Month 代表一年中的某个月</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Month <span class="keyword">int</span></div><div class="line"></div><div class="line"><span class="comment">//Month相关的常量</span></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    January Month = <span class="number">1</span> + <span class="literal">iota</span></div><div class="line">    February</div><div class="line">    March</div><div class="line">    April</div><div class="line">    May</div><div class="line">    June</div><div class="line">    July</div><div class="line">    August</div><div class="line">    September</div><div class="line">    October</div><div class="line">    November</div><div class="line">    December</div><div class="line">)</div></pre></td></tr></table></figure>
<h2 id="time-Weekday星期"><a href="#time-Weekday星期" class="headerlink" title="time.Weekday星期"></a>time.Weekday星期</h2><p>time.Weekday 代表一周的周几。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Weekday <span class="keyword">int</span></div><div class="line"></div><div class="line"><span class="comment">//Weekday相关的常量</span></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    Sunday Weekday = <span class="literal">iota</span></div><div class="line">    Monday</div><div class="line">    Tuesday</div><div class="line">    Wednesday</div><div class="line">    Thursday</div><div class="line">    Friday</div><div class="line">    Saturday</div><div class="line">)</div></pre></td></tr></table></figure>
<h2 id="time-Duration时间段"><a href="#time-Duration时间段" class="headerlink" title="time.Duration时间段"></a>time.Duration时间段</h2><p>time.Duration 类型代表两个时间点之间经过的纳秒数，可表示的最长时间段约为290年。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Duration <span class="keyword">int64</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">    Nanosecond  Duration = <span class="number">1</span></div><div class="line">    Microsecond          = <span class="number">1000</span> * Nanosecond</div><div class="line">    Millisecond          = <span class="number">1000</span> * Microsecond</div><div class="line">    Second               = <span class="number">1000</span> * Millisecond</div><div class="line">    Minute               = <span class="number">60</span> * Second</div><div class="line">    Hour                 = <span class="number">60</span> * Minute</div><div class="line">)</div></pre></td></tr></table></figure>
<h2 id="time-Location时区"><a href="#time-Location时区" class="headerlink" title="time.Location时区"></a>time.Location时区</h2><p>Location代表一个地点，以及该地点所在的时区信息。北京时间可以使用 <code>Asia/Shanghai</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Location <span class="keyword">struct</span> &#123;</div><div class="line">    name <span class="keyword">string</span></div><div class="line">    zone []zone</div><div class="line">    tx   []zoneTrans</div><div class="line">    cacheStart <span class="keyword">int64</span></div><div class="line">    cacheEnd   <span class="keyword">int64</span></div><div class="line">    cacheZone  *zone</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="time-Time-方法"><a href="#time-Time-方法" class="headerlink" title="time.Time 方法"></a>time.Time 方法</h1><h2 id="获取一个时间的方法"><a href="#获取一个时间的方法" class="headerlink" title="获取一个时间的方法"></a>获取一个时间的方法</h2><ul>
<li>func Now() Time {} // 当前本地时间</li>
<li>func Unix(sec int64, nsec int64) Time {} // 根据时间戳返回本地时间</li>
<li>func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time {} // 返回指定时间</li>
</ul>
<h2 id="时间显示"><a href="#时间显示" class="headerlink" title="时间显示"></a>时间显示</h2><ul>
<li>func (t Time) UTC() Time {} // 获取指定时间在UTC 时区的时间表示</li>
<li>func (t Time) Local() Time {} // 以本地时区表示</li>
<li>func (t Time) In(loc *Location) Time {} // 时间在指定时区的表示</li>
<li>func (t Time) Format(layout string) string {} // 按指定格式显示时间</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取指定时间在UTC 时区的时间表示</span></div><div class="line">t_by_utc := t.UTC()</div><div class="line">fmt.Println(<span class="string">"'t.UTC': "</span>, t_by_utc)</div><div class="line"> </div><div class="line"><span class="comment">// 获取本地时间表示</span></div><div class="line">t_by_local := t.Local()</div><div class="line">fmt.Println(<span class="string">"'t.Local': "</span>, t_by_local)</div><div class="line"> </div><div class="line"><span class="comment">// 时间在指定时区的表示</span></div><div class="line">t_in := t.In(time.UTC)</div><div class="line">fmt.Println(<span class="string">"'t.In': "</span>, t_in)</div><div class="line"> </div><div class="line"><span class="comment">// Format</span></div><div class="line">fmt.Println(<span class="string">"t.Format"</span>, t.Format(time.RFC3339))</div></pre></td></tr></table></figure>
<h2 id="获取日期信息"><a href="#获取日期信息" class="headerlink" title="获取日期信息"></a>获取日期信息</h2><ul>
<li>func (t Time) Date() (year int, month Month, day int) {} // 返回时间的日期信息</li>
<li>func (t Time) Year() int {} // 返回年</li>
<li>func (t Time) Month() Month {} // 月</li>
<li>func (t Time) Day() int {} // 日</li>
<li>func (t Time) Weekday() Weekday {} // 星期</li>
<li>func (t Time) ISOWeek() (year, week int) {} // 返回年，星期范围编号</li>
<li>func (t Time) Clock() (hour, min, sec int) {} // 返回时间的时分秒</li>
<li>func (t Time) Hour() int {} // 返回小时</li>
<li>func (t Time) Minute() int {} // 分钟</li>
<li>func (t Time) Second() int {} // 秒</li>
<li>func (t Time) Nanosecond() int {} // 纳秒</li>
<li>func (t Time) YearDay() int {} // 一年中对应的天</li>
<li>func (t Time) Location() *Location {} // 时间的时区</li>
<li>func (t Time) Zone() (name string, offset int) {} // 时间所在时区的规范名和想对UTC 时间偏移量</li>
<li>func (t Time) Unix() int64 {} // 时间转为时间戳</li>
<li>func (t Time) UnixNano() int64 {} // 时间转为时间戳（纳秒）</li>
</ul>
<h2 id="时间比较与计算"><a href="#时间比较与计算" class="headerlink" title="时间比较与计算"></a>时间比较与计算</h2><ul>
<li>func (t Time) IsZero() bool {} // 是否是零时时间</li>
<li>func (t Time) After(u Time) bool {} // 时间在u 之前</li>
<li>func (t Time) Before(u Time) bool {} // 时间在u 之后</li>
<li>func (t Time) Equal(u Time) bool {} // 时间与u 相同</li>
<li>func (t Time) Add(d Duration) Time {} // 返回t +d 的时间点</li>
<li>func (t Time) Sub(u Time) Duration {} // 返回 t-u</li>
<li>func (t Time) AddDate(years int, months int, days int) Time {} 返回增加了给出的年份、月份和天数的时间点Time</li>
</ul>
<h2 id="时间序列化"><a href="#时间序列化" class="headerlink" title="时间序列化"></a>时间序列化</h2><ul>
<li>func (t Time) MarshalBinary() ([]byte, error) {} // 时间序列化</li>
<li>func (t Time) UnmarshalBinary(data []byte) error {} // 反序列化</li>
<li>func (t Time) MarshalJSON() ([]byte, error) {} // 时间序列化</li>
<li>func (t Time) MarshalText() ([]byte, error) {} // 时间序列化</li>
<li>func (t Time) GobEncode() ([]byte, error) {} // 时间序列化</li>
<li>func (t Time) GobDecode() ([]byte, error) {} // 时间序列化</li>
</ul>
<h1 id="time-Duration-方法"><a href="#time-Duration-方法" class="headerlink" title="time.Duration 方法"></a>time.Duration 方法</h1><ul>
<li>func (d Duration) String() string // 格式化输出 Duration</li>
<li>func (d Duration) Nanoseconds() int64 // 将时间段表示为纳秒</li>
<li>func (d Duration) Seconds() float64 // 将时间段表示为秒</li>
<li>func (d Duration) Minutes() float64 // 将时间段表示为分钟</li>
<li>func (d Duration) Hours() float64 // 将时间段表示为小时</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// time.Duration 时间段</span></div><div class="line">fmt.Println(<span class="string">"time.Duration 时间段"</span>)</div><div class="line">d = time.Duration(<span class="number">10000000000000</span>)</div><div class="line"> </div><div class="line">fmt.Printf(<span class="string">"'String: %v', 'Nanoseconds: %v', 'Seconds: %v', 'Minutes: %v', 'Hours: %v'\n"</span>, </div><div class="line">d.String(), d.Nanoseconds(), d.Seconds(), d.Minutes(), d.Hours())</div></pre></td></tr></table></figure>
<h1 id="time-Location-方法"><a href="#time-Location-方法" class="headerlink" title="time.Location 方法"></a>time.Location 方法</h1><ul>
<li>func (l *Location) String() string // 输出时区名</li>
<li>func FixedZone(name string, offset int) *Location // FixedZone 使用给定的地点名name和时间偏移量offset（单位秒）创建并返回一个Location</li>
<li>func LoadLocation(name string) (*Location, error) // LoadLocation 使用给定的名字创建Location</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> local *time.Location</div><div class="line">local, ok := time.LoadLocation(<span class="string">"Asia/Shanghai"</span>)</div><div class="line">fmt.Printf(<span class="string">"%v, %T, %v\n"</span>, local, local, ok)</div></pre></td></tr></table></figure>
<h1 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h1><ul>
<li>func Sleep(d Duration) // Sleep阻塞当前go线程至少d代表的时间段。d&lt;=0时，Sleep会立刻返回。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d_second := time.Second</div><div class="line">time.Sleep(d_second)</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2017/05/13/Go 标准库②time/" data-id="cj6er1fv600306y197z1lypv5" class="article-share-link">Share</a>
      
        <a href="http://liuguoquan727.github.io/2017/05/13/Go 标准库②time/#ds-thread" class="article-comment-link">Kommentarer</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go基础/">Go基础</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Go 标准库①strings" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/12/Go 标准库①strings/" class="article-date">
  <time datetime="2017-05-12T13:50:53.000Z" itemprop="datePublished">2017-05-12 21:50:53</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/12/Go 标准库①strings/">Go 标准库介绍①string</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>strings 包实现了用于操作字符串的简单函数，包括 string 导出函数和 Reader, Replacer 两个结构体。</p>
<h1 id="strings-常用导出函数"><a href="#strings-常用导出函数" class="headerlink" title="strings 常用导出函数"></a>strings 常用导出函数</h1><h2 id="判断字符串与子串关系"><a href="#判断字符串与子串关系" class="headerlink" title="判断字符串与子串关系"></a>判断字符串与子串关系</h2><ul>
<li>func EqualFold(s, t string) bool // 判断两个utf-8编码字符串，大小写不敏感</li>
<li>func HasPrefix(s, prefix string) bool // 判断s是否有前缀字符串prefix</li>
<li>func Contains(s, substr string) bool // 判断字符串s是否包含子串substr</li>
<li>func ContainsAny(s, chars string) bool // 判断字符串s是否包含字符串chars中的任一字符</li>
<li>func Count(s, sep string) int // 返回字符串s中有几个不重复的sep子串</li>
<li><p>获取字符串中子串位置</p>
</li>
<li><p>func Index(s, sep string) int // 子串sep在字符串s中第一次出现的位置，不存在则返回-1</p>
</li>
<li>func IndexByte(s string, c byte) int // 字符c在s中第一次出现的位置，不存在则返回-</li>
<li>func IndexAny(s, chars string) int // 字符串chars中的任一utf-8码值在s中第一次出现的位置，如果不存在或者chars为空字符串则返回-1</li>
<li>func IndexFunc(s string, f func(rune) bool) int // s中第一个满足函数f的位置i（该处的utf-8码值r满足f(r)==true），不存在则返回-1</li>
<li>func LastIndex(s, sep string) int // 子串sep在字符串s中最后一次出现的位置，不存在则返回-1</li>
</ul>
<h2 id="字符处理"><a href="#字符处理" class="headerlink" title="字符处理"></a>字符处理</h2><ul>
<li>func Title(s string) string // 返回s中每个单词的首字母都改为标题格式的字符串拷贝</li>
<li>func ToLower(s string) string // 返回将所有字母都转为对应的小写版本的拷贝</li>
<li>func ToUpper(s string) string // 返回将所有字母都转为对应的大写版本的拷贝</li>
<li>func Repeat(s string, count int) string // 返回count个s串联的字符串</li>
<li>func Replace(s, old, new string, n int) string // 返回将s中前n个不重叠old子串都替换为new的新字符串，如果n&lt;0会替换所有old子串</li>
<li>func Map(mapping func(rune) rune, s string) string // 将s的每一个unicode码值r都替换为mapping(r)，返回这些新码值组成的字符串拷贝。如果mapping返回一个负值，将会丢弃该码值而不会被替换</li>
</ul>
<h2 id="字符串前后端处理"><a href="#字符串前后端处理" class="headerlink" title="字符串前后端处理"></a>字符串前后端处理</h2><ul>
<li>func Trim(s string, cutset string) string // 返回将s前后端所有cutset包含的utf-8码值都去掉的字符串</li>
<li>func TrimSpace(s string) string // 返回将s前后端所有空白（unicode.IsSpace指定）都去掉的字符串</li>
<li>func TrimFunc(s string, f func(rune) bool) string // 返回将s前后端所有满足f的unicode码值都去掉的字符串</li>
</ul>
<h2 id="分割与合并"><a href="#分割与合并" class="headerlink" title="分割与合并"></a>分割与合并</h2><ul>
<li>func Fields(s string) []string // 返回将字符串按照空白（通过unicode.IsSpace判断，可以是一到多个连续的空白字符）分割的多个字符串</li>
<li>func Split(s, sep string) []string // 用去掉s中出现的sep的方式进行分割，会分割到结尾，并返回生成的所有片段组成的切片</li>
<li>func Join(a []string, sep string) string // 将一系列字符串连接为一个字符串，之间用sep来分隔</li>
</ul>
<h1 id="Reader结构体"><a href="#Reader结构体" class="headerlink" title="Reader结构体"></a>Reader结构体</h1><p>Reader 类型从一个字符串读取数据，实现了io.Reader, io.Seeker等接口。</p>
<ul>
<li>func NewReader(s string) *Reader // 通过字符串 s 创建一个 Reader</li>
<li>func (r *Reader) Len() int // 返回 r 还没有读取部分的长度</li>
<li>func (r *Reader) Read(b []byte) (n int, err error) // 读取部分数据到 b 中，读取的长度取决于 b 的容量</li>
<li>func (r *Reader) ReadByte() (b byte, err error) // 从 r 中读取一字节数据</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// go 标准库 strings.Reader</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"> </div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"strings"</span></div><div class="line">)</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    s := <span class="string">"hello world"</span></div><div class="line">    <span class="comment">// 创建 Reader</span></div><div class="line">    r := strings.NewReader(s)</div><div class="line"> </div><div class="line">    fmt.Println(r) <span class="comment">// &amp;amp;&#123;hello world 0 -1&#125;</span></div><div class="line">    fmt.Println(r.Size()) <span class="comment">// 11 获取字符串长度</span></div><div class="line">    fmt.Println(r.Len()) <span class="comment">// 11 获取未读取长度</span></div><div class="line"> </div><div class="line">    <span class="comment">// 读取前6个字符</span></div><div class="line">    <span class="keyword">for</span> r.Len() &lt; <span class="number">5</span> &#123;</div><div class="line">        b, err := r.ReadByte() <span class="comment">// 读取1 byte</span></div><div class="line">        fmt.Println(<span class="keyword">string</span>(b), err, r.Len(), r.Size())</div><div class="line">        <span class="comment">// h &amp;lt;nil&amp;gt; 10 11</span></div><div class="line">        <span class="comment">// e &amp;lt;nil&amp;gt; 9 11</span></div><div class="line">        <span class="comment">// l &amp;lt;nil&amp;gt; 8 11</span></div><div class="line">        <span class="comment">// l &amp;lt;nil&amp;gt; 7 11</span></div><div class="line">        <span class="comment">// o &amp;lt;nil&amp;gt; 6 11</span></div><div class="line">        <span class="comment">//   &amp;lt;nil&amp;gt; 5 11</span></div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">// 读取还未被读取字符串中5字符的数据</span></div><div class="line">    b_s := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>)</div><div class="line">    n, err := r.Read(b_s)</div><div class="line">    fmt.Println(<span class="keyword">string</span>(b_s), n ,err) <span class="comment">// world 5 &amp;lt;nil&amp;gt;</span></div><div class="line">    fmt.Println(r.Size()) <span class="comment">// 11</span></div><div class="line">    fmt.Println(r.Len()) <span class="comment">// 0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Replacer-结构体"><a href="#Replacer-结构体" class="headerlink" title="Replacer 结构体"></a>Replacer 结构体</h1><p>Replacer 类型实现字符串替换的操作</p>
<ul>
<li>func NewReplacer(oldnew …string) <em>Replacer // 使用提供的多组old、new字符串对创建一个</em>Replacer</li>
<li>func (r *Replacer) Replace(s string) string // 返回s 所有替换完后的拷贝</li>
<li>func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error) // 向w中写入s替换完后的拷贝</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// go 标准库 strings.Replacer</div><div class="line">package main</div><div class="line"> </div><div class="line">import (</div><div class="line">    "fmt"</div><div class="line">    "strings"</div><div class="line">    "os"</div><div class="line">)</div><div class="line"> </div><div class="line">func main() &#123;</div><div class="line">    s := "</div><div class="line"> </div><div class="line">Go Language</div><div class="line"> </div><div class="line">"</div><div class="line">    r := strings.NewReplacer("&amp;lt;", "&amp;lt;", "&amp;gt;", "&amp;gt;")</div><div class="line">    fmt.Println(r.Replace(s))</div><div class="line"> </div><div class="line">    r.WriteString(os.Stdout, s)</div><div class="line">&#125;</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2017/05/12/Go 标准库①strings/" data-id="cj6er1fv3002p6y19bz0rpo7u" class="article-share-link">Share</a>
      
        <a href="http://liuguoquan727.github.io/2017/05/12/Go 标准库①strings/#ds-thread" class="article-comment-link">Kommentarer</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go基础/">Go基础</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Go语言基础⑨Go接口和嵌入类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/11/Go语言基础⑨Go接口和嵌入类型/" class="article-date">
  <time datetime="2017-05-11T13:50:53.000Z" itemprop="datePublished">2017-05-11 21:50:53</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/11/Go语言基础⑨Go接口和嵌入类型/">Go语言基础⑨Go接口和嵌入类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口是一种约定，它是一个抽象的类型，和我们见到的具体的类型如int、map、slice等不一样。具体的类型，我们可以知道它是什么，并且可以知道可以用它做什么；但是接口不一样，接口是抽象的，它只有一组接口方法，我们并不知道它的内部实现，所以我们不知道接口是什么，但是我们知道可以利用它提供的方法做什么。</p>
<p>抽象就是接口的优势，它不用和具体的实现细节绑定在一起，我们只需定义接口，告诉编码人员它可以做什么，这样我们可以把具体实现分开，这样编码就会更加灵活方面，适应能力也会非常强。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> b bytes.Buffer</div><div class="line">	fmt.Fprint(&amp;b,<span class="string">"Hello World"</span>)</div><div class="line">	fmt.Println(b.String())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就是一个使用接口的例子，我们先看下fmt.Fprint函数的实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprint</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</div><div class="line">	p := newPrinter()</div><div class="line">	p.doPrint(a)</div><div class="line">	n, err = w.Write(p.buf)</div><div class="line">	p.free()</div><div class="line">	<span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的源代码中，我们可以看到，<code>fmt.Fprint</code>函数的第一个参数是<code>io.Writer</code>这个接口，所以只要实现了这个接口的具体类型都可以作为参数传递给fmt.Fprint函数，而bytes.Buffer恰恰实现了<code>io.Writer</code>接口，所以可以作为参数传递给<code>fmt.Fprint</code>函数。</p>
<h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p>我们前面提过接口是用来定义行为的类型，它是抽象的，这些定义的行为不是由接口直接实现，而是通过方法由用户定义的类型实现。如果用户定义的类型，实现了接口类型声明的所有方法，那么这个用户定义的类型就实现了这个接口，所以这个用户定义类型的值就可以赋值给接口类型的值。</p>
<p>赋值操作执行后，如果我们对接口方法执行调用，其实是调用存储的用户定义类型的对应方法，这里我们可以把用户定义的类型称之为<strong>实体类型</strong>。</p>
<p>我们可以定义很多类型，让它们实现一个接口，那么这些类型都可以赋值给这个接口，这时候接口方法的调用，其实就是对应实体类型对应方法的调用，这就是多态。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> a animal</div><div class="line">	<span class="keyword">var</span> c cat</div><div class="line">	a=c</div><div class="line">	a.printInfo()</div><div class="line">	<span class="comment">//使用另外一个类型赋值</span></div><div class="line">	<span class="keyword">var</span> d dog</div><div class="line">	a=d</div><div class="line">	a.printInfo()</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</div><div class="line">	printInfo()</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> cat <span class="keyword">int</span></div><div class="line"><span class="keyword">type</span> dog <span class="keyword">int</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</div><div class="line">	fmt.Println(<span class="string">"a cat"</span>)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</div><div class="line">	fmt.Println(<span class="string">"a dog"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">a cat</div><div class="line">a cat</div><div class="line">a dog</div><div class="line">a dog</div></pre></td></tr></table></figure>
<p>以上例子演示了一个多态。我们定义了一个接口animal,然后定义了两种类型cat和dog实现了接口animal。在使用的时候，分别把类型cat的值c、类型dog的值d赋值给接口animal的值a,然后分别执行a的printInfo方法，可以看到不同的输出。</p>
<blockquote>
<p>接口的值是一个两个字长度的数据结构，第一个字<strong>包含一个指向内部表结构的指针</strong>，这个内部表里存储的有实体类型的信息以及相关联的方法集；第二个字<strong>包含的是一个指向存储的实体类型值的指针</strong>。所以接口的值结构其实是两个指针，这也可以说明接口其实一个引用类型。</p>
</blockquote>
<h2 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h2><p>我们都知道，如果要实现一个接口，必须实现这个接口提供的所有方法，但是实现方法的时候，我们可以使用指针接收者实现，也可以使用值接收者实现，这两者是有区别的，下面我们就好好分析下这两者的区别。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> c cat</div><div class="line">	<span class="comment">//值作为参数传递</span></div><div class="line">	invoke(c)</div><div class="line">&#125;</div><div class="line"><span class="comment">//需要一个animal接口作为参数</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(a animal)</span></span>&#123;</div><div class="line">	a.printInfo()</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</div><div class="line">	printInfo()</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> cat <span class="keyword">int</span></div><div class="line"><span class="comment">//值接收者实现animal接口</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c cat)</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</div><div class="line">	fmt.Println(<span class="string">"a cat"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还是原来的例子改改，增加一个invoke函数，该函数接收一个animal接口类型的参数，例子中传递参数的时候，也是以类型cat的值c传递的，运行程序可以正常执行。现在我们稍微改造一下，使用类型cat的指针&amp;c作为参数传递。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> c cat</div><div class="line">	<span class="comment">//指针作为参数传递</span></div><div class="line">	invoke(&amp;c)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只修改这一处，其他保持不变，我们运行程序，发现也可以正常执行。通过这个例子我们可以得出结论：<strong>实体类型以值接收者实现接口的时候，不管是实体类型的值，还是实体类型值的指针，都实现了该接口</strong>。</p>
<p>下面我们把接收者改为指针试试。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> c cat</div><div class="line">	<span class="comment">//值作为参数传递</span></div><div class="line">	invoke(c)</div><div class="line">&#125;</div><div class="line"><span class="comment">//需要一个animal接口作为参数</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">invoke</span><span class="params">(a animal)</span></span>&#123;</div><div class="line">	a.printInfo()</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</div><div class="line">	printInfo()</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> cat <span class="keyword">int</span></div><div class="line"><span class="comment">//指针接收者实现animal接口</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cat)</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</div><div class="line">	fmt.Println(<span class="string">"a cat"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子中把实现接口的接收者改为指针，但是传递参数的时候，我们还是按值进行传递，点击运行程序，会出现以下异常提示：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./main.go:<span class="number">10</span>: cannot use c (<span class="keyword">type</span> cat) <span class="keyword">as</span> <span class="keyword">type</span> animal <span class="keyword">in</span> argument <span class="keyword">to</span> invoke:</div><div class="line">	cat does <span class="keyword">not</span> implement animal (printInfo <span class="function"><span class="keyword">method</span> <span class="title">has</span> <span class="title">pointer</span> <span class="title">receiver</span>)</span></div></pre></td></tr></table></figure>
<p>提示中告诉我们，说cat没有实现animal接口，因为printInfo方法有一个指针接收者，所以cat类型的值c不能作为接口类型animal传参使用。下面我们再稍微修改下，改为以指针作为参数传递。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> c cat</div><div class="line">	<span class="comment">//指针作为参数传递</span></div><div class="line">	invoke(&amp;c)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其他都不变，只是把以前使用值的参数，改为使用指针作为参数，我们再运行程序，就可以正常运行了。由此可见<strong>实体类型以指针接收者实现接口的时候，只有指向这个类型的指针才被认为实现了该接口</strong>。</p>
<h1 id="嵌入类型"><a href="#嵌入类型" class="headerlink" title="嵌入类型"></a>嵌入类型</h1><p>嵌入类型，或者嵌套类型，这是一种可以把已有的类型声明在新的类型里的一种方式，这种功能对代码复用非常重要。</p>
<p>在其他语言中，有继承可以做同样的事情，但是在Go语言中，没有继承的概念，Go提倡的代码复用的方式是组合，所以这也是嵌入类型的意义所在，组合而不是继承，所以Go才会更灵活。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</div><div class="line">	Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</div><div class="line">	Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</div><div class="line">	Close() error</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</div><div class="line">	Reader</div><div class="line">	Writer</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> ReadCloser <span class="keyword">interface</span> &#123;</div><div class="line">	Reader</div><div class="line">	Closer</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> WriteCloser <span class="keyword">interface</span> &#123;</div><div class="line">	Writer</div><div class="line">	Closer</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是标准库io包里，我们常用的接口，可以看到ReadWriter接口是嵌入Reader和Reader接口而组合成的新接口，这样我们就不用重复的定义被嵌入接口里的方法，直接通过嵌入就可以了。嵌入类型同样适用于结构体类型，我们再来看个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</div><div class="line">	name <span class="keyword">string</span></div><div class="line">	email <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> admin <span class="keyword">struct</span> &#123;</div><div class="line">	user</div><div class="line">	level <span class="keyword">string</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>嵌入后，被嵌入的类型称之为内部类型、新定义的类型称之为外部类型，这里user就是内部类型，而admin是外部类型。</p>
<p>通过嵌入类型，与内部类型相关联的所有字段、方法、标志符等等所有，都会被外包类型所拥有，就像外部类型自己的一样，这就达到了代码快捷复用组合的目的，而且定义非常简单，只需声明这个类型的名字就可以了。</p>
<p>同时，外部类型还可以添加自己的方法、字段属性等，可以很方便的扩展外部类型的功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	ad:=admin&#123;user&#123;<span class="string">"张三"</span>,<span class="string">"zhangsan@flysnow.org"</span>&#125;,<span class="string">"管理员"</span>&#125;</div><div class="line">	fmt.Println(<span class="string">"可以直接调用,名字为："</span>,ad.name)</div><div class="line">	fmt.Println(<span class="string">"也可以通过内部类型调用,名字为："</span>,ad.user.name)</div><div class="line">	fmt.Println(<span class="string">"但是新增加的属性只能直接调用，级别为："</span>,ad.level)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上是嵌入类型的使用，可以看到，我们在初始化的时候，采用的是字面值的方式，所以要按其定义的结构进行初始化，先初始化user这个内部类型的，再初始化新增的level 属性。</p>
<p>对于内部类型的属性和方法访问上，我们可以用外部类型直接访问，也可以通过内部类型进行访问；但是我们为<strong>外部类型新增的方法属性字段，只能使用外部类型访问，因为内部类型没有这些</strong>。</p>
<p>当然，外部类型也可以声明同名的字段或者方法，来覆盖内部类型的，这种情况方法比较多，我们以方法为例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	ad:=admin&#123;user&#123;<span class="string">"张三"</span>,<span class="string">"zhangsan@flysnow.org"</span>&#125;,<span class="string">"管理员"</span>&#125;</div><div class="line">	ad.user.sayHello()</div><div class="line">	ad.sayHello()</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</div><div class="line">	name <span class="keyword">string</span></div><div class="line">	email <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> admin <span class="keyword">struct</span> &#123;</div><div class="line">	user</div><div class="line">	level <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</div><div class="line">	fmt.Println(<span class="string">"Hello，i am a user"</span>)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a admin)</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</div><div class="line">	fmt.Println(<span class="string">"Hello，i am a admin"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内部类型user有一个sayHello方法，外部类型对其进行了覆盖，同名重写sayHello，然后我们在main方法里分别访问这两个类型的方法，打印输出:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello，i am a user</div><div class="line">Hello，i am a admin</div></pre></td></tr></table></figure>
<p>嵌入类型的强大，还体现在：<strong>如果内部类型实现了某个接口，那么外部类型也被认为实现了这个接口</strong>。我们稍微改造下例子看下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	ad:=admin&#123;user&#123;<span class="string">"张三"</span>,<span class="string">"zhangsan@flysnow.org"</span>&#125;,<span class="string">"管理员"</span>&#125;</div><div class="line">	sayHello(ad.user)<span class="comment">//使用user作为参数</span></div><div class="line">	sayHello(ad)<span class="comment">//使用admin作为参数</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> Hello <span class="keyword">interface</span> &#123;</div><div class="line">	hello()</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</div><div class="line">	fmt.Println(<span class="string">"Hello，i am a user"</span>)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(h Hello)</span></span>&#123;</div><div class="line">	h.hello()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现这个接口，最后我们定义了一个sayHello方法，它接受一个Hello接口类型的参数，最终我们在main函数演示的时候，发现不管是user类型，还是admin类型作为参数传递给sayHello方法的时候，都可以正常调用。</p>
<p>这里就可以说明admin实现了接口Hello,但是我们又没有显示的声明类型admin实现，所以这个实现是通过内部类型user实现的，因为admin包含了user所有的方法函数，所以也就实现了接口Hello。</p>
<p>当然外部类型也可以重新实现，只需要像上面例子一样覆盖同名的方法即可。这里要说明的是，不管我们如何同名覆盖，都不会影响内部类型，我们还可以通过访问内部类型来访问它的方法、属性字段等。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2017/05/11/Go语言基础⑨Go接口和嵌入类型/" data-id="cj6er1fvt004k6y19qfzzzyqi" class="article-share-link">Share</a>
      
        <a href="http://liuguoquan727.github.io/2017/05/11/Go语言基础⑨Go接口和嵌入类型/#ds-thread" class="article-comment-link">Kommentarer</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go基础/">Go基础</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Go语言基础⑧Go Map" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/10/Go语言基础⑧Go Map/" class="article-date">
  <time datetime="2017-05-10T13:50:53.000Z" itemprop="datePublished">2017-05-10 21:50:53</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/10/Go语言基础⑧Go Map/">Go语言基础⑧Go Map</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>Map是基于散列表来实现，就是我们常说的Hash表，所以我们每次迭代Map的时候，打印的Key和Value是无序的，<strong>Map存储的是无序的键值对集合。</strong></p>
<h1 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h1><ul>
<li><strong>make方式</strong></li>
</ul>
<p>示例中创建了一个键类型为string的，值类型为int的map，并存储一个键值对</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dict:=<span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</div><div class="line">dict[<span class="string">"张三"</span>] = <span class="number">43</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>使用map字面量的方式创建和初始化map</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"张三"</span>:<span class="number">43</span>&#125;</div><div class="line">dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"张三"</span>:<span class="number">43</span>,<span class="string">"李四"</span>:<span class="number">50</span>&#125;</div><div class="line">dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125; <span class="comment">//空Map</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>创建nil的Map</strong></li>
</ul>
<p>nil的Map是未初始化的，所以我们可以只声明一个变量，既不能使用map字面量，也不能使用make函数分配内存。<br>我们是不能对nil的Map操作存储键值对的，必须要初始化后才可以，比如使用make函数,为其开启一块可以存储数据的内存，也就是初始化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dict <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></div><div class="line">dict = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">//开辟内存</span></div><div class="line">dict[<span class="string">"张三"</span>] = <span class="number">43</span></div><div class="line">fmt.Println(dict)</div></pre></td></tr></table></figure>
<blockquote>
<p>Map的键可以是任何值，键的类型可以是内置的类型，也可以是结构类型，但是不管怎么样，这个键可以使用<code>==</code>运算符进行比较，所以像切片、函数以及含有切片的结构类型就不能用于Map的键了，因为他们具有引用的语义，不可比较。对于Map的值来说，就没有什么限制了，切片这种在键里不能用的，完全可以用在值里。</p>
</blockquote>
<h1 id="使用Map"><a href="#使用Map" class="headerlink" title="使用Map"></a>使用Map</h1><h2 id="访问Map"><a href="#访问Map" class="headerlink" title="访问Map"></a>访问Map</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</div><div class="line">dict[<span class="string">"张三"</span>] = <span class="number">43</span></div><div class="line">age := dict[<span class="string">"张三"</span>]</div><div class="line">age,exists := dict[<span class="string">"李四"</span>]</div><div class="line"><span class="built_in">delete</span>(dict,<span class="string">"张三"</span>) <span class="comment">//删除</span></div></pre></td></tr></table></figure>
<ul>
<li><p><code>age,exists := dict[&quot;李四&quot;]</code>第一个返回值是键的值；第二个返回值标记这个键是否存在，这是一个boolean类型的变量，我们判断它就知道该键是否存在了。</p>
</li>
<li><p>delete函数删除不存在的键也是可以的，只是没有任何作用。</p>
</li>
</ul>
<h2 id="遍历Map"><a href="#遍历Map" class="headerlink" title="遍历Map"></a>遍历Map</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"张三"</span>: <span class="number">43</span>&#125;</div><div class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> dict &#123;</div><div class="line">	fmt.Println(key, value)</div><div class="line">&#125;</div><div class="line"></div><div class="line">dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"王五"</span>: <span class="number">60</span>, <span class="string">"张三"</span>: <span class="number">43</span>&#125;</div><div class="line"><span class="keyword">var</span> names []<span class="keyword">string</span></div><div class="line"><span class="keyword">for</span> name := <span class="keyword">range</span> dict &#123;</div><div class="line">	names = <span class="built_in">append</span>(names, name)</div><div class="line">&#125;</div><div class="line">sort.Strings(names) <span class="comment">//排序</span></div><div class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> names &#123; <span class="comment">//range 一个Map的时候，也可以使用一个返回值，这个默认的返回值就是Map的键。</span></div><div class="line">	fmt.Println(key, dict[key])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>range 一个Map的时候，也可以使用一个返回值，这个默认的返回值就是Map的键。</p>
</blockquote>
<h1 id="函数间传递Map"><a href="#函数间传递Map" class="headerlink" title="函数间传递Map"></a>函数间传递Map</h1><p>函数间传递Map是不会拷贝一个该Map的副本的，也就是说如果一个Map传递给一个函数，该函数对这个Map做了修改，那么这个Map的所有引用，都会同步这个修改。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"王五"</span>: <span class="number">60</span>, <span class="string">"张三"</span>: <span class="number">43</span>&#125;</div><div class="line">	modify(dict)</div><div class="line">	fmt.Println(dict[<span class="string">"张三"</span>])</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(dict <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	dict[<span class="string">"张三"</span>] = <span class="number">10</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.flysnow.org/2017/03/23/go-in-action-go-map.html" target="_blank" rel="external">Go Map</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2017/05/10/Go语言基础⑧Go Map/" data-id="cj6er1fvr004h6y19ewc19xvt" class="article-share-link">Share</a>
      
        <a href="http://liuguoquan727.github.io/2017/05/10/Go语言基础⑧Go Map/#ds-thread" class="article-comment-link">Kommentarer</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go基础/">Go基础</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Go语言基础⑦Go Slice" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/10/Go语言基础⑦Go Slice/" class="article-date">
  <time datetime="2017-05-10T13:40:53.000Z" itemprop="datePublished">2017-05-10 21:40:53</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/10/Go语言基础⑦Go Slice/">Go语言基础⑦Go Slice</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>切片是基于数组实现的，它的底层是数组，它自己本身非常小，可以理解为对底层数组的抽象。因为基于数组实现，所以它的底层的内存是连续分配的，效率非常高，还可以通过索引或迭代获得数据。</p>
<p>切片对象非常小，是因为它是只有3个字段的数据结构：一个是指向底层数组的指针，一个是切片的长度，一个是切片的容量。这3个字段，就是Go语言操作底层数组的元数据，有了它们，我们就可以任意的操作切片了。</p>
<h1 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h1><ul>
<li><strong>make方式</strong></li>
</ul>
<p>使用内置的make函数时，需要传入一个参数，指定切片的长度，例子中我们使用的时5，这时候切片的容量也是5。当然我们也可以单独指定切片的容量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">slice:=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>) <span class="comment">//5是长度</span></div><div class="line">slice:=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">5</span>,<span class="number">10</span>) <span class="comment">//10是容量</span></div></pre></td></tr></table></figure>
<p>因为切片的底层是数组，所以创建切片时，如果不指定字面值的话，默认值就是数组的元素的零值。这里我们所以指定了容量是10，但是我们只能访问5个元素，因为切片的长度是5，剩下的5个元素，需要切片扩充后才可以访问。</p>
<blockquote>
<p>容量必须&gt;=长度，我们是不能创建长度大于容量的切片的。</p>
</blockquote>
<ul>
<li><strong>使用字面量，就是指定初始化的值</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">slice:=[]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; <span class="comment">//不用指定[]的值</span></div><div class="line">slice:=[]<span class="keyword">int</span>&#123;<span class="number">4</span>:<span class="number">1</span>&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>基于现有的数组或者切片创建</strong></li>
</ul>
<p>基于现有的切片或者数组创建，使用[i:j]这样的操作符即可，她表示以i索引开始，到j索引结束,截取原数组或者切片，创建而成的新切片，新切片的值包含原切片的i索引，但是不包含j索引。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</div><div class="line">slice1 := slice[:]</div><div class="line">slice2 := slice[<span class="number">0</span>:]</div><div class="line">slice3 := slice[:<span class="number">5</span>]</div><div class="line"></div><div class="line">fmt.Println(slice1)</div><div class="line">fmt.Println(slice2)</div><div class="line">fmt.Println(slice3)</div></pre></td></tr></table></figure>
<p>i如果省略，默认是0；j如果省略默认是原数组或者切片的长度,所以例子中的三个新切片的值是一样的。这里注意的是i和j都不能超过原切片或者数组的索引。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</div><div class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</div><div class="line">newSlice[<span class="number">0</span>] = <span class="number">10</span></div><div class="line">	</div><div class="line">fmt.Println(slice)</div><div class="line">fmt.Println(newSlice)</div></pre></td></tr></table></figure>
<p>新的切片和原切片共用的是一个底层数组，所以当修改的时候，底层数组的值就会被改变，所以原切片的值也改变了。当然对于基于数组的切片也一样的。</p>
<h1 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h1><p>切片算是一个动态数组，所以它可以按需增长，我们使用内置append函数即可。append函数可以为一个切片追加一个元素，至于如何增加、返回的是原切片还是一个新切片、长度和容量如何改变这些细节，append函数都会帮我们自动处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</div><div class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</div><div class="line">	</div><div class="line">newSlice=<span class="built_in">append</span>(newSlice,<span class="number">10</span>)</div><div class="line">fmt.Println(newSlice)</div><div class="line">fmt.Println(slice)</div><div class="line"><span class="comment">//Output</span></div><div class="line">[<span class="number">2</span> <span class="number">3</span> <span class="number">10</span>]</div><div class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">10</span> <span class="number">5</span>]</div></pre></td></tr></table></figure>
<p>append函数会智能的增长底层数组的容量，目前的算法是：容量小于1000个时，总是成倍的增长，一旦容量超过1000个，增长因子设为1.25，也就是说每次会增加25%的容量。</p>
<h1 id="使用切片"><a href="#使用切片" class="headerlink" title="使用切片"></a>使用切片</h1><h2 id="访问切片"><a href="#访问切片" class="headerlink" title="访问切片"></a>访问切片</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</div><div class="line">fmt.Println(slice[<span class="number">2</span>]) <span class="comment">//获取值</span></div><div class="line">slice[<span class="number">2</span>] = <span class="number">10</span> <span class="comment">//修改值</span></div><div class="line">fmt.Println(slice[<span class="number">2</span>]) <span class="comment">//输出10</span></div></pre></td></tr></table></figure>
<h2 id="迭代切片"><a href="#迭代切片" class="headerlink" title="迭代切片"></a>迭代切片</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//for range</span></div><div class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</div><div class="line"><span class="keyword">for</span> i,v:=<span class="keyword">range</span> slice&#123;</div><div class="line">	fmt.Printf(<span class="string">"索引:%d,值:%d\n"</span>,i,v)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//for range</span></div><div class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</div><div class="line"><span class="keyword">for</span> _,v:=<span class="keyword">range</span> slice&#123; <span class="comment">// _ 忽略索引</span></div><div class="line">	fmt.Printf(<span class="string">"值:%d\n"</span>,v)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//len</span></div><div class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</div><div class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(slice); i++ &#123;</div><div class="line">	fmt.Printf(<span class="string">"值:%d\n"</span>, slice[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="在函数间传递切片"><a href="#在函数间传递切片" class="headerlink" title="在函数间传递切片"></a>在函数间传递切片</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	slice := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</div><div class="line">	fmt.Printf(<span class="string">"%p\n"</span>, &amp;slice)</div><div class="line">	modify(slice)</div><div class="line">	fmt.Println(slice)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(slice []<span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	fmt.Printf(<span class="string">"%p\n"</span>, &amp;slice)</div><div class="line">	slice[<span class="number">1</span>] = <span class="number">10</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="number">0xc420082060</span></div><div class="line"><span class="number">0xc420082080</span></div><div class="line">[<span class="number">1</span> <span class="number">10</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</div></pre></td></tr></table></figure>
<p>这两个切片的地址不一样，所以可以确认切片在函数间传递是复制的。而我们修改一个索引的值后，发现原切片的值也被修改了，说明它们共用一个底层数组。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.flysnow.org/2017/03/14/go-in-action-go-slice.html" target="_blank" rel="external">Go 切片</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2017/05/10/Go语言基础⑦Go Slice/" data-id="cj6er1fvq004e6y199zfnxuj9" class="article-share-link">Share</a>
      
        <a href="http://liuguoquan727.github.io/2017/05/10/Go语言基础⑦Go Slice/#ds-thread" class="article-comment-link">Kommentarer</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go基础/">Go基础</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Go语言基础⑥Go数组" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/10/Go语言基础⑥Go数组/" class="article-date">
  <time datetime="2017-05-10T13:30:53.000Z" itemprop="datePublished">2017-05-10 21:30:53</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/10/Go语言基础⑥Go数组/">Go语言基础⑥数组</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>[TOC]</p>
<p>数组是长度固定的数据类型，必须存储一段相同类型的元素，而且这些元素是连续的。数组存储的类型可以是内置类型，比如整型或者字符串，也可以是自定义的数据结构。因为是连续的，所以索引比较好计算，所以我们可以很快的索引数组中的任何数据。</p>
<h1 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h1><p>数组的声明和初始化，和其他类型差不多。声明的原则是：</p>
<ol>
<li>指明存储数据的类型。</li>
<li>存储元素的数量，也就是数组长度。</li>
</ol>
<p>数组一旦声明后，其元素类型和大小都不能变了，如果还需要存储更多的元素怎么办？那么只能通过创建一个新的数组，然后把原来数组的数据复制过去。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> array [<span class="number">5</span>]<span class="keyword">int</span> <span class="comment">//初始值为0</span></div><div class="line">array = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; <span class="comment">//初始化</span></div></pre></td></tr></table></figure>
<p>Go为我们提供了:=操作符，可以让我们在创建数组的时候直接初始化。这种简短变量声明的方式不仅适用于数组，还适用于任何数据类型，这也是Go语言中常用的方式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array:=[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</div></pre></td></tr></table></figure>
<p>有时候我们更懒，连数组的长度都不想指定，不过没有关系，使用…代替就好了，Go会自动推导出数组的长度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array:=[...]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</div></pre></td></tr></table></figure>
<p>假如我们只想给索引为1和3的数组初始化相应的值，其他都为0怎么做呢，直接的办法有：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array:=[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>&#125;</div></pre></td></tr></table></figure>
<p>还有一种更好的办法，上面讲默认初始化为零值，那么我们就可以利用这个特性，只初始化索引1和3的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array:=[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">1</span>,<span class="number">3</span>:<span class="number">4</span>&#125; <span class="comment">//只初始化索引1和3的值</span></div></pre></td></tr></table></figure>
<h1 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h1><h2 id="索引访问"><a href="#索引访问" class="headerlink" title="索引访问"></a>索引访问</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">array:=[<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">1</span>,<span class="number">3</span>:<span class="number">4</span>&#125;</div><div class="line">fmt.Printf(<span class="string">"%d\n"</span>,array[<span class="number">1</span>])</div><div class="line">array[<span class="number">1</span>] = <span class="number">3</span></div><div class="line">fmt.Printf(<span class="string">"%d\n"</span>,array[<span class="number">1</span>])</div></pre></td></tr></table></figure>
<h2 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//for</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">4</span>&#125;</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</div><div class="line">		fmt.Printf(<span class="string">"索引:%d,值:%d\n"</span>, i, array[i])</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//for range</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">4</span>&#125;</div><div class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> array &#123;</div><div class="line">		fmt.Printf(<span class="string">"索引:%d,值:%d\n"</span>, i, v)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h2><p>同样类型的数组是可以相互赋值的，不同类型的不行，会编译错误。那么什么是同样类型的数组呢？Go语言规定，必须是长度一样，并且每个元素的类型也一样的数组，才是同样类型的数组。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">4</span>&#125;</div><div class="line"><span class="keyword">var</span> array1 [<span class="number">5</span>]<span class="keyword">int</span> = array <span class="comment">//success</span></div><div class="line"><span class="keyword">var</span> array2 [<span class="number">4</span>]<span class="keyword">int</span> = array1 <span class="comment">//error</span></div></pre></td></tr></table></figure>
<h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><p>下面创建了一个指针数组，它的元素类型是指针，并且为索引1和3都创建了内存空间，其他索引是指针的零值nil。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">array := [<span class="number">5</span>]*<span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="built_in">new</span>(<span class="keyword">int</span>), <span class="number">3</span>:<span class="built_in">new</span>(<span class="keyword">int</span>)&#125;</div><div class="line">*array[<span class="number">1</span>] = <span class="number">1</span> <span class="comment">//修改指针元素的值</span></div><div class="line"></div><div class="line"><span class="comment">//给未初始化的元素赋值</span></div><div class="line">array[<span class="number">0</span>] =<span class="built_in">new</span>(<span class="keyword">int</span>) <span class="comment">//分配内存</span></div><div class="line">*array[<span class="number">0</span>] = <span class="number">2</span> <span class="comment">//赋值</span></div><div class="line">fmt.Println(*array[<span class="number">0</span>]) <span class="comment">//取值</span></div></pre></td></tr></table></figure>
<h1 id="函数间传递数组"><a href="#函数间传递数组" class="headerlink" title="函数间传递数组"></a>函数间传递数组</h1><h2 id="数组传递"><a href="#数组传递" class="headerlink" title="数组传递"></a>数组传递</h2><blockquote>
<p>不改变原数组的值</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="number">2</span>, <span class="number">3</span>:<span class="number">4</span>&#125;</div><div class="line">	modify(array)</div><div class="line">	fmt.Println(array)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(a [5]<span class="keyword">int</span>)</span></span>&#123;</div><div class="line">	a[<span class="number">1</span>] =<span class="number">3</span></div><div class="line">	fmt.Println(a)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数组指针传递"><a href="#数组指针传递" class="headerlink" title="数组指针传递"></a>数组指针传递</h2><blockquote>
<p>数组与原数组会同时改变</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="number">2</span>, <span class="number">3</span>:<span class="number">4</span>&#125;</div><div class="line">	modify(&amp;array)</div><div class="line">	fmt.Println(array)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(a *[5]<span class="keyword">int</span>)</span></span>&#123;</div><div class="line">	a[<span class="number">1</span>] =<span class="number">3</span></div><div class="line">	fmt.Println(*a)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.flysnow.org/2017/03/13/go-in-action-go-array.html" target="_blank" rel="external">Go 数组</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2017/05/10/Go语言基础⑥Go数组/" data-id="cj6er1fvp004b6y19wwfhc12q" class="article-share-link">Share</a>
      
        <a href="http://liuguoquan727.github.io/2017/05/10/Go语言基础⑥Go数组/#ds-thread" class="article-comment-link">Kommentarer</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go基础/">Go基础</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Go语言基础⑤流程控制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/09/Go语言基础⑤流程控制/" class="article-date">
  <time datetime="2017-05-09T13:30:53.000Z" itemprop="datePublished">2017-05-09 21:30:53</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/09/Go语言基础⑤流程控制/">Go语言基础⑤流程控制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="for"><a href="#for" class="headerlink" title="for"></a>for</h1><p>Go 只有一种循环结构：for 循环。基本的 for 循环由三部分组成，用分号隔开：</p>
<ul>
<li>初始化语句：在第一次迭代前执行</li>
<li>条件表达式：在每次迭代前求值</li>
<li>后置语句：在每次迭代的结尾执行</li>
</ul>
<p>初始化语句通常为一句短变量声明，该变量声明仅在 for 语句的作用域中可见。Go 的 for 语句后面没有小括号，大括号 { } 则是必须的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line"></div><div class="line">	sum := <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ &#123;</div><div class="line">		sum += i</div><div class="line">	&#125;</div><div class="line">	fmt.Println(<span class="string">"sum:"</span>, sum) <span class="comment">// sum: 45</span></div><div class="line"></div><div class="line">	<span class="comment">// 初始化语句和后置语句是可选的</span></div><div class="line">	sum = <span class="number">1</span></div><div class="line">	<span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123;</div><div class="line">		sum += sum</div><div class="line">	&#125;</div><div class="line">	fmt.Println(<span class="string">"sum:"</span>, sum) <span class="comment">// sum: 1024</span></div><div class="line"></div><div class="line">	<span class="comment">// 去掉分号 `;`, `for` 是 Go 中的 `while`</span></div><div class="line">	sum = <span class="number">1</span></div><div class="line">	<span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</div><div class="line">		sum += sum</div><div class="line">	&#125;</div><div class="line">	fmt.Println(<span class="string">"sum:"</span>, sum) <span class="comment">// sum: 1024</span></div><div class="line">	</div><div class="line">	<span class="comment">//无限循环</span></div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">	</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * go if 控制语句</div><div class="line"> */</div><div class="line"> </div><div class="line"><span class="keyword">package</span> main</div><div class="line"> </div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"math"</span></div><div class="line">)</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">string</span></span> &#123;</div><div class="line">    <span class="comment">// 表达式外无需小括号</span></div><div class="line">    <span class="keyword">if</span> x &lt;= <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">return</span> sqrt(-x) + <span class="string">"i"</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> fmt.Sprint(math.Sqrt(x))</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</div><div class="line">    <span class="comment">// 条件表达式前可以执行一个简单的语句</span></div><div class="line">    <span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</div><div class="line">        <span class="keyword">return</span> v</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 表达式前执行简单的语句，语句声明的变量作用域仅在 if 和对应的 else 块中使用</span></div><div class="line">        fmt.Printf(<span class="string">"%g &amp;gt;= %g\n"</span>, v, lim)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> lim</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Println(sqrt(<span class="number">2</span>), sqrt(<span class="number">-4</span>))</div><div class="line"> </div><div class="line">    fmt.Println(</div><div class="line">        pow(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>),</div><div class="line">        pow(<span class="number">3</span>, <span class="number">3</span>, <span class="number">20</span>),</div><div class="line">    )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Go 的 if 语句与 for 循环类似，表达式外无需小括号 ( ) ，而大括号 { } 则是必须的。</p>
<h1 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * go switch 控制语句</div><div class="line"> */</div><div class="line"> </div><div class="line"><span class="keyword">package</span> main</div><div class="line"> </div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">switch</span> i := <span class="number">1</span>; i &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">        fmt.Println(<span class="number">0</span>)</div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">        fmt.Println(<span class="number">1</span>)</div><div class="line">        <span class="keyword">fallthrough</span> <span class="comment">// 继续运行下面的代码，否则终止</span></div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        fmt.Println(<span class="number">2</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 以上代码段输出</span></div><div class="line">    <span class="comment">// 1</span></div><div class="line">    <span class="comment">// 2</span></div><div class="line"> </div><div class="line">    <span class="comment">// 没有条件的 switch</span></div><div class="line">    t := time.Now()</div><div class="line">    <span class="keyword">switch</span> &#123;</div><div class="line">    <span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</div><div class="line">        fmt.Println(<span class="string">"早上好!"</span>)</div><div class="line">    <span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</div><div class="line">        fmt.Println(<span class="string">"下午好!"</span>)</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        fmt.Println(<span class="string">"晚上好!"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果在执行完每个分支的代码后，还希望继续执行后续分支的代码，可以使用 fallthrough 关键字来达到目的。。switch 的 case 语句从上到下顺次执行，直到匹配成功时停止。</p>
<p>没有条件的 switch 同 switch true 一样，这种形式能将一长串 if-then-else 写得更加清晰</p>
<h1 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h1><p>defer 语句会将函数推迟到外层函数返回之后执行，通常用于释放资源或错误处理。推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。推迟的函数调用会被压入一个栈中。 当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">"world"</span>)</div><div class="line">	fmt.Println(<span class="string">"hello"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="built_in">print</span>()</div><div class="line"></div><div class="line">	fmt.Println(<span class="string">"counting"</span>)</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line">		<span class="keyword">defer</span> fmt.Println(i)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(<span class="string">"done"</span>)</div><div class="line">	<span class="comment">//hello </span></div><div class="line">	<span class="comment">// world</span></div><div class="line">	<span class="comment">// counting</span></div><div class="line">	<span class="comment">// done</span></div><div class="line">	<span class="comment">// 9</span></div><div class="line">	<span class="comment">// 8</span></div><div class="line">	<span class="comment">// 7</span></div><div class="line">	<span class="comment">// 6</span></div><div class="line">	<span class="comment">// 5</span></div><div class="line">	<span class="comment">// 4</span></div><div class="line">	<span class="comment">// 3</span></div><div class="line">	<span class="comment">// 2</span></div><div class="line">	<span class="comment">// 1</span></div><div class="line">	<span class="comment">// 0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Break-与-continue"><a href="#Break-与-continue" class="headerlink" title="Break 与 continue"></a>Break 与 continue</h1><ul>
<li>break 语句的作用结果是跳过整个代码块，执行后续的代码。</li>
<li>continue 跳过本次循环的语句而直接进入下一次循环的过程。</li>
<li>关键字 break 可用于 for、switch、select 语句中，关键字 continue 仅能用于 for 循环中。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2017/05/09/Go语言基础⑤流程控制/" data-id="cj6er1fvo00486y194thxx6ds" class="article-share-link">Share</a>
      
        <a href="http://liuguoquan727.github.io/2017/05/09/Go语言基础⑤流程控制/#ds-thread" class="article-comment-link">Kommentarer</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go基础/">Go基础</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Go语言基础④函数方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/09/Go语言基础④函数方法/" class="article-date">
  <time datetime="2017-05-09T12:52:53.000Z" itemprop="datePublished">2017-05-09 20:52:53</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/09/Go语言基础④函数方法/">Go语言基础④函数方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数和方法，虽然概念不同，但是定义非常相似。函数的定义声明没有接收者，所以我们直接在go文件里，go包之下定义声明即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">**</div><div class="line"> * function 函数相关概念</div><div class="line"> */</div><div class="line"> </div><div class="line"><span class="keyword">package</span> main</div><div class="line"> </div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"> </div><div class="line"><span class="comment">// 数字相加</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> x + y</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">substract</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> x - y</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 字符交换位置  多值返回</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</div><div class="line">    <span class="keyword">return</span> y, x</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 命名返回值</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</div><div class="line">    x = sum * <span class="number">4</span> / <span class="number">9</span></div><div class="line">    y = sum - x</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><ul>
<li>函数可以没有参数或接受多个参数。add 函数接受两个 int 类型的参数。需要注意类型在变量名后面。</li>
<li>当两个或多个连续的函数命名参数是同一类型，则除了最后一个类型之外，其他都可以省略。</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x <span class="built_in">string</span>, y <span class="built_in">string</span></div><div class="line">x, y <span class="built_in">string</span></div></pre></td></tr></table></figure>
<h2 id="多值返回"><a href="#多值返回" class="headerlink" title="多值返回"></a>多值返回</h2><p>函数可以返回任意数量的返回值。swap 函数返回了两个字符串。</p>
<ul>
<li>不能用容器对象接收多返回值。</li>
<li>多返回值可直接作为其他函数调用的实参。</li>
</ul>
<h2 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a>命名返回值</h2><p>Go 的返回值可以被命名，并且就像在函数体开头声明的变量那样使用。返回值的名称应当具有一定的意义，可以作为文档使用。没有参数的 return 语句返回各个返回变量的当前值。</p>
<h2 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h2><p>参数列表本质上就是 slice ，只能有一个，且必须是最后一个。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(s <span class="keyword">string</span>, n ...<span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;    <span class="keyword">var</span> x <span class="keyword">int</span>    <span class="keyword">for</span> _, i := <span class="keyword">range</span> n &#123;        x += i&#125;    <span class="keyword">return</span> fmt.Sprintf(s, x)&#125;<span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;    <span class="built_in">println</span>(test(<span class="string">"sum: %d"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))&#125;</div></pre></td></tr></table></figure>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>例子中的函数名称是小写开头的，它的作用域只属于所声明的包内使用，不能被其他包使用，如果我们把函数名以大写字母开头，该函数的作用域就大了，可以被其他包调用。这也是Go语言中大小写的用处。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>方法的声明和函数类似，他们的区别是：方法在定义的时候，会在func和方法名之间增加一个参数，这个参数就是接收者，这样我们定义的这个方法就和接收者绑定在了一起，称之为这个接收者的方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</div><div class="line">	name <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="string">"the person name is "</span>+p.name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	p:=person&#123;name:<span class="string">"张三"</span>&#125;</div><div class="line">	fmt.Println(p.String())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>func和方法名之间增加的参数<code>(p person)</code>,这个就是接收者。</p>
<h2 id="值接收者"><a href="#值接收者" class="headerlink" title="值接收者"></a>值接收者</h2><p>使用值类型接收者定义的方法，在调用的时候，使用的其实是值接收者的一个副本，所以对该值的任何操作，不会影响原来的类型变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	p:=person&#123;name:<span class="string">"张三"</span>&#125;</div><div class="line">	p.modify() <span class="comment">//值接收者，修改无效</span></div><div class="line">	fmt.Println(p.String())</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</div><div class="line">	name <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="string">"the person name is "</span>+p.name</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span> <span class="title">modify</span><span class="params">()</span></span>&#123;</div><div class="line">	p.name = <span class="string">"李四"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h2><p>如果我们使用一个指针作为接收者，那么就会其作用了，因为指针接收者传递的是一个指向原值指针的副本，指针的副本，指向的还是原来类型的值，所以修改时，同时也会影响原来类型变量的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	p:=person&#123;name:<span class="string">"张三"</span>&#125;</div><div class="line">	p.modify() <span class="comment">//指针接收者，修改有效 == (&amp;p).modify() </span></div><div class="line">	fmt.Println(p.String())</div><div class="line">&#125;</div><div class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</div><div class="line">	name <span class="keyword">string</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="string">"the person name is "</span>+p.name</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">modify</span><span class="params">()</span></span>&#123;</div><div class="line">	p.name = <span class="string">"李四"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在调用方法的时候，传递的接收者本质上都是副本，只不过一个是这个值副本，一是指向这个值指针的副本。指针具有指向原有值的特性，所以修改了指针指向的值，也就修改了原有的值。我们可以简单的理解为值接收者使用的是值的副本来调用方法，而指针接收者使用实际的值来调用方法。</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.flysnow.org/2017/03/31/go-in-action-go-method.html" target="_blank" rel="external">Go 函数方法</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2017/05/09/Go语言基础④函数方法/" data-id="cj6er1fvm00456y19ljs2t61b" class="article-share-link">Share</a>
      
        <a href="http://liuguoquan727.github.io/2017/05/09/Go语言基础④函数方法/#ds-thread" class="article-comment-link">Kommentarer</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go基础/">Go基础</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Go语言基础③类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/08/Go语言基础③类型/" class="article-date">
  <time datetime="2017-05-08T13:30:53.000Z" itemprop="datePublished">2017-05-08 21:30:53</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/08/Go语言基础③类型/">Go语言基础③类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>常量的定义与变量类似，使用 const 关键字修饰，用于存储不会改变的数据。常量只可以是字符、字符串、布尔或数字类型（整数型、浮点型和复数）的值。常量不能使用 := 语法定义。一个未指定类型的常量由上下文来决定其类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"> </div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"> </div><div class="line"><span class="comment">// 隐式类型数值常量</span></div><div class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></div><div class="line"></div><div class="line"><span class="comment">//显示类型</span></div><div class="line"><span class="keyword">const</span> b <span class="keyword">string</span> = <span class="string">"abc"</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 字符常量</span></div><div class="line">    <span class="keyword">const</span> World = <span class="string">"world"</span></div><div class="line"> </div><div class="line">    fmt.Println(<span class="string">"Hello "</span>, World)</div><div class="line">    fmt.Println(<span class="string">"the value of Pi is "</span>, Pi)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p><code>var</code> 语句定义了一个变量的列表。跟函数的参数列表一样，类型在后面，<code>var</code> 语句可以定义在包或函数级别。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * variable 变量相关概念</div><div class="line"> */</div><div class="line"> </div><div class="line"><span class="keyword">package</span> main</div><div class="line"> </div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"> </div><div class="line"><span class="keyword">var</span> a, b *<span class="keyword">int</span> <span class="comment">//声明指针类型</span></div><div class="line"><span class="keyword">var</span> c, python, java <span class="keyword">bool</span> <span class="comment">// 定义变量，类型在后面</span></div><div class="line"><span class="keyword">var</span> x, y, s = <span class="number">1</span>, <span class="number">2</span>, <span class="string">"hello"</span> <span class="comment">// 初始化是使用表达式，则可以省略类型，变量从初始值中获得类型</span></div><div class="line"></div><div class="line"><span class="comment">//一般用于声明全局变量</span></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    d <span class="keyword">int</span></div><div class="line">    f <span class="keyword">bool</span></div><div class="line">    str <span class="keyword">string</span></div><div class="line">)</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></div><div class="line">    fmt.Println(i, c, python, java)</div><div class="line"> </div><div class="line">    a, b := <span class="number">1</span>, <span class="string">"hello"</span> <span class="comment">// `:=` 简洁赋值语句用在明确类型的地方，用于替代 `var` 定义</span></div><div class="line">    fmt.Println(x, y, s, a, b)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="初始化变量"><a href="#初始化变量" class="headerlink" title="初始化变量"></a>初始化变量</h2><p>变量定义可以包含初始值，每个变量对应一个。如果初始化是使用表达式，则可以省略类型，变量将从初始值中获得类型。</p>
<h2 id="短声明变量"><a href="#短声明变量" class="headerlink" title="短声明变量"></a>短声明变量</h2><p>在函数中， := 简洁赋值语句用在明确类型的地方，用于替代 var 定义。:= 结构不能使用在函数外，函数外的每个语句都必须以关键字开始（ var 、 func 、等等）。</p>
<h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> <span class="comment">//布尔类型</span></div><div class="line"><span class="keyword">string</span>  <span class="comment">//字符串</span></div><div class="line"><span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span>  <span class="comment">//整型</span></div><div class="line"><span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span> <span class="comment">//无符号整数</span></div><div class="line"><span class="keyword">byte</span> <span class="comment">// uint8 的别名</span></div><div class="line"><span class="keyword">rune</span> <span class="comment">// int32 的别名, 代表一个Unicode码</span></div><div class="line"><span class="keyword">float32</span> <span class="keyword">float64</span> <span class="comment">//浮点数</span></div><div class="line"><span class="keyword">complex64</span> (<span class="number">32</span> 位实数和虚数)</div><div class="line"><span class="keyword">complex128</span> (<span class="number">64</span> 位实数和虚数)</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * go 数据类型</div><div class="line"> */</div><div class="line"> </div><div class="line"><span class="keyword">package</span> main</div><div class="line"> </div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"math"</span></div><div class="line">    <span class="string">"math/cmplx"</span></div><div class="line">)</div><div class="line"> </div><div class="line"><span class="comment">// 同导入语句一样，变量的定义“打包”在一个语法块中。</span></div><div class="line"><span class="keyword">var</span> (</div><div class="line">    ToBe   <span class="keyword">bool</span>       = <span class="literal">false</span></div><div class="line">    MaxInt <span class="keyword">uint64</span>     = <span class="number">1</span>&amp;lt;&amp;lt;<span class="number">64</span> - <span class="number">1</span></div><div class="line">    z      <span class="keyword">complex128</span> = cmplx.Sqrt(<span class="number">-5</span> + <span class="number">12i</span>)</div><div class="line">)</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">const</span> f = <span class="string">"%T(%v)\n"</span></div><div class="line">    fmt.Printf(f, ToBe, ToBe)     <span class="comment">// bool(false)</span></div><div class="line">    fmt.Printf(f, MaxInt, MaxInt) <span class="comment">// uint64(18446744073709551615)</span></div><div class="line">    fmt.Printf(f, z, z)           <span class="comment">// complex128((2+3i))</span></div><div class="line"> </div><div class="line">    <span class="comment">// 变量在定义时没有明确的初始化时会赋值为零值</span></div><div class="line">    <span class="keyword">var</span> i <span class="keyword">int</span></div><div class="line">    <span class="keyword">var</span> fl <span class="keyword">float64</span></div><div class="line">    <span class="keyword">var</span> b <span class="keyword">bool</span></div><div class="line">    <span class="keyword">var</span> s <span class="keyword">string</span></div><div class="line">    fmt.Printf(<span class="string">"%v %v %v %q\n"</span>, i, fl, b, s) <span class="comment">// 0 0 false ""</span></div><div class="line"> </div><div class="line">    <span class="comment">// 类型推导: 在定义一个变量却并不显式指定其类型时， 变量的类型由（等号）右侧的值推导得出</span></div><div class="line">    <span class="keyword">var</span> m <span class="keyword">int</span></div><div class="line">    n := m</div><div class="line">    fmt.Printf(f, m, m) <span class="comment">// int(0)</span></div><div class="line">    fmt.Printf(f, n, n) <span class="comment">// int(0)</span></div><div class="line"> </div><div class="line">    <span class="comment">// 类型转换</span></div><div class="line">    x, y := <span class="number">3</span>, <span class="number">4</span></div><div class="line">    z := math.Sqrt(<span class="keyword">float64</span>(x*x + y*y))</div><div class="line">    u := <span class="keyword">uint</span>(z)</div><div class="line">    fmt.Printf(f, x, x) <span class="comment">// int(3)</span></div><div class="line">    fmt.Printf(f, y, y) <span class="comment">// int(4)</span></div><div class="line">    fmt.Printf(f, z, z) <span class="comment">// float64(5)</span></div><div class="line">    fmt.Printf(f, u, u) <span class="comment">// uint(5)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>int，uint 和 uintptr 类型在32位的系统上一般是32位，而在64位系统上是64位。当你需要使用一个整数类型时，你应该首选 int，仅当有特别的理由才使用定长整数类型或者无符号整数类型</li>
<li>尽可能地使用 float64，因为 math 包中所有有关数学运算的函数都会要求接收这个类型</li>
<li>你可以通过增加前缀 0 来表示 8 进制数（如：077），增加前缀 0x 来表示 16 进制数（如：0xFF），以及使用 e 来表示 10 的连乘（如： 1e3 = 1000，或者 6.022e23 = 6.022 x 1e23）。</li>
<li>Go 中不允许不同类型之间的混合使用，但是对于常量的类型限制非常少，因此允许常量之间的混合使用。</li>
</ul>
<h2 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h2><p>变量在定义时没有明确的初始化时会赋值为零值</p>
<ul>
<li>int 数值类型为 0</li>
<li>bool 布尔类型为 false</li>
<li>string 字符串为 “” （空字符串）</li>
</ul>
<h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><p>在定义一个变量却并不显式指定其类型时（使用 := 语法或者 var = 表达式语法‘）， 变量的类型由（等号）右侧的值推导得出。</p>
<p>当右值定义了类型时，新变量的类型与其相同：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i <span class="keyword">int</span></div><div class="line">j := i <span class="comment">// j 也是一个 int</span></div></pre></td></tr></table></figure>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>表达式 <code>T(v)</code> 将值 v 转换为类型 T。Go 不同类型之间的项目赋值时需要显式转换。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">42</span></div><div class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="keyword">float64</span>(i)</div><div class="line"><span class="keyword">var</span> u <span class="keyword">uint</span> = <span class="keyword">uint</span>(f)</div></pre></td></tr></table></figure>
<p>##格式化说明符</p>
<p>在格式化字符串里，%d 用于格式化整数（%x 和 %X 用于格式化 16 进制表示的数字），%g 用于格式化浮点型（%f 输出浮点数，%e 输出科学计数表示法），%0d 用于规定输出定长的整数，其中开头的数字 0 是必须的。</p>
<p>%n.mg 用于表示数字 n 并精确到小数点后 m 位，除了使用 g 之外，还可以使用 e 或者 f，例如：使用格式化字符串 %5.2e 来输出 3.4 的结果为 3.40e+00。</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h3><ul>
<li>按位与 &amp;</li>
<li>按位或 |</li>
<li>按位异或 ^</li>
<li>位清除 &amp;^：将指定位置上的值设置为 0。</li>
</ul>
<h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><ul>
<li>按位补足 ^</li>
<li>位左移 &lt;&lt;</li>
</ul>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">1 </span>&lt;&lt; <span class="number">10</span> // 等于 <span class="number">1</span> KB</div><div class="line"><span class="symbol">1 </span>&lt;&lt; <span class="number">20</span> // 等于 <span class="number">1</span> MB</div><div class="line"><span class="symbol">1 </span>&lt;&lt; <span class="number">30</span> // 等于 <span class="number">1</span> GB</div></pre></td></tr></table></figure>
<ul>
<li>位右移 &gt;&gt;</li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>Go 中拥有以下逻辑运算符：<code>==、!= 、&lt;、&lt;=、&gt;、&gt;=、&amp;&amp;、||、！</code>。</p>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>常见可用于整数和浮点数的二元运算符有<code>+、-、* 和 /</code>。</p>
<ul>
<li>/ 对于整数运算而言，结果依旧为整数，例如：<code>9 / 4 -&gt; 2</code></li>
<li>取余运算符只能作用于整数：<code>9 % 4 -&gt; 1</code></li>
</ul>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">    <span class="string">"math/rand"</span></div><div class="line">    <span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line">        a := rand.Int()</div><div class="line">        fmt.Printf(<span class="string">"%d / "</span>, a)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</div><div class="line">        r := rand.Intn(<span class="number">8</span>)</div><div class="line">        fmt.Printf(<span class="string">"%d / "</span>, r)</div><div class="line">    &#125;</div><div class="line">    fmt.Println()</div><div class="line">    timens := <span class="keyword">int64</span>(time.Now().Nanosecond())</div><div class="line">    rand.Seed(timens)</div><div class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</div><div class="line">        fmt.Printf(<span class="string">"%2.2f / "</span>, <span class="number">100</span>*rand.Float32())</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><p>引用类型和原始的基本类型恰恰相反，它的修改可以影响到任何引用到它的变量。在Go语言中，引用类型有slice、map、接口、函数类型以及channel。</p>
<p>引用类型之所以可以引用，是因为我们创建引用类型的变量，其实是一个标头值，标头值里包含一个指针，指向底层的数据结构，当我们在函数中传递引用类型时，其实传递的是这个标头值的副本，它所指向的底层结构并没有被复制传递，这也是引用类型传递高效的原因。</p>
<blockquote>
<p>本质上，我们可以理解函数的传递都是值传递，只不过引用类型传递的是一个指向底层数据的指针，所以我们在操作的时候，可以修改共享的底层数据的值，进而影响到所有引用到这个共享底层数据的变量。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	ages := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"张三"</span>: <span class="number">20</span>&#125;</div><div class="line">	fmt.Println(ages)</div><div class="line">	modify(ages)</div><div class="line">	fmt.Println(ages)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span></span> &#123;</div><div class="line">	m[<span class="string">"张三"</span>] = <span class="number">10</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h1><p>GO语言支持指针类型 <em>T，指针的指针 **T，以及包含包名前缀的 </em><package>.T。</package></p>
<ul>
<li>默认值 nil，没有 NULL 常量。</li>
<li>操作符 “&amp;” 取变量地址，”*” 透过指针访问 标对象。</li>
<li>不支持指针运算，不支持 “-&gt;” 运算符，直接用 “.” 访问 标成员。</li>
<li>&amp; 操作符会生成一个指向其操作数的指针</li>
<li><ul>
<li>操作符表示指针指向的底层值</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * go 语言指针</div><div class="line"> */</div><div class="line"> </div><div class="line"><span class="keyword">package</span> main</div><div class="line"> </div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    i, j := <span class="number">42</span>, <span class="number">36</span></div><div class="line"> </div><div class="line">    p := &amp;i <span class="comment">//&amp; 操作符会生成一个指向其操作数的指针。</span></div><div class="line">    fmt.Println(*p) <span class="comment">// 42 * 操作符表示指针指向的底层值。</span></div><div class="line">    *p = <span class="number">21</span></div><div class="line">    fmt.Println(i) <span class="comment">// 21</span></div><div class="line"> </div><div class="line">    p = &amp;j</div><div class="line">    *p = *p / <span class="number">4</span></div><div class="line">    fmt.Println(j) <span class="comment">// 9</span></div><div class="line">    mt.Println(p) <span class="comment">//打印指针地址</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>一个结构体（ struct ）就是一个字段的集合，结构体字段使用点号来访问。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"> </div><div class="line"><span class="keyword">import</span> (</div><div class="line">    <span class="string">"fmt"</span></div><div class="line">)</div><div class="line"> </div><div class="line"><span class="comment">//定义结构体</span></div><div class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</div><div class="line">    X <span class="keyword">int</span></div><div class="line">    Y <span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">var</span> (</div><div class="line">    p1  = Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">//初始化 x=1 y = 2</span></div><div class="line">    p2  = Point&#123;X: <span class="number">1</span>&#125; <span class="comment">//初始化 x=1 y = 0</span></div><div class="line">    p3  = Point&#123;&#125;</div><div class="line">    pt1 = &amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</div><div class="line">)</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    fmt.Println(Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</div><div class="line"> </div><div class="line">    p := Point&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</div><div class="line">    p.X = <span class="number">4</span> <span class="comment">// 结构体字段使用点号来访问</span></div><div class="line">    fmt.Println(p, p.Y)</div><div class="line"> </div><div class="line">    pt := &amp;p</div><div class="line">    pt.X = <span class="number">5</span> <span class="comment">// 使用隐式间接引用，直接写 `pt.X`</span></div><div class="line">    (*pt).Y = <span class="number">6</span> <span class="comment">// 通过 `(*pt).Y` 来访问其字段 `Y`</span></div><div class="line">    fmt.Println(p)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><p>结构体字段可以通过结构体指针来访问。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pt := &amp;p</div><div class="line">pt.X = <span class="number">5</span> <span class="comment">// 使用隐式间接引用，直接写 `pt.X`</span></div><div class="line">(*pt).Y = <span class="number">6</span> <span class="comment">// 通过 `(*pt).Y` 来访问其字段 `Y`</span></div></pre></td></tr></table></figure>
<h2 id="结构体语法"><a href="#结构体语法" class="headerlink" title="结构体语法"></a>结构体语法</h2><ul>
<li>结构体文法通过直接列出字段的值来新分配一个结构体。</li>
<li>使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。）</li>
<li>特殊的前缀 &amp; 返回一个指向结构体的指针。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> (</div><div class="line">    p1  = Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</div><div class="line">    p2  = Point&#123;X: <span class="number">1</span>&#125;</div><div class="line">    p3  = Point&#123;&#125;</div><div class="line">    pt1 = &amp;amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h1 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h1><p>Go语言支持我们自定义类型，比如刚刚上面的结构体类型，就是我们自定义的类型，这也是比较常用的自定义类型的方法。另外一个自定义类型的方法是基于一个已有的类型，就是基于一个现有的类型创造新的类型，这种也是使用<code>type</code>关键字。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Duration <span class="keyword">int64</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> i Duration = <span class="number">100</span></div><div class="line"><span class="keyword">var</span> j <span class="keyword">int64</span> = <span class="number">100</span></div></pre></td></tr></table></figure>
<p>但是本质上，他们并不是同一种类型，所以对于Go这种强类型语言，他们是不能相互赋值的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Duration <span class="keyword">int64</span></div><div class="line"><span class="keyword">var</span> dur Duration</div><div class="line">dur=<span class="keyword">int64</span>(<span class="number">100</span>) <span class="comment">//error</span></div><div class="line">fmt.Println(dur)</div></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.flysnow.org/2017/03/26/go-in-action-go-type.html" target="_blank" rel="external">Go 类型</a></p>
<p><a href="http://ironxu.com/709" target="_blank" rel="external">Go 之旅三: 复杂类型</a></p>
<p><a href=""></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2017/05/08/Go语言基础③类型/" data-id="cj6er1fvm00426y19pld3uxj7" class="article-share-link">Share</a>
      
        <a href="http://liuguoquan727.github.io/2017/05/08/Go语言基础③类型/#ds-thread" class="article-comment-link">Kommentarer</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go基础/">Go基础</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Go语言基础②Go开发工具" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/08/Go语言基础②Go开发工具/" class="article-date">
  <time datetime="2017-05-08T13:00:53.000Z" itemprop="datePublished">2017-05-08 21:00:53</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/08/Go语言基础②Go开发工具/">Go语言基础②Go开发工具</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>在Go语言中，我们很多操作都是通过go命令进行的，比如我们要执行go文件的编译，就需要使用go build命令，除了build命令之外，还有很多常用的命令，这一次我们就统一进行介绍，对常用命令有一个了解，这样我们就可以更容易的开发我们的Go程序了。</p>
<h1 id="go命令概览"><a href="#go命令概览" class="headerlink" title="go命令概览"></a>go命令概览</h1><p>打开 Mac 终端，运行 go 命令。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">➜  ~ <span class="keyword">go</span></div><div class="line">Go is a tool <span class="keyword">for</span> managing Go source code.</div><div class="line"></div><div class="line">Usage:</div><div class="line"></div><div class="line">	<span class="keyword">go</span> command [arguments]</div><div class="line"></div><div class="line">The commands are:</div><div class="line"></div><div class="line">	build       compile packages and dependencies</div><div class="line">	clean       remove object files</div><div class="line">	doc         show documentation <span class="keyword">for</span> <span class="keyword">package</span> or symbol</div><div class="line">	env         <span class="built_in">print</span> Go environment information</div><div class="line">	bug         start a bug report</div><div class="line">	fix         run <span class="keyword">go</span> tool fix on packages</div><div class="line">	fmt         run gofmt on <span class="keyword">package</span> sources</div><div class="line">	generate    generate Go files by processing source</div><div class="line">	get         download and install packages and dependencies</div><div class="line">	install     compile and install packages and dependencies</div><div class="line">	list        list packages</div><div class="line">	run         compile and run Go program</div><div class="line">	test        test packages</div><div class="line">	tool        run specified <span class="keyword">go</span> tool</div><div class="line">	version     <span class="built_in">print</span> Go version</div><div class="line">	vet         run <span class="keyword">go</span> tool vet on packages</div><div class="line"></div><div class="line">Use <span class="string">"go help [command]"</span> <span class="keyword">for</span> more information about a command.</div><div class="line"></div><div class="line">Additional help topics:</div><div class="line"></div><div class="line">	c           calling between Go and C</div><div class="line">	buildmode   description of build modes</div><div class="line">	filetype    file types</div><div class="line">	gopath      GOPATH environment variable</div><div class="line">	environment environment variables</div><div class="line">	importpath  <span class="keyword">import</span> path syntax</div><div class="line">	packages    description of <span class="keyword">package</span> lists</div><div class="line">	testflag    description of testing flags</div><div class="line">	testfunc    description of testing functions</div><div class="line"></div><div class="line">Use <span class="string">"go help [topic]"</span> <span class="keyword">for</span> more information about that topic.</div></pre></td></tr></table></figure>
<h1 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h1><p><strong>go build</strong>,是非常常用的命令，它可以启动编译，把我们的包和相关的依赖编译成一个可执行的文件。</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usage: go build <span class="string">[-o output]</span> <span class="string">[-i]</span> <span class="string">[build flags]</span> <span class="string">[packages]</span></div></pre></td></tr></table></figure>
<p><code>go build</code>的使用比较简洁，所有的参数都可以忽略，直到只有go build，这个时候意味着使用当前目录进行编译，下面的几条命令是等价的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> build</div><div class="line"><span class="keyword">go</span> build .</div><div class="line"><span class="keyword">go</span> build hello.<span class="keyword">go</span></div></pre></td></tr></table></figure>
<p>以上这三种写法，都是使用当前目录编译的意思。因为我们忽略了packages,所以自然就使用当前目录进行编译了。从这里我们也可以推测出，go build本质上需要的是一个路径，让编译器可以找到哪些需要编译的go文件。packages其实是一个相对路径，是相对于我们定义的GOROOT和GOPATH这两个环境变量的，所以有了packages这个参数后，go build就可以知道哪些需要编译的go文件了。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">go</span> <span class="keyword">build </span>github/tools</div></pre></td></tr></table></figure>
<p>这种方式是指定包的方式，这样会明确的编译我们这个包。当然我们也可以使用通配符。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> build github.<span class="keyword">com</span>/tools/...</div></pre></td></tr></table></figure>
<p>3个点表示匹配所有字符串，这样go build就会编译tools目录下的所有包。</p>
<h1 id="go-clean"><a href="#go-clean" class="headerlink" title="go clean"></a>go clean</h1><p>在我们使用<code>go build</code>编译的时候，会产生编译生成的文件，尤其是在我们签入代码的时候，并不想把我们生成的文件也签入到我们的Git代码库中，这时候我们可以手动删除生成的文件，但是有时候会忘记，也很麻烦，不小心还是会提交到Git中。要解决这个问题，我们可以使用<code>go clean</code>,它可以清理我们编译生成的文件，比如生成的可执行文件，生成obj对象等等。</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">usage: go clean <span class="string">[-i]</span> <span class="string">[-r]</span> <span class="string">[-n]</span> <span class="string">[-x]</span> <span class="string">[build flags]</span> <span class="string">[packages]</span></div></pre></td></tr></table></figure>
<h1 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h1><p>go build是先编译，然后我们在执行可以执行文件来运行我们的程序，需要两步。go run这个命令就是可以把这两步合成一步的命令，通过go run命令，我们可以直接看到输出的结果。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">➜  ~ go <span class="keyword">help</span> run</div><div class="line"><span class="keyword">usage</span>: <span class="keyword">go</span> run [<span class="keyword">build</span> flags] [-exec xprog] gofiles... [arguments...]</div><div class="line"></div><div class="line">Run compiles <span class="keyword">and</span> runs the <span class="keyword">main</span> <span class="keyword">package</span> comprising the named <span class="keyword">Go</span> <span class="keyword">source</span> files.</div><div class="line">A <span class="keyword">Go</span> <span class="keyword">source</span> <span class="keyword">file</span> <span class="keyword">is</span> defined <span class="keyword">to</span> be a <span class="keyword">file</span> ending <span class="keyword">in</span> a literal <span class="string">".go"</span> suffix.</div><div class="line"></div><div class="line"><span class="keyword">By</span> <span class="keyword">default</span>, <span class="string">'go run'</span> runs the <span class="keyword">compiled</span> <span class="built_in">binary</span> directly: <span class="string">'a.out arguments...'</span>.</div><div class="line"><span class="keyword">If</span> the -exec flag <span class="keyword">is</span> given, <span class="string">'go run'</span> invokes the <span class="built_in">binary</span> <span class="keyword">using</span> xprog:</div><div class="line">	<span class="string">'xprog a.out arguments...'</span>.</div><div class="line"><span class="keyword">If</span> the -exec flag <span class="keyword">is</span> <span class="keyword">not</span> given, GOOS <span class="keyword">or</span> GOARCH <span class="keyword">is</span> different <span class="keyword">from</span> the <span class="keyword">system</span></div><div class="line"><span class="keyword">default</span>, <span class="keyword">and</span> a program named go_$GOOS_$GOARCH_exec can be <span class="keyword">found</span></div><div class="line"><span class="keyword">on</span> the <span class="keyword">current</span> <span class="keyword">search</span> <span class="keyword">path</span>, <span class="string">'go run'</span> invokes the <span class="built_in">binary</span> <span class="keyword">using</span> that program,</div><div class="line"><span class="keyword">for</span> example <span class="string">'go_nacl_386_exec a.out arguments...'</span>. This allows execution <span class="keyword">of</span></div><div class="line"><span class="keyword">cross</span>-<span class="keyword">compiled</span> programs <span class="keyword">when</span> a simulator <span class="keyword">or</span> other execution method <span class="keyword">is</span></div><div class="line">available.</div></pre></td></tr></table></figure>
<p>go run 命令需要一个go文件作为参数，这个go文件必须包含main包和main函数，这样才可以运行，其他的参数和go build差不多。在运行go run的时候，如果需要的话，我们可以给我们的程序传递参数，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">)</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Println(<span class="string">"输入的参数为："</span>,os.Args[<span class="number">1</span>])</div><div class="line">&#125;</div><div class="line"></div><div class="line">打开终端，输入如下命令执行：</div><div class="line"><span class="keyword">go</span> run main.<span class="keyword">go</span> <span class="number">12</span></div><div class="line"></div><div class="line">打印：</div><div class="line">输入的参数为： <span class="number">12</span></div></pre></td></tr></table></figure>
<h1 id="go-test"><a href="#go-test" class="headerlink" title="go test"></a>go test</h1><p>该命令用于Go的单元测试，它也是接受一个包名作为参数，如果没有指定，使用当前目录。<br>go test运行的单元测试必须符合go的测试要求。</p>
<ol>
<li>写有单元测试的文件名，必须以_test.go结尾。</li>
<li>测试文件要包含若干个测试函数。</li>
<li>这些测试函数要以Test为前缀，还要接收一个*testing.T类型的参数。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//testing</span></div><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(x <span class="keyword">int</span> ,y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> x + y</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span> <span class="string">"testing"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> Add(<span class="number">1</span>,<span class="number">2</span>) == <span class="number">3</span> &#123;</div><div class="line">		t.Log(<span class="string">"1+2=3"</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> Add(<span class="number">1</span>,<span class="number">1</span>) == <span class="number">3</span> &#123;</div><div class="line">		t.Error(<span class="string">"1+1=3"</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个单元测试，保存在<code>main_test.go</code>文件中，对main包里的<code>Add(a,b int)</code>函数进行单元测试。<br>如果要运行这个单元测试，在该文件目录下，执行go test 即可。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜  main go test</div><div class="line">PASS</div><div class="line">ok      _<span class="regexp">/Users/</span>liuguoquan<span class="regexp">/GoglandProjects/m</span>ain <span class="number">0.006</span>s</div></pre></td></tr></table></figure>
<h1 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h1><p>它和go build类似，不过它可以在编译后，把生成的可执行文件或者库安装到对应的目录下，以供使用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜  hello go <span class="keyword">help</span> <span class="keyword">install</span></div><div class="line"><span class="keyword">usage</span>: <span class="keyword">go</span> <span class="keyword">install</span> [<span class="keyword">build</span> flags] [packages]</div><div class="line"><span class="keyword">Install</span> compiles <span class="keyword">and</span> installs the packages named <span class="keyword">by</span> the <span class="keyword">import</span> paths,</div><div class="line">along <span class="keyword">with</span> their dependencies.</div></pre></td></tr></table></figure>
<p>它的用法和go build差不多，如果不指定一个包名，就使用当前目录。安装的目录都是约定好的，如果生成的是可执行文件，那么安装在$GOPATH/bin目录下；如果是可引用的库，那么安装在$GOPATH/pkg目录下。</p>
<h1 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h1><p><strong>go get</strong>命令，可以从网上下载更新指定的包以及依赖的包，并对它们进行编译和安装。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/astaxie/beego</div></pre></td></tr></table></figure>
<p>以上示例，我们就可以从github上直接下载这个go库到我们GOPATH工作空间中，以供我们使用。下载的是整个源代码工程，并且会根据它们编译和安装，和执行go install类似。</p>
<p><strong>go get</strong>支持大多数版本控制系统(VCS)，比如我们常用的git，通过它和包依赖管理结合，我们可以在代码中直接导入网络上的包以供我们使用。</p>
<p>如果我们需要更新网络上的一个go工程，加<code>-u</code> 标记即可。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">go</span> <span class="built_in">get</span> -<span class="keyword">u</span> github.<span class="keyword">com</span>/astaxie/beego</div></pre></td></tr></table></figure>
<p>类似的，启用-v标记，可以看到下载的进度以及更多的调试信息。</p>
<h1 id="go-fmt"><a href="#go-fmt" class="headerlink" title="go fmt"></a>go fmt</h1><p><code>go fmt</code>可以格式化我们的源代码的布局和Go源代码一样的风格，也就是统一代码风格，这样我们再也不用为大括号要不要放到行尾还是另起一行，缩进是使用空格还是tab而争论不休了，都给我们统一了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; </div><div class="line">	fmt.Println(<span class="string">"输入的参数为："</span>, os.Args[<span class="number">1</span>]) &#125;</div></pre></td></tr></table></figure>
<p>比如以上代码，我们执行<code>go fmt</code> 格式化后，会变成如下这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Println(<span class="string">"输入的参数为："</span>, os.Args[<span class="number">1</span>])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>go fmt也是接受一个包名作为参数，如果不传递，则使用当前目录。go fmt会自动格式化代码文件并保存，它本质上其实是调用的gofmt -l -w这个命令，我们看下gofmt的使用帮助。</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">➜  hello gofmt -h  </div><div class="line">usage: gofmt [flags] [path ...]</div><div class="line">  -<span class="ruby">cpuprofile string</span></div><div class="line">    	write cpu profile to this file</div><div class="line">  -<span class="ruby">d	display diffs instead of rewriting files</span></div><div class="line">  -<span class="ruby">e	report all errors (<span class="keyword">not</span> just the first <span class="number">10</span> on different lines)</span></div><div class="line">  -<span class="ruby">l	list files whose formatting differs from gofmt<span class="string">'s</span></span></div><div class="line">  -<span class="ruby"><span class="string">r string</span></span></div><div class="line">    	rewrite rule (e.g., 'a[b:len(a)] -&gt; a[b:]')</div><div class="line">  -<span class="ruby"><span class="string">s	simplify code</span></span></div><div class="line">  -<span class="ruby"><span class="string">w	write result to (source) file instead of stdout</span></span></div></pre></td></tr></table></figure>
<h1 id="go-vet"><a href="#go-vet" class="headerlink" title="go vet"></a>go vet</h1><p><code>go vet</code>它会帮助我们检查我们代码中常见的错误。</p>
<ol>
<li>Printf这类的函数调用时，类型匹配了错误的参数。</li>
<li>定义常用的方法时，方法签名错误。</li>
<li>错误的结构标签。</li>
<li>没有指定字段名的结构字面量。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Printf(<span class="string">" 哈哈"</span>,<span class="number">3.14</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子是一个明显错误的例子，新手经常会犯，这里我们忘记输入了格式化的指令符，这种编辑器是检查不出来的，但是如果我们使用go vet就可以帮我们检查出这类常见的小错误。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  hello <span class="keyword">go</span> vet</div><div class="line">main.<span class="keyword">go</span>:<span class="number">8</span>: <span class="keyword">no</span> formatting directive in Printf <span class="keyword">call</span></div></pre></td></tr></table></figure>
<h1 id="go-env"><a href="#go-env" class="headerlink" title="go env"></a>go env</h1><p><code>go env</code> 用于查看编译环境</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">➜  ~ go env</div><div class="line">GOARCH=<span class="string">"amd64"</span> <span class="comment">//目标处理器架构</span></div><div class="line">GOBIN=<span class="string">""</span></div><div class="line">GOEXE=<span class="string">""</span></div><div class="line">GOHOSTARCH=<span class="string">"amd64"</span></div><div class="line">GOHOSTOS=<span class="string">"darwin"</span></div><div class="line">GOOS=<span class="string">"darwin"</span> <span class="comment">//目标操作系统</span></div><div class="line">GOPATH=<span class="string">"/Users/liuguoquan/go"</span></div><div class="line">GORACE=<span class="string">""</span></div><div class="line">GOROOT=<span class="string">"/usr/local/go"</span> <span class="comment">//</span></div><div class="line">GOTOOLDIR=<span class="string">"/usr/local/go/pkg/tool/darwin_amd64"</span></div><div class="line">GCCGO=<span class="string">"gccgo"</span></div><div class="line">CC=<span class="string">"clang"</span></div><div class="line">GOGCCFLAGS=<span class="string">"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/ph/tdtx7f3167z3fzl3nqj3ht4w0000gn/T/go-build886960492=/tmp/go-build -gno-record-gcc-switches -fno-common"</span></div><div class="line">CXX=<span class="string">"clang++"</span></div><div class="line">CGO_ENABLED=<span class="string">"1"</span></div><div class="line">PKG_CONFIG=<span class="string">"pkg-config"</span></div><div class="line">CGO_CFLAGS=<span class="string">"-g -O2"</span></div><div class="line">CGO_CPPFLAGS=<span class="string">""</span></div><div class="line">CGO_CXXFLAGS=<span class="string">"-g -O2"</span></div><div class="line">CGO_FFLAGS=<span class="string">"-g -O2"</span></div><div class="line">CGO_LDFLAGS=<span class="string">"-g -O2"</span></div></pre></td></tr></table></figure>
<p>GOOS指的是目标操作系统，它的可用值为：</p>
<ul>
<li>darwin</li>
<li>freebsd</li>
<li>linux</li>
<li>windows</li>
<li>android</li>
<li>dragonfly</li>
<li>netbsd</li>
<li>openbsd</li>
<li>plan9</li>
<li>solaris</li>
</ul>
<p>GOARCH指的是目标处理器的架构，目前支持的有：</p>
<ul>
<li>arm</li>
<li>arm64</li>
<li>386</li>
<li>amd64</li>
<li>ppc64</li>
<li>ppc64le</li>
<li>mips64</li>
<li>mips64le</li>
<li>s390x</li>
</ul>
<p>GOOS和GOARCH组合起来，支持生成的可执行程序种类很多，具体组合参考<a href="https://golang.org/doc/install/source#environment" target="_blank" rel="external">https://golang.org/doc/install/source#environment</a>。如果我们要生成不同平台架构的可执行程序，只要改变这两个环境变量就可以了，比如要生成linux 64位的程序，命令如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">GOOS</span>=linux GOARCH=amd64 go build github.com/hello</div></pre></td></tr></table></figure>
<h1 id="go-help"><a href="#go-help" class="headerlink" title="go help"></a>go help</h1><p><code>go help</code> 用于查看命令的具体作用，比如</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">go <span class="keyword">help</span> <span class="keyword">build</span></div><div class="line"><span class="keyword">go</span> <span class="keyword">help</span> <span class="keyword">test</span></div></pre></td></tr></table></figure>
<h1 id="Go文档"><a href="#Go文档" class="headerlink" title="Go文档"></a>Go文档</h1><p>在Go语言中，Go为我们提供了快速生成文档以及查看文档的工具，让我们可以很容易的编写查看文档。</p>
<p>Go提供了两种查看文档的方式，一种是使用go doc命令在终端查看，这种适用于使用VIM等工具在终端开发的人员，它们不用离开终端，既可以查看想查看的文档，又可以编码。</p>
<p>第二种方式，是使用浏览器查看的方式，通过godoc命令可以在本机启动一个web服务，我们可以通过打开浏览器，访问这个服务来查看我们的Go文档。</p>
<h2 id="从终端查看文档"><a href="#从终端查看文档" class="headerlink" title="从终端查看文档"></a>从终端查看文档</h2><p>这种方式适用于在终端开发的，它们一般不像离开终端，查完即可继续编码，这时候使用go doc命令是很不错的选择。</p>
<h2 id="在线浏览文档"><a href="#在线浏览文档" class="headerlink" title="在线浏览文档"></a>在线浏览文档</h2><p>go doc终端查看的方式，虽然也很便捷，不过效率不高，并且没有查看细节以及进行跳转，为此Go为我们提供了基于浏览器使用的网页方式进行浏览API 文档，我们只用点点鼠标，就可以查看了，还可以在方法、包等之间进行跳转，更简洁方便。</p>
<p>要想启动一个Web在线API文档服务很简单，使用<strong>godoc</strong>就可以了。</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">godoc -http=:<span class="number">6060</span></div></pre></td></tr></table></figure>
<p>后面的http是要指定Web服务监听的IP和Port，运行后，我们就可以打开浏览器，输入<code>http://127.0.0.1:6060</code>进行访问了，你会发现打开的页面，和GoLang的官方网站一样，没错，这个其实就是官网的一个拷贝，但是包的文档<code>http://127.0.0.1:6060/pkg/</code>会和官网不一样,你自己启动的这个服务，是基于你电脑上<code>GOROOT</code>和<code>GOPATH</code>这两个路径下的所有包生成的文档，会比官网只是标准库的文档要多。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.flysnow.org/2017/03/08/go-in-action-go-tools.html" target="_blank" rel="external">Go开发工具</a><br><a href="http://wiki.jikexueyuan.com/project/go-command-tutorial/0.0.html" target="_blank" rel="external">标准命令详解</a><br><a href="http://www.flysnow.org/2017/03/09/go-in-action-go-doc.html" target="_blank" rel="external">Go Doc</a><br><a href="http://wiki.jikexueyuan.com/project/go-command-tutorial/0.5.html" target="_blank" rel="external">go doc与godoc</a></p>
<p>《Go语言实战》</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2017/05/08/Go语言基础②Go开发工具/" data-id="cj6er1fvk003z6y19k0qqrpkc" class="article-share-link">Share</a>
      
        <a href="http://liuguoquan727.github.io/2017/05/08/Go语言基础②Go开发工具/#ds-thread" class="article-comment-link">Kommentarer</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go基础/">Go基础</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Go语言基础①Go包管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/08/Go语言基础①Go包管理/" class="article-date">
  <time datetime="2017-05-08T12:52:53.000Z" itemprop="datePublished">2017-05-08 20:52:53</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/08/Go语言基础①Go包管理/">Go语言基础①Go包管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>我们在使用其他语言，比如Java，是有包的概念的，它是Java语言中组织我们的Java文件的一个概念，比如java.lang这个包，他里面有很多我们常用的类，比如String。在Go语言中，包也是类似的概念，它是把我们的go文件组织起来，可以方便进行归类、复用等目的。 比如Go内置的net包</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">net</div><div class="line">├── http</div><div class="line">├── internal</div><div class="line">├── mail</div><div class="line">├── rpc</div><div class="line">├── smtp</div><div class="line">├── testdata</div><div class="line">├── textproto</div><div class="line">└── url</div></pre></td></tr></table></figure>
<p>以上是net包的一个目录结构，net本身是一个包，net目录下的http又是一个包。从这个大家可以看到，go语言的包其实就是我们计算机里的目录，或者叫文件夹，通过它们进行目录结构和文件组织，go只是对目录名字做了一个翻译，叫【包】而已。比如这里的net包其实就是net目录，http包其实就是http目录，这也是go语言中的一个命名习惯，包名和文件所在的目录名是一样的。</p>
<h1 id="包的命名"><a href="#包的命名" class="headerlink" title="包的命名"></a>包的命名</h1><p>go 语言包的命名，<strong>遵循简洁、小写、和 go 文件所在目录同名的原则</strong>，这样就便于我们引用，书写以及快速定位查找。</p>
<p>比如go自带的http这个包，它这个http目录下的所有go文件都属于这个http包,所以我们使用http包里的函数、接口的时候，导入这个http包就可以了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	http.ListenAndServe(<span class="string">"127.0.0.1:8080"</span>,handler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这个例子可以看到，我们导入的是<strong>net/http</strong>,在这里叫做全路径，因为 http 包在 net 里面，net 是最顶级的包，所以必须使用全路径导入，go 编译程序才能找到 http 这个包，和我们文件系统的目录路径是一样的。</p>
<p>因为有了全路径，<strong>所以命名的包名可以和其他库的一样，只要它们的全路径不同就可以了</strong>，使用全路径的导入，也增加了包名命名的灵活性。</p>
<p>对于自己或者公司开发的程序而言，我们一般采用域名作为顶级包名的方式，这样就不用担心和其他开发者包名重复的问题了，假设我的个人域名是 <strong>www.deason.com</strong>,那么我自己开发的go程序都以 <strong>deason.com</strong> 作为全路径中的最顶层部分，比如导入我开发的一个工具包:</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> <span class="title">main</span></div><div class="line">import <span class="string">"deason.com/tools"</span></div></pre></td></tr></table></figure>
<p>如果你没有自己的域名，怎么办呢？这时候可以使用 <strong>github.com</strong>。这时候我们就可以使用 <strong>github.com/<username></username></strong> 作为你的顶级路径了，别人是不会和你重名的。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> <span class="title">main</span></div><div class="line">import <span class="string">"github.com/liuguoquan/tools"</span></div></pre></td></tr></table></figure>
<p>这就是换成github.com命名的方式。</p>
<h1 id="main包"><a href="#main包" class="headerlink" title="main包"></a>main包</h1><p>当把一个go文件的包名声明为main时，就等于告诉go编译程序，我这个是一个可执行的程序，那么go编译程序就会尝试把它编译为一个二进制的可执行文件。</p>
<p>一个main的包，一定会包含一个<strong>main()</strong>函数，比如C和Java都有main()函数,它是一个程序的入口，没这个函数，程序就无法执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Println(<span class="string">"Hello, 世界"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设该go文件叫hello.go,放在<strong>$GOPATH/src/hello</strong>目录下，那么我们在这个目录下执行go build命令就会生成二进制的可执行文件，在window系统下生成的是hello.exe，在Unix，MAC和Linux下生成的是hello,我们在CMD或者终端里执行它，就可以看到控制台打印的:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello, 世界</div></pre></td></tr></table></figure>
<h1 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h1><p>要想使用一个包，必须先导入它才可以使用，Go语言提供了import关键字来导入一个包，这个关键字告诉Go编译器到磁盘的哪里去找要想导入的包，所以导入的包必须是一个全路径的包，也就是包所在的位置。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div></pre></td></tr></table></figure>
<p><strong>如果要导入多个包怎么办呢？Go语言还为我们提供的导入块</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"net/http"</span></div><div class="line">	<span class="string">"fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line">或者</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"net/http"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>对于多于一个路径的包名，在代码中引用的时候，使用全路径最后一个包名作为引用的包名，比如net/http,我们在代码使用的是http，而不是net。</p>
</blockquote>
<p>现在我导入了包，那么编译的时候，go编译器去什么位置找他们呢？这里就要介绍下Go的环境变量了。Go有两个很重要的环境变量<strong>GOROOT</strong>和<strong>GOPATH</strong>,这是两个定义路径的环境变量，GOROOT是安装Go的路径，比如<strong>/usr/local/go</strong>；<strong>GOPATH</strong> 是我们自己定义的开发者个人的工作空间，比如/home/liuguoquan/go。</p>
<p>编译器会使用我们设置的这两个路径，再加上<strong>import</strong>导入的相对全路径来查找磁盘上的包，比如我们导入的fmt包，编译器最终找到的是/usr/local/go/fmt这个位置。</p>
<p>值得了解的是：对于<strong>包的查找，是有优先级的</strong>，编译器会优先在GOROOT里搜索，其次是GOPATH,一旦找到，就会马上停止搜索。如果最终都没找到，就报编译异常了。</p>
<h1 id="远程包导入"><a href="#远程包导入" class="headerlink" title="远程包导入"></a>远程包导入</h1><p>如果有的Go包共享在Github上，我们一样有办法使用他们，这就是远程导入包了，或者是网络导入，Go天生就支持这种情况，所以我们可以很随意的使用Github上的Go库开发程序。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"github.com/astaxie/beego"</span></div></pre></td></tr></table></figure>
<p>这种导入，前提必须是该包托管在一个分布式的版本控制系统上，比如Github、Bitbucket等，并且是Public的权限，可以让我们直接访问它们。</p>
<p>编译在导入它们的时候，会先在<strong>GOPATH</strong>下搜索这个包，如果没有找到，就会使用go get工具从版本控制系统（GitHub）获取，并且会把获取到的源代码存储在GOPATH目录下对应URL的目录里，以供编译使用。</p>
<p><code>go get</code>工具可以递归获取依赖包，如果<code>github.com/astaxie/beego</code>也引用了其他的远程包，该工具可以一并下载下来。</p>
<h1 id="命名导入包"><a href="#命名导入包" class="headerlink" title="命名导入包"></a>命名导入包</h1><p>我们知道，在使用<code>import</code>关键字导入包之后，我们就可以在代码中通过包名使用该包下相应的函数、接口等。如果我们导入的包名正好有重复的怎么办呢？针对这种情况，Go语言可以让我们对导入的包重新命名，这就是命名导入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	myfmt <span class="string">"mylib/fmt"</span></div><div class="line">)</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	fmt.Println()</div><div class="line">	myfmt.Println()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果没有重新命名，那么对于编译器来说，这两个fmt它是区分不清楚的。重命名也很简单，在我们导入的时候，在包名的左侧，起一个新的包名就可以了。</p>
<p><strong>Go语言规定，导入的包必须要使用，否则会包编译错误</strong>，这是一个非常好的规则，因为这样可以避免我们引用很多无用的代码而导致的代码臃肿和程序的庞大，因为很多时候，我们都不知道哪些包是否使用，这在C和Java上会经常遇到，有时候我们不得不借助工具来查找我们没有使用的文件、类型、方法和变量等，把它们清理掉。</p>
<p>但是有时候，我们需要导入一个包，但是又不使用它，按照规则，这是不行的，为此Go语言给我们提供了一个空白标志符<code>_</code>,只需要我们使用<code>_</code>重命名我们导入的包就可以了。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="literal">_</span> <span class="string">"mylib/fmt"</span></div><div class="line">)</div><div class="line"></div><div class="line">或者</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="literal">_</span> <span class="string">"mylib/fmt"</span></div></pre></td></tr></table></figure>
<h1 id="包的init函数"><a href="#包的init函数" class="headerlink" title="包的init函数"></a>包的init函数</h1><p>每个包都可以有任意多个init函数，这些init函数都会在main函数之前执行。init函数通常用来做初始化变量、设置包或者其他需要在程序执行前的引导工作。比如上面我们讲的需要使用_空标志符来导入一个包的目的，就是想执行这个包里的init函数。</p>
<p>我们以数据库的驱动为例，Go语言为了统一关于数据库的访问，使用databases/sql抽象了一层数据库的操作，可以满足我们操作MYSQL、Postgre等数据库，这样不管我们使用这些数据库的哪个驱动，编码操作都是一样的，想换驱动的时候，就可以直接换掉，而不用修改具体的代码。</p>
<p>这些数据库驱动的实现，就是具体的，可以由任何人实现的，它的原理就是定义了init函数，在程序运行之前，把实现好的驱动注册到sql包里，这样我们就使用使用它操作数据库了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> mysql</div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"database/sql"</span></div><div class="line">)</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</div><div class="line">	sql.Register(<span class="string">"mysql"</span>, &amp;MySQLDriver&#123;&#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为我们只是想执行这个mysql包的init方法，并不想使用这个包，所以我们在导入这个包的时候，需要使用<code>_</code>重命名包名，避免编译错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"database/sql"</span></div><div class="line"><span class="keyword">import</span> _ <span class="string">"github.com/go-sql-driver/mysql"</span></div><div class="line"></div><div class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"user:password@/dbname"</span>)</div></pre></td></tr></table></figure>
<p>看非常简洁，剩下针对的数据库的操作，都是使用的<code>database/sql</code>标准接口，如果我们想换一个<code>mysql</code>的驱动的话，只需要换个导入就可以了，灵活方便，这也是面向接口编程的便利。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.flysnow.org/2017/03/04/go-in-action-go-package.html" target="_blank" rel="external">Go包管理</a></p>
<p>《Go语言实战》</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2017/05/08/Go语言基础①Go包管理/" data-id="cj6er1fvi003w6y193b2oo66l" class="article-share-link">Share</a>
      
        <a href="http://liuguoquan727.github.io/2017/05/08/Go语言基础①Go包管理/#ds-thread" class="article-comment-link">Kommentarer</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go基础/">Go基础</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Python基础⑪数据存储" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/07/Python基础⑪数据存储/" class="article-date">
  <time datetime="2017-05-07T13:14:53.000Z" itemprop="datePublished">2017-05-07 21:14:53</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/07/Python基础⑪数据存储/">Python基础⑪数据存储</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h1><p>pickle是标准库中的一个模块，在Python 2中还有一个cpickle，两者的区别就是后者更快。所以，下面操作中，不管是用<code>import pickle</code>，还是用<code>import cpickle as pickle</code>，在功能上都是一样的。</p>
<p>而在Python 3中，你只需要<code>import pickle</code>即可，因为它已经在Python 3中具备了Python 2中的cpickle同样的性能。</p>
<p><code>pickle.dump(obj,file[,protocol])</code></p>
<ul>
<li>obj：序列化对象，在上面的例子中是一个列表，它是基本类型，也可以序列化自己定义的对象。</li>
<li>file：要写入的文件。可以更广泛地可以理解为为拥有<code>write()</code>方法的对象，并且能接受字符串为为参数，所以，它还可以是一个<code>StringIO</code>对象，或者其它自定义满足条件的对象。</li>
<li>protocol：可选项。默认为False（或者说0），是以ASCII格式保存对象；如果设置为1或者True，则以压缩的二进制格式保存对象。</li>
</ul>
<h2 id="序列化对象"><a href="#序列化对象" class="headerlink" title="序列化对象"></a>序列化对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pickle</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>integers = range(<span class="number">9999</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">"i"</span>] = integers        <span class="comment">#下面将这个字典类型的对象存入文件</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">"22902.dat"</span>, <span class="string">"wb"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.dump(d, f)           <span class="comment">#文件中以ascii格式保存数据</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">"22903.dat"</span>, <span class="string">"wb"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.dump(d, f, <span class="keyword">True</span>)     <span class="comment">#文件中以二进制格式保存数据,文件较小，推荐方式</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = os.stat(<span class="string">"22902.dat"</span>).st_size    <span class="comment">#得到两个文件的大小</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = os.stat(<span class="string">"22903.dat"</span>).st_size</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"%d, %d, %.2f%%"</span> % (s1, s2, (s2+<span class="number">0.0</span>)/s1*<span class="number">100</span>)    <span class="comment">#Python 3: print("&#123;0:d&#125;, &#123;1:d&#125;, &#123;2:.2f&#125;".format (s1, s2, (s2+0.0)/s1*100))</span></div><div class="line"><span class="number">68903</span>, <span class="number">29774</span>, <span class="number">43.21</span>%</div></pre></td></tr></table></figure>
<h2 id="反序列化对象"><a href="#反序列化对象" class="headerlink" title="反序列化对象"></a>反序列化对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">将数据保存入文件，还有另外一个目标，就是要读出来，也称之为反序列化。</div><div class="line"></div><div class="line">    &gt;&gt;&gt; integers = pickle.load(open(<span class="string">"22901.dat"</span>, <span class="string">"rb"</span>))</div><div class="line">    &gt;&gt;&gt; <span class="keyword">print</span> integers    <span class="comment">#Python 3: print(integers)</span></div><div class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"></div><div class="line">再看看以二进制存入的那个文件：</div><div class="line"></div><div class="line">    &gt;&gt;&gt; f = open(<span class="string">"22903.dat"</span>, <span class="string">"rb"</span>)</div><div class="line">    &gt;&gt;&gt; d = pickle.load(f)</div><div class="line">    &gt;&gt;&gt; <span class="keyword">print</span> d</div><div class="line">    &#123;<span class="string">'i'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, ....   <span class="comment">#省略后面的数字&#125;</span></div><div class="line">    &gt;&gt;&gt; f.close()</div></pre></td></tr></table></figure>
<h2 id="读取自定义对象"><a href="#读取自定义对象" class="headerlink" title="读取自定义对象"></a>读取自定义对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">    &gt;&gt;&gt; <span class="keyword">import</span> cPickle <span class="keyword">as</span> pickle        <span class="comment">#这是Python 2的引入方式，如果是Python 3，直接使用import pickle</span></div><div class="line">    &gt;&gt;&gt; <span class="keyword">import</span> StringIO                 <span class="comment">#标准库中的一个模块，跟file功能类似，只不过是在内存中操作“文件”</span></div><div class="line">    </div><div class="line">    &gt;&gt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">Book</span><span class="params">(object)</span>:</span>             <span class="comment">#自定义一种类型</span></div><div class="line">    ...     <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></div><div class="line">    ...         self.name = name</div><div class="line">    ...     <span class="function"><span class="keyword">def</span> <span class="title">my_book</span><span class="params">(self)</span>:</span></div><div class="line">    ...         <span class="keyword">print</span> <span class="string">"my book is: "</span>, self.name        <span class="comment">#Python 3: print("my book is: ", self.name)</span></div><div class="line">    ... </div><div class="line">    </div><div class="line"><span class="comment"># 存数据</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>file = StringIO.StringIO()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.dump(pybook, file, <span class="number">1</span>)</div><div class="line">    </div><div class="line"><span class="comment"># 取数据</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>file.seek(<span class="number">0</span>)       <span class="comment">#找到对应类型  </span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pybook2 = pickle.load(file)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pybook2.my_book()</div><div class="line">my book <span class="keyword">is</span>:  &lt;<span class="keyword">from</span> beginner to master&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>file.close()</div></pre></td></tr></table></figure>
<h1 id="shelve"><a href="#shelve" class="headerlink" title="shelve"></a>shelve</h1><p>由于数据的复杂性，<code>pickle</code>只能完成一部分工作，在另外更复杂的情况下，它就稍显麻烦了。于是，又有了<code>shelve</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># 写操作</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> shelve</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = shelve.open(<span class="string">"22901.db"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="string">"name"</span>] = <span class="string">"www.itdiffer.com"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="string">"lang"</span>] = <span class="string">"python"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="string">"pages"</span>] = <span class="number">1000</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="string">"contents"</span>] = &#123;<span class="string">"first"</span>:<span class="string">"base knowledge"</span>,<span class="string">"second"</span>:<span class="string">"day day up"</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s.close()</div><div class="line">  </div><div class="line"><span class="comment"># 读操作</span></div><div class="line">    </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>s = shelve.open(<span class="string">"22901.db"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>name = s[<span class="string">"name"</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> name        <span class="comment">#Python 3: print(name)</span></div><div class="line">www.itdiffer.com</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>contents = s[<span class="string">"contents"</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> contents        <span class="comment">#Python 3: print(contents)</span></div><div class="line">&#123;<span class="string">'second'</span>: <span class="string">'day day up'</span>, <span class="string">'first'</span>: <span class="string">'base knowledge'</span>&#125;</div><div class="line"></div><div class="line"><span class="comment"># for循环读</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k <span class="keyword">in</span> s:</div><div class="line"><span class="meta">... </span>    <span class="keyword">print</span> k, s[k]</div><div class="line"><span class="meta">... </span></div><div class="line">contents &#123;<span class="string">'second'</span>: <span class="string">'day day up'</span>, <span class="string">'first'</span>: <span class="string">'base knowledge'</span>&#125;</div><div class="line">lang python</div><div class="line">pages <span class="number">1000</span></div><div class="line">name www.itdiffer.com</div></pre></td></tr></table></figure>
<p>所建立的对象被变量<code>s</code>所引用，就如同字典一样，可称之为类字典对象。所以，可以如同操作字典那样来操作它。</p>
<p>但是，要小心坑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">    &gt;&gt;&gt; f = shelve.open(<span class="string">"22901.db"</span>)</div><div class="line">    &gt;&gt;&gt; f[<span class="string">"author"</span>]</div><div class="line">    [<span class="string">'qiwsir'</span>]</div><div class="line">    &gt;&gt;&gt; f[<span class="string">"author"</span>].append(<span class="string">"Hetz"</span>)    <span class="comment">#试图增加一个</span></div><div class="line">    &gt;&gt;&gt; f[<span class="string">"author"</span>]                   <span class="comment">#坑就在这里</span></div><div class="line">    [<span class="string">'qiwsir'</span>]</div><div class="line">    &gt;&gt;&gt; f.close()</div><div class="line"></div><div class="line">当试图修改一个已有键的值时没有报错，但是并没有修改成功。要填平这个坑，需要这样做：</div><div class="line">    </div><div class="line">    &gt;&gt;&gt; f = shelve.open(<span class="string">"22901.db"</span>, writeback=<span class="keyword">True</span>)    <span class="comment">#多一个参数True</span></div><div class="line">    &gt;&gt;&gt; f[<span class="string">"author"</span>].append(<span class="string">"Hetz"</span>)</div><div class="line">    &gt;&gt;&gt; f[<span class="string">"author"</span>]                   <span class="comment">#没有坑了</span></div><div class="line">    [<span class="string">'qiwsir'</span>, <span class="string">'Hetz'</span>]</div><div class="line">    &gt;&gt;&gt; f.close()</div><div class="line"></div><div class="line">还用`<span class="keyword">for</span>`循环一下：</div><div class="line"></div><div class="line">    &gt;&gt;&gt; f = shelve.open(<span class="string">"22901.db"</span>)</div><div class="line">    &gt;&gt;&gt; <span class="keyword">for</span> k,v <span class="keyword">in</span> f.items():</div><div class="line">    ...     <span class="keyword">print</span> k,<span class="string">": "</span>,v        <span class="comment">#Python 3: print(k,": ",v)</span></div><div class="line">    ... </div><div class="line">    contents :  &#123;<span class="string">'second'</span>: <span class="string">'day day up'</span>, <span class="string">'first'</span>: <span class="string">'base knowledge'</span>&#125;</div><div class="line">    lang :  python</div><div class="line">    pages :  <span class="number">1000</span></div><div class="line">    author :  [<span class="string">'qiwsir'</span>, <span class="string">'Hetz'</span>]</div><div class="line">    name :  www.itdiffer.com</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2017/05/07/Python基础⑪数据存储/" data-id="cj6er1fxv009e6y19zowqx75s" class="article-share-link">Share</a>
      
        <a href="http://liuguoquan727.github.io/2017/05/07/Python基础⑪数据存储/#ds-thread" class="article-comment-link">Kommentarer</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python基础/">Python基础</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Python基础⑩模块" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/07/Python基础⑩模块/" class="article-date">
  <time datetime="2017-05-07T13:12:53.000Z" itemprop="datePublished">2017-05-07 21:12:53</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Python/">Python</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/07/Python基础⑩模块/">Python基础⑩模块</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="编写模块"><a href="#编写模块" class="headerlink" title="编写模块"></a>编写模块</h1><h2 id="模块是程序"><a href="#模块是程序" class="headerlink" title="模块是程序"></a>模块是程序</h2><p>模块就是一个扩展名为<code>.py</code>的Python程序。</p>
<h3 id="编写模块-1"><a href="#编写模块-1" class="headerlink" title="编写模块"></a>编写模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding=utf-8</span></div><div class="line"></div><div class="line">lang = <span class="string">"python"</span></div></pre></td></tr></table></figure>
<h3 id="引入模块"><a href="#引入模块" class="headerlink" title="引入模块"></a>引入模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path.append(<span class="string">"~/Documents/VBS/StartLearningPython/2code/pm.py"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pm</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pm.lang</div><div class="line"><span class="string">'python'</span></div></pre></td></tr></table></figure>
<p>当Python解释器读取了<code>.py</code>文件，先将它变成由字节码组成的<code>.pyc</code>文件，然后这个<code>.pyc</code>文件交给一个叫做Python虚拟机的东西去运行（那些号称编译型的语言也是这个流程，不同的是它们先有一个明显的编译过程，编译好了之后再运行）。如果<code>.py</code>文件修改了，Python解释器会重新编译，只是这个编译过程不是完全显示给你看的。</p>
<p>我这里说的比较笼统，要深入了解Python程序的执行过程，可以阅读这篇文章：<a href="http://www.cnblogs.com/kym/archive/2012/05/14/2498728.html" target="_blank" rel="external">说说Python程序的执行过程</a></p>
<p>有了<code>.pyc</code>文件后，每次运行就不需要重新让解释器来编译<code>.py</code>文件了，除非<code>.py</code>文件修改了。这样，Python运行的就是那个编译好了的<code>.pyc</code>文件。</p>
<h3 id="if-name-“main“"><a href="#if-name-“main“" class="headerlink" title="if name == “main“"></a>if <strong>name</strong> == “<strong>main</strong>“</h3><p>如果要作为程序执行，则<code>__name__ == &quot;__main__&quot;</code>；如果作为模块引入，则<code>pm.__name__ == &quot;pm&quot;</code>，即属性<code>__name__</code>的值是模块名称。</p>
<h2 id="模块的位置"><a href="#模块的位置" class="headerlink" title="模块的位置"></a>模块的位置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pprint</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pprint.pprint(sys.path)  <span class="comment">#查看所有模块的位置</span></div></pre></td></tr></table></figure>
<h2 id="all-在模块中的作用"><a href="#all-在模块中的作用" class="headerlink" title="__all__在模块中的作用"></a><code>__all__</code>在模块中的作用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># /usr/bin/env python</span></div><div class="line"><span class="comment"># coding:utf-8</span></div><div class="line"></div><div class="line">__all__ = [<span class="string">'_private_variable'</span>, <span class="string">'public_teacher'</span>]</div><div class="line"></div><div class="line">public_variable = <span class="string">"Hello, I am a public variable."</span></div><div class="line">_private_variable = <span class="string">"Hi, I am a private variable."</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">public_teacher</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">"I am a public teacher, I am from JP."</span>    <span class="comment">#Python 3: print("I am a public teacher, I am from JP.")</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_private_teacher</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">"I am a private teacher, I am from CN."</span>    <span class="comment">#Python 3:  print("I am a private teacher, I am from CN.")</span></div></pre></td></tr></table></figure>
<p><code>__all__</code>属性以及相应的值，在<code>__all__</code>属性列表中包含了一个私有变量的名字和一个函数的名字。这是在告诉引用本模块的解释器，这两个东西是有权限被访问的，而且只有这两个东西。</p>
<h2 id="包或者库"><a href="#包或者库" class="headerlink" title="包或者库"></a>包或者库</h2><p>包或者库，应该是比“模块”大的。也的确如此，一般来讲，一个“包”里面会有多个模块，当然，“库”是一个更大的概念了，比如Python标准库中的每个库都有好多个包，每个包都有若干个模块。</p>
<p>一个包是由多个模块组成，即多个<code>.py</code>的文件，那么这个所谓“包”也就是我们熟悉的一个目录罢了。现在就需要解决如何引用某个目录中的模块问题了。解决方法就是在该目录中放一个<code>__init__.py</code>文件。<code>__init__.py</code>是一个空文件，将它放在某个目录中，就可以将该目录中的其它<code>.py</code>文件作为模块被引用。</p>
<h1 id="自带电池"><a href="#自带电池" class="headerlink" title="自带电池"></a>自带电池</h1><p>在Python被安装的时候，就有不少模块也随着安装到本地的计算机上了。这些东西就如同“能源”、“电力”一样，让Python拥有了无限生机，能够非常轻而易举地免费使用很多模块。所以，称之为“自带电池”。</p>
<p>那些在安装Python时就默认已经安装好的模块被统称为“标准库”。</p>
<h2 id="引用的方式"><a href="#引用的方式" class="headerlink" title="引用的方式"></a>引用的方式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> pprint <span class="comment">#引入模块</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint <span class="comment">#引入该模块下的方法</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> * <span class="comment">#引入该模块下的所有方法</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> pprint <span class="keyword">as</span> pr <span class="comment">#重命名模块</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint <span class="keyword">as</span> pt  <span class="comment">#重命名方法</span></div></pre></td></tr></table></figure>
<h2 id="深入探究"><a href="#深入探究" class="headerlink" title="深入探究"></a>深入探究</h2><ul>
<li><code>dir()</code>,查看对象的属性和方法</li>
<li><code>help()</code>查看对象的含义</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="帮助、文档和源码"><a href="#帮助、文档和源码" class="headerlink" title="帮助、文档和源码"></a>帮助、文档和源码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> pprint.__doc__  <span class="comment">#查看文档</span></div><div class="line"><span class="keyword">print</span> pprint.__file__ <span class="comment">#查看模块的位置，根据这个位置查到源代码</span></div></pre></td></tr></table></figure>
<h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><h2 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h2><h3 id="sys-argv"><a href="#sys-argv" class="headerlink" title="sys.argv"></a>sys.argv</h3><p>sys.argv是专门用来向python解释器传递参数，名曰“命令行参数”。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ python --version <span class="comment"># --veriosn就是命令行参数</span></div><div class="line">Python <span class="number">2.7</span><span class="number">.6</span></div></pre></td></tr></table></figure>
<h3 id="sys-exit"><a href="#sys-exit" class="headerlink" title="sys.exit()"></a>sys.exit()</h3><p>退出当前程序.</p>
<p>在大多数函数中会用到return，其含义是终止当前的函数，并向调用函数的位置返回相应值（如果没有就是None）。但是<code>sys.exit()</code>的含义是退出当前程序——不仅仅是函数，并发起<code>SystemExit</code>异常。这就是两者的区别了。</p>
<p>如果使用<code>sys.exit(0)</code>表示正常退出。若需要在退出的时候有一个对人友好的提示，可以用<code>sys.exit(&quot;I wet out at here.&quot;)</code>，那么字符串信息就被打印出来。</p>
<h3 id="sys-stdout"><a href="#sys-stdout" class="headerlink" title="sys.stdout"></a>sys.stdout</h3><p>与Python中的函数功能对照，<code>sys.stdin</code>获得输入（等价于Python 2中的raw_input()，Python 3中的input()），<code>sys.stdout</code>负责输出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = open(<span class="string">"stdout.md"</span>, <span class="string">"w"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sys.stdout = f  <span class="comment">#重定向到文件</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"Learn Python: From Beginner to Master"</span>        <span class="comment">#Python 3: print("Learn Python: From Beginner to Master")</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.close()</div></pre></td></tr></table></figure>
<h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> copy</div><div class="line">copy.copy() <span class="comment">#浅拷贝</span></div><div class="line">copy.deepcopy() <span class="comment">#深拷贝</span></div></pre></td></tr></table></figure>
<h2 id="os"><a href="#os" class="headerlink" title="os"></a>os</h2><h3 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line">os.rename(<span class="string">"22201.py"</span>, <span class="string">"newtemp.py"</span>) <span class="comment">#重命名文件</span></div><div class="line">os.remove(<span class="string">"123.txt"</span>) <span class="comment">#删除一个文件，不能是目录</span></div></pre></td></tr></table></figure>
<h3 id="操作目录"><a href="#操作目录" class="headerlink" title="操作目录"></a>操作目录</h3><p><strong>os.listdir</strong>：显示目录中的内容（包括文件和子目录）<br><strong>os.getcwd</strong>：获取当前工作目录；<br><strong>os.pardir</strong>:获得上一级目录<br><strong>os.chdir</strong>：改变当前工作目录<br><strong>os.makedirs, os.removedirs</strong>：创建和删除目录</p>
<h3 id="文件和目录属性"><a href="#文件和目录属性" class="headerlink" title="文件和目录属性"></a>文件和目录属性</h3><p><code>os.stat(p)</code>显示文件或目录的属性<br><code>os.chmod()</code>改变权限</p>
<h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><p><code>os</code>模块中提供了这样的方法，许可程序员在Python程序中使用操作系统的命令。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>p</div><div class="line"><span class="string">'/home/qw/Documents/VBS/StarterLearningPython'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>command = <span class="string">"ls "</span> + p <span class="comment">#命令复制给Command变量</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>command</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.system(command) <span class="comment">#执行命令</span></div></pre></td></tr></table></figure>
<p>需要注意的是，<code>os.system()</code>是在当前进程中执行命令，直到它执行结束。如果需要一个新的进程，可以使用<code>os.exec</code>或者<code>os.execvp</code>。对此有兴趣详细了解的读者，可以查看帮助文档了解。另外，<code>os.system()</code>是通过shell执行命令，执行结束后将控制权返回到原来的进程，但是<code>os.exec()</code>及相关的函数，则在执行后不将控制权返回到原继承，从而使Python失去控制。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding=utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> webbrowser</div><div class="line">webbrowser.open(<span class="string">"http://www.baidu.com"</span>) <span class="comment">#跨平台打开浏览器</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="heapq-堆"><a href="#heapq-堆" class="headerlink" title="heapq:堆"></a>heapq:堆</h2><h3 id="headpq模块"><a href="#headpq模块" class="headerlink" title="headpq模块"></a>headpq模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> heapq</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.__all__</div><div class="line">[<span class="string">'heappush'</span>, <span class="string">'heappop'</span>, <span class="string">'heapify'</span>, <span class="string">'heapreplace'</span>, <span class="string">'merge'</span>, <span class="string">'nlargest'</span>, <span class="string">'nsmallest'</span>, <span class="string">'heappushpop'</span>]</div></pre></td></tr></table></figure>
<p><strong>heappush(heap, x)</strong>：将x压入堆heap</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> heapq</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heap = []    </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.heappush(heap, <span class="number">3</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.heappush(heap, <span class="number">9</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.heappush(heap, <span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.heappush(heap, <span class="number">4</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.heappush(heap, <span class="number">0</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.heappush(heap, <span class="number">8</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heap</div><div class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">8</span>]</div></pre></td></tr></table></figure>
<p><strong>heappop(heap)</strong>：删除最小元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.heappop(heap)</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heap</div><div class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>]</div></pre></td></tr></table></figure>
<p><strong>heapify()</strong>：将列表转换为堆</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>hl = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.heapify(hl)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hl</div><div class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]</div></pre></td></tr></table></figure>
<p><strong>heapreplace()</strong>是<code>heappop()</code>和<code>heappush()</code>的联合，也就是删除一个，同时加入一个</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>heap</div><div class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heapq.heapreplace(heap, <span class="number">3.14</span>)</div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>heap</div><div class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">3.14</span>, <span class="number">9</span>, <span class="number">8</span>]</div></pre></td></tr></table></figure>
<h2 id="deque-双端队列"><a href="#deque-双端队列" class="headerlink" title="deque:双端队列"></a>deque:双端队列</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>qlst.append(<span class="number">5</span>)        <span class="comment">#从右边增加</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>qlst</div><div class="line">deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>qlst.appendleft(<span class="number">7</span>)    <span class="comment">#从左边增加</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>qlst</div><div class="line">deque([<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</div><div class="line">    </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>qlst.pop() <span class="comment">#右边删除一个元素</span></div><div class="line"><span class="number">5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>qlst</div><div class="line">deque([<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>qlst.popleft() <span class="comment"># 左边删除一个元素</span></div><div class="line"><span class="number">7</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>qlst</div><div class="line">deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</div><div class="line">    </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>qlst.rotate(<span class="number">3</span>) <span class="comment">#循环移动n个位置</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>qlst</div><div class="line">deque([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>])</div></pre></td></tr></table></figure>
<h2 id="calendar-日历"><a href="#calendar-日历" class="headerlink" title="calendar:日历"></a>calendar:日历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> calendar</div><div class="line">cal = calendar.month(<span class="number">2016</span>,<span class="number">8</span>)</div><div class="line"><span class="keyword">print</span> cal</div><div class="line"></div><div class="line">    August <span class="number">2016</span></div><div class="line">Mo Tu We Th Fr Sa Su</div><div class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></div><div class="line"> <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span></div><div class="line"><span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span></div><div class="line"><span class="number">22</span> <span class="number">23</span> <span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span></div><div class="line"><span class="number">29</span> <span class="number">30</span> <span class="number">31</span></div></pre></td></tr></table></figure>
<p><strong>calendar(year,w=2,l=1,c=6)</strong><br>返回year年的年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为<code>21* w+18+2* c</code>。l是每星期行数。</p>
<p><strong>isleap(year)</strong>判断是否为闰年，是则返回true，否则false.</p>
<p><strong>leapdays(y1, y2)</strong>返回在y1，y2两年之间的闰年总数，包括y1，但不包括y2.</p>
<p><strong>month(year, month, w=2, l=1)</strong>返回year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6，l是每星期的行数。</p>
<p><strong>monthcalendar(year,month)</strong>返回一个列表，列表内的元素还是列表。每个子列表代表一个星期，都是从星期一到星期日，如果没有本月的日期，则为0。</p>
<p><strong>monthrange(year, month)</strong>返回一个元组，里面有两个整数。第一个整数代表着该月的第一天从星期几是（从0开始，依次为星期一、星期二，直到6代表星期日）。第二个整数是该月一共多少天。</p>
<p><strong>weekday(year,month,day)</strong>输入年月日，知道该日是星期几（注意，返回值依然按照从0到6依次对应星期一到星期六）。</p>
<h2 id="time"><a href="#time" class="headerlink" title="time"></a>time</h2><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><strong>time()</strong>获得的是当前时间（严格说是时间戳），只不过这个时间对人不友好，它是以1970年1月1日0时0分0秒为计时起点，到当前的时间长度（不考虑闰秒）。</p>
<p><strong>localtime()</strong>得到的结果可以称之为时间元组（也有括号），其各项的含义是：</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>tm_year</td>
<td>年</td>
</tr>
<tr>
<td>1</td>
<td>tm_mon</td>
<td>月</td>
</tr>
<tr>
<td>2</td>
<td>tm_mday</td>
<td>日</td>
</tr>
<tr>
<td>3</td>
<td>tm_hour</td>
<td>时</td>
</tr>
<tr>
<td>4</td>
<td>tm_min</td>
<td>分</td>
</tr>
<tr>
<td>5</td>
<td>tm_sec</td>
<td>秒</td>
</tr>
<tr>
<td>6</td>
<td>tm_wday</td>
<td>一周中的第几天</td>
</tr>
<tr>
<td>7</td>
<td>tm_yday</td>
<td>一年中的第几天</td>
</tr>
<tr>
<td>8</td>
<td>tm_isdst</td>
<td>夏令时</td>
</tr>
</tbody>
</table>
<p><strong>gmtime()</strong>localtime()得到的是本地时间，如果要国际化，就最好使用格林威治时间。</p>
<p><strong>asctime()</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>time.asctime()</div><div class="line"><span class="string">'Mon May  4 21:46:13 2015'</span></div><div class="line"></div><div class="line">time.asctime(h) <span class="comment">#参数必须是时间元组，即localtime返回的值</span></div></pre></td></tr></table></figure>
<p><strong>ctime()</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>time.ctime()</div><div class="line"><span class="string">'Mon May  4 21:52:22 2015'</span></div><div class="line">    </div><div class="line"> &gt;&gt;&gt; time.ctime(<span class="number">1000000</span>)  <span class="comment">#参数是时间戳</span></div><div class="line"><span class="string">'Mon Jan 12 21:46:40 1970'</span></div></pre></td></tr></table></figure>
<p><strong>mktime()</strong>mktime()也是以时间元组为参数，但是它返回的是时间戳</p>
<p><strong>strftime()</strong>将时间元组按照指定格式要求转化为字符串。如果不指定时间元组，就默认为<code>localtime()</code>值。</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>含义</th>
<th>取值范围（格式）</th>
</tr>
</thead>
<tbody>
<tr>
<td>%y</td>
<td>去掉世纪的年份</td>
<td>00-99，如”15”</td>
</tr>
<tr>
<td>%Y</td>
<td>完整的年份</td>
<td>如”2015”</td>
</tr>
<tr>
<td>%j</td>
<td>指定日期是一年中的第几天</td>
<td>001-366</td>
</tr>
<tr>
<td>%m</td>
<td>返回月份</td>
<td>01-12</td>
</tr>
<tr>
<td>%b</td>
<td>本地简化月份的名称</td>
<td>简写英文月份</td>
</tr>
<tr>
<td>%B</td>
<td>本地完整月份的名称</td>
<td>完整英文月份</td>
</tr>
<tr>
<td>%d</td>
<td>该月的第几日</td>
<td>如5月1日返回”01”</td>
</tr>
<tr>
<td>%H</td>
<td>该日的第几时（24小时制）</td>
<td>00-23</td>
</tr>
<tr>
<td>%l</td>
<td>该日的第几时（12小时制）</td>
<td>01-12</td>
</tr>
<tr>
<td>%M</td>
<td>分钟</td>
<td>00-59</td>
</tr>
<tr>
<td>%S</td>
<td>秒</td>
<td>00-59</td>
</tr>
<tr>
<td>%U</td>
<td>在该年中的第多少星期（以周日为一周起点）</td>
<td>00-53</td>
</tr>
<tr>
<td>%W</td>
<td>同上，只不过是以周一为起点</td>
<td>00-53</td>
</tr>
<tr>
<td>%w</td>
<td>一星期中的第几天</td>
<td>0-6</td>
</tr>
<tr>
<td>%Z</td>
<td>时区</td>
<td>在中国大陆测试，返回CST，即China Standard Time</td>
</tr>
<tr>
<td>%x</td>
<td>日期</td>
<td>日/月/年</td>
</tr>
<tr>
<td>%X</td>
<td>时间</td>
<td>时:分:秒</td>
</tr>
<tr>
<td>%c</td>
<td>详细日期时间</td>
<td>日/月/年 时:分:秒</td>
</tr>
<tr>
<td>%%</td>
<td>‘%’字符</td>
<td>‘%’字符</td>
</tr>
<tr>
<td>%p</td>
<td>上下午</td>
<td>AM    or    PM</td>
</tr>
</tbody>
</table>
<p><strong>strptime()</strong>作用是将字符串转化为时间元组,其参数要指定两个，一个是时间字符串，另外一个是时间字符串所对应的格式，格式符号用上表中的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>today = time.strftime(<span class="string">"%y/%m/%d"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>today</div><div class="line"><span class="string">'15/05/05'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>time.strptime(today, <span class="string">"%y/%m/%d"</span>)</div><div class="line">time.struct_time(tm_year=<span class="number">2015</span>, tm_mon=<span class="number">5</span>, tm_mday=<span class="number">5</span>, tm_hour=<span class="number">0</span>, tm_min=<span class="number">0</span>, tm_sec=<span class="number">0</span>, tm_wday=<span class="number">1</span>, tm_yday=<span class="number">125</span>, tm_isdst=<span class="number">-1</span>)</div></pre></td></tr></table></figure>
<h2 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h2><p><code>datetime</code>模块中有几个类：</p>
<ul>
<li>datetime.date：日期类，常用的属性有year/month/day</li>
<li>datetime.time：时间类，常用的有hour/minute/second/microsecond</li>
<li>datetime.datetime：日期时间类</li>
<li>datetime.timedelta：时间间隔，即两个时间点之间的时间长度</li>
<li>datetime.tzinfo：时区类</li>
</ul>
<h3 id="date类"><a href="#date类" class="headerlink" title="date类"></a>date类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># 生成日期对象</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> datetime</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>today = datetime.date.today()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>today</div><div class="line">datetime.date(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="comment"># 操作日期对象</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> today        <span class="comment">#Python 3: print(today)</span></div><div class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-05</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> today.ctime()        <span class="comment">#Python 3: print(today.ctime())</span></div><div class="line">Tue May  <span class="number">5</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">2015</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> today.timetuple()        <span class="comment">#Python 3: print(today.timetuple())</span></div><div class="line">time.struct_time(tm_year=<span class="number">2015</span>, tm_mon=<span class="number">5</span>, tm_mday=<span class="number">5</span>, tm_hour=<span class="number">0</span>, tm_min=<span class="number">0</span>, tm_sec=<span class="number">0</span>, tm_wday=<span class="number">1</span>, tm_yday=<span class="number">125</span>, tm_isdst=<span class="number">-1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> today.toordinal()        <span class="comment">#Python 3: print(today.toordinal())</span></div><div class="line"><span class="number">735723</span></div><div class="line">    </div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> today.year</div><div class="line"><span class="number">2015</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> today.month</div><div class="line"><span class="number">5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> today.day</div><div class="line"><span class="number">5</span></div><div class="line">    </div><div class="line"><span class="comment"># 时间戳与格式化时间格式的转换</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>to = today.toordinal()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>to</div><div class="line"><span class="number">735723</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> datetime.date.fromordinal(to)</div><div class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-05</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> time</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = time.time()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t</div><div class="line"><span class="number">1430787994.80093</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> datetime.date.fromtimestamp(t)</div><div class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-05</span></div><div class="line"></div><div class="line"><span class="comment"># 修改日期。</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d1 = datetime.date(<span class="number">2015</span>,<span class="number">5</span>,<span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> d1</div><div class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-01</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d2 = d1.replace(year=<span class="number">2005</span>, day=<span class="number">5</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> d2</div><div class="line"><span class="number">2005</span><span class="number">-05</span><span class="number">-05</span></div></pre></td></tr></table></figure>
<h3 id="time类"><a href="#time类" class="headerlink" title="time类"></a>time类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># 生成time对象</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = datetime.time(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> t</div><div class="line"><span class="number">01</span>:<span class="number">02</span>:<span class="number">03</span></div><div class="line"></div><div class="line"><span class="comment"># 常用属性：</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> t.hour</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> t.minute</div><div class="line"><span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> t.second</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t.microsecond</div><div class="line"><span class="number">0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> t.tzinfo</div><div class="line"><span class="keyword">None</span></div></pre></td></tr></table></figure>
<h3 id="timedelta类"><a href="#timedelta类" class="headerlink" title="timedelta类"></a>timedelta类</h3><p>主要用来做时间的运算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">    &gt;&gt;&gt; now = datetime.datetime.now()</div><div class="line">    &gt;&gt;&gt; <span class="keyword">print</span> now        <span class="comment">#Python 3: print(now)</span></div><div class="line">    <span class="number">2015</span><span class="number">-05</span><span class="number">-05</span> <span class="number">09</span>:<span class="number">22</span>:<span class="number">43.142520</span></div><div class="line"></div><div class="line"><span class="comment"># 对`now`增加5个小时；</span></div><div class="line"></div><div class="line">    &gt;&gt;&gt; b = now + datetime.timedelta(hours=<span class="number">5</span>)</div><div class="line">    &gt;&gt;&gt; <span class="keyword">print</span> b        <span class="comment">#Python 3: print(b)</span></div><div class="line">    <span class="number">2015</span><span class="number">-05</span><span class="number">-05</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">43.142520</span></div><div class="line"></div><div class="line"><span class="comment"># 增加两周；</span></div><div class="line"></div><div class="line">    &gt;&gt;&gt; c = now + datetime.timedelta(weeks=<span class="number">2</span>)</div><div class="line">    &gt;&gt;&gt; <span class="keyword">print</span> c        <span class="comment">#Python 3: print(c)</span></div><div class="line">    <span class="number">2015</span><span class="number">-05</span><span class="number">-19</span> <span class="number">09</span>:<span class="number">22</span>:<span class="number">43.142520</span></div><div class="line"></div><div class="line"><span class="comment"># 计算时间差：</span></div><div class="line"></div><div class="line">    &gt;&gt;&gt; d = c - b</div><div class="line">    &gt;&gt;&gt; <span class="keyword">print</span> d        <span class="comment">#Python 3: print(d)</span></div><div class="line">    <span class="number">13</span> days, <span class="number">19</span>:<span class="number">00</span>:<span class="number">00</span></div></pre></td></tr></table></figure>
<h2 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h2><p><code>urllib</code>模块用于读取来自网上（服务器上）的数据，比如不少人用Python做爬虫程序，就可以使用这个模块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 在Python 2中，这样操作：</span></div><div class="line">    &gt;&gt;&gt; <span class="keyword">import</span> urllib</div><div class="line">    &gt;&gt;&gt; itdiffer =  urllib.urlopen(<span class="string">"http://www.itdiffer.com"</span>)</div><div class="line"></div><div class="line"><span class="comment"># 但是如果读者使用的是Python 3，必须换个姿势：</span></div><div class="line"></div><div class="line">    &gt;&gt;&gt; <span class="keyword">import</span> urllib.request</div><div class="line">    &gt;&gt;&gt; itdiffer = urllib.request.urlopen(<span class="string">"http://www.itdiffer.com"</span>)</div><div class="line">    </div><div class="line">    &gt;&gt;&gt; <span class="keyword">print</span> itdiffer.read() <span class="comment">#得到网页的内容</span></div></pre></td></tr></table></figure>
<h3 id="urlopen"><a href="#urlopen" class="headerlink" title="urlopen()"></a>urlopen()</h3><p><code>urlopen()</code>主要用于打开url文件，然后就获得指定url的数据，然后就如同在操作文件那样来操作,得到的对象叫做类文件对象。</p>
<p>参数说明一下：</p>
<ul>
<li>url：远程数据的路径，常常是网址</li>
<li>data：如果使用post方式，这里就是所提交的数据</li>
<li>proxies：设置代理</li>
</ul>
<h3 id="url编码、解码"><a href="#url编码、解码" class="headerlink" title="url编码、解码"></a>url编码、解码</h3><p>url对其中的字符有严格的编码要求，要对url进行编码和解码。</p>
<ul>
<li>quote(string[, safe])：对字符串进行编码。参数safe指定了不需要编码的字符</li>
<li>urllib.unquote(string) ：对字符串进行解码</li>
<li>quote_plus(string [ , safe ] ) ：与urllib.quote类似，但这个方法用’+’来替换空格<code>&#39; &#39;</code>，而quote用’%20’来代替空格</li>
<li>unquote_plus(string ) ：对字符串进行解码；</li>
<li>urllib.urlencode(query[, doseq])：将dict或者包含两个元素的元组列表转换成url参数。例如{‘name’: ‘laoqi’, ‘age’: 40}将被转换为”name=laoqi&amp;age=40”</li>
<li>pathname2url(path)：将本地路径转换成url路径</li>
<li>url2pathname(path)：将url路径转换成本地路径</li>
</ul>
<h3 id="urlretrieve"><a href="#urlretrieve" class="headerlink" title="urlretrieve()"></a>urlretrieve()</h3><p>将远程文件保存在本地存储器中.</p>
<p><code>urllib.urlretrieve(url[, filename[, reporthook[, data]]])</code></p>
<ul>
<li>url：文件所在的网址</li>
<li>filename：可选。将文件保存到本地的文件名，如果不指定，urllib会生成一个临时文件来保存</li>
<li>reporthook：可选。是回调函数，当链接服务器和相应数据传输完毕时触发本函数</li>
<li>data：可选。如果用post方式所发出的数据</li>
</ul>
<p>函数执行完毕，返回的结果是一个元组(filename, headers)，filename是保存到本地的文件名，headers是服务器响应头信息。</p>
<h2 id="urllib2"><a href="#urllib2" class="headerlink" title="urllib2"></a>urllib2</h2><p>仅仅是针对Python 2的，在Python 3中，已经没有<code>urllib2</code>这个模块了，取代它的是<code>urllib.request</code>。</p>
<p><strong>Request类</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;req = urllib2.Request(<span class="string">"http://www.itdiffer.com"</span>)</div><div class="line"></div><div class="line"><span class="comment"># Python2</span></div><div class="line">	&gt;&gt;&gt; response = urllib2.urlopen(req)</div><div class="line">	&gt;&gt;&gt; page = response.read()</div><div class="line">	&gt;&gt;&gt; <span class="keyword">print</span> page</div><div class="line"></div><div class="line">Python <span class="number">3</span>:</div><div class="line"></div><div class="line">    &gt;&gt;&gt; response = urllib.request.urlopen(req)</div><div class="line">    &gt;&gt;&gt; page = response.read()</div><div class="line">    &gt;&gt;&gt; print(page)</div></pre></td></tr></table></figure>
<p><code>urllib2</code>或者<code>urllib.request</code>的东西还很多，比如还可以:</p>
<ul>
<li>设置HTTP Proxy</li>
<li>设置Timeout值</li>
<li>自动redirect</li>
<li>处理cookie</li>
</ul>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>Python提供了多种模块来处理XML。</p>
<ul>
<li>xml.dom.* 模块：Document Object Model。适合用于处理 DOM API。它能够将XML数据在内存中解析成一个树，然后通过对树的操作来操作XML。但是，这种方式由于将XML数据映射到内存中的树，导致比较慢，且消耗更多内存。</li>
<li>xml.sax.* 模块：simple API for XML。由于SAX以流式读取XML文件，从而速度较快，切少占用内存，但是操作上稍复杂，需要用户实现回调函数。</li>
<li>xml.parser.expat：是一个直接的，低级一点的基于 C 的 expat 的语法分析器。 expat接口基于事件反馈，有点像 SAX 但又不太像，因为它的接口并不是完全规范于 expat 库的。</li>
<li>xml.etree.ElementTree (以下简称 ET)：元素树。它提供了轻量级的Python式的API，相对于DOM，ET快了很多<br>，而且有很多令人愉悦的API可以使用；相对于SAX，ET也有ET.iterparse提供了 “在空中” 的处理方式，没有必要加载整个文档到内存，节省内存。ET的性能的平均值和SAX差不多，但是API的效率更高一点而且使用起来很方便。</li>
</ul>
<p><code>ElementTree</code>在标准库中有两种实现。一种是纯Python实现：<code>xml.etree.ElementTree</code> ，另外一种是速度快一点：<code>xml.etree.cElementTree</code> 。</p>
<p>如果使用的是Python 2，可以像这样引入模块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">import</span> xml.etree.cElementTree <span class="keyword">as</span> ET</div><div class="line"><span class="keyword">except</span> ImportError:</div><div class="line">    <span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</div></pre></td></tr></table></figure>
<p>如果是Python 3以上，就没有这个必要了，只需要一句话<code>import xml.etree.ElementTree as ET</code>即可，然后由模块自动来寻找适合的方式。显然Python 3相对Python 2有了很大进步。</p>
<h3 id="常用属性和方法总结"><a href="#常用属性和方法总结" class="headerlink" title="常用属性和方法总结"></a>常用属性和方法总结</h3><p>ET里面的属性和方法不少，这里列出常用的，供使用中备查。</p>
<h4 id="Element对象"><a href="#Element对象" class="headerlink" title="Element对象"></a>Element对象</h4><p>常用属性：</p>
<ul>
<li>tag：string，元素数据种类</li>
<li>text：string，元素的内容</li>
<li>attrib：dictionary，元素的属性字典</li>
<li>tail：string，元素的尾形</li>
</ul>
<p>针对属性的操作</p>
<ul>
<li>clear()：清空元素的后代、属性、text和tail也设置为None</li>
<li>get(key, default=None)：获取key对应的属性值，如该属性不存在则返回default值</li>
<li>items()：根据属性字典返回一个列表，列表元素为(key, value）</li>
<li>keys()：返回包含所有元素属性键的列表</li>
<li>set(key, value)：设置新的属性键与值</li>
</ul>
<p>针对后代的操作</p>
<ul>
<li>append(subelement)：添加直系子元素</li>
<li>extend(subelements)：增加一串元素对象作为子元素 </li>
<li>find(match)：寻找第一个匹配子元素，匹配对象可以为tag或path</li>
<li>findall(match)：寻找所有匹配子元素，匹配对象可以为tag或path</li>
<li>findtext(match)：寻找第一个匹配子元素，返回其text值。匹配对象可以为tag或path</li>
<li>insert(index, element)：在指定位置插入子元素</li>
<li>iter(tag=None)：生成遍历当前元素所有后代或者给定tag的后代的迭代器</li>
<li>iterfind(match)：根据tag或path查找所有的后代</li>
<li>itertext()：遍历所有后代并返回text值</li>
<li>remove(subelement)：删除子元素</li>
</ul>
<h4 id="ElementTree对象"><a href="#ElementTree对象" class="headerlink" title="ElementTree对象"></a>ElementTree对象</h4><ul>
<li>find(match)</li>
<li>findall(match)</li>
<li>findtext(match, default=None)</li>
<li>getroot()：获取根节点.</li>
<li>iter(tag=None)</li>
<li>iterfind(match)</li>
<li>parse(source, parser=None)：装载xml对象，source可以为文件名或文件类型对象.</li>
<li>write(file, encoding=”us-ascii”, xml_declaration=None, default_namespace=None,method=”xml”)　</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="name">bookstore</span> <span class="attr">liu</span>=<span class="string">"a"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">"COOKING"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span>Everyday Italian<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">author</span>&gt;</span>Giada De Laurentiis<span class="tag">&lt;/<span class="name">author</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">price</span>&gt;</span>30.00<span class="tag">&lt;/<span class="name">price</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">book</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">"CHILDREN"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">author</span>&gt;</span>J K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">year</span>&gt;</span>2005<span class="tag">&lt;/<span class="name">year</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">price</span>&gt;</span>29.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">book</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">"WEB"</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span>Learning XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">author</span>&gt;</span>Erik T. Ray<span class="tag">&lt;/<span class="name">author</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">year</span>&gt;</span>2003<span class="tag">&lt;/<span class="name">year</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">price</span>&gt;</span>39.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">book</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding=utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</div><div class="line"></div><div class="line">fd = open(<span class="string">"xml.xml"</span>)</div><div class="line"></div><div class="line">data = fd.read()</div><div class="line"></div><div class="line">tree = ET.ElementTree(file=<span class="string">"xml.xml"</span>)</div><div class="line"><span class="keyword">print</span> tree</div><div class="line"></div><div class="line"><span class="comment">#获得根元素</span></div><div class="line">root = tree.getroot()</div><div class="line"><span class="keyword">print</span> root.tag</div><div class="line"><span class="keyword">print</span> root.attrib</div><div class="line"></div><div class="line"><span class="comment">#获得根元素下面的元素</span></div><div class="line"><span class="keyword">for</span> child <span class="keyword">in</span> root:</div><div class="line">    <span class="keyword">print</span> child.tag,child.attrib</div><div class="line">    <span class="keyword">for</span> gen <span class="keyword">in</span> child:</div><div class="line">        <span class="keyword">print</span> gen.tag,gen.text</div></pre></td></tr></table></figure>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON建构于两种结构：</p>
<ul>
<li>“名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。</li>
<li>值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。</li>
</ul>
<p>python标准库中有JSON模块，主要是执行序列化和反序列化功能：</p>
<ul>
<li>序列化：encoding，把一个Python对象编码转化成JSON字符串</li>
<li>反序列化：decoding，把JSON格式字符串解码转换为Python数据对象</li>
</ul>
<h3 id="encoding-dumps"><a href="#encoding-dumps" class="headerlink" title="encoding: dumps()"></a>encoding: dumps()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">data_json = json.dumps(data)</div><div class="line">json.dumps(data, sort_keys=<span class="keyword">True</span>, indent=<span class="number">2</span>) <span class="comment">#格式化输出json数据</span></div></pre></td></tr></table></figure>
<h3 id="decoding-loads"><a href="#decoding-loads" class="headerlink" title="decoding: loads()"></a>decoding: loads()</h3><h3 id="大json字符串"><a href="#大json字符串" class="headerlink" title="大json字符串"></a>大json字符串</h3><p>如果数据不是很大，上面的操作足够了。但现在是所谓“大数据”时代了，随便一个什么业务都在说自己是大数据，显然不能总让JSON很小，事实上真正的大数据，再“大”的JSON也不行了。前面的操作方法是将数据都读入内存，如果数据太大了就会内存溢出。怎么办？JSON提供了<code>load()</code>和<code>dump()</code>函数解决这个问题，注意，跟上面已经用过的函数相比，是不同的，请仔细观察。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> tempfile    <span class="comment">#临时文件模块</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>data</div><div class="line">[&#123;<span class="string">'lang'</span>: (<span class="string">'python'</span>, <span class="string">'english'</span>), <span class="string">'age'</span>: <span class="number">40</span>, <span class="string">'name'</span>: <span class="string">'qiwsir'</span>&#125;]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f = tempfile.NamedTemporaryFile(mode=<span class="string">'w+'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>json.dump(data, f)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>f.flush()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> open(f.name, <span class="string">"r"</span>).read()        <span class="comment">#Python 3: print(open(f.name, "r").read())</span></div><div class="line">[&#123;<span class="string">"lang"</span>: [<span class="string">"python"</span>, <span class="string">"english"</span>], <span class="string">"age"</span>: <span class="number">40</span>, <span class="string">"name"</span>: <span class="string">"qiwsir"</span>&#125;]</div></pre></td></tr></table></figure>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="attr">"code"</span>:<span class="number">20</span>,<span class="attr">"data"</span>:<span class="string">"liuguoquan"</span>,<span class="attr">"person"</span>:[&#123;<span class="attr">"name"</span>:<span class="string">"zhang"</span>,<span class="attr">"age"</span>:<span class="number">19</span>,<span class="attr">"sex"</span>:<span class="string">"male"</span>&#125;,&#123;<span class="attr">"name"</span>:<span class="string">"zhang"</span>,<span class="attr">"age"</span>:<span class="number">20</span>,<span class="attr">"sex"</span>:<span class="string">"male"</span>&#125;]&#125;</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding=utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.age = <span class="number">0</span></div><div class="line">        self.name = <span class="string">""</span></div><div class="line">        self.sex = <span class="string">""</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span>  </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.code = <span class="number">2</span></div><div class="line">        self.data = <span class="string">""</span></div><div class="line">        self.person = []</div><div class="line">    </div><div class="line"></div><div class="line">f = open(<span class="string">"sample.json"</span>)</div><div class="line">value = f.read();</div><div class="line"><span class="keyword">print</span> value</div><div class="line"></div><div class="line">ret = json.loads(value)</div><div class="line"><span class="keyword">print</span> type(ret)</div><div class="line"></div><div class="line">a = A()</div><div class="line"><span class="comment">#对象转为字典</span></div><div class="line">a.__dict__ = ret</div><div class="line"><span class="keyword">print</span> a.code</div><div class="line"><span class="keyword">print</span> a.data</div><div class="line"><span class="keyword">print</span> a.person</div><div class="line"><span class="keyword">print</span> type(a.person)</div><div class="line"></div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> a.person:</div><div class="line">    b = B()</div><div class="line">    b.__dict__ = item;</div><div class="line">    <span class="keyword">print</span> b.age</div><div class="line">    <span class="keyword">print</span> b.name</div><div class="line">    <span class="keyword">print</span> b.sex</div></pre></td></tr></table></figure>
<h1 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h1><h2 id="安装第三方库"><a href="#安装第三方库" class="headerlink" title="安装第三方库"></a>安装第三方库</h2><h2 id="利用源码安装"><a href="#利用源码安装" class="headerlink" title="利用源码安装"></a>利用源码安装</h2><p>在github.com网站可以下载第三方库的源码,通常会看见一个 setup.py 的文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python setup.py install</div></pre></td></tr></table></figure>
<h2 id="pip管理工具"><a href="#pip管理工具" class="headerlink" title="pip管理工具"></a>pip管理工具</h2><blockquote>
<p>pip是一个以Python计算机程序语言写成的软件包管理系统，它可以安装和管理软件包，另外不少的软件包也可以在“Python软件包索引”（英语：Python Package Index，简称PyPI）中找到。</p>
</blockquote>
<p><code>pip install XXXXXX</code>（XXXXXX代表第三方库的名字）即可安装第三方库。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2017/05/07/Python基础⑩模块/" data-id="cj6er1fxw009h6y19psdv7a5g" class="article-share-link">Share</a>
      
        <a href="http://liuguoquan727.github.io/2017/05/07/Python基础⑩模块/#ds-thread" class="article-comment-link">Kommentarer</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python基础/">Python基础</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; Forrige</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/">Neste&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">Siste innlegg</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/21/JavaScript⑦对象/">JavaScript⑦对象</a>
          </li>
        
          <li>
            <a href="/2017/06/19/JavaScript⑥引用类型RegExp/">JavaScript⑥引用类型RegExp</a>
          </li>
        
          <li>
            <a href="/2017/06/19/JavaScript⑥引用类型Global/">JavaScript⑥引用类型Global</a>
          </li>
        
          <li>
            <a href="/2017/06/19/JavaScript⑥引用类型Date/">JavaScript⑥引用类型Date</a>
          </li>
        
          <li>
            <a href="/2017/06/19/JavaScript⑥引用类型Array/">JavaScript⑥引用类型Array</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2017 刘涤生&nbsp;|&nbsp;
      Theme by <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      Contact&nbsp;|&nbsp;michaelliu0727@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/categories" class="mobile-nav-link">分类</a>
  
    <a href="/tags" class="mobile-nav-link">标签</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>
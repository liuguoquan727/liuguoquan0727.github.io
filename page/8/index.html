<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>再读斋</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="像外行一样思考,像专家一样实践。">
<meta property="og:type" content="website">
<meta property="og:title" content="再读斋">
<meta property="og:url" content="http://liuguoquan727.github.io/page/8/index.html">
<meta property="og:site_name" content="再读斋">
<meta property="og:description" content="像外行一样思考,像专家一样实践。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="再读斋">
<meta name="twitter:description" content="像外行一样思考,像专家一样实践。">
  
    <link rel="alternate" href="/atom.xml" title="再读斋" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liuguoquan727.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/categories">分类</a>
        
          <a class="main-nav-link" href="/tags">标签</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">再读斋</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">MICHAEL</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Android的线程和线程池" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/25/Android的线程和线程池/" class="article-date">
  <time datetime="2016-04-25T13:06:06.000Z" itemprop="datePublished">2016-04-25 21:06:06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/25/Android的线程和线程池/">Android的线程和线程池</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>线程在Android中是一个很重要的概念，从用途上来说，线程分为主线程和子线程，主线程主要处理和界面相关的事情，而子线程则往往用于执行耗时操作。由于Android的特性，如果在主线程中执行耗时操作那么就会导致程序无法及时地响应，因此耗时操作必须放在子线程中去执行。</p>
<p>在操作系统中，线程是操作系统调度的最小单元，同时线程又是一种受限的系统资源，即线程不可能无限制的产生，并且线程的创建和销毁都会有相应的开销。档系统中存在大量的线程时，系统会通过时间片轮转的方式调度每个线程，因此线程不可能做到绝对的并行，除非线程数量小于等于CPU核心数，一般来说这是不可能的。正确的做法是采用线程池，一个线程池会缓存一定数量的线程，通过线程池就可以避免因为频繁创建和销毁线程所带来的系统开销。</p>
<h1 id="主线程和子线程"><a href="#主线程和子线程" class="headerlink" title="主线程和子线程"></a>主线程和子线程</h1><p>Android沿用了Java的线程模型，其中的线程也分为主线程和子线程，其中主线程也叫UI线程。主线程的作用是运行四大组件以及处理它们和用户的交互，而子线程的作用则是执行耗时任务，比如网络请求、I/O操作等。从Android3.0开始系统要求网络访问必须在子线程中进行，否则网络访问将会失败并抛出NetworkOnMainThreadException这个异常，这样做事为了避免主线程由于耗时操作所阻塞而出现ANR异常。</p>
<h1 id="Android中的线程形态"><a href="#Android中的线程形态" class="headerlink" title="Android中的线程形态"></a>Android中的线程形态</h1><p>除了传统的Thread线程外，Android还提供了AsyncTask、HandlerTask以及IntentService，这三者的底层实现也是线程，但它们具有特殊的表现形式，同时在使用上也各有优缺点。</p>
<h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><p>AsyncTask是一种轻量级的异步任务类，它可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程并在主线程上更新UI。是实现上来说，<strong>AsyncTask封装了Thread和Handler</strong>，通过AsyncTask可以更加方便地执行后台任务以及在主线程中访问UI，但是AsyncTask并不适合进行特别耗时的任务，对应特别耗时的任务来说，建议使用线程池。</p>
<h3 id="AsyncTask使用"><a href="#AsyncTask使用" class="headerlink" title="AsyncTask使用"></a>AsyncTask使用</h3><p>AsyncTask是一个抽象的泛型类，它提供了Params、Progress和Result这三个泛型参数，其中Params表示输入参数的类型，Progress表示后台任务的执行进度的类型，而Result则表示后台任务返回结果的类型，如果AsyncTask确实不需要传递具体的参数，那么这三个泛型可以用Void来代替。声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>,<span class="title">Progress</span>,<span class="title">Result</span>&gt;</span></div></pre></td></tr></table></figure>
<p>AsyncTask提供了4个核心方法，它们的含义如下图所示</p>
<ol>
<li><p>onPreExecute()，在主线程中执行，在异步任务执行之前会调用此方法，一般可以用于做一些准备工作。</p>
</li>
<li><p>doInBackground(Params…params)，在线程池中执行，用于执行异步任务，params表示异步任务的输入参数。在该方法中可以通过调用publishProgress方法来更新任务的进度，因为publishProgress会调用onProgressUpdate方法。</p>
</li>
<li><p>onProgressUpdate(Progress…values)，在主线程中执行，当后台任务的执行进度发生改变时此方法会被调用。</p>
</li>
<li><p>onPostExecute(Result result)，在主线程中执行，在异步任务执行之后，次方法会被调用，其中result参数是后台任务的返回值，即doInBackground的返回值。  </p>
</li>
</ol>
<p>上述方法中，onPreExecute先执行，然后是doInBackground，最后才是onPostExecute。此外AsyncTask还提供了onCancelled()方法，它同样在主线程中执行，当异步任务被取消时，onCancelled()方法会被调用，这个时候onPostExecute则不会被调用。</p>
<p>下面代码为AsyncTask的一个应用实例： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadRecordTask</span> <span class="keyword">extends</span></span></div><div class="line">		<span class="title">AsyncTask</span>&lt;<span class="title">Object</span>, <span class="title">VideoInfo</span>, <span class="title">List</span>&lt;<span class="title">VideoInfo</span>&gt;&gt; &#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.onPreExecute();</div><div class="line">		mDescLoad.setVisibility(View.VISIBLE);</div><div class="line">		mDescLoad.setText(R.string.refreshing);</div><div class="line">		mVideoRecords.setEnabled(<span class="keyword">false</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> List&lt;VideoInfo&gt; <span class="title">doInBackground</span><span class="params">(Object... params)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		videoInfos = (ArrayList&lt;VideoInfo&gt;) MediaContentResolverUtils</div><div class="line">				.getVideoInfoList(RecordVideoActivity.<span class="keyword">this</span>);</div><div class="line"></div><div class="line">		mVideoThumbnailMap = (HashMap&lt;String, String&gt;) mVideoThumbnailDao</div><div class="line">				.findAllToMap();</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (videoInfos == <span class="keyword">null</span> || videoInfos.size() == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> videoInfos;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 没有缩略图 获取缩略图</span></div><div class="line">		<span class="keyword">for</span> (VideoInfo info : videoInfos) &#123;</div><div class="line"></div><div class="line">			String md5Name = Md5Utils.encode(info.getFileTitle());</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (!mVideoThumbnailMap.containsKey(md5Name)) &#123;</div><div class="line">				<span class="comment">//数据处理</span></div><div class="line">			&#125;</div><div class="line"></div><div class="line">			publishProgress(info);</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (isCancelled()) &#123; <span class="comment">//异步任务取消时会调用</span></div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> videoInfos;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(VideoInfo... values)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.onProgressUpdate(values);</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (VideoInfo info : values) &#123;</div><div class="line">			<span class="comment">//UI更新进度</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(List&lt;VideoInfo&gt; result)</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="comment">//取得后台任务的结果，更新UI</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 运行在UI线程，调用cancel()方法后触发，在doInBackground()方法结束后执行</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancelled</span><span class="params">(List&lt;VideoInfo&gt; result)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.onCancelled(result);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行和取消该任务的代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mLoadRecordTask = <span class="keyword">new</span> LoadRecordTask();</div><div class="line">mLoadRecordTask.execute();</div><div class="line">mLoadRecordTask.cancel(<span class="keyword">true</span>); <span class="comment">//结束任务</span></div></pre></td></tr></table></figure>
<h3 id="AsyncTask条件限制"><a href="#AsyncTask条件限制" class="headerlink" title="AsyncTask条件限制"></a>AsyncTask条件限制</h3><ul>
<li>AsyncTask的类必须在主线程中加载</li>
<li>AsyncTask的对象必须在主线程中创建</li>
<li>execute方法必须在UI线程调用</li>
<li>不要在程序中直接调用onPreExecute()、onPostExecute()、doInBackgroud()和onProgressUpdate()</li>
<li>一个AsyncTask对象只能执行一次，即只能调用一次execute方法，否则会报运行时异常</li>
<li>在Android1.6之前，AsyncTask是串行执行任务的，Android1.6的时候AsyncTask开始采用线程池里处理并行任务，但从Android3.0开始，为了避免AsyncTask所带来的并发错误，AsyncTask又采用一个线程来串行执行任务。<strong>尽管如此，在Android3.0及以后版本中，我们仍然可以通过AsyncTask的executeOnExecutor方法（不能向下兼容）来并行的执行任务</strong></li>
</ul>
<h3 id="AsyncTask工作原理"><a href="#AsyncTask工作原理" class="headerlink" title="AsyncTask工作原理"></a>AsyncTask工作原理</h3><p>我们从AsyncTask的execute方法开始分析，execute方法又会调用ecuteOnExecutor方法，它们的实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></div><div class="line">        Params... params) &#123;</div><div class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</div><div class="line">        <span class="keyword">switch</span> (mStatus) &#123;</div><div class="line">            <span class="keyword">case</span> RUNNING:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span> <span class="comment">//异步任务执行一次</span></div><div class="line">                        + <span class="string">" the task is already running."</span>); </div><div class="line">            <span class="keyword">case</span> FINISHED:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span> <span class="comment">//异步任务执行一次</span></div><div class="line">                        + <span class="string">" the task has already been executed "</span></div><div class="line">                        + <span class="string">"(a task can be executed only once)"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mStatus = Status.RUNNING;</div><div class="line"></div><div class="line">    onPreExecute(); <span class="comment">//最先执行</span></div><div class="line"></div><div class="line">    mWorker.mParams = params;</div><div class="line">    exec.execute(mFuture); <span class="comment">//线程池开始执行</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中，sDefaultExecutor实际上是一个串行的线程池，<strong>一个进程中所有的AsyncTask全部在这个串行的线程池中排队执行</strong>。在executeOnExecutor方法中，AsyncTask的onPreExecute()最先执行，然后线程池开始执行。下面分析线程池的执行过程，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">       mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">           <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">               Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">               <span class="comment">//noinspection unchecked</span></div><div class="line">               <span class="keyword">return</span> postResult(doInBackground(mParams));</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line">	</div><div class="line">	<span class="comment">//将AsyncTask的Params参数封装到FutureTask对象中，FutureTask的run方法会调用mWorker的call方法</span></div><div class="line">       mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   postResultIfNotInvoked(get());</div><div class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                   android.util.Log.w(LOG_TAG, e);</div><div class="line">               &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occured while executing doInBackground()"</span>,</div><div class="line">                           e.getCause());</div><div class="line">               &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                   postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors(); <span class="comment">//CPU核心数</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = CPU_COUNT + <span class="number">1</span>; <span class="comment">//核心工作线程</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">//最多工作线程</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE = <span class="number">1</span>; <span class="comment">//空闲线程的超时时间为1秒</span></div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR</div><div class="line">           = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</div><div class="line">                   TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();  </div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</div><div class="line"></div><div class="line"><span class="comment">//实现一个线程池</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">       <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</div><div class="line">       Runnable mActive;</div><div class="line"></div><div class="line">	<span class="comment">//线程同步</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</div><div class="line">		<span class="comment">//将任务r插入mTasks任务队列中</span></div><div class="line">           mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                   <span class="keyword">try</span> &#123;</div><div class="line">                       r.run(); <span class="comment">//执行任务</span></div><div class="line">                   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                       scheduleNext(); <span class="comment">//继续执行下一个任务</span></div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;);</div><div class="line">		</div><div class="line">		<span class="comment">//没有真正活动的AsyncTask时调用</span></div><div class="line">           <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</div><div class="line">               scheduleNext(); </div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">               THREAD_POOL_EXECUTOR.execute(mActive); <span class="comment">//真正执行任务</span></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>从SerialExecutor的实现可以分析AsyncTask的排队执行情况。首先系统会将AsyncTask的Params参数封装到FutureTask对象中，FutureTask是一个并发类，在这里它充当了Runnable的作用(FutureTask实现了Runnable方法)。接着这个FutureTask即mFuture会交给SerialExecutor的execute方法去处理。SerialExecutor的execute方法首先会把FutureTask对象添加到任务队列mTasks中，如果当前没有正在活动的AsyncTask任务，那么就会调用SerialExecutor的scheduleNext方法来执行下一个AsyncTask任务，否则等待当前AsyncTask任务完成再继续执行新的AsyncTask任务，直到所有的AsyncTask任务执行完毕。<strong>从这可以看出，AsyncTask是串行执行任务的</strong></p>
<p>AsyncTask中有两个线程池（SerialExecutor和THREAD_POOL_EXECUTOR）和一个Handler（InternalHandler），其中线程池SerialExecutor用于执行任务的排队，线程池THREAD_POOL_EXECUTOR用于真正地执行AsyncTask任务，InternalHandler用于将执行环境从线程池切换到主线程。在AsyncTask的构造方法中有如下这么一段代码，由于FutureTask的run方法调用mWorker的call方法，因此mWorker的call方法最终会在线程池中执行。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            mTaskInvoked.set(<span class="keyword">true</span>); <span class="comment">//表示当前任务以及调用过了</span></div><div class="line"></div><div class="line">            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">            <span class="comment">//noinspection unchecked</span></div><div class="line">            <span class="keyword">return</span> postResult(doInBackground(mParams)); <span class="comment">//执行doInBackground方法</span></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">	</div><div class="line">	<span class="comment">//将AsyncTask的Params参数封装到FutureTask对象中，FutureTask的run方法会调用mWorker的call方法</span></div><div class="line">    mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                postResultIfNotInvoked(get());</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                android.util.Log.w(LOG_TAG, e);</div><div class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occured while executing doInBackground()"</span>,</div><div class="line">                        e.getCause());</div><div class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在mWorker的call方法中，首先将mTaskInvoked设为true，表示当前任务以及被调用了，然后执行AsyncTask的doInBackground方法，接着将其返回值传递给postResult方法，它的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</div><div class="line">    message.sendToTarget();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的代码中，postResult方法会通过sHandler发送一个MESSAGE_POST_RESULT的消息，这个sHandler的定义如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> InternalHandler sHandler;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">synchronized</span> (AsyncTask.class) &#123;</div><div class="line">           <span class="keyword">if</span> (sHandler == <span class="keyword">null</span>) &#123;</div><div class="line">               sHandler = <span class="keyword">new</span> InternalHandler();</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> sHandler;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(Looper.getMainLooper());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</div><div class="line">                <span class="comment">// There is only one result</span></div><div class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</div><div class="line">                result.mTask.onProgressUpdate(result.mData);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现，sHandler是一个静态的Handler类对象，为了能够将执行环境切换到主线程，这就sHandler这个对象必须在主线程中创建。<strong>由于静态成员会在加载类的时候进行初始化，因此这就变相要求AsyncTask的类必须在主线程中加载，否则同一进程中的AsyncTask都将无法正常工作</strong>。sHandler收到sHandlerMESSAGE_POST_PROGRESS会调用onProgressUpdate方法更新进度，收到MESSAGE_POST_RESULT这个消息后会调用AsyncTask的finish方法，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</div><div class="line">        onCancelled(result);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        onPostExecute(result);</div><div class="line">    &#125;</div><div class="line">    mStatus = Status.FINISHED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AsyncTask的finish方法会判断AsyncTask是否取消执行了，是则调用onCancelled方法，否则调用onPostExecute(result)，此时doInBackground的返回结果会传递给onPostExecute方法，最后将任务状态mStatus置为完成。至此AsyncTask的整个过程就分析完成了。</p>
<p><strong>通过分析AsyncTask的源码，可以进一步确定，从Android3.0开始，默认情况下AsyncTask的确是串行执行。</strong>我们仍然可以通过AsyncTask的executeOnExecutor方法（不能向下兼容）来并行的执行任务。</p>
<h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><p>HandlerThread继承了Thread，它是一种可以使用Handler的Thread，它的实现也很简单，就是在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许HandlerThread中创建Handler。HandlerThread的run方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">	mTid = Process.myTid();</div><div class="line">	Looper.prepare();</div><div class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">		mLooper = Looper.myLooper();</div><div class="line">		notifyAll();</div><div class="line">	&#125;</div><div class="line">	Process.setThreadPriority(mPriority);</div><div class="line">	onLooperPrepared();</div><div class="line">	Looper.loop();</div><div class="line">	mTid = -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从HandlerThread的实现来看，它和普通的Thread有显著的不同之处。普通Thread主要同于run方法中执行一个耗时任务，而HandlerThread在内部创建了消息队列，外界需要通过Handler的消息方式来通知HandlerThread执行一个具体任务。HandlerThread是个很有用的类，它在Android中的一个具体的使用场景是IntentService。由于HandlerThread的run方法是一个无限循环，因此当明确不需要再使用HandlerThread时，可以通过它的quit或者quitSafely方法来终止线程的执行，这是一个好的编程习惯。示例代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThreadDemo</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Looper mLooper;</div><div class="line">	<span class="keyword">private</span> MyHandlerThread mHandlerThread;</div><div class="line">	<span class="keyword">private</span> TextView mInfoTxt;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Handler mHandler;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_thread);</div><div class="line">		</div><div class="line">		mInfoTxt  = (TextView) findViewById(R.id.tv_info);</div><div class="line">		</div><div class="line">		mHandlerThread = <span class="keyword">new</span> MyHandlerThread(<span class="string">"mHandlerThread"</span>);</div><div class="line">		mHandlerThread.start(); <span class="comment">//先start</span></div><div class="line">		mLooper = mHandlerThread.getLooper();</div><div class="line">		</div><div class="line">		<span class="comment">//注册到Handler，通过Handler发送消息</span></div><div class="line">		mHandler = <span class="keyword">new</span> Handler(mLooper,mHandlerThread);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">		</div><div class="line">		mHandler.sendEmptyMessage(<span class="number">1</span>);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandlerThread</span> <span class="keyword">extends</span> <span class="title">HandlerThread</span> <span class="keyword">implements</span> <span class="title">Callback</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyHandlerThread</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">			<span class="keyword">super</span>(name);</div><div class="line">			<span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			</div><div class="line">			<span class="keyword">if</span> (msg.what == <span class="number">1</span>) &#123;</div><div class="line">				System.out.println(<span class="string">"mHandlerThread"</span>);</div><div class="line">				mInfoTxt.setText(<span class="string">"mHandlerThread"</span>);</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>IntentService是一种特殊的Service，它继承了Service并且它是一个抽象类，因此必须创建它的子类才能使用IntentService。IntentService可用于执行后台耗时的后台，当任务执行后它会自动停止，同时由于IntentService是服务的原因，这导致它的优先级比单纯的线程要高很多，所以IntentService比较适合执行一些高优先级的后台任务，因为它的优先级高不容易被系统杀死。在实现上，IntentService封装了HandlerThread和Handler，这一点可以在它的onCreate方法中看出来，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> It would be nice to have an option to hold a partial wakelock</span></div><div class="line">    <span class="comment">// during processing, and to have a static startService(Context, Intent)</span></div><div class="line">    <span class="comment">// method that would launch the service &amp; hand off a wakelock.</span></div><div class="line"></div><div class="line">    <span class="keyword">super</span>.onCreate();</div><div class="line">    HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</div><div class="line">    thread.start();</div><div class="line"></div><div class="line">    mServiceLooper = thread.getLooper();</div><div class="line">    mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当IntentService被第一次启动时，它的onCreate方法会被调用，onCreate方法会创建一个HandlerThread，然后使用它的Looper来构造一个Handler对象mServiceHandler，这样通过mServiceHandler发送的消息最终都会在HandlerThread中执行，从这个角度来看，IntentService也可以用于执行后台任务。<strong>每次启动IntentService，它的onStartCommand方法就会调用一次</strong>，IntentService在onStartCommand中处理每个后台任务的Intent。下面看一下onStartCommand方法是如何处理外界Intent的，onStartCommand调用了onStart，onStart方法的实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">	Message msg = mServiceHandler.obtainMessage();</div><div class="line">	msg.arg1 = startId;</div><div class="line">	msg.obj = intent;</div><div class="line">	mServiceHandler.sendMessage(msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，IntentService仅仅是通过mServiceHandler发送了一个消息，这个消息会在HandlerThread中去处理。mServiceHandler收到消息后，会将Intent对象对象传递给onHandleIntent方法去处理。注意这个Intent对象的内容和外界的startService(intent)中的intent的内容是完全一致的，通过这个Intent对象即可解析出外界启动IntentService时所传递的参数，通过这些参数就可以区分具体的后台任务，这样在onHandleIntent方法中就可以对不同的后台任务做处理了。当onHandleIntent方法执行结束后，IntentService会通过stopSelf（int startId）来尝试停止服务。<strong>这里之所以采用stopSelf（int startId）而不是stopSelf（）来停止服务，是因为stopSelf（）会立刻停止服务，而这个时候还可能有其他消息未处理，stopSelf（int startId）则会等待所有的消息都处理完毕后才终止服务</strong>。一般来说，stopSelf（int startId）在尝试停止服务之前会判断最近启动服务的次数是否和startId相等，如果相等就立刻停止服务，不相等则不停止服务，这个策略可以从AMS的stopServiceToken方法的实现中找到依据。ServiceHandler的实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(looper);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">		onHandleIntent((Intent)msg.obj);</div><div class="line">		stopSelf(msg.arg1);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>IntentService的onHandleIntent方法是一个抽象方法，它需要我们在子类中实现，它的作用是从Intent参数中区分具体的任务并执行这些任务。如果目前只存在一个后台任务，那么onHandleIntent(Intent)方法执行完这个任务后，stopSelf（int startId）就会直接停止服务；如果目前存在多个后台任务，那么当onHandleIntent方法执行完最后一个任务时，stopSelf（int startId）才会直接停止服务。另外，由于没执行一个后台任务就必须启动一次IntentService，而IntentService内部则通过消息的方式向HandlerThread请求执行任务，Handler中的Looper是顺序处理消息的，这就意味着IntentService也是顺序执行后台任务，当有多个后台任务同时存在时，这些后台任务会按照外界发起的顺序排队执行。</p>
<p>下面通过一个示例来说明IntentService的工作方式，首先派生一个IntentService的子类，它的实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LocalIntentService</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(<span class="string">"LocalIntentService"</span>);</div><div class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(<span class="string">"onStartCommand"</span>);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		String action = intent.getStringExtra(<span class="string">"task"</span>);</div><div class="line">		System.out.println(<span class="string">"action: "</span> + action);</div><div class="line">		SystemClock.sleep(<span class="number">3000</span>); <span class="comment">//休眠模拟耗时的后台任务</span></div><div class="line">		<span class="keyword">if</span> (action.equals(<span class="string">"task1"</span>)) &#123;</div><div class="line">			System.out.println(<span class="string">"handle action: "</span> + action);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (action.equals(<span class="string">"task2"</span>)) &#123;</div><div class="line">			System.out.println(<span class="string">"handle action: "</span> + action);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (action.equals(<span class="string">"task3"</span>)) &#123;</div><div class="line">			System.out.println(<span class="string">"handle action: "</span> + action);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(<span class="string">"onDestroy"</span>);</div><div class="line">		<span class="keyword">super</span>.onDestroy();</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LocalIntentService实现完成以后，就可以在外界请求执行后台任务了，下面在Activity中发起3个后台任务的请求，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Intent service = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, LocalIntentService.class);</div><div class="line">service.putExtra(<span class="string">"task"</span>, <span class="string">"task1"</span>);</div><div class="line">startService(service);</div><div class="line">service.putExtra(<span class="string">"task"</span>, <span class="string">"task2"</span>);</div><div class="line">startService(service);</div><div class="line">service.putExtra(<span class="string">"task"</span>, <span class="string">"task3"</span>);</div><div class="line">startService(service);</div></pre></td></tr></table></figure>
<p>运行程序，观察日记如下</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">22</span>:<span class="number">14</span>:<span class="number">19.407</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): onStartCommand</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">19.407</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): action: task1</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">19.407</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): onStartCommand</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">19.408</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): onStartCommand</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">22.407</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): handle action: task1</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">22.409</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): action: task2</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">25.410</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): handle action: task2</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">25.418</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): action: task3</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">28.418</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): handle action: task3</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">28.429</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): onDestroy</div></pre></td></tr></table></figure>
<p>从日志可以看出，三个后台任务是排队执行的，它们的执行顺序就是它们发起请求对的顺序。当task3执行完毕后，LocalIntentService才真正地停止，执行了onDestroy方法。</p>
<h1 id="Android中的线程池"><a href="#Android中的线程池" class="headerlink" title="Android中的线程池"></a>Android中的线程池</h1><p>线程池的有点主要有三点：</p>
<ul>
<li><p>重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销</p>
</li>
<li><p>能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致的阻塞现象。</p>
</li>
<li><p>能够对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。</p>
</li>
</ul>
<p>Android中的线程池概念来源于Java中的Executor，Executor是一个接口，真正的线程池的实现为ThreadPoolExecutor。ThreadPoolExecutor提供了一系列参数来配置线程池，通过不同的参数可以创建不同的线程池。由于Android中的线程池都是直接或者间接通过配置ThreadPoolExecutor来实现的，因此需要先介绍ThreadPoolExecutor。</p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>ThreadPoolExecutor是线程池的真正实现，它的构造方法提供了一系列参数来配置线程池，下面介绍ThreadPoolExecutor的构造方法中各个参数的含义，这些参数将会直接影响到线程池的功能特性，下面是ThreadPoolExecutor的一个比较常用的构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                          <span class="keyword">int</span> maximumPoolSize,</div><div class="line">                          <span class="keyword">long</span> keepAliveTime,</div><div class="line">                          TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                          ThreadFactory threadFactory) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>corePoolSize</strong>  </li>
</ul>
<p>线程池的核心线程数，默认情况下，核心线程会在线程池中一直存活，即使他们处于闲置状态。如果将ThreadPoolExecutor的allowCoreThreadTimeout属性设置为true，那么闲置的核心线程在等待新任务到来会有超时策略，这个时间间隔由keepAliveTime所指定，当等待时间超时keepAliveTime所指定的时长后，核心线程会被终止。</p>
<ul>
<li><strong>maximumPoolSize</strong></li>
</ul>
<p>线程池所能容纳的最大线程数，当活动线程达到这个数值后，后续的新任务将会被阻塞。</p>
<ul>
<li><strong>keepAliveTime</strong></li>
</ul>
<p>非核心线程闲置时的超时时长，超过这个时间，非核心线程就会被收回。当ThreadPoolExecutor的allowCoreThreadTimeout属性设置为true时，keepAliveTime同样会作用于核心线程。</p>
<ul>
<li><strong>unit</strong></li>
</ul>
<p>用于指定keepAliveTime参数的时间单位，这是一个枚举，常用的有TimeUnit.MILLISECONDS;TimeUnit.SECONDS;TimeUnit.MINUTES等</p>
<ul>
<li><strong>workQueue</strong></li>
</ul>
<p>线程池的任务队列，通过线程池的execute方法提交的Runnable对象会存储在这个参数中。</p>
<ul>
<li><strong>ThreadFactory</strong></li>
</ul>
<p>线程工厂，为线程池提供创建新线程的功能。ThreadFactory是一个接口，它只有一个方法：Thread newThread(Runnable r);</p>
<p>除上面的这些主要的参数外，ThreadPoolExecutor还有一个不常用的参数RejectedExecutionHandler。当线程池无法执行新的任务时，这可能是由于任务队列已满或者是无法成功执行任务，这个时候ThreadPoolExecutor回调用RejectedExecutionHandler的rejectedExecution(Runnable r, ThreadPoolExecutor executor)方法来通知调用者，默认情况下rejectedExecution会直接抛出一个RejectedExecutionException的运行时异常。ThreadPoolExecutor为RejectedExectutionHandler提供了几个可选值：CallerRunsPolicy、AbortPolicy、DiscardPolicy、DiscardOldestPolicy，其中AbortPolicy是默认值，但是RejectedExecutionHandler这个参数不常用。</p>
<p>ThreadPoolExecutor执行任务时大致遵循如下规则：</p>
<ul>
<li><p>如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务</p>
</li>
<li><p>如果线程池中的线程数量已经达到或超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行。</p>
</li>
<li><p>如果在步骤2中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务。</p>
</li>
<li><p>如果步骤3中线程数量已经达到线程池中规定的最大值，那么就拒绝执行此任务，ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution方法来通知调用者。</p>
</li>
</ul>
<p>ThreadPoolExecutor的参数配置在AsyncTask中有明显的体现，下面是AsyncTask中的线程池配置情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors();</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = CPU_COUNT + <span class="number">1</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AsyncTask #"</span> + mCount.getAndIncrement());</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =</div><div class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">128</span>);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * An &#123;<span class="doctag">@link</span> Executor&#125; that can be used to execute tasks in parallel.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR</div><div class="line">        = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</div><div class="line">                TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</div></pre></td></tr></table></figure>
<p>AsyncTask线程池配置后的规格如下：</p>
<ul>
<li>核心线程数等于CPU核心数+1</li>
<li>线程池的最大线程数为CPU的核心数的2倍 + 1</li>
<li>核心线程无超时机制，非核心线程在闲置时的超时时间为1秒</li>
<li>任务队列的容量为128</li>
</ul>
<h2 id="线程池的分类"><a href="#线程池的分类" class="headerlink" title="线程池的分类"></a>线程池的分类</h2><ul>
<li><strong>FixedThreadPool</strong></li>
</ul>
<p>通过Executors的newFixedThreadPool方法来创建。它是一种线程数量固定的线程池，当线程处于空闲状态时，它们并不会被收回，除非线程池关闭了。当所有的线程都处于活动状态时，新任务都会处于等待状态，直到有线程空闲出来。由于FixedThreadPool只有核心线程并且这些核心线程都不会被回收，<strong>这意味着它能够更加快速的响应外界的请求</strong>。实现如下，可以发现FixedThreadPool中只有核心线程并且这些核心线程没有超时机制，另外任务队列也是没有大小限制的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">    * @param nThreads the number of threads in the pool</div><div class="line">    * @return the newly created thread pool</div><div class="line">    * </div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                     <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                     <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>CachedThreadPool</strong></li>
</ul>
<p>通过Executors的newCachedThreadPool方法来创建。它是一种线程数量不定的线程池，它只有非核心线程，并且最大线程数为Integer.MAX_VALUE。由于Integer.MAX_VALUE是一个很大的数，实际上就相当于最大线程数可以任意大。当线程池中的线程都处于活动状态时，线程池会创建新的线程来处理新任务，否则就会利用空闲的线程来处理新的任务。线程池中的空闲线程都有超时机制，这个超时时长为60秒，超过60秒闲置线程就会被回收。和FixedThreadPool不同的是，CachedThreadPool的任务队列其实相当于一个空集合，这将导致任何任务都会立即被执行，因为这种情况下SynchronousQueue是无法插入任务的。SynchronousQueue是一个非常特殊的队列，很多情况下可以理解为一个无法存储元素的队列（实际中很少使用）。从CachedThreadPool的特性来看<strong>这类线程池比较适合执行大量的耗时较少的任务</strong>。当整个线程池都处于闲置状态时，线程池中的线程都会超时而被停止，这个时候CachedThreadPool之中是没有任何线程的，它几乎不占用任何系统资源的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</div><div class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>ScheduledThreadPoll</strong></li>
</ul>
<p>通过Executors的newScheduledThreadPool方法来创建。它的核心线程数量是固定的，而非核心线程数量是没有限制的，并且当核心线程闲置时会被立即收回。ScheduledThreadPoll这类线程<strong>主要用于执行定时任务和具有固定周期的重复任务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">								   ThreadFactory threadFactory) &#123;</div><div class="line">	<span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</div><div class="line">		  <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>SingleThreadExecutor</strong></li>
</ul>
<p>通过Executors的newSingleThreadExecutor方法来创建。这类线程池内部只有一个核心线程，它确保所有的任务都在同一个线程中顺序执行。SingleThreadExecutor的意义在于统一所有的外界任务到一个线程中，这使得在这些任务之间不需要处理线程同步的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</div><div class="line">		(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</div><div class="line">								<span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">								<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2016/04/25/Android的线程和线程池/" data-id="cj6esnzc8002kwg1949mtybs3" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2016/04/25/Android的线程和线程池/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android系统/">Android系统</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Android的IPC方式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/19/Android的IPC方式/" class="article-date">
  <time datetime="2016-04-19T14:49:47.000Z" itemprop="datePublished">2016-04-19 22:49:47</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/19/Android的IPC方式/">Android的IPC方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h1><p>四大组件中的三大组件（Activity、Service、BroadcastReceiver）都是支持在Intent中传递Bundle数据的，由于Bundle实现了Parcelable接口，所以它可以方便地在不同的进程间传输，基于这一点，当我们在一个进程中启动了另一个进程的Activity、Service和BroadcastReceiver，我们就可以在Bundle中附加我们需要传输给远程进程的信息并通过Intent发送出去。当然，我们传输的数据必须能够被序列化，比如基本类型、实现了Parcelable接口的对象、实现了Serializable接口的对象以及一些Android所支持的特殊对象（如Bundle、Size、SizeF、IBinder）。</p>
<h1 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h1><p>共享文件也是一种不错的进程间通信方式，两个进程提供读/写同一个文件来交换数据，比如A进程把数据写入文件，B进程提供读取这个文件来获取数据。通过文件交换数据很好使用，除了可以交换一些文本信息外，我们还可以序列化一个对象到文件中，从另一进程中恢复这个对象。</p>
<p>通过文件共享方式来共享数据对文件格式是没有具体要求的，比如可以是文本文件，也可以是XML文件，只要读写双方约定数据格式即可。通过文件共享的方式是有局限性的，比如并发读/写的问题，因此我们要尽量避免并发写这种情况的发生或者考虑使用线程同步来限制多个线程的写操作。通过上面的分析可以知道，<strong>文件共享方式适合在对数据同步要求不高的进程之间进行通信</strong>，并且要妥善处理并发读/写的问题。</p>
<p>SharedPreference是个特例，SharedPreference是Android中提供的轻量级存储方案，它通过键值对的方式来存储数据，在底层实现上采用XML文件来存储键值对，每个应用的SharedPreference文件都可以在当前包所在的data目录下查到，一般来说，它的目录位于/data/data/package name/shared_prefs目录下。<strong>从本质上来说，</strong>SharedPreference属于文件的一种，但是由于系统对它的读/写有一定的缓存策略2，即在内存中会有一份SharedPreference文件的缓存。因此在多进程模式下，系统对它的读/写变得不可靠，当面对搞并发的读/写访问时，SharedPreference有很大几率会丢失数据，因此不建议在进程间通信中使用SharedPreference。</p>
<h1 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h1><p>Messenger可以翻译为信使，通过它可以在不同进程中传递Message对象，在Message中放入我们需要传递的数据，就可以轻松实现数据的进程间传递,也可以在同一个进程中使用。Messenger是一种轻量级的IPC方案，它的底层实现是AIDL。Messenger类的构造方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(Handler target)</span> </span>&#123;</div><div class="line">	mTarget = target.getIMessenger();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(IBinder target)</span> </span>&#123;</div><div class="line">	mTarget = IMessenger.Stub.asInterface(target);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Messenger使用简单，它对AIDL做了封装。同时，由于它一次处理一个请求，因此在服务端我们不用考虑线程同步的问题，这是因为服务端不存在并发执行的情形。实现一个Messenger由如下几个步骤，分为服务端和客户端。</p>
<ul>
<li><strong>1. 服务端进程</strong></li>
</ul>
<p>首先，我们需要在服务端创建一个Service来处理客户端的连接请求，同时创建一个Handler，并通过它来创建一个Messenger对象，然后在Service的onBind中返回这个Messenger对象底层的Binder即可。</p>
<ul>
<li><strong>2. 客户端进程</strong></li>
</ul>
<p>客户端进程中，首先要绑定服务端的Servcie，绑定成功后用服务端返回的IBinder对象创建一个Messenger，通过这个Messenger就可以向服务器发送消息了，发送消息类型为Message对象。如果需要服务端回应客户端蛮久和服务端一样，我们还需要创建一个Handler并创建一个新的Messenger，并把这个Messenger对象通过Messge的replyTo参数传递给服务端，服务端通过这个replyTo参数就可以回应客户端。</p>
<p>首先是服务端的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="comment">//1.创建Handler对象处理Message</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			<span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">			</div><div class="line">			<span class="keyword">case</span> Constants.MSG_FROM_CLIENT:</div><div class="line">				</div><div class="line">				System.out.println(<span class="string">"receiver msg from client: "</span> + msg.getData().get(<span class="string">"msg"</span>));</div><div class="line">				</div><div class="line">				<span class="comment">//返回信息到服务端</span></div><div class="line">				<span class="comment">//获取客户端接收消息的Messenger</span></div><div class="line">				Messenger client = msg.replyTo;</div><div class="line">				Message replyMessage = Message.obtain();</div><div class="line">				replyMessage.what = Constants.MSG_FROM_SERVER;</div><div class="line">				Bundle data = <span class="keyword">new</span> Bundle();</div><div class="line">				data.putString(<span class="string">"reply"</span>, <span class="string">"嗯，你的消息我已经收到!"</span>);</div><div class="line">				replyMessage.setData(data);</div><div class="line">				</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					client.send(replyMessage);</div><div class="line">				&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">					<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">				<span class="keyword">break</span>;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			</div><div class="line">			<span class="keyword">super</span>.handleMessage(msg);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//2.创建一个Messenger,将客户端发送的消息传递给MessengerHandler处理</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Messenger mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHandler());</div><div class="line"></div><div class="line">	<span class="comment">//3.返回Messenger对象底层Binder</span></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> mMessenger.getBinder();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，注册Service</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;service</div><div class="line">    android:name="com.ryg.chapter_2.messenger.MessengerService"</div><div class="line">    android:process=":remote" &gt;</div><div class="line">&lt;/service&gt;</div></pre></td></tr></table></figure>
<p>最后是客户端代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Messenger mService;</div><div class="line">	</div><div class="line">	<span class="comment">//将服务端返回的消息传递MessengerHandler处理</span></div><div class="line">	<span class="keyword">private</span> Messenger mGetReplyMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHandler());</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			</div><div class="line">			<span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">			</div><div class="line">			<span class="keyword">case</span> Constants.MSG_FROM_SERVER:</div><div class="line">				</div><div class="line">				System.out.println(<span class="string">"receiv msg from server: "</span> + msg.getData().getString(<span class="string">"reply"</span>));</div><div class="line">				</div><div class="line">				<span class="keyword">break</span>;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			<span class="keyword">super</span>.handleMessage(msg);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			<span class="comment">//2.创建一个Messenger</span></div><div class="line">			mService = <span class="keyword">new</span> Messenger(service);</div><div class="line">			</div><div class="line">	    	<span class="comment">//3.通过Messenger发送Message消息到服务端</span></div><div class="line">	    	<span class="keyword">if</span> (mService != <span class="keyword">null</span>) &#123;</div><div class="line">				Message msg = Message.obtain();</div><div class="line">				msg.what = Constants.MSG_FROM_CLIENT;</div><div class="line">				Bundle data = <span class="keyword">new</span> Bundle();</div><div class="line">				data.putString(<span class="string">"msg"</span>, <span class="string">"hello,this is client"</span>);</div><div class="line">				msg.setData(data);</div><div class="line">				</div><div class="line">				<span class="comment">//将接收服务端回复的Messenger传递给服务端，必须要传递过去，否则收不到回复</span></div><div class="line">				msg.replyTo = mGetReplyMessenger;</div><div class="line">				</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					mService.send(msg);</div><div class="line">				&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">					<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        </div><div class="line">        <span class="comment">//1.绑定服务</span></div><div class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MessengerService.class);</div><div class="line">        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    	<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">    	<span class="keyword">if</span> (mConnection != <span class="keyword">null</span>) &#123;</div><div class="line">			</div><div class="line">    		unbindService(mConnection);</div><div class="line">		&#125;</div><div class="line">    	<span class="keyword">super</span>.onDestroy();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> <span class="number">13</span>:<span class="number">20</span>:<span class="number">43.218</span>: I/System.<span class="keyword">out</span>(<span class="number">3280</span>): receiver msg <span class="keyword">from</span> client: hello,<span class="keyword">this</span> <span class="keyword">is</span> client</div><div class="line"><span class="number">01</span><span class="number">-11</span> <span class="number">13</span>:<span class="number">20</span>:<span class="number">43.234</span>: I/System.<span class="keyword">out</span>(<span class="number">3222</span>): receiv msg <span class="keyword">from</span> server: 嗯，你的消息我已经收到!</div></pre></td></tr></table></figure>
<p>通过上面的例子可以看出，在Messenger中进行数据传递必须将数据放入Message中，而Messenger和Message都实现了Parcelable接口，因此可以跨进程传输。简单来说，Message中所支持的数据类型就是Messenger中所支持的传输类型。实际上，通过Messenger来传输Message，Message中能使用的载体只有what、arg1、arg2、Bundle以及reply。Message中的另一个字段object在同一进程中的很实用的，但是再进程间通信的时候，在Android2.2以前object字段不支持跨进程传输，即便是android2.2以后，也仅仅是系统提供的实现了Parcelable接口的对象才能通过它来传输，这就意味着我们自定义的Parcelable对象无法通过object字段来传输。因此使用Bundle可以支持大量的数据类型。</p>
<h1 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h1><p>Messenger是以串行的方式处理客户端发来的消息，如果大量的消息同时发送到服务器，服务端仍然只能一个一个处理,（1）如果有大量的并发请求，那么用Messenger就不太合适了。同时，Messenger的作用仅仅是为了传递消息，（2）很多时候我们可能需要跨进程调用服务端的方法，这种情形用Messenger就无法做到了，但是我们可以使用AIDL来实现跨进程的方法调用。</p>
<p>下面介绍使用AIDL来进行进程间通信的流畅，分为服务端和客户端两个方面</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>服务端要首先创建一个Service用来监听客户端的连接，然后创建一个AIDL文件，将暴露给客户端的接口再这个AIDL文件中声明，最后在Service中实现这个AIDL接口。</p>
<p>（1）AIDL接口的创建<br>创建一个后缀为aidl的文件，在里面声明了一个接口和两个接口方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//IBookManager.aidl</span></div><div class="line"></div><div class="line"><span class="keyword">package</span> com.ryg.chapter_2.aidl;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.ryg.chapter_2.aidl.Book;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在AIDL文件中，并不是所有的数据类型都是可以使用的，AIDL到底支持哪些数据类型呢？如下所示</p>
<ul>
<li>基本数据类型</li>
<li>String和CharSequence</li>
<li>List：只支持ArrayList，并且里面的每个元素必须能够被AIDL支持</li>
<li>Map： 只支持HashMap，并且里面的每个元素都必须能够被AIDL文件支持，包括key和value</li>
<li>Parcelable：所有实现了Parcelable接口的对象</li>
<li>AIDL：所有的AIDL接口本身也可以在AIDL文件中使用</li>
</ul>
<p>以上6中就是AIDL支持的数据类型，其中自定义的Parcelable对象和AIDL对象必须要显示的import进来，不管它们是否和当前的AIDL文件位于同一个文件夹内。</p>
<p>IBookManager.aidl文件中引用了Book这个类，Book类是一个自定义的Parcelable对象，所以必须新建一个与它同名的AIDL文件，并在其中声明它为Parcelable，如下所示：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//Book.aidl</div><div class="line"></div><div class="line">package com.ryg.chapter_2.aidl<span class="comment">;</span></div><div class="line"></div><div class="line">parcelable Book<span class="comment">;</span></div></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>除此之外，AIDL中除了基本数据类型，其他类型的参数必须标上方向：in、out或者inout，in表示输入型参数，out表示输出型参数，inout表示输入输出型参数。</p>
<p>AIDL的包结构在客户端工程和服务端工程中要保持一致，否则会运行出错，这是因为客户端需要反序列化服务端中和AIDL接口相关的所有类，如果类的完整路径不一致，就无法成功反序列化，程序也就无法正常运行。</p>
<p>（2）远程服务端service的实现  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookManagerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> CopyOnWriteArrayList&lt;Book&gt; mBookList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;Book&gt;();</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Binder mBinder = <span class="keyword">new</span> IBookManager.Stub() &#123;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			<span class="keyword">return</span> mBookList;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			<span class="keyword">if</span> (!mBookList.contains(book)) &#123;</div><div class="line">				mBookList.add(book);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.onCreate();</div><div class="line">		</div><div class="line">		mBookList.add(<span class="keyword">new</span> Book(<span class="number">1</span>, <span class="string">"Android"</span>));</div><div class="line">		mBookList.add(<span class="keyword">new</span> Book(<span class="number">2</span>, <span class="string">"IOS"</span>));</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> mBinder;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是一个服务端Service的典型实现，首先在onCreate中初始化添加两本书的信息，然后创建一个Binder对象并在Binder中返回次对象，这个对象继承自IBookManager.Stub并实现了内部的AIDL方法。这里采用了CopyOnWriteArrayList，这个CopyOnWriteArrayList支持并发读/写。AIDL方法是在服务端的Binder线程池中执行的，因此当多个客户端同时连接的时候，会存在多个线程同时访问的情形，所以我们要在AISL方法中处理线程的同步，这里使用CopyOnWriteArrayList来进行自动的线程同步。</p>
<p>AIDL中能够使用的List只有ArrayList，但是我们这里使用的CopyOnWriteArrayList不是继承自ArrayList，为什么能够正常工作呢？这是因为AIDL所支持的是抽象的List，而List只是一个接口，因此虽然服务端返回的是CopyOnWriteArrayList，但在Binder中会按照List的规范去访问数据并最终形成一个ArrayList传递给客户端。所以，在服务端采用CopyOnWriteArrayList是完全可行的，与此类似的类还有ConCureentHashMap。</p>
<p>注册Service</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">service</span></span></div><div class="line">    <span class="attr">android:name</span>=<span class="string">"com.ryg.chapter_2.aidl.BookManagerService"</span></div><div class="line">    <span class="attr">android:process</span>=<span class="string">":remote1"</span> &gt;</div><div class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端首先要绑定远程服务，绑定成功后将服务端返回的Binder对象转换成AIDL接口，然后就可以通过这个接口去调用服务端的远程方法了，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		IBookManager bookManager = IBookManager.Stub.asInterface(service);</div><div class="line">		</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			List&lt;Book&gt; list = bookManager.getBookList();</div><div class="line">			System.out.println(<span class="string">"query book list type: "</span> + list.getClass().getCanonicalName());</div><div class="line">			System.out.println(<span class="string">"query book list: "</span> + list.toString());</div><div class="line">			</div><div class="line">			bookManager.addBook(<span class="keyword">new</span> Book(<span class="number">3</span>, <span class="string">"Windows Phone"</span>));</div><div class="line">			list = bookManager.getBookList();</div><div class="line">			System.out.println(<span class="string">"query book list: "</span> + list.toString());</div><div class="line">			</div><div class="line">		&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">	<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">	<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">	setContentView(R.layout.activity_main);</div><div class="line">	Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, BookManagerService.class);</div><div class="line">	bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> <span class="number">14</span>:<span class="number">51</span>:<span class="number">36</span>.<span class="number">937</span>: I/System.out(<span class="number">24841</span>): query <span class="keyword">book </span>list type: java.util.ArrayList  //CopyOnWriteArrayList转为Arraylist</div><div class="line"><span class="number">01</span>-<span class="number">11</span> <span class="number">14</span>:<span class="number">51</span>:<span class="number">36</span>.<span class="number">937</span>: I/System.out(<span class="number">24841</span>): query <span class="keyword">book </span>list: [<span class="keyword">Book </span>[<span class="keyword">bookId=1, </span><span class="keyword">bookName=Android], </span><span class="keyword">Book </span>[<span class="keyword">bookId=2, </span><span class="keyword">bookName=IOS]]</span></div><div class="line"><span class="number">01</span>-<span class="number">11</span> <span class="number">14</span>:<span class="number">51</span>:<span class="number">36</span>.<span class="number">939</span>: I/System.out(<span class="number">24841</span>): query <span class="keyword">book </span>list: [<span class="keyword">Book </span>[<span class="keyword">bookId=1, </span><span class="keyword">bookName=Android], </span><span class="keyword">Book </span>[<span class="keyword">bookId=2, </span><span class="keyword">bookName=IOS], </span><span class="keyword">Book </span>[<span class="keyword">bookId=3, </span><span class="keyword">bookName=Windows </span>Phone]]</div></pre></td></tr></table></figure>
<h2 id="Binder意外死亡的处理办法"><a href="#Binder意外死亡的处理办法" class="headerlink" title="Binder意外死亡的处理办法"></a>Binder意外死亡的处理办法</h2><p>（1）给Binder设置DeathRecipinent监听，当Binder死亡时，会收到binderDied的回调，在此回调中重新连接远程服务，次方法在客户端的Binder线程池中调用，不能直接访问UI  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> IBinder.DeathRecipient mDeathRecipient = <span class="keyword">new</span> IBinder.DeathRecipient() &#123;</div><div class="line">	</div><div class="line">	<span class="comment">//Binder死亡时的回调方法</span></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">if</span> (bookManager == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		bookManager.asBinder().unlinkToDeath(mDeathRecipient, <span class="number">0</span>);</div><div class="line">		bookManager = <span class="keyword">null</span>;</div><div class="line">		</div><div class="line">		<span class="comment">//重新绑定远程服务</span></div><div class="line">		Intent intent = <span class="keyword">new</span> Intent(BookManagerActivity.<span class="keyword">this</span>, BookManagerService.class);</div><div class="line">		bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		bookManager = IBookManager.Stub.asInterface(service);</div><div class="line">		<span class="comment">//给binder设置死亡代理</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			service.linkToDeath(mDeathRecipient, <span class="number">0</span>);</div><div class="line">		&#125; <span class="keyword">catch</span> (RemoteException e1) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			e1.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>（2）在onServiceDisconnected中重连远程服务，此方法在客户端的UI线程中调用  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="comment">//重新绑定远程服务</span></div><div class="line">		Intent intent = <span class="keyword">new</span> Intent(BookManagerActivity.<span class="keyword">this</span>, BookManagerService.class);</div><div class="line">		bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		bookManager = IBookManager.Stub.asInterface(service);</div><div class="line">		<span class="comment">//给binder设置死亡代理</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			service.linkToDeath(mDeathRecipient, <span class="number">0</span>);</div><div class="line">		&#125; <span class="keyword">catch</span> (RemoteException e1) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			e1.printStackTrace();</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="AIDL中使用权限验证功能"><a href="#AIDL中使用权限验证功能" class="headerlink" title="AIDL中使用权限验证功能"></a>AIDL中使用权限验证功能</h2><p>默认情况下，我们的远程服务任何人都可以连接，所以我们必须给服务加入权限验证功能，权限验证失败则无法调用服务的方法，这里介绍两种常用的方法。</p>
<ul>
<li><strong>onBind中验证</strong></li>
</ul>
<p>早onBind中进行验证，验证不通过就直接返回null，这样验证失败的客户端无法绑定服务，比如使用permission验证。首先，在Manifest.xml中声明所需要的权限，比如：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;permission </div><div class="line">    android:<span class="built_in">name</span>=<span class="string">"com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE"</span></div><div class="line">    android:protectionLevel=<span class="string">"normal"</span>&gt;</div></pre></td></tr></table></figure>
<p>然后在BookManagerService的onBind做权限验证，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">	<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">	<span class="keyword">int</span> check = checkCallingOrSelfPermission(<span class="string">"com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE"</span>);</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (check == PackageManager.PERMISSION_DENIED) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//客户端就无法绑定到此服务</span></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> mBinder;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方法同样适用于Messenger中。如果我们自己内部的应用想绑定到我们的服务中，只需要在它的AndroidManifest文件中使用permission即可</p>
<uses-permission android:name="com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE">

<ul>
<li><strong>服务端的onTransact方法中验证</strong></li>
</ul>
<p>在服务端的onTransact方法中进行权限验证，验证失败就返回false，这样服务端就不会终止执行AIDL中的方法从而达到保护服务端的效果。至于验证的方式有很多，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Binder mBinder = <span class="keyword">new</span> IBookManager.Stub() &#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> mBookList;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">if</span> (!mBookList.contains(book)) &#123;</div><div class="line">			mBookList.add(book);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></div><div class="line">			<span class="keyword">throws</span> RemoteException &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		</div><div class="line">		<span class="comment">//1.通过permission验证</span></div><div class="line">		<span class="keyword">int</span> check = checkCallingOrSelfPermission(<span class="string">"com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE"</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (check == PackageManager.PERMISSION_DENIED) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="comment">//2.验证包名</span></div><div class="line">		String packageName = <span class="keyword">null</span>;</div><div class="line">		String[] packages = getPackageManager().getPackagesForUid(getCallingUid());</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (packages != <span class="keyword">null</span> &amp;&amp; packages.length &gt; <span class="number">0</span>) &#123;</div><div class="line">			packageName = packages[<span class="number">0</span>];</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (!packageName.startsWith(<span class="string">"com.ryg"</span>)) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面介绍了常用的两种权限验证方式，但是还有其他方式做权限验证，比如为Service指定android:permission属性等。</p>
<h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><p>ContentProvider是Android中专门用于不同应用间进行数据共享的方式，从这一点来看，它天生适合进程间通信。和Messenger一样，ContentProvider的底层实现同样是Binder。</p>
<p>系统预置了许多ContentProvider，比如通讯录信息<br>日程表信息等，要跨进程访问这些信息，只需要通过ContentResolver的query、update、insert和delete方法。下面我们演示实现一个自定义的ContentProvider，并演示如何在其他应用中获取ContentProvider中的数据从而实现进行间通信的目的。首先，创建一个ContentProvider的类，叫BookProvider，并实现6个抽象方法即可onCreate、query、delete、update、insert和getType。onCreate代表ContentProvider的创建，需要做一些初始化的工作；getType用来返回一个Uri请求所对应的MIME类型，比如视频、图片、等，如果应用不关心这个选项，可以直接在方法中返回null或者“*/*”剩下的四个方法对应于CRUD操作，对数据表的增删改查功能。</p>
<p>根据Binder的工作原理，这留个方法均运行在ContentProvider的进程中，除了onCreate有系统回调运行在主线程里，其他无非方法由外界回调并运行在Binder线程池中。</p>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//BookProvider.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(<span class="string">"onCreate current thread:"</span> + Thread.currentThread().getName());</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection,</span></span></div><div class="line">			String[] selectionArgs, String sortOrder) &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(<span class="string">"query current thread:"</span> + Thread.currentThread().getName());</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection,</span></span></div><div class="line">			String[] selectionArgs) &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们需要注册这个BookProvider，如下所示。其中android:anthorities是ContentProvider的唯一标识，通过这个属性外部应用就可以访问我们的BookProvide。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;provider</div><div class="line">    android:name=<span class="string">"com.ryg.chapter_2.provider.BookProvider"</span></div><div class="line">    android:authorities=<span class="string">"com.ryg.chapter_2.provider.book.provider"</span> <span class="regexp">//</span>标识</div><div class="line">    android:permission=<span class="string">"com.ryg.PROVIDER"</span> <span class="regexp">//</span>权限</div><div class="line">    android:process=<span class="string">":provider"</span></div><div class="line">    <span class="regexp">//</span>ndroid:readPermission=<span class="string">"com.ryg.PROVIDER.READ"</span> <span class="regexp">//</span>读权限</div><div class="line">    <span class="regexp">//</span>android:writePermission=<span class="string">"com.ryg.PROVIDER.WRITE"</span> &gt;  <span class="regexp">//</span>写权限</div><div class="line">&lt;<span class="regexp">/provider&gt;</span></div></pre></td></tr></table></figure>
<p>然后声明权限和加入权限</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:<span class="built_in">name</span>=<span class="string">"com.ryg.PROVIDER"</span> /&gt;</div><div class="line"></div><div class="line">  &lt;permission</div><div class="line">      android:<span class="built_in">name</span>=<span class="string">"com.ryg.PROVIDER"</span></div><div class="line">      android:protectionLevel=<span class="string">"normal"</span> /&gt;</div></pre></td></tr></table></figure>
<p>创建BookActivity.java访问这个ContentProvider，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		</div><div class="line">		Uri uri = Uri.parse(<span class="string">"content://com.ryg.chapter_2.provider.book.provider"</span>);</div><div class="line">		getContentResolver().query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">		getContentResolver().query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">		getContentResolver().query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">		getContentResolver().query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码中，我们提供ContentResolver对象的query方法查询BookProvider中的数据，其中”content://com.ryg.chapter_2.provider.book.provider”位移标识了BookProvider，这个标识正式为BookProvider的android:authorities属性所指定的值。</p>
<p>运行结果如下</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> 16:50:31.678: I/System.<span class="keyword">out</span>(22482): onCreate current thread:main        <span class="comment">//主线程</span></div><div class="line">01-11 16:50:31.680: I/System.<span class="keyword">out</span>(22482): <span class="keyword">query</span> current thread:Binder_2  <span class="comment">//Binder线程池中</span></div><div class="line">01-11 16:50:31.681: I/System.<span class="keyword">out</span>(22482): <span class="keyword">query</span> current thread:Binder_1</div><div class="line">01-11 16:50:31.682: I/System.<span class="keyword">out</span>(22482): <span class="keyword">query</span> current thread:Binder_2</div><div class="line">01-11 16:50:31.682: I/System.<span class="keyword">out</span>(22482): <span class="keyword">query</span> current thread:Binder_1</div></pre></td></tr></table></figure>
<p>从结果可以看出，onCreate运行于主线程中，所以不能在onCreate中做耗时操作，query方法的四次调用不在同一个线程中，但是在同一个Binder线程池中。</p>
<p>接下来，我们继续完善BookProvider，从而使其对外界的应用提供数据。为了完成上述功能，我们需要一个数据库来管理图示和用户信息，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookOpenHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DB_NAME = <span class="string">"book_provider.db"</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BOOK_TABLE_NAME = <span class="string">"book"</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_TABLE_NAME = <span class="string">"user"</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DB_VERSION = <span class="number">1</span>;</div><div class="line">	</div><div class="line">	<span class="comment">//图书列表</span></div><div class="line">	<span class="keyword">private</span> String CREATE_BOOK_TABLE = <span class="string">"CREATE TABLE IF NOT EXISTS "</span> + BOOK_TABLE_NAME +<span class="string">"(_id INTEGER PRIMARY KEY, name TEXT)"</span>;</div><div class="line">	<span class="comment">//用户列表</span></div><div class="line">	<span class="keyword">private</span> String CREATE_USER_TABLE = <span class="string">"CREATE TABLE IF NOT EXISTS "</span> + USER_TABLE_NAME +<span class="string">"(_id INTEGER PRIMARY KEY, name TEXT, sex INT)"</span>;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BookOpenHelper</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(context, DB_NAME, <span class="keyword">null</span>, DB_VERSION);</div><div class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		db.execSQL(CREATE_BOOK_TABLE);</div><div class="line">		db.execSQL(CREATE_USER_TABLE);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，分别为book表和user表指定Uri，并关联对应的uri——code</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookOpenHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DB_NAME = <span class="string">"book_provider.db"</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BOOK_TABLE_NAME = <span class="string">"book"</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_TABLE_NAME = <span class="string">"user"</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DB_VERSION = <span class="number">1</span>;</div><div class="line">	</div><div class="line">	<span class="comment">//图书列表</span></div><div class="line">	<span class="keyword">private</span> String CREATE_BOOK_TABLE = <span class="string">"CREATE TABLE IF NOT EXISTS "</span> + BOOK_TABLE_NAME +<span class="string">"(_id INTEGER PRIMARY KEY, name TEXT)"</span>;</div><div class="line">	<span class="comment">//用户列表</span></div><div class="line">	<span class="keyword">private</span> String CREATE_USER_TABLE = <span class="string">"CREATE TABLE IF NOT EXISTS "</span> + USER_TABLE_NAME +<span class="string">"(_id INTEGER PRIMARY KEY, name TEXT, sex INT)"</span>;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BookOpenHelper</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(context, DB_NAME, <span class="keyword">null</span>, DB_VERSION);</div><div class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	.......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们就可以通过如下方式获取外界要访问点饿数据源，根据Uri取出Uri_code，根据Uri_code得到数据表的名称</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span> </span>&#123;</div><div class="line"></div><div class="line">	String tableName = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="keyword">switch</span> (sUriMatcher.match(uri)) &#123;</div><div class="line"></div><div class="line">	<span class="keyword">case</span> BOOK_URI_CODE:</div><div class="line"></div><div class="line">		tableName = BookOpenHelper.BOOK_TABLE_NAME;</div><div class="line">		</div><div class="line">		<span class="keyword">break</span>;</div><div class="line"></div><div class="line">	<span class="keyword">case</span> USER_URI_CODE:</div><div class="line">		</div><div class="line">		tableName = BookOpenHelper.USER_TABLE_NAME;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line"></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> tableName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，我们就实现query、update、insert、delete方法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORITY = <span class="string">"com.ryg.chapter_2.provider.book.provider"</span>;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri BOOK_CONTENT_URI = Uri.parse(<span class="string">"content://"</span></div><div class="line">			+ AUTHORITY + <span class="string">"/book"</span>);</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOOK_URI_CODE = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri USER_CONTENT_URI = Uri.parse(<span class="string">"content://"</span></div><div class="line">			+ AUTHORITY + <span class="string">"/user"</span>);</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> USER_URI_CODE = <span class="number">1</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> UriMatcher sUriMatcher = <span class="keyword">new</span> UriMatcher(</div><div class="line">			UriMatcher.NO_MATCH);</div><div class="line"></div><div class="line">	<span class="keyword">static</span> &#123;</div><div class="line">		<span class="comment">// 将Uri和Uri_Code关联起来</span></div><div class="line">		sUriMatcher.addURI(AUTHORITY, <span class="string">"book"</span>, <span class="number">0</span>);</div><div class="line">		sUriMatcher.addURI(AUTHORITY, <span class="string">"book"</span>, <span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Context mContext;</div><div class="line">	<span class="keyword">private</span> SQLiteDatabase db;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">		mContext = getContext();</div><div class="line">		initData();</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		db = <span class="keyword">new</span> BookOpenHelper(mContext).getWritableDatabase();</div><div class="line">		db.execSQL(<span class="string">"delete from "</span> + BookOpenHelper.BOOK_TABLE_NAME);</div><div class="line">		db.execSQL(<span class="string">"delete from "</span> + BookOpenHelper.USER_TABLE_NAME);</div><div class="line">		db.execSQL(<span class="string">"insert into book values(2,'Android');"</span>);</div><div class="line">		db.execSQL(<span class="string">"insert into book values(3,'IOS');"</span>);</div><div class="line">		db.execSQL(<span class="string">"insert into book values(4,'Window Phone');"</span>);</div><div class="line">		db.execSQL(<span class="string">"insert into user values(6,'lee',1);"</span>);</div><div class="line">		db.execSQL(<span class="string">"insert into book values(7,'lau',0);"</span>);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection,</span></span></div><div class="line">			String[] selectionArgs, String sortOrder) &#123;</div><div class="line">		</div><div class="line">		String table = getTableName(uri);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported URI: "</span> + uri);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> db.query(table, projection, selection, selectionArgs, <span class="keyword">null</span>, <span class="keyword">null</span>, sortOrder, <span class="keyword">null</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		String table = getTableName(uri);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported URI: "</span> + uri);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		db.insert(table, <span class="keyword">null</span>, values);</div><div class="line">		mContext.getContentResolver().notifyChange(uri, <span class="keyword">null</span>); <span class="comment">//通过数据源变化</span></div><div class="line">		</div><div class="line">		<span class="keyword">return</span> uri;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		String table = getTableName(uri);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported URI: "</span> + uri);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> count = db.delete(table, selection, selectionArgs);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (count &gt;<span class="number">0</span>) &#123;</div><div class="line">			mContext.getContentResolver().notifyChange(uri, <span class="keyword">null</span>);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> count;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection,</span></span></div><div class="line">			String[] selectionArgs) &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		</div><div class="line">		String table = getTableName(uri);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported URI: "</span> + uri);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> row = db.update(table, values, selection, selectionArgs);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (row &gt; <span class="number">0</span>) &#123;</div><div class="line">			mContext.getContentResolver().notifyChange(uri, <span class="keyword">null</span>);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> row;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span> </span>&#123;</div><div class="line"></div><div class="line">		String tableName = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">		<span class="keyword">switch</span> (sUriMatcher.match(uri)) &#123;</div><div class="line"></div><div class="line">		<span class="keyword">case</span> BOOK_URI_CODE:</div><div class="line"></div><div class="line">			tableName = BookOpenHelper.BOOK_TABLE_NAME;</div><div class="line">			</div><div class="line">			<span class="keyword">break</span>;</div><div class="line"></div><div class="line">		<span class="keyword">case</span> USER_URI_CODE:</div><div class="line">			</div><div class="line">			tableName = BookOpenHelper.USER_TABLE_NAME;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line"></div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> tableName;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>访问BookProvider</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> ContentObserver mObserver = <span class="keyword">new</span> ContentObserver(<span class="keyword">new</span> Handler()) &#123;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange, Uri uri)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			System.out.println(uri);</div><div class="line">			<span class="keyword">super</span>.onChange(selfChange, uri);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		</div><div class="line">		</div><div class="line">		Uri uri = Uri.parse(<span class="string">"content://com.ryg.chapter_2.provider.book.provider/book"</span>);</div><div class="line">		getContentResolver().registerContentObserver(uri, <span class="keyword">false</span>, mObserver);</div><div class="line">		ContentValues values = <span class="keyword">new</span> ContentValues();</div><div class="line">		values.put(<span class="string">"_id"</span>, <span class="number">7</span>);</div><div class="line">		values.put(<span class="string">"name"</span>, <span class="string">"Html"</span>);</div><div class="line">		getContentResolver().insert(uri, values);</div><div class="line">		</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是，query、update、insert、delete四大方法是存在多线程并发访问的，因此方法内部要做好线程同步本例中，由于采用的是SQLite并且只有一个SQLiteDataBase的连接，所以可以正确应对多线程的情况。具体原因是SQLiteDatabase内部对数据库的操作是有同步处理的，但是如果通过多个SQLiteDatabase对象来操作数据库就无法保证线程同步，因为SQLiteDatabase对象之间无法进行线程同步。如果ContentProvider的底层数据是一块内存的话，比如List，在这种情况下同List的遍历、插入、删除操作就需要进行线程同步，否则就会引起并发错误。</p>
<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p>Socket又称为套接字，是网络通信的概念，它分为流式套接字和用户数据报套接字，分别对应于网络传输层的TCP和UDP协议。TCP是面向连接的协议，提供稳定的双向通信功能，TCP连接的建立需要经过“三次握手”才能完成，为了提供稳定的数据传输功能，其本身提供了超时重传机制，因此具有很高的稳定性；而UDP是面向无连接的协议，提供不稳定的单向通信功能，当然UDP也可以实现双向通信功能。在性能上，UDP具有更高的效率，其缺点是不能保证数据一定能够正确传输，尤其是在网络拥塞的情况下。</p>
<p>下面示例一个聊天室程序，首先是服务端的设计，当Service启动时，会在线程中建立TCP服务，这里监听的是8688端口，然后就可以等待客户端的连接请求。当有客户端连接时，就会生成一个新的Socket，通过每次新创建的Socket就可以分别和不同的客户端通信了。当客户端断开连接时，服务端这边也会关闭对应Socket并结束通话线程。这点是如何做到的呢？这里是通过判断服务端输入流的返回值来确定的，当客户端断开连接后，服务端这边的输入流会返回null，这个时候我们就知道客户端退出了。服务端代码如下：</p>
<h1 id="选用合适的IPC方式"><a href="#选用合适的IPC方式" class="headerlink" title="选用合适的IPC方式"></a>选用合适的IPC方式</h1><table>
<thead>
<tr>
<th>名称</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bundle</td>
<td>简单易用</td>
<td>只能传输Bundle支持的数据类型</td>
<td>四大组件间的进程间通信</td>
</tr>
<tr>
<td>文件共享</td>
<td>简单易用</td>
<td>不适合高并发场景，并且无法做到进程间的即时通信</td>
<td>无并发访问情形，交换简单的数据实时性不高的场景</td>
</tr>
<tr>
<td>AIDL</td>
<td>功能强大，支持一对多并发通信，支持实时通信</td>
<td>使用稍复杂，需要处理好现场同步</td>
<td>一对多通信且有RPC需求</td>
</tr>
<tr>
<td>Messenger</td>
<td>功能一般，支持一对多串行通信，支持实时通信</td>
<td>不能很好地处理搞并发情形，不支持RPC，数据通过Messenger进行传输，因此只能传输Bundle支持的数据类型</td>
<td>低并发的一对多即时通信，无RPC需求，或者无需要返回结果的RPC需求</td>
</tr>
<tr>
<td>ContentProvider</td>
<td>在数据源访问方面功能强大，支持一对多并发数据共享，可通过Call方法扩展其他操作</td>
<td>可以理解为受约束的AIDL，主要提供数据源的CRUD操作</td>
<td>一对多的进程间的数据共享</td>
</tr>
<tr>
<td>Socket</td>
<td>功能强大，可通过网络传输字节流，支持一对多并发实时通信</td>
<td>实现细节稍微有些烦琐，不支持直接的RPC</td>
<td>网络数据交换</td>
</tr>
</tbody>
</table>
</uses-permission>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2016/04/19/Android的IPC方式/" data-id="cj6esnzc00021wg19ocevaquz" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2016/04/19/Android的IPC方式/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android系统/">Android系统</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Android的IPC机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/19/Android的IPC机制/" class="article-date">
  <time datetime="2016-04-19T14:39:32.000Z" itemprop="datePublished">2016-04-19 22:39:32</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/19/Android的IPC机制/">Android的IPC机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="Android-IPC简介"><a href="#Android-IPC简介" class="headerlink" title="Android IPC简介"></a>Android IPC简介</h1><p>IPC是Inter-Process Communication的缩写，含义为进程间通信，是指两个进程之间进行数据交换的过程。</p>
<p>Android中IPC的使用情况分为两种：</p>
<ul>
<li><p>第一种情况是一个应用因为某些原因自身需要采用多进程模式来实现，至于原因，可能有很多，比如有些模块由于特殊的原因需要运行在单独的进程中，又或者为了加大一个应用可使用的内存所以需要通过多进行来获取多分内存空间。</p>
</li>
<li><p>第二种情况是当前应用需要向其他应用获取数据，由于是两个应用，所以必须采用跨进程的方式来获取所需要的数据，甚至我们系统提供的ContentProvider去查询数据的时候，其实也是一种进程间通信，只不过通信细节被系统内部屏蔽了。</p>
</li>
</ul>
<h1 id="Android中的多进程模式"><a href="#Android中的多进程模式" class="headerlink" title="Android中的多进程模式"></a>Android中的多进程模式</h1><h2 id="开启多进行模式"><a href="#开启多进行模式" class="headerlink" title="开启多进行模式"></a>开启多进行模式</h2><p>正常情况下，在Android中多进程是指一个应用中存在多个进程的情况，因此这里不讨论两个应用之间的多进程情况。首先，在Android中使用多进程只有一种方法，就是给四大组件在AndroidManifest中指定android:process属性，除此之外没有其他办法。其实还有另一种非常规的多进程方法，那就是通过JNI在native层其fork一个新的进程，这种方法属于特殊情况，也不是常用的创建多进程的方式。下面示例，描述如何在Android中创建多进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;activity</div><div class="line">    android:name=<span class="string">"com.example.demo.AActivity"</span></div><div class="line">    android:process=<span class="string">":remote"</span> /&gt;</div><div class="line"></div><div class="line">&lt;activity</div><div class="line">    android:name=<span class="string">"com.example.demo.BActivity"</span></div><div class="line">    android:process=<span class="string">"com.example.demo.BaseActivity.remote"</span> /&gt;</div></pre></td></tr></table></figure>
<p>上面示例分为为AActivity和BActivity指定了process属性，并且他们的属性值不同，意味着当前应用又增加了两个进程。当AActivity启动时，系统会为它创建一个单独的进程，进程名为”com.example.demo.BaseActivity:remote”；当BActivity启动时，系统也会为它创建一个单独的进程，进程名为”com.example.demo.BaseActivity.remote”。</p>
<p>“:remote”和”com.example.demo.BaseActivity.remote”这两种命名方式的区别？</p>
<ul>
<li><p>首先“:”的含义是指要在当前的进程名前面附加当前的包名，而”com.example.demo.BaseActivity.remote”是完整的命名方式不会附加包名信息</p>
</li>
<li><p>其次，进程名以“:”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中，而进程名不易“：”开头的进程属于全局进程，其他应用通过ShareUID方式可以和它跑在同一个进程中。</p>
</li>
</ul>
<h2 id="多进程模式的运行机制"><a href="#多进程模式的运行机制" class="headerlink" title="多进程模式的运行机制"></a>多进程模式的运行机制</h2><p>Android为你每个应用分配了一个独立的虚拟机，或者说为每个进程都分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就会导致在不同的虚拟机中访问同一个类对象会产生多份副本。</p>
<p>所有运行在不同进程中的四大组件，只要它们之间需要通过内存来共享数据，都会共享失败，这也是多线程所带来的主要影响。</p>
<p>一般来说，使用多线程会造成如下四个方面的问题：</p>
<ul>
<li>（1）静态成员和单例模式完全失效</li>
</ul>
<p>Android为你每个应用分配了一个独立的虚拟机，或者说为每个进程都分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就会导致在不同的虚拟机中访问同一个类对象会产生多份副本。</p>
<ul>
<li>（2）线程同步机制完全失效</li>
</ul>
<p>本质上和第一个问题是类似的，既然都不是一块内存了，那么不管锁对象还是锁全局类都无法保证线程同步，因为不同进程锁的不是同一个对象。</p>
<ul>
<li>（3）SharedPreference的可靠性下降</li>
</ul>
<p>是因为SharedPreference不支持两个进程同步去执行写操作，否则会导致一定几率的丢失，这是因为SharedPreference底层是通过读/写XML文件实现的，并发写文件显然是可能出问题的，甚至并发读/写都有可能出问题。</p>
<ul>
<li>（4）Application会多次创建</li>
</ul>
<p>当一个组件跑在一个新的进程中的时候，<strong>由于系统要在创建新的进程同时分配独立的虚拟机，所以这个过程其实就是启动一个新应用的过程</strong>。因此，相当于系统又把这个应用重新启动了一遍，既然重新启动了，那么自然会创建新的Application。</p>
<p>在多进程模式中，不同进程的组件的确会拥有独立的虚拟机、Application和内存空间。</p>
<p>为了解决这个问题，Android系统提供了很多跨进程通信方法实现数据交互。如Intent来传递数据，共享文件和SharedPreference，基于Binder的Messenger和AIDL，Socket等。</p>
<h1 id="IPC基础概念介绍"><a href="#IPC基础概念介绍" class="headerlink" title="IPC基础概念介绍"></a>IPC基础概念介绍</h1><h2 id="Serializable接口"><a href="#Serializable接口" class="headerlink" title="Serializable接口"></a>Serializable接口</h2><p>Serializable是Java所提供的一个序列化接口，它是一个空接口，为对象提供标准的序列化和反序列化操作。使用Serializable来实现序列化相当简单只需要在类的声明中指定一个类似下面的标志即可自动实现默认的序列化过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5123020951483359287L</span>; <span class="comment">//系统生成的hash值</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>; <span class="comment">//指定为1L</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * </div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5123020951483359287L</span>; <span class="comment">//系统生成的hash值</span></div><div class="line">	</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> 		userId;</div><div class="line">	<span class="keyword">public</span> String 	userName;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> 	isMale;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"User [userId="</span> + userId + <span class="string">", userName="</span> + userName</div><div class="line">				+ <span class="string">", isMale="</span> + isMale + <span class="string">"]"</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过Serializable接口来实现对象的序列化过程非常简单，几乎所有的工作都被系统自动完成了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//序列化存储</span></div><div class="line">User user = <span class="keyword">new</span> User(<span class="number">2</span>, <span class="string">"liuguoquan"</span>, <span class="keyword">true</span>);</div><div class="line">	ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(Environment.getExternalStorageDirectory()+<span class="string">"/cache.txt"</span>));</div><div class="line">	out.writeObject(user);</div><div class="line">	out.close();</div><div class="line"></div><div class="line"><span class="comment">//反序列化</span></div><div class="line">	ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(Environment.getExternalStorageDirectory()+<span class="string">"/cache.txt"</span>));</div><div class="line">	User newUser = (User) in.readObject();</div><div class="line">	in.close();</div></pre></td></tr></table></figure>
<p>上述代码描述了采用Serializable方式序列化对象的典型过程，很简单，只需要把实现了Serializable接口的User对象写到文件中就可以快速恢复了，恢复后的对象newUser和user的内容完全一样，但是两者并不是同一个对象。</p>
<p>其实，不指定serialVersionUID也可以实现序列化，那到底要不要指定呢？系统既然提供了这个serialVersionUID，那么它必须是有用的，原则上序列化的数据中的serialVersionUID只有和当前类的serialVersionUID相同时才能够正常地被反序列化。</p>
<p>serialVersionUID的详细工作机制是这样的：序列化的时候系统会把当前类的serialVersionUID写入序列化的文件中，当反序列化的时候系统会去检查文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，如果一致说明序列化的类版本与当前类的版本是相同的则可以成功反序列化；否则就说明当前类和序列化的类相比发生了某些变化，比如成员变量的数量、类型可能发生了改变，这个时候是无法正常反序列化的。</p>
<p>给serialVersionUID指定为1L或者采用系统当前类结构去生成的hash值，这两者并没有什么区别，效果完全一样。以下两点需要注意：</p>
<ul>
<li>静态成员变量属于类不属于对象，所以不会参与序列化过程</li>
<li>用transient关键字标记的成员变量不参与序列化过程</li>
</ul>
<h2 id="Parcalable接口"><a href="#Parcalable接口" class="headerlink" title="Parcalable接口"></a>Parcalable接口</h2><p>Parcelable也是一个也是一个接口，只要实现这个接口，一个类的对象就要就可以实现序列化并可以通过Intent和Binder传递。下面的示例是一个典型的用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> sex;</div><div class="line">	<span class="keyword">private</span> User user;</div><div class="line">	</div><div class="line">	</div><div class="line"></div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//序列化</span></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		dest.writeInt(id);</div><div class="line">		dest.writeString(name);</div><div class="line">		dest.writeInt(sex);</div><div class="line">		dest.writeSerializable(user);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//反序列化</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Person&gt; CREATOR = <span class="keyword">new</span> Parcelable.Creator&lt;Person&gt;() &#123;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> Person <span class="title">createFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			</div><div class="line">			Person person = <span class="keyword">new</span> Person();</div><div class="line">			<span class="comment">//必须要按照成员变量的初始化顺序</span></div><div class="line">			person.id = source.readInt();</div><div class="line">			person.name = source.readString();</div><div class="line">			person.sex = source.readInt();</div><div class="line">			person.user = (User) source.readSerializable();</div><div class="line">			<span class="keyword">return</span> person;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="keyword">public</span> Person[] newArray(<span class="keyword">int</span> size) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Person[size];</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>系统已经为我们提供了许多实现了Parcelable接口的类，它们逗死可以直接序列化的，比如Intent、Bundle、Bitmap等，同时List和Map也可以序列化，前提是他们里面的每个元素都可以序列化。</p>
<p>既然Parcelable和Serializable都能实现序列化并且都可用于Intent间的数据传递，那么二者该如何选取呢？Serializable是Java中的序列化接口，其使用起来非常简单但是开销很大，序列化和反序列化过程需要大量的I/O操作。而Parcelable是Android中的序列化方式，因此更适合在Android平台上，它的缺点就是使用起来稍微麻烦点，但是它的效率很高，这是Android推荐的序列化方式。因此首选Parcelable。Parcelable主要用在内存序列化上，通过Parcelable将对象序列化到存储设备中或者将对象序列化后通过网络传输也都是可以的，但这个过程显得复杂，因此这两种情况下建议使用Serializable。</p>
<p>Binder是Android中的一个类，它实现了IBinder接口。从IPC角度来说，Binder是Android中的一种跨进程通信方式，Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在Linux中没有；从Android Framework角度来说，Binder是ServiceManager连接各种Manager（ActivityManager、WindowManager，等待）和相应的ManagerService的桥梁；从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindservice时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或数据，这里的服务包括普通的服务和基于AIDL的服务。</p>
<p>Android开发中，Binder主要用在service中，包括AIDL和Messenger，其中普通Service中的Binder不涉及进程间通信，而Messenger的底层其实是AIDL，所以这里选用AIDL来分析Binder的工作机制。</p>
<p>下面新建一个AIDL示例，新建三个文件Book.java、Book.aidl、IBookManager.aidl，代码如下所示：</p>
<p>Book.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">	<span class="keyword">package</span> com.ryg.chapter_2.aidl;</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="keyword">import</span> android.os.Parcel;</div><div class="line">	<span class="keyword">import</span> android.os.Parcelable;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> <span class="keyword">int</span> bookId;</div><div class="line">		<span class="keyword">public</span> String bookName;</div><div class="line">	</div><div class="line">		</div><div class="line">		</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">int</span> bookId, String bookName)</span> </span>&#123;</div><div class="line">			<span class="keyword">this</span>.bookId = bookId;</div><div class="line">			<span class="keyword">this</span>.bookName = bookName;</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			dest.writeInt(bookId);</div><div class="line">			dest.writeString(bookName);</div><div class="line">	</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Book&gt; CREATOR = <span class="keyword">new</span> Parcelable.Creator&lt;Book&gt;() &#123;</div><div class="line">	</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> Book <span class="title">createFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				</div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Book(source);</div><div class="line">			&#125;</div><div class="line">	</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="keyword">public</span> Book[] newArray(<span class="keyword">int</span> size) &#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Book[size];</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">		</div><div class="line">		</div><div class="line">		<span class="function"><span class="keyword">private</span> <span class="title">Book</span><span class="params">(Parcel in)</span> </span>&#123;</div><div class="line">			</div><div class="line">			bookId = in.readInt();</div><div class="line">			bookName = in.readString();</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">	&#125;</div><div class="line"></div><div class="line">Book.aidl</div><div class="line"></div><div class="line">	<span class="keyword">package</span> com.ryg.chapter_2.aidl;</div><div class="line">	</div><div class="line">	parcelable Book;</div><div class="line"></div><div class="line">IBookManager.aidl</div><div class="line"></div><div class="line">	<span class="keyword">package</span> com.ryg.chapter_2.aidl;</div><div class="line">	</div><div class="line">	<span class="keyword">import</span> com.ryg.chapter_2.aidl.Book;</div><div class="line">	</div><div class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</div><div class="line">	</div><div class="line">		<span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</div><div class="line">		</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>Book.java是一个图书信息的类，它实现了Parcelable接口。Book.aidl是Book类在AIDL的声明。IBookManager.aidl是我们定义的一个接口，里面有两个方法，其中getBookList用于从远程服务端获取图书列表，而addBook用于向图书列表中添加一本书。尽管Book类已经和IBookManager位于相同的包中，但是IBookManager中仍然要导入Book类，接下来系统会在gen目录自动生成一个IBookManager的类。如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * This file is auto-generated.  DO NOT MODIFY.</div><div class="line"> * Original file: D:\\liuguoquan\\workspace\\chapter_2\\src\\com\\ryg\\chapter_2\\aidl\\IBookManager.aidl</div><div class="line"> */</div><div class="line"><span class="keyword">package</span> com.ryg.chapter_2.aidl;</div><div class="line"></div><div class="line"><span class="comment">//在Binder传输的接口都要实现IInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span> </span>&#123;</div><div class="line">	<span class="comment">/** Local-side IPC implementation stub class. */</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span></span></div><div class="line">			<span class="title">com</span>.<span class="title">ryg</span>.<span class="title">chapter_2</span>.<span class="title">aidl</span>.<span class="title">IBookManager</span> &#123;</div><div class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.ryg.chapter_2.aidl.IBookManager"</span>;</div><div class="line"></div><div class="line">		<span class="comment">//内部类，这个Stub就是一个Binder类</span></div><div class="line">		<span class="comment">/** Construct the stub at attach it to the interface. */</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">/**</span></div><div class="line">		 * Cast an IBinder object into an com.ryg.chapter_2.aidl.IBookManager</div><div class="line">		 * interface, generating a proxy if needed.</div><div class="line">		 */</div><div class="line">		<span class="keyword">public</span> <span class="keyword">static</span> com.ryg.chapter_2.aidl.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(</span></span></div><div class="line">				android.os.IBinder obj) &#123;</div><div class="line">			<span class="keyword">if</span> ((obj == <span class="keyword">null</span>)) &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">			&#125;</div><div class="line">			android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</div><div class="line">			<span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.ryg.chapter_2.aidl.IBookManager))) &#123;</div><div class="line">				<span class="keyword">return</span> ((com.ryg.chapter_2.aidl.IBookManager) iin);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> com.ryg.chapter_2.aidl.IBookManager.Stub.Proxy(obj);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data,</span></span></div><div class="line">				android.os.Parcel reply, <span class="keyword">int</span> flags)</div><div class="line">				<span class="keyword">throws</span> android.os.RemoteException &#123;</div><div class="line">			<span class="keyword">switch</span> (code) &#123;</div><div class="line">			<span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</div><div class="line">				reply.writeString(DESCRIPTOR);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">case</span> TRANSACTION_getBookList: &#123;  <span class="comment">//用于标识方法</span></div><div class="line">				data.enforceInterface(DESCRIPTOR);</div><div class="line">				java.util.List&lt;com.ryg.chapter_2.aidl.Book&gt; _result = <span class="keyword">this</span></div><div class="line">						.getBookList();</div><div class="line">				reply.writeNoException();</div><div class="line">				reply.writeTypedList(_result);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">case</span> TRANSACTION_addBook: &#123;</div><div class="line">				data.enforceInterface(DESCRIPTOR);</div><div class="line">				com.ryg.chapter_2.aidl.Book _arg0;</div><div class="line">				<span class="keyword">if</span> ((<span class="number">0</span> != data.readInt())) &#123;</div><div class="line">					_arg0 = com.ryg.chapter_2.aidl.Book.CREATOR</div><div class="line">							.createFromParcel(data);</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					_arg0 = <span class="keyword">null</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">this</span>.addBook(_arg0);</div><div class="line">				reply.writeNoException();</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span></span></div><div class="line">				<span class="title">com</span>.<span class="title">ryg</span>.<span class="title">chapter_2</span>.<span class="title">aidl</span>.<span class="title">IBookManager</span> &#123;</div><div class="line">			<span class="keyword">private</span> android.os.IBinder mRemote;</div><div class="line"></div><div class="line">			Proxy(android.os.IBinder remote) &#123;</div><div class="line">				mRemote = remote;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">return</span> mRemote;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">return</span> DESCRIPTOR;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="keyword">public</span> java.util.List&lt;com.ryg.chapter_2.aidl.Book&gt; getBookList()</div><div class="line">					<span class="keyword">throws</span> android.os.RemoteException &#123;</div><div class="line">				android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">				android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">				java.util.List&lt;com.ryg.chapter_2.aidl.Book&gt; _result;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					_data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">					mRemote.transact(Stub.TRANSACTION_getBookList, _data,</div><div class="line">							_reply, <span class="number">0</span>);</div><div class="line">					_reply.readException();</div><div class="line">					_result = _reply</div><div class="line">							.createTypedArrayList(com.ryg.chapter_2.aidl.Book.CREATOR);</div><div class="line">				&#125; <span class="keyword">finally</span> &#123;</div><div class="line">					_reply.recycle();</div><div class="line">					_data.recycle();</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">return</span> _result;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.ryg.chapter_2.aidl.Book book)</span></span></div><div class="line">					<span class="keyword">throws</span> android.os.RemoteException &#123;</div><div class="line">				android.os.Parcel _data = android.os.Parcel.obtain();</div><div class="line">				android.os.Parcel _reply = android.os.Parcel.obtain();</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					_data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">					<span class="keyword">if</span> ((book != <span class="keyword">null</span>)) &#123;</div><div class="line">						_data.writeInt(<span class="number">1</span>);</div><div class="line">						book.writeToParcel(_data, <span class="number">0</span>);</div><div class="line">					&#125; <span class="keyword">else</span> &#123;</div><div class="line">						_data.writeInt(<span class="number">0</span>);</div><div class="line">					&#125;</div><div class="line">					mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</div><div class="line">					_reply.readException();</div><div class="line">				&#125; <span class="keyword">finally</span> &#123;</div><div class="line">					_reply.recycle();</div><div class="line">					_data.recycle();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>); <span class="comment">//标识方法的id</span></div><div class="line">		<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> java.util.List&lt;com.ryg.chapter_2.aidl.Book&gt; getBookList()</div><div class="line">			<span class="keyword">throws</span> android.os.RemoteException;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.ryg.chapter_2.aidl.Book book)</span></span></div><div class="line">			<span class="keyword">throws</span> android.os.RemoteException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码实现的功能：<br>（1）IBookManager类继承IInterface接口，同时它自己也是个接口，所有可以在Binder中传输的接口都需要继承IInterface接口<br>（2）首先，它声明了两个方法getBookList和addBook，就是我们自IBookManager.aidl中定义的方法，同时还声明了两个整形id分别用于标识这两个方法，这两个id用于标识在transact中客户端所请求的到底是哪个方法<br>（3）接着，它声明了一个内部类Stub，这个Stub就是一个Binder类，当客户端和服务端都位于一个进程时，方法调用不会走跨进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由Stub的内部代理类Proxy来完成。这个接口的核心实现就是<strong>内部了Stub和Stub的内部代理类Proxy</strong></p>
<p><strong>说明：</strong>首先，当客户端发起远程请求时，由于当前线程会被挂起直至服务器进程返回数据，所以如果一个远程方法是很耗时的，那么不能在UI线程中发起次远程请求；其次，由于服务器的Binder方法运行在Binder线程池中，所以Binder方法不管是否耗时都应该采用同步的方式去实现，因为它已经运行在一个线程中了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2016/04/19/Android的IPC机制/" data-id="cj6esnzbw001rwg19nt7eef6e" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2016/04/19/Android的IPC机制/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android系统/">Android系统</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Android EventBus3.0源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/18/Android EventBus3.0源码解析/" class="article-date">
  <time datetime="2016-04-18T15:05:06.000Z" itemprop="datePublished">2016-04-18 23:05:06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/18/Android EventBus3.0源码解析/">Android EventBus3.0源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>前面已经介绍了EventBus3.0开源库的详细使用，下面我们开始进入其源代码的学习，先看看EventBus3.0与2.x版本之间的区别。</p>
<blockquote>
<p>项目地址<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">https://github.com/greenrobot/EventBus</a><br>EventBus版本是3.0</p>
</blockquote>
<h1 id="EventBus-3-0与2-x的区别"><a href="#EventBus-3-0与2-x的区别" class="headerlink" title="EventBus 3.0与2.x的区别"></a>EventBus 3.0与2.x的区别</h1><h2 id="注册订阅者"><a href="#注册订阅者" class="headerlink" title="注册订阅者"></a>注册订阅者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//3.0版本的注册</span></div><div class="line">EventBus.getDefault().register(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"><span class="comment">//2.x版本的注册</span></div><div class="line">EventBus.getDefault().register(<span class="keyword">this</span>);</div><div class="line">EventBus.getDefault().register(<span class="keyword">this</span>, <span class="number">100</span>);</div><div class="line">EventBus.getDefault().registerSticky(<span class="keyword">this</span>, <span class="number">100</span>);</div><div class="line">EventBus.getDefault().registerSticky(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<p>2.x版本中有四种注册方法，区分了普通注册和粘性事件注册，并且在注册时可以选择接受事件的优先级；</p>
<p>3.0版本中将粘性事件以及订阅事件的优先级用注解的方式实现，所以3.0版本中的注册就变得只有一个register()方法注册。</p>
<h2 id="事件订阅方法"><a href="#事件订阅方法" class="headerlink" title="事件订阅方法"></a>事件订阅方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//3.0版本</span></div><div class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.BACKGROUND, sticky = <span class="keyword">true</span>, priority = <span class="number">100</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String str)</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//2.x版本</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(String str)</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventMainThread</span><span class="params">(String str)</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventBackgroundThread</span><span class="params">(String str)</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.x版本中只有通过onEvent开头的方法会被注册，而且响应事件方法触发的线程通过onEventMainThread或onEventBackgroundThread这些方法名区分；</p>
<p>3.0版本中，通过@Subscribe注解来确定运行的线程threadMode，是否接收粘性事件sticky以及事件优先级priority，而且方法名不再需要使用onEvent开头，所以3.0提高了简单性和灵活性。</p>
<h2 id="发送事件"><a href="#发送事件" class="headerlink" title="发送事件"></a>发送事件</h2><p>发送事件和发送粘性事件在2.x和3.0版本中是相同的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().post(<span class="string">"str"</span>);</div><div class="line">EventBus.getDefault().postSticky(<span class="string">"str"</span>);</div></pre></td></tr></table></figure>
<h2 id="解除注册"><a href="#解除注册" class="headerlink" title="解除注册"></a>解除注册</h2><p>2.x和3.0版本的解除注册的方法也是相同的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().unregister(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<h1 id="类关系图"><a href="#类关系图" class="headerlink" title="类关系图"></a>类关系图</h1><p>类图引用自<a href="http://a.codekk.com/detail/Android/Trinea/EventBus%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">CodeKK的EventBus源代码分析</a></p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/eventbus-%E7%B1%BB%E5%9B%BE.png" alt="类图"></p>
<p>从类图可以看出，上部分主要是订阅相关信息，中间是EventBus，下面部分是发布者发布事件后的调用。下面开始进入源码分析:</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>通过EventBus的使用流程来分析它的调用流程及实现原理。</p>
<h2 id="创建EventBus"><a href="#创建EventBus" class="headerlink" title="创建EventBus"></a>创建EventBus</h2><p>一般都是通过<code>EventBus.getDefault()</code>静态方法获取到EventBus对象，先来看看getDefault()方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">synchronized</span> (EventBus.class) &#123;</div><div class="line">			<span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</div><div class="line">				defaultInstance = <span class="keyword">new</span> EventBus();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> defaultInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用<strong>单例模式</strong>获取EventBus对象，目的是保证getDefault方法得到的是同一个EventBus对象。第一次创建实例，会调用EventBus的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>(DEFAULT_BUILDER);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//key:订阅的事件 value：订阅这个事件的所有订阅者集合</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</div><div class="line"></div><div class="line"><span class="comment">//key:订阅者对象， value：这个订阅者订阅的事件集合</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</div><div class="line"></div><div class="line"><span class="comment">//粘性事件 key：粘性事件的class对象， value：事件对象</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</div><div class="line"></div><div class="line">EventBus(EventBusBuilder builder) &#123;</div><div class="line">	subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">	typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">	stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="comment">//事件主线程处理</span></div><div class="line">	mainThreadPoster = <span class="keyword">new</span> HandlerPoster(<span class="keyword">this</span>, Looper.getMainLooper(), <span class="number">10</span>);</div><div class="line">	<span class="comment">//事件Background处理</span></div><div class="line">	backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);</div><div class="line">	<span class="comment">//事件异步线程处理</span></div><div class="line">	asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);</div><div class="line">	indexCount = builder.subscriberInfoIndexes != <span class="keyword">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;</div><div class="line">	<span class="comment">//订阅者想要方法信息存储和查找</span></div><div class="line">	subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,</div><div class="line">			builder.strictMethodVerification, builder.ignoreGeneratedIndex);</div><div class="line">	logSubscriberExceptions = builder.logSubscriberExceptions;</div><div class="line">	logNoSubscriberMessages = builder.logNoSubscriberMessages;</div><div class="line">	sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</div><div class="line">	sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</div><div class="line">	throwSubscriberException = builder.throwSubscriberException;</div><div class="line">	<span class="comment">//是否支持事件继承</span></div><div class="line">	eventInheritance = builder.eventInheritance;</div><div class="line">	executorService = builder.executorService;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="注册事件过程"><a href="#注册事件过程" class="headerlink" title="注册事件过程"></a>注册事件过程</h2><h3 id="register-方法的实现"><a href="#register-方法的实现" class="headerlink" title="register()方法的实现"></a>register()方法的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</div><div class="line">	<span class="comment">//首先获取订阅者的class对象</span></div><div class="line">	Class&lt;`?&gt; subscriberClass = subscriber.getClass();</div><div class="line">	<span class="comment">//1 获取订阅者订阅的事件集合</span></div><div class="line">	List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</div><div class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">		<span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</div><div class="line">			<span class="comment">//2 订阅</span></div><div class="line">			subscribe(subscriber, subscriberMethod);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SubscriberMethod</span><span class="params">(Method method, Class&lt;?&gt; eventType, ThreadMode threadMode, <span class="keyword">int</span> priority, <span class="keyword">boolean</span> sticky)</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>.method = method; <span class="comment">//事件处理方法的Method对象</span></div><div class="line">	<span class="keyword">this</span>.threadMode = threadMode; <span class="comment">//线程的ThreadMode</span></div><div class="line">	<span class="keyword">this</span>.eventType = eventType; <span class="comment">//订阅的事件类型</span></div><div class="line">	<span class="keyword">this</span>.priority = priority; <span class="comment">//事件优先级</span></div><div class="line">	<span class="keyword">this</span>.sticky = sticky; <span class="comment">//是否接收粘性事件</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过subscriberMethodFinder.findSubscriberMethods(subscriberClass)方法可以返回一个SubscriberMethod对象的集合，下面来看看findSubscriberMethods()方法的实现</p>
<h3 id="SubscriberMethodFinder的实现"><a href="#SubscriberMethodFinder的实现" class="headerlink" title="SubscriberMethodFinder的实现"></a>SubscriberMethodFinder的实现</h3><p>SubscriberMethodFinder类就是用来查找和缓存订阅者响应方法的信息的类。那么怎么能获得订阅者响应函数的相关信息呢？在3.0版本中,EventBus提供了一个EventBusAnnotationProcessor注解处理器来在编译期通过读取@Subscribe注解并解析，然后生成java类来保存所有订阅者关于订阅的信息，这样就比在运行时使用反射来获得这些订阅者的信息速度要快。我们可以参考EventBus项目里的EventBusPerformance这个例子，编译后我们可以在build文件夹里找到这个类，MyEventBusIndex类，当然类名是可以自定义的，下面看一下生成的MyEventBusIndex类的组成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * This class is generated by EventBus, do not edit.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventBusIndex</span> <span class="keyword">implements</span> <span class="title">SubscriberInfoIndex</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        SUBSCRIBER_INDEX = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();</div><div class="line"></div><div class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(org.greenrobot.eventbusperf.testsubject.PerfTestEventBus.SubscriberClassEventBusAsync.class,</div><div class="line">                <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[]&#123;</div><div class="line">                <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventAsync"</span>, TestEvent.class, ThreadMode.ASYNC),</div><div class="line">        &#125;));</div><div class="line"></div><div class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(TestRunnerActivity.class, <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[]&#123;</div><div class="line">                <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventMainThread"</span>, TestFinishedEvent.class, ThreadMode.MAIN),</div><div class="line">        &#125;));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putIndex</span><span class="params">(SubscriberInfo info)</span> </span>&#123;</div><div class="line">        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);</div><div class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> info;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出是使用一个静态HashMap即：SUBSCRIBER_INDEX来保存订阅类的信息，其中包括了订阅类的Class对象，是否需要检查父类，以及订阅方法的信息SubscriberMethodInfo的数组，SubscriberMethodInfo中又保存了订阅方法的方法名、订阅的事件类型、触发线程，是否接收sticky事件以及优先级priority。这其中就保存了register()的所有需要的信息，如果再配置EventBus的时候通过EventBuilder配置：<code>eventBus=EventBus.builder().addIndex(new MyEventBusIndex()).build()</code>；来将编译生成的MyEventBusIndex配置进去，这样能在SubscriberMethodFinder类中直接查找出订阅类的信息，就不需要再利用注解判断了，这种方法是作为EventBus的可选配置存在的。</p>
<p>SubscriberMethodFinder同样提供了通过注解来获得订阅类信息的方法，下面来看看findSubscriberMethods()到底是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//先从Method_CACHE取看是否有缓存，key：保存订阅类的类名，value:保存类中订阅的方法名</span></div><div class="line">	List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</div><div class="line">	<span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">return</span> subscriberMethods;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//是否忽略注解器生成的MyEventIndex类，默认false</span></div><div class="line">	<span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</div><div class="line">		<span class="comment">//利用反射来读取订阅类中的订阅方法</span></div><div class="line">		subscriberMethods = findUsingReflection(subscriberClass);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">//从注解器生成的MyEventBusIndex类中获得订阅类的订阅方法</span></div><div class="line">		subscriberMethods = findUsingInfo(subscriberClass);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass</div><div class="line">				+ <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">//保存到缓存中</span></div><div class="line">		METHOD_CACHE.put(subscriberClass, subscriberMethods);</div><div class="line">		<span class="keyword">return</span> subscriberMethods;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>findUsingInfo()方法就是通过查找MyEventBusIndex类中的信息来转换成List<subscribermethod>从而获得订阅类的相关订阅方法的信息集合。</subscribermethod></p>
<p>下面来看看findUsingReflection()的实现过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingReflection</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</div><div class="line">	<span class="comment">//FindState用来做订阅方法的校验和保存</span></div><div class="line">	FindState findState = prepareFindState();</div><div class="line">	findState.initForSubscriber(subscriberClass);</div><div class="line">	<span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">//通过反射获得订阅方法信息</span></div><div class="line">		findUsingReflectionInSingleClass(findState);</div><div class="line">		<span class="comment">//查找父类的订阅方法</span></div><div class="line">		findState.moveToSuperclass();</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//获取findState中的SubscriberMethod(也就是订阅方法List)并返回</span></div><div class="line">	<span class="keyword">return</span> getMethodsAndRelease(findState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里通过FindState类来做订阅方法的校验和保存，并通过FIND_STATE_POOL静态数组来保存FindState对象，可以使FindState复用，避免重复创建过多的对象，最终是通过findUsingReflectionSingleClass()来具体获得相关订阅方法的信息的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</div><div class="line">	Method[] methods;</div><div class="line">	<span class="comment">//通过反射得到方法数组</span></div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		<span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></div><div class="line">		methods = findState.clazz.getDeclaredMethods();</div><div class="line">	&#125; <span class="keyword">catch</span> (Throwable th) &#123;</div><div class="line">		<span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></div><div class="line">		methods = findState.clazz.getMethods();</div><div class="line">		findState.skipSuperClasses = <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//遍历Method</span></div><div class="line">	<span class="keyword">for</span> (Method method : methods) &#123;</div><div class="line">		<span class="keyword">int</span> modifiers = method.getModifiers();</div><div class="line">		<span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</div><div class="line">			Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</div><div class="line">			<span class="comment">//保证必须只有一个事件参数</span></div><div class="line">			<span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</div><div class="line">				<span class="comment">//得到注解</span></div><div class="line">				Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</div><div class="line">				<span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</div><div class="line">					Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</div><div class="line">					<span class="comment">//校验是否添加该方法</span></div><div class="line">					<span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</div><div class="line">						ThreadMode threadMode = subscribeAnnotation.threadMode();</div><div class="line">						<span class="comment">//实例化SubscriberMethod对象并添加</span></div><div class="line">						findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</div><div class="line">								subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</div><div class="line">				String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</div><div class="line">						<span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</div><div class="line">			String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</div><div class="line">					<span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码运行后，订阅类的所有SubscriberMethod都已经被保存了，最后在通过getMethodsAndRelease方法返回List<subscribermethod>集合。</subscribermethod></p>
<p>下面接着来看subscribe()是如何实现的</p>
<h3 id="subsribe-方法的实现"><a href="#subsribe-方法的实现" class="headerlink" title="subsribe()方法的实现"></a>subsribe()方法的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 必须在同步代码块中调用</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//获取订阅事件的事件类型</span></div><div class="line">	Class&lt;?&gt; eventType = subscriberMethod.eventType;</div><div class="line">	<span class="comment">//创建SubScription对象</span></div><div class="line">	Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</div><div class="line">	<span class="comment">//检查是否已经添加过该SubScription对象，添加过则抛出异常</span></div><div class="line">	CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line">	<span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</div><div class="line">		subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</div><div class="line">		subscriptionsByEventType.put(eventType, subscriptions);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></div><div class="line">					+ eventType);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//根据优先级来添加SubScription对象</span></div><div class="line">	<span class="keyword">int</span> size = subscriptions.size();</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</div><div class="line">		<span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</div><div class="line">			subscriptions.add(i, newSubscription);</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//将订阅者对象以及订阅的事件保存到typesBySubscriber中</span></div><div class="line">	List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</div><div class="line">	<span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</div><div class="line">		subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">		typesBySubscriber.put(subscriber, subscribedEvents);</div><div class="line">	&#125;</div><div class="line">	subscribedEvents.add(eventType);</div><div class="line">	<span class="comment">//如果接受sticky事件则立即分发sticky事件</span></div><div class="line">	<span class="keyword">if</span> (subscriberMethod.sticky) &#123;</div><div class="line">		<span class="comment">//eventInheritance表示是否分发订阅了响应事件类及父类事件的方法</span></div><div class="line">		<span class="keyword">if</span> (eventInheritance) &#123;</div><div class="line">			<span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></div><div class="line">			<span class="comment">// <span class="doctag">Note:</span> Iterating over all events may be inefficient with lots of sticky events,</span></div><div class="line">			<span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></div><div class="line">			<span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></div><div class="line">			Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</div><div class="line">			<span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</div><div class="line">				Class&lt;?&gt; candidateEventType = entry.getKey();</div><div class="line">				<span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</div><div class="line">					Object stickyEvent = entry.getValue();</div><div class="line">					checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			Object stickyEvent = stickyEvents.get(eventType);</div><div class="line">			checkPostStickyEventToSubscription(newSubscription, stickyEvent);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一下结合一张图来理解整个注册过程：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/eventbus-%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.png" alt="注册过程"></p>
<h2 id="事件分发过程"><a href="#事件分发过程" class="headerlink" title="事件分发过程"></a>事件分发过程</h2><p>EventBus通过post方法来发送一个事件，首先看看post方法的实现过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</div><div class="line">	<span class="comment">//得到当前线程的Posting状态</span></div><div class="line">	PostingThreadState postingState = currentPostingThreadState.get();</div><div class="line">	<span class="comment">//获取当前线程的事件队列</span></div><div class="line">	List&lt;Object&gt; eventQueue = postingState.eventQueue;</div><div class="line">	<span class="comment">//加入事件到队列</span></div><div class="line">	eventQueue.add(event);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!postingState.isPosting) &#123;</div><div class="line">		postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</div><div class="line">		postingState.isPosting = <span class="keyword">true</span>;</div><div class="line">		<span class="keyword">if</span> (postingState.canceled) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">//发送知道队列为空</span></div><div class="line">			<span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</div><div class="line">				<span class="comment">//发送单个事件</span></div><div class="line">				postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">finally</span> &#123;</div><div class="line">			postingState.isPosting = <span class="keyword">false</span>;</div><div class="line">			postingState.isMainThread = <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先是通过currentPostingThreadState.get()方法来得到当前线程PostingThreadState的对象，为什么是说当前线程？我们来看看currentPostingThreadState的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = <span class="keyword">new</span> ThreadLocal&lt;PostingThreadState&gt;() &#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> PostingThreadState <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> PostingThreadState();</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>currentPostingThreadState的实现是一个包含了PostingThreadState的ThreadLocal对象。</p>
<p>ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储线程，而这段数据是不会与其他线程共享的，其内部原理是通过生成一个它包裹的泛型对象的数组，在不同的线程会有不同的数组索引值，这样就可以做到每个线程通过get()方法获取的时候，取到的只能是自己线程所对应的数据，所以这里取到的就是每个线程的PostingThreadState状态。</p>
<p>接下来我们来看postingSingleEvent()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</div><div class="line">	Class&lt;?&gt; eventClass = event.getClass();</div><div class="line">	<span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</div><div class="line">	<span class="comment">//是否触发订阅了该事件（eventClass）的父类，以及接口的类的响应方法</span></div><div class="line">	<span class="keyword">if</span> (eventInheritance) &#123;</div><div class="line">		<span class="comment">////查找eventClass类所有的父类以及接口</span></div><div class="line">		List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</div><div class="line">		<span class="keyword">int</span> countTypes = eventTypes.size();</div><div class="line">		<span class="comment">//循环postSingleEventForEventType</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</div><div class="line">			Class&lt;?&gt; clazz = eventTypes.get(h);</div><div class="line">			subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="comment">//post单个事件</span></div><div class="line">		subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//如果没有发现</span></div><div class="line">	<span class="keyword">if</span> (!subscriptionFound) &#123;</div><div class="line">		<span class="keyword">if</span> (logNoSubscriberMessages) &#123;</div><div class="line">			Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</div><div class="line">				eventClass != SubscriberExceptionEvent.class) &#123;</div><div class="line">				<span class="comment">//发送一个NoSubscriberEvent事件，如果我们需要处理这种状态，接收这个事件就可以了</span></div><div class="line">			post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面可知，实际上事件分发是在postSingleEventForEventType()方法里进行的，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</div><div class="line">	CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</div><div class="line">	<span class="comment">//获取订阅了这个事件的Subscription列表.</span></div><div class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">		subscriptions = subscriptionsByEventType.get(eventClass);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</div><div class="line">		<span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</div><div class="line">			postingState.event = event;</div><div class="line">			postingState.subscription = subscription;</div><div class="line">			<span class="comment">//是否被中断</span></div><div class="line">			<span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				<span class="comment">//分发给订阅者</span></div><div class="line">				postToSubscription(subscription, event, postingState.isMainThread);</div><div class="line">				aborted = postingState.canceled;</div><div class="line">			&#125; <span class="keyword">finally</span> &#123;</div><div class="line">				postingState.event = <span class="keyword">null</span>;</div><div class="line">				postingState.subscription = <span class="keyword">null</span>;</div><div class="line">				postingState.canceled = <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span> (aborted) &#123;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</div><div class="line">	<span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</div><div class="line">		<span class="keyword">case</span> POSTING:</div><div class="line">			invokeSubscriber(subscription, event);</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> MAIN:</div><div class="line">			<span class="keyword">if</span> (isMainThread) &#123;</div><div class="line">				invokeSubscriber(subscription, event);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				mainThreadPoster.enqueue(subscription, event);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> BACKGROUND:</div><div class="line">			<span class="keyword">if</span> (isMainThread) &#123;</div><div class="line">				backgroundPoster.enqueue(subscription, event);</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				invokeSubscriber(subscription, event);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> ASYNC:</div><div class="line">			asyncPoster.enqueue(subscription, event);</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先从subscriptionsByEventType里获得所有订阅了这个事件的Subscription列表，然后在通过postToSubScription()方法来分发事件，在postToSubScription()通过不同的threadMode在不同的线程里invoke()订阅者的方法，ThreadMode共有四类：</p>
<ul>
<li><p>PostThread：默认的 ThreadMode，表示在执行 Post 操作的线程直接调用订阅者的事件响应方法，不论该线程是否为主线程（UI 线程）。当该线程为主线程时，响应方法中不能有耗时操作，否则有卡主线程的风险。适用场景：对于是否在主线程执行无要求，但若 Post 线程为主线程，不能耗时的操作；</p>
</li>
<li><p>MainThread：在主线程中执行响应方法。如果发布线程就是主线程，则直接调用订阅者的事件响应方法，否则通过主线程的 Handler 发送消息在主线程中处理——调用订阅者的事件响应函数。显然，MainThread类的方法也不能有耗时操作，以避免卡主线程。适用场景：必须在主线程执行的操作；</p>
</li>
<li><p>BackgroundThread：在后台线程中执行响应方法。如果发布线程不是主线程，则直接调用订阅者的事件响应函数，否则启动唯一的后台线程去处理。由于后台线程是唯一的，当事件超过一个的时候，它们会被放在队列中依次执行，因此该类响应方法虽然没有PostThread类和MainThread类方法对性能敏感，但最好不要有重度耗时的操作或太频繁的轻度耗时操作，以造成其他操作等待。适用场景：操作轻微耗时且不会过于频繁，即一般的耗时操作都可以放在这里；</p>
</li>
<li><p>Async：不论发布线程是否为主线程，都使用一个空闲线程来处理。和BackgroundThread不同的是，Async类的所有线程是相互独立的，因此不会出现卡线程的问题。适用场景：长耗时操作，例如网络访问。</p>
</li>
</ul>
<p>下面我们来看看invokeSubscriber(subscription, event)是如何实现的，关于不同线程的Poster使用可以参考这篇文章<a href="http://kymjs.com/code/2015/12/12/01" target="_blank" rel="external">http://kymjs.com/code/2015/12/12/01</a></p>
<p>invokeSubscriber(subscription, event)代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</div><div class="line">	&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">		handleSubscriberException(subscription, event, e.getCause());</div><div class="line">	&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上就是通过反射调用了订阅者的订阅函数并把event对象作为参数传入，至此post()流程如上述所示。整体流程图如下：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/eventbus-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B.png" alt="Post流程"></p>
<h2 id="解除注册过程"><a href="#解除注册过程" class="headerlink" title="解除注册过程"></a>解除注册过程</h2><p>解除注册只要调用unregister()方法即可，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</div><div class="line">	<span class="comment">//通过typesBySubscriber来取出这个subscriber订阅者订阅的事件类型,</span></div><div class="line">	List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</div><div class="line">	<span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="comment">//分别解除每个订阅了的事件类型</span></div><div class="line">		<span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</div><div class="line">			unsubscribeByEventType(subscriber, eventType);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//从typesBySubscriber移除subscriber</span></div><div class="line">		typesBySubscriber.remove(subscriber);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		Log.w(TAG, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>&#123;</div><div class="line">	<span class="comment">//subscriptionsByEventType里拿出这个事件类型的订阅者列表.</span></div><div class="line">	List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</div><div class="line">	<span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">int</span> size = subscriptions.size();</div><div class="line">		<span class="comment">//取消订阅</span></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</div><div class="line">			Subscription subscription = subscriptions.get(i);</div><div class="line">			<span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</div><div class="line">				subscription.active = <span class="keyword">false</span>;</div><div class="line">				subscriptions.remove(i);</div><div class="line">				i--;</div><div class="line">				size--;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终分别从typesBySubscriber和subscriptions里分别移除订阅者以及相关信息即可</p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式是对象的行为模式，又叫发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者模式。观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。EventBus并不是标准的观察者模式的实现，但是它的整体就是一个发布/订阅框架，也拥有观察者模式的有点，比如：发布者和订阅者的解耦。</p>
<p>参考文章:</p>
<p><a href="http://www.jianshu.com/p/f057c460c77e" target="_blank" rel="external">EventBus 3.0 源码分析</a><br><a href="http://kymjs.com/code/2015/12/12/01" target="_blank" rel="external">EventBus源码研读</a><br><a href="http://a.codekk.com/detail/Android/Trinea/EventBus%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">EventBus 源码解析</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2016/04/18/Android EventBus3.0源码解析/" data-id="cj6esnzbe000uwg195d65wxz6" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2016/04/18/Android EventBus3.0源码解析/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码分析/">源码分析</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Android Otto源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/18/Android Otto源码解析/" class="article-date">
  <time datetime="2016-04-18T15:04:06.000Z" itemprop="datePublished">2016-04-18 23:04:06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/18/Android Otto源码解析/">Otto源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>前面介绍了<a href="http://liuguoquan727.github.io/2016/04/17/Android_Otto%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">Otto的使用情况</a>，下面开始进入Otto的源码分析之旅。</p>
<p>首先来看看构造函数：</p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> String identifier;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadEnforcer enforcer;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> HandlerFinder handlerFinder;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bus</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(DEFAULT_IDENTIFIER);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bus</span><span class="params">(String identifier)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(ThreadEnforcer.MAIN, identifier);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bus</span><span class="params">(ThreadEnforcer enforcer, String identifier)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(enforcer, identifier, HandlerFinder.ANNOTATED);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Bus(ThreadEnforcer enforcer, String identifier, HandlerFinder handlerFinder) &#123;</div><div class="line">    <span class="keyword">this</span>.enforcer =  enforcer;</div><div class="line">    <span class="keyword">this</span>.identifier = identifier;</div><div class="line">    <span class="keyword">this</span>.handlerFinder = handlerFinder;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>默认参数enforcer=ThreadEnforcer.MAIN，identifier=DEFAULT_IDENTIFIER，handlerFinder=HandlerFinder.ANNOTATED。下面来看看这些参数是什么意思：</p>
<h2 id="ThreadEnforce"><a href="#ThreadEnforce" class="headerlink" title="ThreadEnforce"></a>ThreadEnforce</h2><p>ThreadEnforce是一个接口，enforce()方法用于检查当前的线程是否为指定的线程类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadEnforcer</span> </span>&#123;</div><div class="line"></div><div class="line">    ThreadEnforcer ANY = <span class="keyword">new</span> ThreadEnforcer() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enforce</span><span class="params">(Bus bus)</span> </span>&#123;</div><div class="line">                <span class="comment">// Allow any thread.</span></div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    ThreadEnforcer MAIN = <span class="keyword">new</span> ThreadEnforcer() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enforce</span><span class="params">(Bus bus)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span> (Looper.myLooper() != Looper.getMainLooper()) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Event bus "</span> + bus +</div><div class="line">                        <span class="string">" accessed from non-main thread "</span> + Looper.myLooper());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enforce</span><span class="params">(Bus bus)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不带参数的构造函数默认使用ThreadEnforcer.MAIN，表示enforce()方法必须在主线程上执行。</p>
<h2 id="identifier"><a href="#identifier" class="headerlink" title="identifier"></a>identifier</h2><p>identifier为Bus对象的名字，debug用</p>
<h2 id="HandlerFinder"><a href="#HandlerFinder" class="headerlink" title="HandlerFinder"></a>HandlerFinder</h2><p>HandlerFinder用于在注册/反注册的时候查找Subscriber和Produce，后文会对其展开源码级别的解析。默认使用HandlerANNOTATED，表示使用注解来进行查找。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>除上述以外，Bus类还有两个成员变量handlersByType和producersByType:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">** 通过event的类型（class类型）来查找event handle。</div><div class="line">*	键为 event类型  值为 事件订阅者集合</div><div class="line">*	一个事件类型可以有多个事件订阅者</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; handlersByType =</div><div class="line">	  <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt;();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">** 通过event的类型（class类型）来查找event producer。</div><div class="line">*	键为 event类型  值为 事件生产者</div><div class="line">*	一个事件类型，只能有一个事件生产者</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, EventProducer&gt; producersByType =</div><div class="line">	  <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, EventProducer&gt;();</div></pre></td></tr></table></figure>
<h1 id="注册-反注册事件"><a href="#注册-反注册事件" class="headerlink" title="注册/反注册事件"></a>注册/反注册事件</h1><p>如下所示要成为订阅者HandlerEvent，只需将其注册到bus，然后使用@Subscribe注解标记回调处理方法即可。回调方法要求可见性为public，有且仅有一个参数，类型为订阅的event。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</div><div class="line">        bus.register(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Subscribe</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">answerAvailable</span><span class="params">(HandlerEvent event)</span> </span>&#123;</div><div class="line">        <span class="comment">// process event</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Subsrible"><a href="#Subsrible" class="headerlink" title="@Subsrible"></a>@Subsrible</h2><p>首先看一下@Subscribe注解:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(ElementType.METHOD)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Subscribe &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RetentionPolicy.RUNTIME表示它是运行时的注解，ElementType.METHOD表示用于注解方法。</p>
<h2 id="register"><a href="#register" class="headerlink" title="register()"></a>register()</h2><p>register流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object object)</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//1.检查当前线程是否符合ThreadEnforcer的设置</span></div><div class="line">	<span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</div><div class="line">	  <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Object to register must not be null."</span>);</div><div class="line">	&#125;</div><div class="line">	enforcer.enforce(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">	<span class="comment">//2.默认情况下，通过@Producer注解找到所有的事件生产者Producers</span></div><div class="line">	Map&lt;Class&lt;?&gt;, EventProducer&gt; foundProducers = handlerFinder.findAllProducers(object);</div><div class="line">	<span class="keyword">for</span> (Class&lt;?&gt; type : foundProducers.keySet()) &#123;</div><div class="line"></div><div class="line">	  <span class="comment">//2-1 判断object上的produce注册的event是否已经被别人注册过</span></div><div class="line">	  <span class="keyword">final</span> EventProducer producer = foundProducers.get(type);</div><div class="line"></div><div class="line">	  <span class="comment">//type存在则返回type对应的值 type不存在则将type的键值设为producer</span></div><div class="line">	  EventProducer previousProducer = producersByType.putIfAbsent(type, producer);</div><div class="line">	  <span class="comment">//checking if the previous producer existed</span></div><div class="line">	  <span class="keyword">if</span> (previousProducer != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Producer method for type "</span> + type</div><div class="line">		  + <span class="string">" found on type "</span> + producer.target.getClass()</div><div class="line">		  + <span class="string">", but already registered by type "</span> + previousProducer.target.getClass() + <span class="string">"."</span>);</div><div class="line">	  &#125;</div><div class="line"></div><div class="line"></div><div class="line">	  <span class="comment">//2-2 如果没有被注册过，那么找出对应event的handler，触发一次回调</span></div><div class="line">	  Set&lt;EventHandler&gt; handlers = handlersByType.get(type);</div><div class="line">	  <span class="keyword">if</span> (handlers != <span class="keyword">null</span> &amp;&amp; !handlers.isEmpty()) &#123;</div><div class="line">		<span class="keyword">for</span> (EventHandler handler : handlers) &#123;</div><div class="line">		  dispatchProducerResultToHandler(handler, producer);</div><div class="line">		&#125;</div><div class="line">	  &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//3. 找出object上用@Subscribe注解的方法</span></div><div class="line">	Map&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; foundHandlersMap = handlerFinder.findAllSubscribers(object);</div><div class="line">	<span class="keyword">for</span> (Class&lt;?&gt; type : foundHandlersMap.keySet()) &#123;</div><div class="line">	  Set&lt;EventHandler&gt; handlers = handlersByType.get(type);</div><div class="line">	  </div><div class="line">	  </div><div class="line">	  <span class="keyword">if</span> (handlers == <span class="keyword">null</span>) &#123;</div><div class="line">		</div><div class="line">		<span class="comment">//3-1，该event是第一次注册，那么新建一个CopyOnWriteArraySet用来保存handler和event的对应关系</span></div><div class="line">		</div><div class="line">		Set&lt;EventHandler&gt; handlersCreation = <span class="keyword">new</span> CopyOnWriteArraySet&lt;EventHandler&gt;();</div><div class="line">		handlers = handlersByType.putIfAbsent(type, handlersCreation);</div><div class="line">		<span class="keyword">if</span> (handlers == <span class="keyword">null</span>) &#123;</div><div class="line">			handlers = handlersCreation;</div><div class="line">		&#125;</div><div class="line">	  &#125;</div><div class="line">	  </div><div class="line">	  <span class="comment">//3-2,保存object中新增的event-handler对应关系</span></div><div class="line">	  <span class="keyword">final</span> Set&lt;EventHandler&gt; foundHandlers = foundHandlersMap.get(type);</div><div class="line">	  <span class="keyword">if</span> (!handlers.addAll(foundHandlers)) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Object already registered."</span>);</div><div class="line">	  &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//4.检查object上的event是否存在对应的Producer，有则触发一次调用</span></div><div class="line">	<span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; entry : foundHandlersMap.entrySet()) &#123;</div><div class="line">	  Class&lt;?&gt; type = entry.getKey();</div><div class="line">	  EventProducer producer = producersByType.get(type);</div><div class="line">	  <span class="keyword">if</span> (producer != <span class="keyword">null</span> &amp;&amp; producer.isValid()) &#123;</div><div class="line">		Set&lt;EventHandler&gt; foundHandlers = entry.getValue();</div><div class="line">		<span class="keyword">for</span> (EventHandler foundHandler : foundHandlers) &#123;</div><div class="line">		  <span class="keyword">if</span> (!producer.isValid()) &#123;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		  &#125;</div><div class="line">		  <span class="keyword">if</span> (foundHandler.isValid()) &#123;</div><div class="line">			dispatchProducerResultToHandler(foundHandler, producer);</div><div class="line">		  &#125;</div><div class="line">		&#125;</div><div class="line">	  &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>register方法主要做了三件事情：触发新的Producer；注册新的event-handler关系；触发旧的Producer。另外有两点要注意：</p>
<ul>
<li>在保证线程安全的情况下，使用CopyOnWriteArraySet作为保存event和handler的容器，可以大大提高效率。</li>
<li>由于register方法没有加锁，所有在3-1中，尽管已经检查了handlers是否存在，但仍需使用putIfAbsent来保存handler。</li>
</ul>
<h2 id="HandlerFinder-1"><a href="#HandlerFinder-1" class="headerlink" title="HandlerFinder"></a>HandlerFinder</h2><p>注意到Bus通过HandlerFinder来查找object上的producer和subscriber，接下来看一下HanderFinder的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HandlerFinder</span> </span>&#123;</div><div class="line"></div><div class="line">  Map&lt;Class&lt;?&gt;, EventProducer&gt; findAllProducers(Object listener);</div><div class="line"></div><div class="line">  Map&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; findAllSubscribers(Object listener);</div><div class="line"></div><div class="line"></div><div class="line">  HandlerFinder ANNOTATED = <span class="keyword">new</span> HandlerFinder() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Map&lt;Class&lt;?&gt;, EventProducer&gt; findAllProducers(Object listener) &#123;</div><div class="line">      <span class="keyword">return</span> AnnotatedHandlerFinder.findAllProducers(listener);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Map&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; findAllSubscribers(Object listener) &#123;</div><div class="line">      <span class="keyword">return</span> AnnotatedHandlerFinder.findAllSubscribers(listener);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中findAllProducers方法返回某event type对应的EventProducers，findAllSubscribers返回某event type对应的EventHandler集合。</p>
<h2 id="EventProducer"><a href="#EventProducer" class="headerlink" title="EventProducer"></a>EventProducer</h2><p>EventProducer是producer方法的包装类，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventProducer</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Object target;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hashCode;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    EventProducer(Object target, Method method) &#123;</div><div class="line">        <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(</div><div class="line">                <span class="string">"EventProducer target cannot be null."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(</div><div class="line">                <span class="string">"EventProducer method cannot be null."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.target = target;</div><div class="line">        <span class="keyword">this</span>.method = method;</div><div class="line">        method.setAccessible(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 提前计算hashcode，以防每次调用hash()时消耗资源</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</div><div class="line">        hashCode = ((prime + method.hashCode()) * prime) + target.hashCode();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> valid;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 应在object unregister时调用</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span> </span>&#123;</div><div class="line">        valid = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">produceEvent</span><span class="params">()</span> <span class="keyword">throws</span> InvocationTargetException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!valid) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(toString() +</div><div class="line">                <span class="string">" has been invalidated and can no longer produce events."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> method.invoke(target);</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e);</div><div class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">            <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> Error) &#123;</div><div class="line">                <span class="keyword">throw</span> (Error) e.getCause();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 produceEvent方法用于获得event。可以看出Otto要求produce方法不能有参数。</p>
<h2 id="EventHandler"><a href="#EventHandler" class="headerlink" title="EventHandler"></a>EventHandler</h2><p>EventHandler是一个event handler方法（事件回调）的包装类，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hashCode;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    EventHandler(Object target, Method method) &#123;</div><div class="line">        <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(</div><div class="line">                <span class="string">"EventHandler target cannot be null."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(</div><div class="line">                <span class="string">"EventHandler method cannot be null."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.target = target;</div><div class="line">        <span class="keyword">this</span>.method = method;</div><div class="line">        method.setAccessible(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Compute hash code eagerly since we know it will be used frequently and we cannot estimate the runtime of the</span></div><div class="line">        <span class="comment">// target's hashCode call.</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prime = <span class="number">31</span>;</div><div class="line">        hashCode = ((prime + method.hashCode()) * prime) + target.hashCode();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> valid;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span> </span>&#123;</div><div class="line">        valid = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">(Object event)</span> <span class="keyword">throws</span> InvocationTargetException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!valid) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(toString() +</div><div class="line">                <span class="string">" has been invalidated and can no longer handle events."</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            method.invoke(target, event);</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e);</div><div class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">            <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> Error) &#123;</div><div class="line">                <span class="keyword">throw</span> (Error) e.getCause();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中handlEvent方法用于在object上调用handle方法（事件回调），传入event对象。Otto要求event handler方法只能有一个参数就是event handler类。</p>
<h2 id="dispatchProducerResultToHandler"><a href="#dispatchProducerResultToHandler" class="headerlink" title="dispatchProducerResultToHandler()"></a>dispatchProducerResultToHandler()</h2><p>dispatchProducerResultToHandler方法用于将Producer产生的event分发给对应的handler，源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchProducerResultToHandler</span><span class="params">(EventHandler handler, EventProducer producer)</span> </span>&#123;</div><div class="line">    Object event = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        event = producer.produceEvent();</div><div class="line">    &#125; <span class="keyword">catch</span>(InvocationTargetException e) &#123;</div><div class="line">        throwRuntimeException(<span class="string">"Producer "</span> + producer + <span class="string">" threw an exception."</span>, e);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    dispatch(event, handler);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Object event, EventHandler wrapper)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        wrapper.handleEvent(event);</div><div class="line">    &#125; <span class="keyword">catch</span>(InvocationTargetException e) &#123;</div><div class="line">        throwRuntimeException(<span class="string">"Could not dispatch event: "</span> + event.getClass() + <span class="string">" to handler "</span> + wrapper, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要使用了Producer的produceEvent()获取event对象后，调用EventHandler的handleEvent（）方法处理事件。</p>
<h2 id="unregister"><a href="#unregister" class="headerlink" title="unregister()"></a>unregister()</h2><p>Bus类的unregister()方法用于解除目标对象和Bus之间的关联关系，包括对象上的producer方法，subscriber方法，源码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object object)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Object to unregister must not be null."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//1. 检查当前线程是否符合ThreadEnforcer的设置</span></div><div class="line">    enforcer.enforce(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="comment">//2. 默认情况下，通过注解在object上找出所有Producer，将其从producersByType中删除并标记为invalidate</span></div><div class="line">    Map&lt;Class&lt;?&gt;, EventProducer&gt; producersInListener = handlerFinder.findAllProducers(object);</div><div class="line">    <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, EventProducer&gt; entry : producersInListener.entrySet()) &#123;</div><div class="line">        <span class="keyword">final</span> Class&lt;?&gt; key = entry.getKey();</div><div class="line">        EventProducer producer = getProducerForEventType(key);</div><div class="line">        EventProducer value = entry.getValue();</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span> || !value.equals(producer)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">            <span class="string">"Missing event producer for an annotated method. Is "</span> + object.getClass() + <span class="string">" registered?"</span>);</div><div class="line">        &#125;</div><div class="line">        producersByType.remove(key).invalidate();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//3. 默认情况下，找出object上用@Subscribe注解了的handler，将其从event集合中删除并标记为invalidate</span></div><div class="line">    Map&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; handlersInListener = handlerFinder.findAllSubscribers(object);</div><div class="line">    <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; entry : handlersInListener.entrySet()) &#123;</div><div class="line">        Set&lt;EventHandler&gt; currentHandlers = getHandlersForEventType(entry.getKey());</div><div class="line">        Collection&lt;EventHandler&gt; eventMethodsInListener = entry.getValue();</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (currentHandlers == <span class="keyword">null</span> || !currentHandlers.containsAll(eventMethodsInListener)) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">            <span class="string">"Missing event handler for an annotated method. Is "</span> + object.getClass() + <span class="string">" registered?"</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (EventHandler handler : currentHandlers) &#123;</div><div class="line">            <span class="keyword">if</span> (eventMethodsInListener.contains(handler)) &#123;</div><div class="line">                handler.invalidate();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        currentHandlers.removeAll(eventMethodsInListener);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="投递事件"><a href="#投递事件" class="headerlink" title="投递事件"></a>投递事件</h1><h2 id="post"><a href="#post" class="headerlink" title="post()"></a>post()</h2><p>简单的事件投递过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">bus.post(<span class="keyword">new</span> HandlerEvent(<span class="number">42</span>));</div><div class="line"></div><div class="line">或者</div><div class="line"></div><div class="line">bus.post(getEvent);</div><div class="line"></div><div class="line"><span class="meta">@Producer</span></div><div class="line"><span class="function"><span class="keyword">public</span> HandlerEvent <span class="title">getEvent</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> HandlerEvent(<span class="number">42</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面来看下post方法实现的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function">ublic <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Event to post must not be null."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//1. 检查当前线程是否符合ThreadEnforcer的设置</span></div><div class="line">    enforcer.enforce(<span class="keyword">this</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//2. 向上追溯event的所有父类</span></div><div class="line">    Set&lt;Class&lt;?&gt;&gt;dispatchTypes = flattenHierarchy(event.getClass());</div><div class="line">    </div><div class="line">    <span class="comment">//3. 当前event没有注册handler，则发送一个DeadEvent事件</span></div><div class="line">    <span class="keyword">boolean</span> dispatched = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">for</span> (Class&lt;?&gt;eventType: dispatchTypes) &#123;</div><div class="line">        Set&lt;EventHandler&gt; wrappers = getHandlersForEventType(eventType);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (wrappers != <span class="keyword">null</span> &amp;&amp; !wrappers.isEmpty()) &#123;</div><div class="line">            dispatched = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">for</span> (EventHandler wrapper: wrappers) &#123;</div><div class="line">                <span class="comment">//3-1 将事件和handler放到分发队列里</span></div><div class="line">                enqueueEvent(event, wrapper);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//4. 当前event没有注册handler，则发送一个DeadEvent事件</span></div><div class="line">    <span class="keyword">if</span> (!dispatched &amp;&amp; !(event <span class="keyword">instanceof</span> DeadEvent)) &#123;</div><div class="line">        post(<span class="keyword">new</span> DeadEvent(<span class="keyword">this</span>, event));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//5. 通知队列进行分发操作</span></div><div class="line">    dispatchQueuedEvents();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意两点：</p>
<ul>
<li>发送一个Event时，订阅了Event父类的Subscriber方法也会被调用</li>
<li>事件被放到调用者所在线程的队列里依次分发</li>
</ul>
<h2 id="flattenHierarchy"><a href="#flattenHierarchy" class="headerlink" title="flattenHierarchy()"></a>flattenHierarchy()</h2><p>进行post操作时，首先会通过flattenHierarchy方法获得event的所有父类或接口的集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"> Set&lt;Class&lt;?&gt;&gt; flattenHierarchy(Class&lt;?&gt; concreteClass) &#123;</div><div class="line">   Set&lt;Class&lt;?&gt;&gt; classes = flattenHierarchyCache.get(concreteClass);</div><div class="line">   <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</div><div class="line">     Set&lt;Class&lt;?&gt;&gt; classesCreation = getClassesFor(concreteClass);</div><div class="line">     classes = flattenHierarchyCache.putIfAbsent(concreteClass, classesCreation);</div><div class="line">     <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</div><div class="line">       classes = classesCreation;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">return</span> classes;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="comment">//利用深度优先遍历导出了concreteClass的所有父类</span></div><div class="line"> <span class="keyword">private</span> Set&lt;Class&lt;?&gt;&gt; getClassesFor(Class&lt;?&gt; concreteClass) &#123;</div><div class="line">   List&lt;Class&lt;?&gt;&gt; parents = <span class="keyword">new</span> LinkedList&lt;Class&lt;?&gt;&gt;();</div><div class="line">   Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;();</div><div class="line"></div><div class="line">   parents.add(concreteClass);</div><div class="line"></div><div class="line"><span class="comment">//深度优先遍历</span></div><div class="line">   <span class="keyword">while</span> (!parents.isEmpty()) &#123;</div><div class="line">     Class&lt;?&gt; clazz = parents.remove(<span class="number">0</span>);</div><div class="line">     classes.add(clazz);</div><div class="line"></div><div class="line">     Class&lt;?&gt; parent = clazz.getSuperclass();</div><div class="line">     <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">       parents.add(parent);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> classes;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="Dispatch-Queue"><a href="#Dispatch-Queue" class="headerlink" title="Dispatch Queue"></a>Dispatch Queue</h2><p>通过post方法投递的event首先会放到当前线程所在的Dispatch Queue中，然后依次分发。Bus类有如下成员属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;ConcurrentLinkedQueue&lt;EventWithHandler&gt;&gt; eventsToDispatch =</div><div class="line">    <span class="keyword">new</span> ThreadLocal&lt;ConcurrentLinkedQueue&lt;EventWithHandler&gt;&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> ConcurrentLinkedQueue&lt;EventWithHandler&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcurrentLinkedQueue&lt;EventWithHandler&gt;();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>eventsToDispatch是一个ThreadLocal对象，通过initialValue()方法，eventsToDispatch每次在新的线程上调用的时候都会生成新的ConcurrentLinkedQueue实例。event是通过enqueueEvent方法放到queue中的，下面看看equeueEvent()的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">enqueueEvent</span><span class="params">(Object event, EventHandler handler)</span> </span>&#123;</div><div class="line">	eventsToDispatch.get().offer(<span class="keyword">new</span> EventWithHandler(event, handler));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>offer()方法会将EventWithHandler对象放到当前线程的queue的尾部。offer方法和add方法的区别在于，当无法插入（例如空间不够）情况下会返回false，而不是抛出异常。EventWithHandler类对event和handler的关系进行了简单的包装，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EventWithHandler</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> Object event;</div><div class="line">	<span class="keyword">final</span> EventHandler handler;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">EventWithHandler</span><span class="params">(Object event, EventHandler handler)</span> </span>&#123;</div><div class="line">	  <span class="keyword">this</span>.event = event;</div><div class="line">	  <span class="keyword">this</span>.handler = handler;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来看看dispatchQueuedEvents方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchQueuedEvents</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// don't dispatch if we're already dispatching, that would allow reentrancy and out-of-order events. Instead, leave</span></div><div class="line">    <span class="comment">// the events to be dispatched after the in-progress dispatch is complete.</span></div><div class="line">    <span class="comment">//1. 不能重复分发，否则会导致event的分发次序混乱</span></div><div class="line">    <span class="keyword">if</span> (isDispatching.get()) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    isDispatching.set(<span class="keyword">true</span>);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="comment">//2. 依次取出EventWithHandler，并通过dispatch方法进行分发。</span></div><div class="line">            EventWithHandler eventWithHandler = eventsToDispatch.get().poll();</div><div class="line">            <span class="keyword">if</span> (eventWithHandler == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (eventWithHandler.handler.isValid()) &#123;</div><div class="line">                dispatch(eventWithHandler.event, eventWithHandler.handler);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        isDispatching.set(<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Object event, EventHandler wrapper)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      wrapper.handleEvent(event);</div><div class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">      throwRuntimeException(</div><div class="line">          <span class="string">"Could not dispatch event: "</span> + event.getClass() + <span class="string">" to handler "</span> + wrapper, e);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>值得注意的是，所有subscrible方法抛出的异常都会在这里捕获，捕获到异常以后event分发过程即停止，直到下一次在该线程上调用post为止。</p>
<h1 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h1><p>Otto的总体结构如下表示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">            +-------------------------+</div><div class="line">            |Bus(ThreadLocal)         |</div><div class="line">            |     +--------------+    |</div><div class="line">            |     |EventProducers|    |</div><div class="line">            |     |  +-------+   |  register  +-------+</div><div class="line">            |     |  |Produce|   &lt;----+-------+Produce|</div><div class="line">            |     |  +-------+   |    |       +-------+</div><div class="line">            |     |  +-------+   |    |</div><div class="line">            |     |  |Produce|   |    |</div><div class="line">            |     |  +-------+   |    |</div><div class="line">            |     +--------------+    |</div><div class="line">            |            |            |</div><div class="line">            |          event          |</div><div class="line">            |            |            |</div><div class="line"> post(event)|    +-------v--------+   |</div><div class="line">+----------------&gt; Dispatch Queue |   |</div><div class="line">            |    +-------+--------+   |</div><div class="line">            |            |            |</div><div class="line">            |          event          |</div><div class="line">            |            |            |</div><div class="line">            |     +------v------+     |</div><div class="line">            |     |EventHandlers|     |</div><div class="line">            |     | +---------+ |     |</div><div class="line">            |     | |Subscribe| |   register  +---------+</div><div class="line">            |     | +---------+ &lt;-----+-------+Subscribe|</div><div class="line">            |     | +---------+ |     |       +---------+</div><div class="line">            |     | |Subscribe| |     |</div><div class="line">            |     | +---------+ |     |</div><div class="line">            |     +-------------+     |</div><div class="line">            |                         |</div><div class="line">            +-------------------------+</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2016/04/18/Android Otto源码解析/" data-id="cj6esnzbg000ywg19avudynmm" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2016/04/18/Android Otto源码解析/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码分析/">源码分析</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Android Okhttp使用详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/17/Android Okhttp使用详解/" class="article-date">
  <time datetime="2016-04-17T14:04:06.000Z" itemprop="datePublished">2016-04-17 22:04:06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/Android Okhttp使用详解/">Okhttp使用详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>Okhttp是高性能的http库，支持同步、异步，而且实现了spdy、http2、websocket协议，api很简洁易用，和volley一样实现了http协议的缓存。Okhttp已经被Android官方采用，实现了几乎和Java.net.HttpURLConnection一样的功能。</p>
<h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="http://square.github.io/okhttp/" target="_blank" rel="external">官方介绍：http://square.github.io/okhttp/</a><br><a href="https://github.com/square/okhttp" target="_blank" rel="external">Github源代码：https://github.com/square/okhttp</a></p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ul>
<li>一般的Get请求</li>
<li>一般的Post请求</li>
<li>基于Http的文件上传</li>
<li>文件下载</li>
<li>加载图片</li>
<li>支持请求回调，直接返回对象、对象集合</li>
<li>支持session的保持</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="Http-Get"><a href="#Http-Get" class="headerlink" title="Http Get"></a>Http Get</h2><p>对于网络加载库，最常用的就是http get请求，比如获取一个网页的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">//1.创建OkHttpClient对象</span></div><div class="line">    OkHttpClient mOkHttpClient = <span class="keyword">new</span> OkHttpClient();</div><div class="line"></div><div class="line">    <span class="comment">//2.创建一个Request</span></div><div class="line">    <span class="keyword">final</span> Request mRequest = <span class="keyword">new</span> Request.Builder().url(<span class="string">"https://www.baidu.com"</span>).build();</div><div class="line"></div><div class="line">    <span class="comment">//3.创建Call对象</span></div><div class="line">    Call mCall = mOkHttpClient.newCall(mRequest);</div><div class="line"></div><div class="line">    <span class="comment">//4.请求加入调度</span></div><div class="line">    mCall.enqueue(<span class="keyword">new</span> Callback() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</div><div class="line"></div><div class="line">            runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    mMsgTxt.setText(<span class="string">"failure"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, <span class="keyword">final</span> Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"></div><div class="line">            <span class="comment">//字符串</span></div><div class="line">            <span class="keyword">final</span> String msg = response.body().string();</div><div class="line">            <span class="comment">//字节数组</span></div><div class="line">            <span class="keyword">byte</span>[] msgBytes = response.body().bytes();</div><div class="line">            <span class="comment">//流</span></div><div class="line">            InputStream inputStream = response.body().byteStream();</div><div class="line"></div><div class="line">            runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    mMsgTxt.setText(msg);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就是发送一个Get请求的步骤</p>
<ol>
<li>首先构造一个Request对象，参数最少有个url，可以通过Request.Builder设置更多的参数，比如：header、method等。</li>
<li>然后通过Request的对象去够着一个Call对象，类似于将你的请求封装成任务。</li>
<li>最后，我们希望以异步的方式去执行请求，所以我们调用的是call.equeue，将call加入调度队列，然后等待任务执行完成，在Callback中即可得到结果。注意，回调方法都是运行在子线程中，如果需要操作控件，需要使用Handler切换到主线程。</li>
</ol>
<p>上面是异步的方式执行get请求，当然也支持阻塞的方式，直接调用call.execute()方法返回一个Response。如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//阻塞调用</span></div><div class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Response response = mCall.execute();</div><div class="line">			System.out.println(response.body().string());</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<h2 id="Http-post请求"><a href="#Http-post请求" class="headerlink" title="Http post请求"></a>Http post请求</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Request request = buildMultipartFormRequest(</div><div class="line">        url, <span class="keyword">new</span> File[]&#123;file&#125;, <span class="keyword">new</span> String[]&#123;fileKey&#125;, <span class="keyword">null</span>);</div><div class="line">FormEncodingBuilder builder = <span class="keyword">new</span> FormEncodingBuilder();   </div><div class="line">builder.add(<span class="string">"username"</span>,<span class="string">"liuguoquan"</span>);</div><div class="line"></div><div class="line">Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">                   .url(url)</div><div class="line">                .post(builder.build())</div><div class="line">                .build();</div><div class="line"> mOkHttpClient.newCall(request).enqueue(<span class="keyword">new</span> Callback()&#123;&#125;);</div></pre></td></tr></table></figure>
<p>Post请求时，参数是包含在请求体中的，所以我们通过FormEncodingBuilder，添加多个String键值对，然后去构造RequestBody，最后完成Request的构造。</p>
<h2 id="基于Http的文件上传"><a href="#基于Http的文件上传" class="headerlink" title="基于Http的文件上传"></a>基于Http的文件上传</h2><p>接下来构造一个RequestBody的Builder叫做MultipartBuilder。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">File file = new File(Environment.getExternalStorageDirectory(), "balabala.mp4");</div><div class="line"></div><div class="line">RequestBody fileBody = RequestBody.create(MediaType.parse("application/octet-stream"), file);</div><div class="line"></div><div class="line">RequestBody requestBody = new MultipartBuilder()</div><div class="line">     .type(MultipartBuilder.FORM)</div><div class="line">     .addPart(Headers.of(</div><div class="line">          "Content-Disposition", </div><div class="line">              "form-data; name=\"username\""), </div><div class="line">          RequestBody.create(null, "liu"))</div><div class="line">     .addPart(Headers.of(</div><div class="line">         "Content-Disposition", </div><div class="line">         "form-data; name=\"mFile\"; </div><div class="line">         filename=\"wjd.mp4\""), fileBody)</div><div class="line">     .build();</div><div class="line"></div><div class="line">Request request = new Request.Builder()</div><div class="line">    .url("http://192.168.1.103:8080/okHttpServer/fileUpload")</div><div class="line">    .post(requestBody)</div><div class="line">    .build();</div><div class="line"></div><div class="line">Call call = mOkHttpClient.newCall(request);</div><div class="line">call.enqueue(new Callback()</div><div class="line">&#123;</div><div class="line">    //...</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上述代码向服务器传递了一个键值对username：liu和一个文件。通过MultipartBuilder的addPart方法可以添加键值对或者文件。</p>
<h2 id="图片下载"><a href="#图片下载" class="headerlink" title="图片下载"></a>图片下载</h2><p>图片下载和文件下载，这两个是通过回调的Response拿到byte[]然后解码成图片；文件下载就是拿到InputStream后做写文件操作。</p>
<p>参考文章：</p>
<p><a href="http://blog.csdn.net/lmj623565791/article/details/23781773" target="_blank" rel="external">从原理角度解析Android （Java） http 文件上传</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0106/2275.html" target="_blank" rel="external">泡网：OkHttp使用教程</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2016/04/17/Android Okhttp使用详解/" data-id="cj6esnzbc000rwg19xkyo6x19" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2016/04/17/Android Okhttp使用详解/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/实战/">实战</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Android_Otto使用详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/17/Android_Otto使用详解/" class="article-date">
  <time datetime="2016-04-17T12:04:06.000Z" itemprop="datePublished">2016-04-17 20:04:06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/Android_Otto使用详解/">Otto使用详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>Otto是Square推出的基于Guava项目的Android支持库，otto是一个事件总线，用于应用程序的不同组件之间进行有效的通信。OTTO是基于Observer的设计模式。它有发布者，订阅者这两个主要对象。OTTO的最佳实践就是通过反射牺牲了微小的性能，同时极大的降低了程序的耦合度。</p>
<p>Otto官网: <a href="http://square.github.io/otto/" target="_blank" rel="external">http://square.github.io/otto/</a></p>
<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>Otto框架的主要功能是帮助我们来降低多个组件通信之间的耦合度（解耦）。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>比如：由界面A跳转至界面B，然后点击B中的Button发送消息更新界面A的视图；<br>比如：界面有一个界面A，A里面有个Fragment，点击Fragment中的一个Button，跳转至界面B，点击界面B的Button来更新界面A的Fragment视图，等等。</p>
<p>上面列出的两种场景，以前可以用startActivityForResult和interface的方式实现的话会比较麻烦，并且产生了很多的状态判断和逻辑判断，并且可能产生很多不必要的bug，代码量也比较大和繁琐，使用Otto就可以容易的避免这些问题。</p>
<h1 id="基本用法实例"><a href="#基本用法实例" class="headerlink" title="基本用法实例"></a>基本用法实例</h1><h2 id="添加Otto"><a href="#添加Otto" class="headerlink" title="添加Otto"></a>添加Otto</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">dependencies</span> &#123;</div><div class="line">  <span class="keyword">compile</span> <span class="string">'com.squareup:otto:1.3.8'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="实现一个Bus的单例"><a href="#实现一个Bus的单例" class="headerlink" title="实现一个Bus的单例"></a>实现一个Bus的单例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  单例Bus对象</div><div class="line"> * Created by Michael on 2016/4/25.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BusProvider</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Bus bus = <span class="keyword">new</span> Bus();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bus <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> bus;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BusProvider</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="自定义一个Event事件，封装消息"><a href="#自定义一个Event事件，封装消息" class="headerlink" title="自定义一个Event事件，封装消息"></a>自定义一个Event事件，封装消息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 自定义一个Event事件，用来封装信息</div><div class="line"> * Created by Michael on 2016/4/25.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventFirst</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> String msg;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventFirst</span><span class="params">(String msg)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.msg = msg;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="MainActivity，订阅事件"><a href="#MainActivity，订阅事件" class="headerlink" title="MainActivity，订阅事件"></a>MainActivity，订阅事件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Button mBtn1;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        <span class="comment">//订阅事件</span></div><div class="line">        BusProvider.getInstance().register(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">        mBtn1 = (Button) findViewById(R.id.btn_1);</div><div class="line"></div><div class="line">        mBtn1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">                startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,BActivity.class));</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 处理事件EventFirst</div><div class="line">     * <span class="doctag">@param</span> event</div><div class="line">     */</div><div class="line">    <span class="meta">@Subscribe</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventFirst</span><span class="params">(EventFirst event)</span> </span>&#123;</div><div class="line"></div><div class="line">        mBtn1.setText(event.msg);</div><div class="line">        System.out.println(<span class="string">"onEventFirst:"</span> + event.msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Subscribe</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventSecond</span><span class="params">(EventFirst event)</span> </span>&#123;</div><div class="line"></div><div class="line">        mBtn1.setText(event.msg);</div><div class="line">        System.out.println(<span class="string">"onEventFirst:"</span> + event.msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        <span class="comment">//取消订阅</span></div><div class="line">        BusProvider.getInstance().register(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>@Subscrible这个注解在调用了register之后有效，表示订阅一个事件，并且方法用public修饰，方法名可以任意取，参数为自定义的事件类，Otto根据事件对象的类名来判断和处理对应的事件。</p>
<h2 id="BActivity发送订阅事件"><a href="#BActivity发送订阅事件" class="headerlink" title="BActivity发送订阅事件"></a>BActivity发送订阅事件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Button mBtn;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_b);</div><div class="line"></div><div class="line"><span class="comment">//        BusProvider.getInstance().register(this);</span></div><div class="line"></div><div class="line">        mBtn = (Button) findViewById(R.id.btn_1);</div><div class="line"></div><div class="line">        mBtn.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line"> <span class="comment">//               BusProvider.getInstance().post(new EventFirst("Event First"));</span></div><div class="line">                BusProvider.getInstance().post(produceEventFirst());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 产生事件</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Produce</span></div><div class="line">    <span class="function"><span class="keyword">public</span> EventFirst <span class="title">produceEventFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EventFirst(<span class="string">"Event First"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line"><span class="comment">//        BusProvider.getInstance().unregister(this);</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>@Produce注解告诉Bus该函数是一个事件产生者，产生的事件类型为该函数的返回值。</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>点击BActivity中的按钮发送消息，然后返回至MainActivity中，打印如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">04</span>-<span class="number">25</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">13.179</span> <span class="number">24744</span>-<span class="number">24744</span>/com<span class="selector-class">.example</span><span class="selector-class">.michael</span><span class="selector-class">.ottodemo</span> I/System<span class="selector-class">.out</span>: onEventSecond:Event First</div><div class="line"><span class="number">04</span>-<span class="number">25</span> <span class="number">10</span>:<span class="number">52</span>:<span class="number">13.179</span> <span class="number">24744</span>-<span class="number">24744</span>/com<span class="selector-class">.example</span><span class="selector-class">.michael</span><span class="selector-class">.ottodemo</span> I/System<span class="selector-class">.out</span>: onEventFirst:Event First</div></pre></td></tr></table></figure>
<p>结果说明：@Subscrible注解的消息处理函数时根据事件对象的类名来确定事件类型，这里的两个方法的参数都是EventFirst类型，所以两个方法都处理了EventFirst事件消息。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过例子我们可以发现，其实事件发布者不用@Produce注解和注册事件也可以发布消息。但是你要Subscribe订阅事件就一定要register这个类了,否则是接受不到事件的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2016/04/17/Android_Otto使用详解/" data-id="cj6esnzbu001owg19kthyy67p" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2016/04/17/Android_Otto使用详解/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/实战/">实战</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Android_EventBus使用详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/17/Android_EventBus使用详解/" class="article-date">
  <time datetime="2016-04-17T11:22:20.000Z" itemprop="datePublished">2016-04-17 19:22:20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/Android_EventBus使用详解/">EventBus使用详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>EventBus是一个Android事件发布/订阅框架，通过解耦发布者和订阅者简化Android事件传递，这里的事件可以理解为消息。事件传递既可以用于Android四大组件间通讯，也可以用于异步线程和主线程间通讯等。<br>传统的事件传递方式包括：Handler、BroadcastReceiver、Interface回调，相比之下EventBus的有点是代码简洁，使用简单，并将事件发布和 订阅充分解耦。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>事件Event： </strong>又可成为消息，其实就是一个对象，可以是网络请求返回的字符串，也可以是某个开关状态等等。事件类型EventType是指事件所属的Class。</p>
<p>事件分为一般事件和Sticky事件，相对于一般事件，Sticky事件不同之处在于，当事件发布后，再有订阅者开始订阅该类型事件，依然能收到该类型事件的最近一个Sticky事件。</p>
<p><strong>订阅者Subscriber： </strong>订阅某种事件类型的对象，当有发布者发布这类事件后，EventBus会执行订阅者的onEvent函数，这个函数叫事件响应函数。订阅者通过register接口订阅某个事件类型，unregister接口退订。订阅者存在优先级，优先级高的订阅者可以取消事件继续向优先级低的订阅者分发，默认所有订阅者优先级都为0。</p>
<p><strong>发布者Publisher： </strong>发布某事件的对象，通过post接口发布事件。</p>
<h2 id="GitHub地址"><a href="#GitHub地址" class="headerlink" title="GitHub地址"></a>GitHub地址</h2><p><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus源码：https://github.com/greenrobot/EventBus</a></p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="自定义一个事件类"><a href="#自定义一个事件类" class="headerlink" title="自定义一个事件类"></a>自定义一个事件类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnyEventType</span> </span>&#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="title">AnyEventType</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="在要接受消息的页面注册"><a href="#在要接受消息的页面注册" class="headerlink" title="在要接受消息的页面注册"></a>在要接受消息的页面注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().register(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<h3 id="接收消息的方法"><a href="#接收消息的方法" class="headerlink" title="接收消息的方法"></a>接收消息的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Subscribe</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(AnyEventType event)</span> </span>&#123;<span class="comment">/* Do something */</span>&#125;;</div></pre></td></tr></table></figure>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().post(event);</div></pre></td></tr></table></figure>
<h3 id="取消注册"><a href="#取消注册" class="headerlink" title="取消注册"></a>取消注册</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().unregister(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面我们来实现一个具体的例子来介绍EventBus的基本使用。</p>
<p>需求如下：在MainActivity中注册EventBus事件，并实现事件响应方法，当点击MainActivity中的按钮时跳转到SecondActivity，当点击SecondActivity中的按钮时向MainActivity发送Event事件，当MainActivity收到事件后，将事件内容显示在TextView中。</p>
<ol>
<li><p>MainActivity<br><img src="http://7xs7a3.com1.z0.glb.clouddn.com/EventBus_before.png" alt="MainActivity"></p>
</li>
<li><p>SecondActivity<br><img src="http://7xs7a3.com1.z0.glb.clouddn.com/EnventBus_middle.png" alt=""></p>
</li>
<li><p>事件处理<br><img src="http://7xs7a3.com1.z0.glb.clouddn.com/EventBus_Afer.png" alt=""></p>
</li>
</ol>
<h3 id="事件类Event"><a href="#事件类Event" class="headerlink" title="事件类Event"></a>事件类Event</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String messgae;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Event</span><span class="params">(String messgae)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.messgae = messgae;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessgae</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> messgae;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="MainActivity"><a href="#MainActivity" class="headerlink" title="MainActivity"></a>MainActivity</h3><p>在OnCreate()函数中注册EventBus，在Ondestroy()函数中反注册。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bind</span>(R.id.btn_open)</div><div class="line">    Button mOpenBtn;</div><div class="line"></div><div class="line">    <span class="meta">@Bind</span>(R.id.tv_showinfo)</div><div class="line">    TextView mInfoTxt;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        ButterKnife.bind(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">//注册</span></div><div class="line">        EventBus.getDefault().register(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事件响应方法</div><div class="line">     * 接收消息</div><div class="line">     * <span class="doctag">@param</span> event</div><div class="line">     */</div><div class="line">    <span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event)</span> </span>&#123;</div><div class="line"></div><div class="line">        String msg = event.getMessgae();</div><div class="line">        mInfoTxt.setText(msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//绑定点击事件</span></div><div class="line">    <span class="meta">@OnClick</span>(R.id.btn_open)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openSecondActivity</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">            Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, SecondActivity.class);</div><div class="line">            startActivity(intent);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        <span class="comment">//反注册</span></div><div class="line">        EventBus.getDefault().unregister(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="SecondActivity"><a href="#SecondActivity" class="headerlink" title="SecondActivity"></a>SecondActivity</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bind</span>(R.id.btn_post)</div><div class="line">    Button mPostBtn;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_second);</div><div class="line"></div><div class="line">        ButterKnife.bind(<span class="keyword">this</span>);</div><div class="line"></div><div class="line"></div><div class="line">        mPostBtn.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line"></div><div class="line">                <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="comment">//发送事件</span></div><div class="line">                        EventBus.getDefault().post(<span class="keyword">new</span> Event(<span class="string">"Just do it"</span>));</div><div class="line">                    &#125;</div><div class="line">                &#125;).start();</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="EventBus的事件订阅函数"><a href="#EventBus的事件订阅函数" class="headerlink" title="EventBus的事件订阅函数"></a>EventBus的事件订阅函数</h2><h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><p>在上面的例子中，我们再注解<code>@Subscribe(threadMode = ThreadMode.MAIN)</code>中使用了ThreadMode.MAIN这个模式，表示该函数在主线程即UI线程中执行，实际上EventBus总共有四种线程模式，分别是：</p>
<ul>
<li><p>ThreadMode.MAIN：表示无论事件是在哪个线程发布出来的，该事件订阅方法onEvent都会在UI线程中执行，这个在Android中是非常有用的，因为在Android中只能在UI线程中更新UI，所有在此模式下的方法是不能执行耗时操作的。</p>
</li>
<li><p>ThreadMode.POSTING：表示事件在哪个线程中发布出来的，事件订阅函数onEvent就会在这个线程中运行，也就是说发布事件和接收事件在同一个线程。使用这个方法时，在onEvent方法中不能执行耗时操作，如果执行耗时操作容易导致事件分发延迟。</p>
</li>
<li><p>ThreadMode.BACKGROUND：表示如果事件在UI线程中发布出来的，那么订阅函数onEvent就会在子线程中运行，如果事件本来就是在子线程中发布出来的，那么订阅函数直接在该子线程中执行。</p>
</li>
<li><p>ThreadMode.AYSNC：使用这个模式的订阅函数，那么无论事件在哪个线程发布，都会创建新的子线程来执行订阅函数。</p>
</li>
</ul>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="如何调用不同的订阅函数"><a href="#如何调用不同的订阅函数" class="headerlink" title="如何调用不同的订阅函数"></a>如何调用不同的订阅函数</h3><p>要调用四种不同模式的订阅函数，我们首先要用清楚EventBus是如何指定调用的函数的？</p>
<p>先回顾一下上一节中的例子是如何调用订阅函数onEvent的，首先新建一个事件类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String messgae;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Event</span><span class="params">(String messgae)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.messgae = messgae;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessgae</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> messgae;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>发布事件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">EventBus.getDefault().post(<span class="keyword">new</span> Event(<span class="string">"Just do it"</span>));</div></pre></td></tr></table></figure></p>
<p>订阅事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 事件响应方法</div><div class="line"> * <span class="doctag">@param</span> event</div><div class="line"> */</div><div class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventMain</span><span class="params">(Event event)</span> </span>&#123;</div><div class="line"></div><div class="line">    String msg = event.getMessgae();</div><div class="line">    mInfoTxt.setText(msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>观察可以发现：发布事件中的参数是Event的实例，而订阅函数中的参数也是Event的实例，可以推断EventBus是通过post函数传进去的类的实例来确定调用哪个订阅函数的，是哪个就调用哪个，如果有多个订阅函数呢，那么这些函数都会被调用！</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面我们来验证这个推断：</p>
<p>我们在基本使用章节的例子上进行扩展，首先建立四个类：FirstEvent、SecondEvent、ThirdEvent、FourthEvent。</p>
<p>FirstEvent.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstEvent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String messgae;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FirstEvent</span><span class="params">(String messgae)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.messgae = messgae;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessgae</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> messgae;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>SecondEvent.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondEvent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String messgae;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecondEvent</span><span class="params">(String messgae)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.messgae = messgae;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessgae</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> messgae;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThirdEvent.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdEvent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String messgae;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThirdEvent</span><span class="params">(String messgae)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.messgae = messgae;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessgae</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> messgae;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>FourthEvent.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FourthEvent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String messgae;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FourthEvent</span><span class="params">(String messgae)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.messgae = messgae;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessgae</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> messgae;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在MainActivity中，增加四种模式的订阅函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Bind</span>(R.id.btn_open)</div><div class="line">    Button mOpenBtn;</div><div class="line"></div><div class="line">    <span class="meta">@Bind</span>(R.id.tv_showinfo)</div><div class="line">    TextView mInfoTxt;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        ButterKnife.bind(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">//注册</span></div><div class="line">        EventBus.getDefault().register(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 事件响应方法</div><div class="line">     * <span class="doctag">@param</span> event</div><div class="line">     */</div><div class="line">    <span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventMain</span><span class="params">(FirstEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">        String msg = event.getMessgae();</div><div class="line">        Log.i(TAG, <span class="string">"onEventMain: "</span> + event.getMessgae());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Subscribe</span>(threadMode = ThreadMode.POSTING)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventPosting</span><span class="params">(SecondEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">        String msg = event.getMessgae();</div><div class="line">        Log.i(TAG, <span class="string">"onEventPosting: "</span>+ event.getMessgae());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Subscribe</span>(threadMode = ThreadMode.BACKGROUND)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventBackgroud</span><span class="params">(ThirdEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">        String msg = event.getMessgae();</div><div class="line">        Log.i(TAG, <span class="string">"onEventBackgroud: "</span> + event.getMessgae());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Subscribe</span>(threadMode = ThreadMode.ASYNC)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventAsync</span><span class="params">(FourthEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">        String msg = event.getMessgae();</div><div class="line">        Log.i(TAG, <span class="string">"onEventAsync: "</span> + event.getMessgae());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//绑定点击事件</span></div><div class="line">    <span class="meta">@OnClick</span>(R.id.btn_open)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openSecondActivity</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">            Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, SecondActivity.class);</div><div class="line">            startActivity(intent);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        <span class="comment">//反注册</span></div><div class="line">        EventBus.getDefault().unregister(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来在SecondActivity中增加四个按钮，分别发送不同类别的事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_second);</div><div class="line"></div><div class="line">        ButterKnife.bind(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@OnClick</span>(R.id.btn_post)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPostA</span><span class="params">()</span> </span>&#123;</div><div class="line">        EventBus.getDefault().post(<span class="keyword">new</span> FirstEvent(<span class="string">"FirstEvent"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@OnClick</span>(R.id.btn_post2)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPostB</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        EventBus.getDefault().post(<span class="keyword">new</span> SecondEvent(<span class="string">"SecondEvent"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@OnClick</span>(R.id.btn_post3)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPostC</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        EventBus.getDefault().post(<span class="keyword">new</span> ThirdEvent(<span class="string">"ThirdEvent"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@OnClick</span>(R.id.btn_post4)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPostD</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        EventBus.getDefault().post(<span class="keyword">new</span> FourthEvent(<span class="string">"FourthEvent"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行后，分别顺序点击SecondActivity的四个按钮，打印信息如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">03</span>-<span class="number">31</span> <span class="number">02</span>:<span class="number">53</span>:<span class="number">45.950</span> <span class="number">4779</span>-<span class="number">4779</span>/com<span class="selector-class">.example</span><span class="selector-class">.michael</span><span class="selector-class">.eventbusdemo</span> I/MainActivity: onEventMain: FirstEvent</div><div class="line"><span class="number">03</span>-<span class="number">31</span> <span class="number">02</span>:<span class="number">53</span>:<span class="number">47.528</span> <span class="number">4779</span>-<span class="number">4779</span>/com<span class="selector-class">.example</span><span class="selector-class">.michael</span><span class="selector-class">.eventbusdemo</span> I/MainActivity: onEventPosting: SecondEvent</div><div class="line"><span class="number">03</span>-<span class="number">31</span> <span class="number">02</span>:<span class="number">53</span>:<span class="number">48.882</span> <span class="number">4779</span>-<span class="number">4940</span>/com<span class="selector-class">.example</span><span class="selector-class">.michael</span><span class="selector-class">.eventbusdemo</span> I/MainActivity: onEventBackgroud: ThirdEvent</div><div class="line"><span class="number">03</span>-<span class="number">31</span> <span class="number">02</span>:<span class="number">53</span>:<span class="number">50.462</span> <span class="number">4779</span>-<span class="number">4940</span>/com<span class="selector-class">.example</span><span class="selector-class">.michael</span><span class="selector-class">.eventbusdemo</span> I/MainActivity: onEventAsync: FourthEvent</div></pre></td></tr></table></figure>
<blockquote>
<p>由此可见，通过发布不同的事件类的实例，EventBus根据类的实例分别调用了不同的订阅函数来处理事件。</p>
</blockquote>
<p>那么，当同一个类的实例有多个函数订阅时，结果会是怎样呢？答案是，这些函数都会执行。下面我们来验证一下，将MainActivity中订阅函数的参数都改为FirstEvent，代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * 事件响应方法</div><div class="line">  * <span class="doctag">@param</span> event</div><div class="line">  */</div><div class="line"> <span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN)</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventMain</span><span class="params">(FirstEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">     String msg = event.getMessgae();</div><div class="line">     Log.i(TAG, <span class="string">"onEventMain: "</span> + event.getMessgae());</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="meta">@Subscribe</span>(threadMode = ThreadMode.POSTING)</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventPosting</span><span class="params">(FirstEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">     String msg = event.getMessgae();</div><div class="line">     Log.i(TAG, <span class="string">"onEventPosting: "</span>+ event.getMessgae());</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="meta">@Subscribe</span>(threadMode = ThreadMode.BACKGROUND)</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventBackgroud</span><span class="params">(FirstEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">     String msg = event.getMessgae();</div><div class="line">     Log.i(TAG, <span class="string">"onEventBackgroud: "</span> + event.getMessgae());</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="meta">@Subscribe</span>(threadMode = ThreadMode.ASYNC)</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventAsync</span><span class="params">(FirstEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">     String msg = event.getMessgae();</div><div class="line">     Log.i(TAG, <span class="string">"onEventAsync: "</span> + event.getMessgae());</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>运行程序，点击SecondActivity的FirstEvent按钮，打印信息如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">03</span>-<span class="number">31</span> <span class="number">03</span>:<span class="number">14</span>:<span class="number">07.032</span> <span class="number">23611</span>-<span class="number">23746</span>/com<span class="selector-class">.example</span><span class="selector-class">.michael</span><span class="selector-class">.eventbusdemo</span> I/MainActivity: onEventAsync: FirstEvent</div><div class="line"><span class="number">03</span>-<span class="number">31</span> <span class="number">03</span>:<span class="number">14</span>:<span class="number">07.033</span> <span class="number">23611</span>-<span class="number">23611</span>/com<span class="selector-class">.example</span><span class="selector-class">.michael</span><span class="selector-class">.eventbusdemo</span> I/MainActivity: onEventMain: FirstEvent</div><div class="line"><span class="number">03</span>-<span class="number">31</span> <span class="number">03</span>:<span class="number">14</span>:<span class="number">07.033</span> <span class="number">23611</span>-<span class="number">23611</span>/com<span class="selector-class">.example</span><span class="selector-class">.michael</span><span class="selector-class">.eventbusdemo</span> I/MainActivity: onEventPosting: FirstEvent</div><div class="line"><span class="number">03</span>-<span class="number">31</span> <span class="number">03</span>:<span class="number">14</span>:<span class="number">07.034</span> <span class="number">23611</span>-<span class="number">23748</span>/com<span class="selector-class">.example</span><span class="selector-class">.michael</span><span class="selector-class">.eventbusdemo</span> I/MainActivity: onEventBackgroud: FirstEvent</div></pre></td></tr></table></figure>
<blockquote>
<p>分析可知，当SecondActivity发送FirstEvent事件过来的时候，这个四个订阅函数会同时接收到这个事件并执行。</p>
</blockquote>
<p><strong>总结： </strong>订阅函数的执行是根据参数中的事件类的类名来决定的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2016/04/17/Android_EventBus使用详解/" data-id="cj6esnzbq001ewg19zmatw9i2" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2016/04/17/Android_EventBus使用详解/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/实战/">实战</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Android开发模式之MVP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/17/Android开发模式之MVP/" class="article-date">
  <time datetime="2016-04-17T07:28:06.000Z" itemprop="datePublished">2016-04-17 15:28:06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>►<a class="article-category-link" href="/categories/Android/架构/">架构</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/Android开发模式之MVP/">Android开发模式之MVP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在开发Android App时，越到最后肯定会发现，Activity的负担非常重，既要初始化控件，又要写一些逻辑操作的展示等等，很多Activity中的代码都充当了Controller和Model的角色，因而发现Activity违背了单一职责原则，负担过重。所以，MVP架构模式应运而生。</p>
<h2 id="MVP架构是什么"><a href="#MVP架构是什么" class="headerlink" title="MVP架构是什么"></a>MVP架构是什么</h2><p>MVP就是Model-View-Presenter，MVP是从经典的MVC演变而来，它们的基本思想有相通的地方：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。作为一种新的模式，MVP与MVC有着一个重大的区别：在MVP中View并不会直接使用Model，它们之间的通信是通过Presenter（MVC中是Controller）来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过Controller。</p>
<p>在MVC里，View是可以直接访问Model的，从而View里会包含Model信息，不可避免的还要包括一些业务逻辑。在MVC模型里，更关注的是Model的不变，而同时有多个对Model的不同显示的View。所有在MVC模型里，Model不依赖于View，但是View依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。</p>
<p>用流程图的方式解释就更清楚了：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/mvp-mvp%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="MVP流程图"></p>
<h2 id="MVC与MVP的区别"><a href="#MVC与MVP的区别" class="headerlink" title="MVC与MVP的区别"></a>MVC与MVP的区别</h2><h3 id="MVP架构"><a href="#MVP架构" class="headerlink" title="MVP架构"></a>MVP架构</h3><blockquote>
<p>View：对应于Activity，负责View的绘制以及与用户交互、<br>Model：业务逻辑和实体模型<br>Presenter：负责完成View与Model间的交互</p>
</blockquote>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/mvp-mvp.png" alt="MVP示意图"></p>
<ul>
<li>View不直接与Model交互，而是通过Presenter交互来与Model间接交互</li>
<li>Presenter与View的交互是通过接口来进行的</li>
<li>通过View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑</li>
</ul>
<h3 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h3><blockquote>
<p>View：对应于布局文件<br>Model：业务逻辑和实体模型<br>Controller：对应于Activity</p>
</blockquote>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/mvp-mvc.png" alt="mvc示意图"></p>
<ul>
<li>View可以和Model直接交互</li>
<li>Controller是基于行为的，并且可以被多个View共享。</li>
<li>可以复杂决定显示哪个View</li>
</ul>
<p>总的就是说：从MVC到MVP的一个转变，就是减少了Activity的职责，减轻了它的负担，简化了Activity中的代码和一些操作，将逻辑代码提取到了Presenter中进行处理，降低其耦合度。</p>
<p>在MVP里，Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现。而且，Presenter与具体的View是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变，即重用！ 不仅如此，我们还可以编写测试用的View，模拟用户的各种操作，从而实现对Presenter的测试–而不需要使用自动化的测试工具。 我们甚至可以在Model和View都没有完成时候，就可以通过编写Mock Object（即实现了Model和View的接口，但没有具体的内容的）来测试Presenter的逻辑。 在MVP里，应用程序的逻辑主要在Presenter来实现，其中的View是很薄的一层。因此就有人提出了Presenter First的设计模式，就是根据User Story来首先设计和开发Presenter。在这个过程中，View是很简单的，能够把信息显示清楚就可以了。在后面，根据需要再随便更改View，而对Presenter没有任何的影响了。 如果要实现的UI比较复杂，而且相关的显示逻辑还跟Model有关系，就可以在View和Presenter之间放置一个Adapter。由这个 Adapter来访问Model和View，避免两者之间的关联。而同时，因为Adapter实现了View的接口，从而可以保证与Presenter之间接口的不变。这样就可以保证View和Presenter之间接口的简洁，又不失去UI的灵活性。 在MVP模式里，View只应该有简单的Set/Get的方法，用户输入和设置界面显示的内容，除此就不应该有更多的内容，绝不容许直接访问Model–这就是与MVC很大的不同之处。</p>
<h3 id="MVP的优点"><a href="#MVP的优点" class="headerlink" title="MVP的优点"></a>MVP的优点</h3><ul>
<li>降低耦合度，隐藏数据，Activity中代码更简洁</li>
<li>模块职责划分明显</li>
<li>方便测试驱动开发</li>
<li>代码复用度较高</li>
<li>代码灵活性增强</li>
</ul>
<h2 id="MVP架构模式示例"><a href="#MVP架构模式示例" class="headerlink" title="MVP架构模式示例"></a>MVP架构模式示例</h2><p>这个示例是根据用户id获取用户信息并展示的一个过程，其中获取信息用了一个线程进行了模拟获取。</p>
<p>先看一下MVP包结构图：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/mvp-mvp%E5%8C%85%E7%BB%93%E6%9E%84.png" alt=""></p>
<h3 id="1-Model层"><a href="#1-Model层" class="headerlink" title="1.Model层"></a>1.Model层</h3><p>首先是建一个JavaBean User实体类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.deason.mvpdemo.bean;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="keyword">private</span> String id;</div><div class="line">	<span class="keyword">private</span> String sex;</div><div class="line">	<span class="keyword">private</span> String age;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> id;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.id = id;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> sex;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.sex = sex;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> age;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>新建Model层抽象接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGetUser</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserInfo</span><span class="params">(<span class="keyword">int</span> id,OnUserInfoListener listener)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnUserInfoListener</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserInfoSuccess</span><span class="params">(User user)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserInfoFailed</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Model层抽象接口实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetUserInfo</span> <span class="keyword">implements</span> <span class="title">IGetUser</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserInfo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> id, <span class="keyword">final</span> OnUserInfoListener listener)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				SystemClock.sleep(<span class="number">5000</span>); <span class="comment">//模拟子线程耗时操作</span></div><div class="line"></div><div class="line">				<span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</div><div class="line">					User user = <span class="keyword">new</span> User();</div><div class="line">					user.setName(<span class="string">"liu"</span>);</div><div class="line">					user.setAge(<span class="string">"27"</span>);</div><div class="line">					user.setSex(<span class="string">"男"</span>);</div><div class="line">					user.setId(<span class="string">"1"</span>);</div><div class="line">					listener.getUserInfoSuccess(user);</div><div class="line">				&#125; <span class="keyword">else</span> &#123;</div><div class="line">					listener.getUserInfoFailed();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-View层"><a href="#2-View层" class="headerlink" title="2.View层"></a>2.View层</h3><p>Presenter和View交互是通过接口，所有我们需要定义一个IShowUserView的接口，这个接口封装的方法基本都跟视图展示有关。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IShowUserView</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showLoading</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hideLoading</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toMainActivity</span><span class="params">(User user)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showFailedError</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-Presenter层"><a href="#3-Presenter层" class="headerlink" title="3.Presenter层"></a>3.Presenter层</h3><p>Presenter是Model和View之间交互的桥梁，里面有一些业务逻辑的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoPresenter</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> IGetUser iGetUser;</div><div class="line">	<span class="keyword">private</span> IShowUserView iShowUserView;</div><div class="line">	<span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler();</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UserInfoPresenter</span><span class="params">(IShowUserView iShowUserView)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.iShowUserView = iShowUserView;</div><div class="line">		<span class="keyword">this</span>.iGetUser = <span class="keyword">new</span> GetUserInfo();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserInfoToShow</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">		iShowUserView.showLoading();</div><div class="line">		iGetUser.getUserInfo(id, <span class="keyword">new</span> OnUserInfoListener() &#123;</div><div class="line">			</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserInfoSuccess</span><span class="params">(<span class="keyword">final</span> User user)</span> </span>&#123;</div><div class="line">				<span class="comment">// UI线程执行</span></div><div class="line">				mHandler.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">					</div><div class="line">					<span class="meta">@Override</span></div><div class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">						<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">						iShowUserView.toMainActivity(user);</div><div class="line">						iShowUserView.hideLoading();</div><div class="line">					&#125;</div><div class="line">				&#125;);</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserInfoFailed</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				mHandler.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">					</div><div class="line">					<span class="meta">@Override</span></div><div class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">						<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">						iShowUserView.showFailedError();</div><div class="line">						iShowUserView.hideLoading();</div><div class="line">					&#125;</div><div class="line">				&#125;);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-Activity中调用"><a href="#4-Activity中调用" class="headerlink" title="4.Activity中调用"></a>4.Activity中调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">IShowUserView</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> TextView mNameTxt;</div><div class="line">	<span class="keyword">private</span> TextView mAgeTxt;</div><div class="line">	<span class="keyword">private</span> TextView mSexTxt;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Button mLoadBtn;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> ProgressDialog mDialog;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> UserInfoPresenter mPresenter;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		</div><div class="line">		mPresenter = <span class="keyword">new</span> UserInfoPresenter(<span class="keyword">this</span>);</div><div class="line">		</div><div class="line">		mDialog = <span class="keyword">new</span> ProgressDialog(<span class="keyword">this</span>);</div><div class="line">		</div><div class="line">		mNameTxt = (TextView) findViewById(R.id.tv_name);</div><div class="line">		mAgeTxt = (TextView) findViewById(R.id.tv_age);</div><div class="line">		mSexTxt = (TextView) findViewById(R.id.tv_sex);</div><div class="line">		mLoadBtn = (Button) findViewById(R.id.btn_load);</div><div class="line">		mLoadBtn.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				mPresenter.getUserInfoToShow(<span class="number">1</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showLoading</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		mDialog.show();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hideLoading</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		mDialog.dismiss();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toMainActivity</span><span class="params">(User user)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		mNameTxt.setText(user.getName());</div><div class="line">		mAgeTxt.setText(user.getAge());</div><div class="line">		mSexTxt.setText(user.getSex());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showFailedError</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		Toast.makeText(<span class="keyword">this</span>, <span class="string">"Load failed"</span>, Toast.LENGTH_SHORT).show();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>可以看出，虽说是代码量增加了，但是Activity中的代码变得简洁起来，程序也清晰明了，好处还是很多的。好记性不如烂笔头，勤加练习和实践。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2016/04/17/Android开发模式之MVP/" data-id="cj6esnzby001uwg19s8oypl9q" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2016/04/17/Android开发模式之MVP/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Android-Universal-Image-Loader源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/17/Android-Universal-Image-Loader源码分析/" class="article-date">
  <time datetime="2016-04-17T07:25:31.000Z" itemprop="datePublished">2016-04-17 15:25:31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/17/Android-Universal-Image-Loader源码分析/">Android-Universal-Image-Loader源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><h2 id="Android-Universal-Image-Loader"><a href="#Android-Universal-Image-Loader" class="headerlink" title="Android-Universal-Image-Loader"></a>Android-Universal-Image-Loader</h2><p>Android-Universal-Image-Loader是一个强大的、可高度定制的开源图片缓存框架，简称UIL。简单的说UIL就做了一件事–获取图片并显示在相应的控件上。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>添加完依赖后再Application或Activity中初始化ImageLoader，一般式在Application中初始化，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UILApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">		<span class="keyword">super</span>.onCreate();</div><div class="line"></div><div class="line">		initImageLoader(getApplicationContext());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initImageLoader</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="comment">//缓存目录</span></div><div class="line">		File cacheDir = StorageUtils.getCacheDirectory(context);</div><div class="line">		<span class="comment">//添加配置需求</span></div><div class="line">		ImageLoaderConfiguration config = <span class="keyword">new</span> ImageLoaderConfiguration.Builder(context)</div><div class="line">		  .memoryCacheExtraOptions(<span class="number">480</span>, <span class="number">800</span>) <span class="comment">// default = device screen dimensions</span></div><div class="line">		  .diskCacheExtraOptions(<span class="number">480</span>, <span class="number">800</span>, CompressFormat.JPEG, <span class="number">75</span>, <span class="keyword">null</span>)</div><div class="line">		  .taskExecutor(...)</div><div class="line">		  .taskExecutorForCachedImages(...)</div><div class="line">		  .threadPoolSize(<span class="number">3</span>) <span class="comment">// default 线程池大小</span></div><div class="line">		  .threadPriority(Thread.NORM_PRIORITY - <span class="number">1</span>) <span class="comment">// default 线程优先级</span></div><div class="line">		  .tasksProcessingOrder(QueueProcessingType.FIFO) <span class="comment">// default 任务队列模式</span></div><div class="line">		  .denyCacheImageMultipleSizesInMemory()</div><div class="line">		  .memoryCache(<span class="keyword">new</span> LruMemoryCache(<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>)) <span class="comment">//</span></div><div class="line">		  .memoryCacheSize(<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>)</div><div class="line">		  .memoryCacheSizePercentage(<span class="number">13</span>) <span class="comment">// default</span></div><div class="line">		  .diskCache(<span class="keyword">new</span> UnlimitedDiscCache(cacheDir)) <span class="comment">// default</span></div><div class="line">		  .diskCacheSize(<span class="number">50</span> * <span class="number">1024</span> * <span class="number">1024</span>)</div><div class="line">		  .diskCacheFileCount(<span class="number">100</span>)</div><div class="line">		  .diskCacheFileNameGenerator(<span class="keyword">new</span> HashCodeFileNameGenerator()) <span class="comment">// default</span></div><div class="line">		  .imageDownloader(<span class="keyword">new</span> BaseImageDownloader(context)) <span class="comment">// default</span></div><div class="line">		  .imageDecoder(<span class="keyword">new</span> BaseImageDecoder()) <span class="comment">// default</span></div><div class="line">		  .defaultDisplayImageOptions(DisplayImageOptions.createSimple()) <span class="comment">// default</span></div><div class="line">		  .writeDebugLogs()</div><div class="line">		  .build();</div><div class="line"></div><div class="line">		<span class="comment">// 初始化ImageLoader配置</span></div><div class="line">		ImageLoader.getInstance().init(config);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ImageLoaderConfiguration表示ImageLoader的配置信息，可包括图片最大尺寸、线程池、下载器、缓存等参数的配置。</p>
<h3 id="Manifest配置"><a href="#Manifest配置" class="headerlink" title="Manifest配置"></a>Manifest配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.INTERNET"</span> /&gt;</div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</div><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span> /&gt;</div><div class="line"></div><div class="line">&lt;application</div><div class="line">	android:name=<span class="string">".UILApplication"</span></div><div class="line">	``</div><div class="line">	``</div><div class="line">	``</div><div class="line">/application&gt;</div></pre></td></tr></table></figure>
<p>添加网络权限和添加读写外部存储权限</p>
<h3 id="下载显示图片"><a href="#下载显示图片" class="headerlink" title="下载显示图片"></a>下载显示图片</h3><p>下载图片，解析为Bitmap并在ImageView中显示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ImageLoadingListener animateFirstListener = <span class="keyword">new</span> AnimateFirstDisplayListener();</div><div class="line"></div><div class="line"><span class="keyword">private</span> DisplayImageOptions options;</div><div class="line"></div><div class="line">ImageAdapter(Context context) &#123;</div><div class="line">		inflater = LayoutInflater.from(context);</div><div class="line">		</div><div class="line">		<span class="comment">//下载图片选项</span></div><div class="line">options = <span class="keyword">new</span> DisplayImageOptions.Builder()</div><div class="line">		.showImageOnLoading(R.drawable.ic_stub) <span class="comment">//下载中</span></div><div class="line">		.showImageForEmptyUri(R.drawable.ic_empty) <span class="comment">//空URL</span></div><div class="line">		.showImageOnFail(R.drawable.ic_error) <span class="comment">//失败</span></div><div class="line">		.cacheInMemory(<span class="keyword">true</span>)</div><div class="line">		.cacheOnDisk(<span class="keyword">true</span>)</div><div class="line">		.considerExifParams(<span class="keyword">true</span>)</div><div class="line">		.displayer(<span class="keyword">new</span> CircleBitmapDisplayer(Color.WHITE, <span class="number">5</span>))</div><div class="line">		.build();</div><div class="line"><span class="comment">//显示图片</span></div><div class="line">ImageLoader.getInstance().displayImage(imageUrl, holder.image, options, animateFirstListener);	</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">*监听下载图片，传递Bitmap给回调接口</div><div class="line">*/</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimateFirstDisplayListener</span> <span class="keyword">extends</span> <span class="title">SimpleImageLoadingListener</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; displayedImages = Collections.synchronizedList(<span class="keyword">new</span> LinkedList&lt;String&gt;());</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadingComplete</span><span class="params">(String imageUri, View view, Bitmap loadedImage)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (loadedImage != <span class="keyword">null</span>) &#123;</div><div class="line">			ImageView imageView = (ImageView) view;</div><div class="line">			<span class="keyword">boolean</span> firstDisplay = !displayedImages.contains(imageUri);</div><div class="line">			<span class="keyword">if</span> (firstDisplay) &#123;</div><div class="line">				FadeInBitmapDisplayer.animate(imageView, <span class="number">500</span>);</div><div class="line">				displayedImages.add(imageUri);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>可配置度高。支持任务线程池、下载器、解码器、内存及磁盘缓存、显示选项等的配置。</li>
<li>包含内存缓存和磁盘缓存两级缓存。</li>
<li>支持多线程，支持异步和同步加载</li>
<li>支持多种缓存算法、下载进度监听、ListView图片错乱解决等。</li>
</ul>
<h1 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h1><h2 id="总体设计框图"><a href="#总体设计框图" class="headerlink" title="总体设计框图"></a>总体设计框图</h2><p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/uil-overall-design.png" alt="UIL框架图"></p>
<p>上面是UIL的总体框架图。整个库主要分为ImageLoader、ImageLoaderEngine、Cache、ImageDownloader、ImageDecoder、BitmapDisplayer、BitmapProcessor七大模块，其中Cache分为Memory Cache和DiskCache两部分。</p>
<p>简单的讲就是ImageLoader收到加载及显示图片的任务，并将它交给ImageLoaderEngine，ImageLoaderEngine分发任务到具体线程池去执行，任务通过Cache及ImageDownloader获取图片，中间可能经过BitmapProcessor和ImageDecoder处理，最终转换为Bitmap交给BitmapDisplayer在ImageAware中显示。</p>
<h2 id="UIL中的概念"><a href="#UIL中的概念" class="headerlink" title="UIL中的概念"></a>UIL中的概念</h2><ul>
<li><strong>ImageLoaderEngine</strong></li>
</ul>
<p>任务分发器，负责分发LoadAndDisplayImageTask和ProcessAndDisplayImageTask给具体的线程去执行。</p>
<ul>
<li><strong>LoadAndDisplayImageTask</strong></li>
</ul>
<p>用于加载并显示图片的任务。</p>
<ul>
<li><strong>ProcessAndDisplayImageTask</strong></li>
</ul>
<p>用于处理并显示图片的任务。</p>
<ul>
<li><strong>DisplayBitmapTask</strong></li>
</ul>
<p>用于显示图片的任务</p>
<ul>
<li><strong>ImageAware</strong></li>
</ul>
<p>显示图片的对象，可以是ImageView等。</p>
<ul>
<li><strong>BitmapDisplayer</strong></li>
</ul>
<p>将Bitmap对象显示在相应的控件ImageAware上。</p>
<ul>
<li><strong>ImageDownloader</strong></li>
</ul>
<p>图片下载器，负责从图片的各个来源获取输入流</p>
<ul>
<li><strong>MemoryCache</strong></li>
</ul>
<p>内存图片缓存，可向内存缓存图片或从内存读取图片</p>
<ul>
<li><strong>DiskCache</strong></li>
</ul>
<p>本地图片缓存，可向本地磁盘缓存保存图片或从本地磁盘读取图片</p>
<ul>
<li><strong>ImageDecoder</strong></li>
</ul>
<p>图片解码器，负责将图片输入流InputStream转换为Bitmap对象。</p>
<ul>
<li><strong>BitmapProcessor</strong></li>
</ul>
<p>图片处理器，负责从缓存读取或写入前对图片进行处理</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/uil-flow.png" alt="图片加载及显示流程图"></p>
<p>上图为图片加载及显示流程图,可知有三种情况:</p>
<ul>
<li>[ 1 ] - 图片没有缓存</li>
</ul>
<p>先下载图片，然后显示图片，同时异步将图片缓存到磁盘和内存中。</p>
<ul>
<li>[ 2 ] - 图片缓存在磁盘上</li>
</ul>
<p>若图片不在缓存中，则从磁盘缓存中查找图片，然后将图片解码为Bitmap对象并显示在控件上。</p>
<ul>
<li>[ 3 ] - Bitmap对象缓存在内存里</li>
</ul>
<p>直接从内存缓存取出相应的Bitmap对象并显示在控件上。</p>
<h1 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h1><h2 id="类关系图"><a href="#类关系图" class="headerlink" title="类关系图"></a>类关系图</h2><p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/uil-relation-class.png" alt="类关系图"></p>
<h2 id="核心类介绍"><a href="#核心类介绍" class="headerlink" title="核心类介绍"></a>核心类介绍</h2><h3 id="ImageLoader-java"><a href="#ImageLoader-java" class="headerlink" title="ImageLoader.java"></a>ImageLoader.java</h3><p>图片加载器，对外的主要API，采用了<strong>单例设计模式</strong>，用于图片的加载和显示。</p>
<p>主要函数：</p>
<ul>
<li>getInstance()</li>
</ul>
<p>得到ImageLoader单例，通过双层是否为null判断提高性能。</p>
<ul>
<li>init(ImageLoaderConfiguration configuration)</li>
</ul>
<p>初始化配置参数，参数为configuration为ImageLoader的配置信息，包括图片最大尺寸、任务线程池、磁盘缓存、下载器、解码器等等。实现中会初始化ImageLoaderEngine engine属性，该属性为任务分发器。</p>
<ul>
<li>displayImage(String uri, ImageAware imageAware, DisplayImageOptions options, ImageLoadingListener listener, ImageLoadingProgressListener progressListener)</li>
</ul>
<p>加载并显示图片或加载并执行回调接口。ImageLoader加载图片主要分为三类接口：</p>
<ol>
<li>displayImage()表示异步加载并显示图片到对应的ImageAware上。</li>
<li>loadImage()表示异步加载图片并执行回调接口。</li>
<li>loadImageSync()表示同步加载图片。</li>
</ol>
<p>以上三类接口最终都会调用到这个函数进行图片加载。函数参数解释如下：</p>
<p>Uri: 图片的uri，uri支持多种来源的图片，包括http、https、file、content、assets、drawable及自定义<br>ImageAware： 一个接口，表示需要加载图片的对象，可包装View。<br>Options： 图片显示的配置项。比如加载前、加载中、加载失败应该显示的占位图片，图片是否需要在磁盘缓存，是否需要在内存缓存等。<br>listener： 图片加载各种时刻的回调接口，包括开始加载、加载失败、加载成功、取消加载四个时刻的回调函数。<br>progressListener： 图片加载进度的回调接口。</p>
<p>函数流程图如下：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/uil-display-image-flow-chart.png" alt=""></p>
<h3 id="ImageLoaderConfiguration-java"><a href="#ImageLoaderConfiguration-java" class="headerlink" title="ImageLoaderConfiguration.java"></a>ImageLoaderConfiguration.java</h3><p>ImageLoader的配置信息，包括图片最大尺寸、线程池、缓存、下载器、解码器等等。</p>
<p>主要属性：</p>
<ul>
<li><p>Resources resources 程序本地资源访问器，用于加载DisplayImageOptions中设置的一些App中图片资源。</p>
</li>
<li><p>int maxImageWidthForMemoryCache 内存缓存的图片最大宽度。</p>
</li>
<li><p>int maxImageHeightForMemoryCache 内存缓存的图片最大高度。</p>
</li>
<li><p>int maxImageWidthForDiskCache 磁盘缓存的图片最大宽度。</p>
</li>
<li><p>int maxImageHeightForDiskCache 磁盘缓存的图片最大高度。</p>
</li>
<li><p>BitmapProcessor processorForDiskCache 图片处理器，用于处理从磁盘缓存中读取到的图片。</p>
</li>
<li><p>Executor taskExecutor  ImageLoaderEngine中用于执行从源获取图片的任务</p>
</li>
<li><p>Executor taskExecutorForCachedImages ImageLoaderEngine中用于执行从缓存获取图片任务的Executor。</p>
</li>
<li><p>boolean customExecutor 用户是否自定义了上面的taskExecutor</p>
</li>
<li><p>boolean customExecutorForCachedImages 用户是否自定义了上面的taskExecutorForCachedImages</p>
</li>
<li><p>int threadPoolSize 上面两个默认线程池的核心池大小，即最大并发数</p>
</li>
<li><p>int threadPriority 上面默认线程池的线程优先级。</p>
</li>
<li><p>QueueProcessingType tasksProcessingType 上面两个默认线程池的线程队列类型，目前只有FIFO，LIFO两种选择</p>
</li>
<li><p>MemoryCache MemoryCache 图片内存缓存</p>
</li>
<li><p>DiskCache diskCache 图片磁盘缓存，一般放在SD卡</p>
</li>
<li><p>ImageDownloader downloader 图片下载器</p>
</li>
<li><p>ImageDecoder decoder 图片解码器，内部可使用我们常见的BitmapFactory.decode()将图片资源解码成Bitmap对象</p>
</li>
<li><p>DisplayImageOptions defaultDisplayImageOptions 图片显示的配置项。比如加载前、加载中、加载失败应该显示的占位图片，图片是否需要在磁盘缓存，是否需要在内存缓存等。</p>
</li>
<li><p>ImageDownloader networkDeniedDownloader 不允许访问网络的图片下载器</p>
</li>
<li><p>ImageDownloader slowNetworkDownloader 慢网络情况下的图片下载器</p>
</li>
</ul>
<h3 id="ImageLoaderConfiguration-Builder-java-静态内部类"><a href="#ImageLoaderConfiguration-Builder-java-静态内部类" class="headerlink" title="ImageLoaderConfiguration.Builder.java 静态内部类"></a>ImageLoaderConfiguration.Builder.java 静态内部类</h3><p><strong>Builder模式</strong>，用于构造参数繁多的ImageLoaderConfiguration。其属性与ImageLoaderConfiguration类似，函数多是属性设置函数。</p>
<p>主要函数及含义：</p>
<ul>
<li>builder()</li>
</ul>
<p>按照配置，生成ImageLoaderConfiguration。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ImageLoaderConfiguration <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">	initEmptyFieldsWithDefaultValues();</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ImageLoaderConfiguration(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>initEmptyFieldsWithDefaultValues()</li>
</ul>
<p>初始化值为null的属性。若用户没有配置相关项，UIL会通过调用DefaultConfigurationFactory中的函数返回一个默认值当配置。</p>
<p>taskExecutorForCacheImages、taskExecutor及ImageLoaderEngine的taskDistributor的默认值如下：</p>
<table>
<thead>
<tr>
<th>parameters</th>
<th>taskDistributor</th>
<th>taskExecutorForCacheImages/taskExecutor</th>
</tr>
</thead>
<tbody>
<tr>
<td>corePoolSize</td>
<td>0</td>
<td>3</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>Integer.MAX_VALUE</td>
<td>3</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>60</td>
<td>3</td>
</tr>
<tr>
<td>unit</td>
<td>SECONDS</td>
<td>MILLISECONDS</td>
</tr>
<tr>
<td>workQueue</td>
<td>SynchronousQueue</td>
<td>LIFOLinkedBlockingDequeu/LinkedBlockingQueue</td>
</tr>
<tr>
<td>priority</td>
<td>5</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>diskCacheFileNameGenerator默认值为HashCodeFileNameGenerator</p>
<p>memoryCache默认值为LruMemoryCache。如果内存缓存不允许缓存一张图片的多个尺寸，则用FuzzyKeyMemoryCache做封装，同一个图片新的尺寸会覆盖缓存中该图片老的尺寸。</p>
<p>diskCache默认值与diskCacheSize和diskCacheFileCount值有关，如果他们有一个大于0，则默认为LruDiskCache，否则使用无大小限制的UnlimitedDiskCache。</p>
<p>downloader默认值为BaseImageDownloader。</p>
<p>decoder默认值为BaseImageDecoder</p>
<p>defaultDisplayImageOptions为Builder().build()</p>
<ul>
<li>denyCacheImageMultipleSizeInMemory()</li>
</ul>
<p>设置内存缓存不允许缓存一张图片的多个尺寸，默认允许。后面会讲到的View的getWidth()在初始化前后的不同值与这个设置的关系。</p>
<ul>
<li>diskCacheSize(int maxCacheSize)</li>
</ul>
<p>设置磁盘缓存的最大字节数，如果大于0或者下面的maxFileCount大于0，默认的DiskCache会用LruDiskCache，否则使用无大小限制的UnlimitedDiskCache。</p>
<ul>
<li>diskCacheFileCount(int maxFileCount)</li>
</ul>
<p>设置磁盘缓存的最大文件数，如果大于0或者上面的maxCacheSize大于0，默认的DiskCache会用LruDiskCache，否则使用无大小限制的UnlimitedDiskCache。</p>
<h3 id="ImageLoaderConfiguration-NetworkDeniedDownloader-java-静态内部类"><a href="#ImageLoaderConfiguration-NetworkDeniedDownloader-java-静态内部类" class="headerlink" title="ImageLoaderConfiguration.NetworkDeniedDownloader.java 静态内部类"></a>ImageLoaderConfiguration.NetworkDeniedDownloader.java 静态内部类</h3><p>不允许访问网络的图片下载器，实现了ImageDownloader接口。实现也比较简单，包装了一个ImageDownloader对象，通过getStream()函数中禁止Http和Https Scheme禁止网络访问，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkDeniedImageDownloader</span> <span class="keyword">implements</span> <span class="title">ImageDownloader</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ImageDownloader wrappedDownloader;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NetworkDeniedImageDownloader</span><span class="params">(ImageDownloader wrappedDownloader)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.wrappedDownloader = wrappedDownloader;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> InputStream <span class="title">getStream</span><span class="params">(String imageUri, Object extra)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">		<span class="keyword">switch</span> (Scheme.ofUri(imageUri)) &#123;</div><div class="line">			<span class="keyword">case</span> HTTP:</div><div class="line">			<span class="keyword">case</span> HTTPS:</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">			<span class="keyword">default</span>:</div><div class="line">				<span class="keyword">return</span> wrappedDownloader.getStream(imageUri, extra);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ImageLoaderConfiguration-SlowNetworkingImageDownloader-java-静态内部类"><a href="#ImageLoaderConfiguration-SlowNetworkingImageDownloader-java-静态内部类" class="headerlink" title="ImageLoaderConfiguration.SlowNetworkingImageDownloader.java 静态内部类"></a>ImageLoaderConfiguration.SlowNetworkingImageDownloader.java 静态内部类</h3><p>慢网络情况下的图片下载器，实现了ImageDownloader接口。<br>通过包装一个ImageDownloader对象实现，在getStream()函数中当Scheme为Http和Https时，用FlushedInputStream代替InputStream处理慢网络情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SlowNetworkImageDownloader</span> <span class="keyword">implements</span> <span class="title">ImageDownloader</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ImageDownloader wrappedDownloader;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SlowNetworkImageDownloader</span><span class="params">(ImageDownloader wrappedDownloader)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.wrappedDownloader = wrappedDownloader;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> InputStream <span class="title">getStream</span><span class="params">(String imageUri, Object extra)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">		InputStream imageStream = wrappedDownloader.getStream(imageUri, extra);</div><div class="line">		<span class="keyword">switch</span> (Scheme.ofUri(imageUri)) &#123;</div><div class="line">			<span class="keyword">case</span> HTTP:</div><div class="line">			<span class="keyword">case</span> HTTPS:</div><div class="line">				<span class="keyword">return</span> <span class="keyword">new</span> FlushedInputStream(imageStream);</div><div class="line">			<span class="keyword">default</span>:</div><div class="line">				<span class="keyword">return</span> imageStream;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ImageLoaderEngine-java"><a href="#ImageLoaderEngine-java" class="headerlink" title="ImageLoaderEngine.java"></a>ImageLoaderEngine.java</h3><p>LoadAndDisplayImageTask和ProcessAndDisplayImageTask任务分发器，负责分发任务给具体的线程池。</p>
<p>主要属性：</p>
<ul>
<li>ImageLoaderConfiguration configuration</li>
</ul>
<p>ImageLoader的配置信息，可包括图片最大尺寸、线程池、缓存、下载器、解码器等等。</p>
<ul>
<li>Executor taskExecutor</li>
</ul>
<p>用于执行从源执行获取图片任务的Executor，为configuration中的taskExecutor，如果为null，则会调用DefaultConfigurationFactory.createExecutor()根据配置返回一个默认的线程池。</p>
<ul>
<li>Executor taskExecutorForCachedImages</li>
</ul>
<p>用于执行从缓存获取图片任务的Executor，为configuration中的taskExecutorForCachedImages，如果为null，则会调用DefaultConfigurationFactory.createExecutor()根据配置返回一个默认的线程池。</p>
<ul>
<li>Executor taskDistributor</li>
</ul>
<p>任务分发线程池，任务指LoadAndDisplayImageTask和ProcessAndDisplayImageTask，因为需要分发给上面的两个Executor去执行任务，不存在较耗时或阻塞操作，所以无并发数（Int最大值）限制的线程池即可。</p>
<ul>
<li>Map cacheKeysForImageAwares</li>
</ul>
<p>ImageAware与内存缓存key对应的map，key为ImageAware的id，value为内存缓存的key。</p>
<ul>
<li>Map uriLocks</li>
</ul>
<p>图片正在加锁的重入锁map，key为图片的uri，value为标识其正在加载的重入锁。</p>
<ul>
<li>AtomicBoolean pause</li>
</ul>
<p>是否被暂停。如果为true，则所有新的加载或显示任务都会等待直到取消暂停（为false）</p>
<ul>
<li>AtomicBooleannetWorkDenied</li>
</ul>
<p>是否不允许访问网络，如果为true，通过回调ImageLoadingListener.onLoadingFailed()获取图片，则所有不在缓存中需要网络访问的请求都会失败，返回失败的原因为：网络访问被禁止。</p>
<ul>
<li>AtomicBoolean slowNetwork</li>
</ul>
<p>是否是慢网络情况，如果未true，则自动调用SlowNetworkImageDownloader下载图片</p>
<ul>
<li>Object pauseLock</li>
</ul>
<p>暂停的等待锁，可在engine被暂停后调用这个锁等待</p>
<p>主要函数：</p>
<ul>
<li>void submit(final LoadAndDisplayImageTask task)</li>
</ul>
<p>传入一个LoadAndDisplayImageTask，直接用taskDistributor执行一个Runnable，在Runnable内部根据图片是否被磁盘缓存过确定使用taskExecutorForCachedImages还是taskExecutor执行该task。</p>
<ul>
<li>void submit(ProcessAndDisplayImageTask task)</li>
</ul>
<p>传入一个ProcessAndDisplayImageTask，直接用taskExecutorForCachedImages执行该task，从缓存中去图片。</p>
<ul>
<li>void pause()</li>
</ul>
<p>暂停图片加载任务，所有新的加载或显示任务都会等待直到取消暂停为止。</p>
<ul>
<li>void resume()</li>
</ul>
<p>继续图片加载任务</p>
<ul>
<li>stop()</li>
</ul>
<p>暂停所有加载和显示图片任务并清除这里的内部属性值。</p>
<ul>
<li>fireCallBack(Runnable r)</li>
</ul>
<p>taskDistributor立即执行某个任务</p>
<ul>
<li>getLockForUri(String uri)</li>
</ul>
<p>得到某个uri的重入锁，如果不存在则新建一个</p>
<ul>
<li>private Executor createTaskExecutor()</li>
</ul>
<p>调用DefaultConfigurationFactor.createExecutor()创建一个线程池</p>
<ul>
<li>String getLoadingUriForView(ImageAware imageAware)</li>
</ul>
<p>得到某个ImageAware正在加载的图片uri</p>
<ul>
<li>prepareDisplayTaskFor(ImageAware imageAware, String memoryCacheKey)</li>
</ul>
<p>准备开始一个Task。向cacheKeysForImageAwares中插入ImageAware的id和图片在内存缓存中的key</p>
<ul>
<li>void cancelDisplayTaskFor(ImageAware imageAware)</li>
</ul>
<p>取消一个显示任务。从cacheKeysForImageAwares中删除ImageAware对应元素</p>
<ul>
<li>void denyNetworkDownloads(boolean denyNetworkDownloads)</li>
</ul>
<p>设置是否不允许网络访问</p>
<ul>
<li>void handleSlowNetwork(boolean handleSlowNetwork)</li>
</ul>
<p>设置是否慢网络情况</p>
<h3 id="DefaultConfigurationFactory-java"><a href="#DefaultConfigurationFactory-java" class="headerlink" title="DefaultConfigurationFactory.java"></a>DefaultConfigurationFactory.java</h3><p>为ImageLoaderConfiguration及ImageLoaderEngine提供一些默认配置</p>
<p>主要函数：</p>
<ul>
<li>Executor createExecutor(int threadPoolSize, int threadPriority,QueueProcessingType tasksProcessingType)</li>
</ul>
<p>创建线程池：<br>threadPoolSize表示核心线程池大小（最大并发数）<br>threadPriority表示线程优先级<br>tasksProcessingType表示线程队列类型，目前只有FIFO，LIFO两种可选择</p>
<p>内部实现会调用createThreadFactory(…)返回一个支持线程优先级设置，并且以固定规则命名新建的线程的线程工厂类DefaultConfigurationFactory.DefaultThreadFactory。</p>
<ul>
<li>Executor createTaskDistributor()</li>
</ul>
<p>为ImageLoaderEngine中的任务分发器taskDistributor提供线程池，该线程池为normal优先级的无并发大小限制的线程池。</p>
<ul>
<li>FileNameGenerator createFileNameGenerator()</li>
</ul>
<p>返回一个HashCodeFileNameGenerator对象，即以uri HashCode为文件名的文件名生成器。</p>
<ul>
<li>DiskCache createDiskCache(Context context, FileNameGenerator diskCacheFileNameGenerator,long diskCacheSize, int diskCacheFileCount)</li>
</ul>
<p>创建一个 Disk Cache。如果 diskCacheSize 或者 diskCacheFileCount 大于 0，返回一个LruDiskCache，否则返回无大小限制的UnlimitedDiskCache。</p>
<ul>
<li>MemoryCache createMemoryCache(Context context, int memoryCacheSize)</li>
</ul>
<p>创建一个 Memory Cache。返回一个LruMemoryCache，若 memoryCacheSize 为 0，则设置该内存缓存的最大字节数为App最大可用内存的1/8。这里的App的最大可用内存也支持系统在Honeycomb之后（Api Level &gt;= 11)application中android:largeHeap=”true”的设置。</p>
<ul>
<li>ImageDownloader createImageDownloader(Context context)</li>
</ul>
<p>创建图片下载器，返回一个BaseImageDownloader。</p>
<ul>
<li>ImageDecoder createImageDecoder(boolean loggingEnabled)</li>
</ul>
<p>创建图片解码器，返回一个BaseImageDecoder。</p>
<ul>
<li>BitmapDisplayer createBitmapDisplayer()</li>
</ul>
<p>创建图片显示器，返回一个SimpleBitmapDisplayer。</p>
<h3 id="DefaultConfigurationFactory-DefaultThreadFactory"><a href="#DefaultConfigurationFactory-DefaultThreadFactory" class="headerlink" title="DefaultConfigurationFactory.DefaultThreadFactory"></a>DefaultConfigurationFactory.DefaultThreadFactory</h3><p>默认的线程工厂类，为</p>
<p>DefaultConfigurationFactory.createExecutor(…)<br>和<br>DefaultConfigurationFactory.createTaskDistributor(…)<br>提供线程工厂。支持线程优先级设置，并且以固定规则命名新建的线程。</p>
<h3 id="ImageAware"><a href="#ImageAware" class="headerlink" title="ImageAware"></a>ImageAware</h3><p>需要显示图片的对象的接口，可包装View表示某个需要显示图片的View。</p>
<p>主要函数：</p>
<ul>
<li>View getWrappedView()</li>
</ul>
<p>得到被包装的View，图片显示在该View上</p>
<ul>
<li>int getWidth()和int getHeight()</li>
</ul>
<p>得到宽度高度，在计算图片缩放比例时会用到</p>
<ul>
<li>int getId()</li>
</ul>
<p>得到唯一标识id。ImageLoaderEngine中用这个id标识正在加载图片的ImageAware和图片内存缓存key的对应关系，图片请求前会将内存缓存key与新的内存缓存key进行比较，如果不相等，则之前的图片请求会被取消。这样当ImageAware被复用时就不会因异步加载（前面任务未取消）而造成错乱了。</p>
<h3 id="ViewAware-java"><a href="#ViewAware-java" class="headerlink" title="ViewAware.java"></a>ViewAware.java</h3><p>封装Android View来显示图片的抽象类，实现类ImageAware接口，利用Reference来Wrap View防止内存泄露。</p>
<p>主要函数：</p>
<ul>
<li>ViewAware(View view, boolean checkActualViewSize)</li>
</ul>
<p>构造函数：<br>view表示需要显示图片的对象<br>checkActualViewSize表示通过getWidth()和getHeight()获取图片宽高时返回真实的宽和高，还是LayoutParams的宽高，true表示返回真实宽和高。</p>
<p>如果为true会导致一个问题，view在还没有初始化完成时加载图片，这是它的真实宽高为0，会取它LayoutParams的宽高，而图片缓存的key与这个宽高有关，所以当view的初始化完成再次需要加载该图片时，getWidth()和getHeight()返回的宽高都已经变化了，缓存key不一样，从而导致缓存读取失败会再次从网络下载一次图片。可通过ImageLoaderConfiguration.Builder.denyCacheImageMultipleSizesInMemory()设置不允许内存缓存缓存一张图片的多个尺寸。</p>
<ul>
<li>boolean setImageDrawable(Drawable drawable)</li>
</ul>
<p>如果当前操作在主线程并且View没有被回收，则调用抽象函数setImageDrawableInto(Drawable drawable, View view)去向view设置图片。</p>
<ul>
<li>boolean setImageBitmap(Bitmap bitmap)</li>
</ul>
<p>如果当前操作在主线程并且View没有被回收，则调用抽象函数setImageBitmapInto(Bitmap bitmap, View view)去向view设置图片。</p>
<h3 id="ImageViewAware-java"><a href="#ImageViewAware-java" class="headerlink" title="ImageViewAware.java"></a>ImageViewAware.java</h3><p>封装Android ImageView来显示图片的ImageAware，继承了viewAware，利用Reference来Wrap View防止内存泄露。</p>
<p>如果getWidth()函数小于等于0，会利用反射获取mMaxWidth的值作为宽。<br>如果getHeight()函数小于等于0，会利用反射获取mMaxHeight的值作为高。</p>
<h3 id="NonViewAware"><a href="#NonViewAware" class="headerlink" title="NonViewAware"></a>NonViewAware</h3><p>仅包含处理图片相关信息却没有需要显示图片的View的ImageAware，实现了ImageAware接口。常用于加载图片后调用回调接口而不是显示的情况。</p>
<h3 id="DisplayImagesOptions-java"><a href="#DisplayImagesOptions-java" class="headerlink" title="DisplayImagesOptions.java"></a>DisplayImagesOptions.java</h3><p>图片显示的配置项。比如加载前、加载中、加载失败应该显示的占位图片，图片是否需要在磁盘缓存，是否需要在memory缓存等。</p>
<p>主要属性及含义：</p>
<ul>
<li>int imageResOnLoading</li>
</ul>
<p>图片正在加载中的占位图片的resource id，优先级比下面的imageOnLoading高，当存在时，imageOnLoading不起作用。</p>
<ul>
<li>int imageResForEmptyUri</li>
</ul>
<p>空uri时的占位图片的resource id，优先级比下面的imageForEmptyUri高，当存在时，imageForEmptyUri不起作用。</p>
<ul>
<li>int imageResOnFail</li>
</ul>
<p>加载失败时的占位图片的resource id，优先级比下面的imageOnFail高，当存在时，imageOnFail不起作用。</p>
<ul>
<li>Drawable imageOnLoading</li>
</ul>
<p>加载中的占位图片的Drawable对象，默认为null</p>
<ul>
<li>Drawable imageForEmptyUri</li>
</ul>
<p>空uri时的占位图片drawable对象，默认为null</p>
<ul>
<li>boolean resetViewBeforeLoading</li>
</ul>
<p>在加载前是否重置view，通过Builder构建的对象默认为false</p>
<ul>
<li>boolean cacheInMemory</li>
</ul>
<p>是否缓存在内存中，通过Builder构建的对象默认为false。</p>
<ul>
<li>boolean cacheOnDisk</li>
</ul>
<p>是否缓存在磁盘中，通过Builder构建的对象默认为false。</p>
<ul>
<li>ImageScaleType imageScaleType</li>
</ul>
<p>图片的缩放类型，通过Builder构建的对象默认为IN_SAMPLE_POWER_OF_2</p>
<ul>
<li>Options decodingOptions</li>
</ul>
<p>为BitmapFactory.Options，用于BitmapFactory.decodeStream(imageStream, null, decodingOptions)得到图片尺寸等信息。</p>
<ul>
<li>int delayBeforeLoading</li>
</ul>
<p>设置在开始加载前的延迟时间，单位为毫秒，通过Builder构建的对象默认为0。</p>
<ul>
<li>boolean considerExitParams</li>
</ul>
<p>是否考虑图片的EXIF信息，通过Builder构建的对象默认为false。</p>
<ul>
<li>Object extraForDownloader</li>
</ul>
<p>下载器需要的辅助信息。下载时传入ImageDownloader.getStream(String,Object)的对象，方面用户自己扩展，默认为null</p>
<ul>
<li>BitmapProcessor preProcessor;</li>
</ul>
<p>缓存在内存之前的处理程序，默认为null</p>
<ul>
<li>BitmapProcessor postProcessor</li>
</ul>
<p>缓存在内存之后的处理程序，默认为null</p>
<ul>
<li>BitmapDisplayer displayer;</li>
</ul>
<p>图片的显示方式，通过Builder构建的对象默认为SimpleBitmapDisplayer</p>
<ul>
<li>Handler handler;</li>
</ul>
<p>handler对象，默认为null</p>
<ul>
<li>boolean isSyncLoading;</li>
</ul>
<p>是否同步加载，通过Builder构建的对象默认为false。</p>
<h3 id="DisplayImageOptions-Builder-java-静态内部类"><a href="#DisplayImageOptions-Builder-java-静态内部类" class="headerlink" title="DisplayImageOptions.Builder.java 静态内部类"></a>DisplayImageOptions.Builder.java 静态内部类</h3><p>Builder模式，用于构造参数繁多的DisplayImageOptions。</p>
<h3 id="ImageLoadingListener"><a href="#ImageLoadingListener" class="headerlink" title="ImageLoadingListener"></a>ImageLoadingListener</h3><p>图片加载各种时刻的回调接口，可在图片加载的某些点做监听。<br>包括开始加载（onLoadingStarted）、加载失败（onLoadingFailed）、加载成功（onLoadingComplete）、取消加载（onLoadingCancelled）四个回调函数。</p>
<h3 id="SimpleImageLoadingListener"><a href="#SimpleImageLoadingListener" class="headerlink" title="SimpleImageLoadingListener"></a>SimpleImageLoadingListener</h3><p>实现ImageLoadingListener接口，不过各个函数都是空实现，表示不在Image加载过程中做任何回调监听实现。ImageLoader.displayImage()函数中当listener传入值为null时的默认值。</p>
<h3 id="ImageLoadingProgressListener-java"><a href="#ImageLoadingProgressListener-java" class="headerlink" title="ImageLoadingProgressListener.java"></a>ImageLoadingProgressListener.java</h3><p>Image加载进度的回调接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageLoadingProgressListener</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Is called when image loading progress changed.</div><div class="line">	 *</div><div class="line">	 * <span class="doctag">@param</span> imageUri Image URI</div><div class="line">	 * <span class="doctag">@param</span> view     View for image. Can be &lt;b&gt;null&lt;/b&gt;.</div><div class="line">	 * <span class="doctag">@param</span> current  Downloaded size in bytes</div><div class="line">	 * <span class="doctag">@param</span> total    Total size in bytes</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(String imageUri, View view, <span class="keyword">int</span> current, <span class="keyword">int</span> total)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会在获取图片存储到文件系统时被调用，其中total表示图片总大小，为网络请求结果Response Header中content-length字段，如果不存在则为-1。</p>
<h3 id="DisplayBitmapTask-java"><a href="#DisplayBitmapTask-java" class="headerlink" title="DisplayBitmapTask.java"></a>DisplayBitmapTask.java</h3><p>显示图片的Task，实现类Runnable接口，必须在主线程调用。</p>
<p>主要函数：</p>
<ul>
<li>run()</li>
</ul>
<p>首先判断ImageAware是否被GC回收，如果是直接调用取消加载回调接口listener.onLoadingCancelled()；<br>否则判断ImageAware是否被复用，如果是直接调用取消加载回调接口listener.onLoadingCancelled()；<br>否则调用diaplay显示图片，并将ImageAware从正在加载的map中移除。调用加载成功回调接口listener.onLoadingComplete()；</p>
<p>对于ListView或是GridView这里缓存item的View来说，单个Item中如果含有ImageView，在滑动过程中可能因为异步加载及View复用导致图片错乱，这里对ImageAware是否被复用的判断就能很好的解决这个问题。原因类似：<a href="http://www.trinea.cn/android/android-listview-display-error-image-when-scroll/" target="_blank" rel="external"><br>Android ListView滑动过程中图片显示重复错位闪烁问题解决</a></p>
<h3 id="ProcessAndDisplayImageTask-java"><a href="#ProcessAndDisplayImageTask-java" class="headerlink" title="ProcessAndDisplayImageTask.java"></a>ProcessAndDisplayImageTask.java</h3><p>处理并显示图片的Task，实现了Runnable接口。</p>
<p>主要函数：</p>
<ul>
<li>run()</li>
</ul>
<p>主要通过imageLoadingInfo得到BitmapProcessor处理图片，并且处理后的图片和配置新建一个DisplayBitmapTask在ImageAware中显示图片。</p>
<h3 id="LoadAndDisplayImageTask-java"><a href="#LoadAndDisplayImageTask-java" class="headerlink" title="LoadAndDisplayImageTask.java"></a>LoadAndDisplayImageTask.java</h3><p>加载并显示图片的Task，实现了Runnable接口，用于从网络、文件系统或内存获取图片并解析，然后调用DisplayBitmapTask在ImageAware中显示图片。</p>
<p>主要函数：</p>
<ul>
<li>run()</li>
</ul>
<p>获取图片并显示，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">bmp = configuration.memoryCache.get(memoryCacheKey);</div><div class="line"><span class="keyword">if</span> (bmp == <span class="keyword">null</span> || bmp.isRecycled()) &#123;</div><div class="line">	bmp = tryLoadBitmap();</div><div class="line">	<span class="keyword">if</span> (bmp == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// listener callback already was fired</span></div><div class="line"></div><div class="line"></div><div class="line">	<span class="keyword">if</span> (bmp != <span class="keyword">null</span> &amp;&amp; options.isCacheInMemory()) &#123;</div><div class="line">		L.d(LOG_CACHE_IMAGE_IN_MEMORY, memoryCacheKey);</div><div class="line">		configuration.memoryCache.put(memoryCacheKey, bmp);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (bmp != <span class="keyword">null</span> &amp;&amp; options.shouldPostProcess()) &#123;</div><div class="line">		L.d(LOG_POSTPROCESS_IMAGE, memoryCacheKey);</div><div class="line">		bmp = options.getPostProcessor().process(bmp);</div><div class="line">		<span class="keyword">if</span> (bmp == <span class="keyword">null</span>) &#123;</div><div class="line">			L.e(ERROR_POST_PROCESSOR_NULL, memoryCacheKey);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">DisplayBitmapTask displayBitmapTask = <span class="keyword">new</span> DisplayBitmapTask(bmp, imageLoadingInfo, engine, loadedFrom);</div><div class="line">runTask(displayBitmapTask, syncLoading, handler, engine);</div></pre></td></tr></table></figure>
<p>从上面代码可以看到显示从内存缓存中去读bitmap对象，若bitmap对象不存在，则调用tryLoadBitma()函数获取bitmap对象，获取成功后若在DisplayImageOptions.Builder中设置类cacheInMemory(true),同时将Bitmap对象缓存到内存中。最后新建DisplayBitmapTask对象显示图片。</p>
<p>函数流程图如下：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/uil-load-display-flow-chart.png" alt=""></p>
<ol>
<li>判断图片的内存缓存是否存在，若存在直接执行步骤8；</li>
<li>判断图片的内存缓存是否存在，若存在直接执行步骤5；</li>
<li>从网络上下载图片</li>
<li>将图片缓存在磁盘上</li>
<li>将图片decode成bitmap对象；</li>
<li>根据DisplayImageOptions配置对图片进行预处理；</li>
<li>将Bitmap对象缓存到内存中；</li>
<li>根据DisplayImageOptions配置对图片进行后处理；</li>
<li>执行DisplayBitmapTask将图片显示在相应的控件上；</li>
</ol>
<ul>
<li>tryLoadBitmap()</li>
</ul>
<p>从磁盘缓存或网络获取图片，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Bitmap <span class="title">tryLoadBitmap</span><span class="params">()</span> <span class="keyword">throws</span> TaskCancelledException </span>&#123;</div><div class="line">	Bitmap bitmap = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		File imageFile = configuration.diskCache.get(uri);</div><div class="line">		<span class="keyword">if</span> (imageFile != <span class="keyword">null</span> &amp;&amp; imageFile.exists() &amp;&amp; imageFile.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">			</div><div class="line">			...</div><div class="line">			</div><div class="line">			bitmap = decodeImage(Scheme.FILE.wrap(imageFile.getAbsolutePath()));</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (bitmap == <span class="keyword">null</span> || bitmap.getWidth() &lt;= <span class="number">0</span> || bitmap.getHeight() &lt;= <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">			...</div><div class="line"></div><div class="line">			String imageUriForDecoding = uri;</div><div class="line">			<span class="keyword">if</span> (options.isCacheOnDisk() &amp;&amp; tryCacheImageOnDisk()) &#123;</div><div class="line">				imageFile = configuration.diskCache.get(uri);</div><div class="line">				<span class="keyword">if</span> (imageFile != <span class="keyword">null</span>) &#123;</div><div class="line">					imageUriForDecoding = Scheme.FILE.wrap(imageFile.getAbsolutePath());</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			checkTaskNotActual();</div><div class="line">			bitmap = decodeImage(imageUriForDecoding);</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> bitmap;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先根据uri看磁盘中是不是已经缓存了这个文件，如果已经缓存，调用decodeImage函数，将图片文件decode成Bitmap对象；如果Bitmap对象不合法或缓存文件不存在，判断是否需要缓存在磁盘，需要则调用tryCacheImageOnDisk()函数去下载并缓存图片到本地磁盘，再通过decodeImage(imageUri)函数将图片文件decode成bitmap对象，否则直接通过decodeImage(imageUriForDecoding)下载图片并解析。</p>
<h3 id="tryCacheImageOnDisk"><a href="#tryCacheImageOnDisk" class="headerlink" title="tryCacheImageOnDisk()"></a>tryCacheImageOnDisk()</h3><p>下载图片并存储在磁盘内，根据磁盘缓存图片最长宽高的配置处理图片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryCacheImageOnDisk</span><span class="params">()</span> <span class="keyword">throws</span> TaskCancelledException </span>&#123;</div><div class="line">	L.d(LOG_CACHE_IMAGE_ON_DISK, memoryCacheKey);</div><div class="line"></div><div class="line">	<span class="keyword">boolean</span> loaded;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		loaded = downloadImage(); <span class="comment">//调用下载器并保存图片</span></div><div class="line">		<span class="keyword">if</span> (loaded) &#123;</div><div class="line">			<span class="keyword">int</span> width = configuration.maxImageWidthForDiskCache;</div><div class="line">			<span class="keyword">int</span> height = configuration.maxImageHeightForDiskCache;</div><div class="line">			<span class="keyword">if</span> (width &gt; <span class="number">0</span> || height &gt; <span class="number">0</span>) &#123;</div><div class="line">				L.d(LOG_RESIZE_CACHED_IMAGE_FILE, memoryCacheKey);</div><div class="line">				resizeAndSaveImage(width, height); <span class="comment">// TODO : process boolean result</span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">		L.e(e);</div><div class="line">		loaded = <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> loaded;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你在ImageLoaderConfiguration中配置了maxImageWidthForDiskCache或者maxImageHeightForDiskCache，还会调用resizeAndSaveImage()函数，调整图片尺寸，并保存新的图片文件。</p>
<h3 id="downloadImage"><a href="#downloadImage" class="headerlink" title="downloadImage()"></a>downloadImage()</h3><p>下载图片并存储在磁盘内。调用getDownloader()得到ImageDownloader其下载图片。</p>
<h3 id="resizeAndSaveImage-int-maxWidth-int-maxHeight"><a href="#resizeAndSaveImage-int-maxWidth-int-maxHeight" class="headerlink" title="resizeAndSaveImage(int maxWidth,int maxHeight)"></a>resizeAndSaveImage(int maxWidth,int maxHeight)</h3><p>从磁盘缓存中得到图片，重新设置大小及进行一些处理后保存。</p>
<h3 id="geDownloader"><a href="#geDownloader" class="headerlink" title="geDownloader()"></a>geDownloader()</h3><p>根据ImageLoaderEngine配置得到下载器。<br>如果不允许访问网络，则使用不允许访问网络的图片下载器NetWorkDeniedImageDownloader；如果是慢网络情况，则使用慢网络情况下的图片下载器SlowNetworkImageDownloader；否则直接使用ImageLoaderConfiguration中的downloader。</p>
<h3 id="ImageLoadingInfo-java"><a href="#ImageLoadingInfo-java" class="headerlink" title="ImageLoadingInfo.java"></a>ImageLoadingInfo.java</h3><p>加载和显示图片任务需要的信息。成员变量如下：</p>
<p>String uri  图片url<br>String memoryCacheKey  图片缓存key<br>ImageAware imageAware  需要加载图片的对象<br>ImageSize targetSize  图片的显示尺寸<br>DisplayImageOptions options; 图片显示的配置项<br>ImageLoadingListener listener; 图片加载时状态的回调接口<br>ImageLoadingProgressListener progressListener; 图片加载进度的回调接口<br>ReentrantLock loadFromUriLock; 图片加载中的重入锁</p>
<h3 id="ImageDownloader-java"><a href="#ImageDownloader-java" class="headerlink" title="ImageDownloader.java"></a>ImageDownloader.java</h3><p>图片下载接口，待实现函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getString(String imageUri, Object extra)</div></pre></td></tr></table></figure>
<p>表示通过uri得到InputStream<br>通过内部定义的枚举Scheme，可以看出UIL支持哪些图片来源。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">HTTP</span>(<span class="string">"http"</span>), <span class="selector-tag">HTTPS</span>(<span class="string">"https"</span>), <span class="selector-tag">FILE</span>(<span class="string">"file"</span>), <span class="selector-tag">CONTENT</span>(<span class="string">"content"</span>), <span class="selector-tag">ASSETS</span>(<span class="string">"assets"</span>), <span class="selector-tag">DRAWABLE</span>(<span class="string">"drawable"</span>), <span class="selector-tag">UNKNOWN</span>(<span class="string">""</span>);</div></pre></td></tr></table></figure>
<h3 id="BaseImageDownloader-java"><a href="#BaseImageDownloader-java" class="headerlink" title="BaseImageDownloader.java"></a>BaseImageDownloader.java</h3><p>ImageDownloader的具体实现类。得到上面各种Scheme对应的图片InputStream。</p>
<p>主要函数：</p>
<ul>
<li>InputStream getStream(String imageUri, Object extra)</li>
</ul>
<p>函数内根据不同Scheme类型获取图片输入流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getStream</span><span class="params">(String imageUri, Object extra)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	<span class="keyword">switch</span> (Scheme.ofUri(imageUri)) &#123;</div><div class="line">		<span class="keyword">case</span> HTTP:</div><div class="line">		<span class="keyword">case</span> HTTPS:</div><div class="line">			<span class="keyword">return</span> getStreamFromNetwork(imageUri, extra);</div><div class="line">		<span class="keyword">case</span> FILE:</div><div class="line">			<span class="keyword">return</span> getStreamFromFile(imageUri, extra);</div><div class="line">		<span class="keyword">case</span> CONTENT:</div><div class="line">			<span class="keyword">return</span> getStreamFromContent(imageUri, extra);</div><div class="line">		<span class="keyword">case</span> ASSETS:</div><div class="line">			<span class="keyword">return</span> getStreamFromAssets(imageUri, extra);</div><div class="line">		<span class="keyword">case</span> DRAWABLE:</div><div class="line">			<span class="keyword">return</span> getStreamFromDrawable(imageUri, extra);</div><div class="line">		<span class="keyword">case</span> UNKNOWN:</div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			<span class="keyword">return</span> getStreamFromOtherSource(imageUri, extra);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>InputStream getStreamFromNetwork(String imageUri, Object extra)</li>
</ul>
<p>通过HttpURLConnection从网络获取图片的InputStream，支持response code为3xx的重定向。这里有个小细节代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">InputStream imageStream;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">	imageStream = conn.getInputStream();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">	<span class="comment">// Read all data to allow reuse connection (http://bit.ly/1ad35PY)</span></div><div class="line">	IoUtils.readAndCloseStream(conn.getErrorStream());</div><div class="line">	<span class="keyword">throw</span> e;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (!shouldBeProcessed(conn)) &#123;</div><div class="line">	IoUtils.closeSilently(imageStream);</div><div class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Image request failed with response code "</span> + conn.getResponseCode());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在发生异常时会调用<code>conn.getErrorStream()</code>继续读取Error Stream，这是为了利用网络连接回收及复用，但有意思的是在2.2之前，HttpURLConnection有个重大Bug，调用close()函数会影响连接池，导致连接复用失效，不过2.3以后已经解决了此went。</p>
<ul>
<li>InputStream getStreamFromFile(String imageUri, Object extra)</li>
</ul>
<p>从文件系统获取图片的InputStream。如果uri的类型是Video，则得到video的缩略图返回，否则按照一般文件操作返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> InputStream <span class="title">getStreamFromFile</span><span class="params">(String imageUri, Object extra)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	String filePath = Scheme.FILE.crop(imageUri);</div><div class="line">	<span class="keyword">if</span> (isVideoFileUri(imageUri)) &#123;</div><div class="line">		<span class="keyword">return</span> getVideoThumbnailStream(filePath); <span class="comment">//缩略图</span></div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		BufferedInputStream imageStream = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(filePath), BUFFER_SIZE);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ContentLengthInputStream(imageStream, (<span class="keyword">int</span>) <span class="keyword">new</span> File(filePath).length());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>InputStream getStreamFromContent(String imageUri, Object extra)</li>
</ul>
<p>从ContentProvider获取图片的InputStream。<br>如果是video类型，则先从MediaStore得到video的缩略图返回；<br>如果是联系人类型，则通过<code>ContactsContract.Contacts.openContactPhotoInputStream(res, uri, true)</code>读取内容返回；<br>否则通过<code>ContentResolver..openInputStream(uri)</code>读取内容返回</p>
<ul>
<li>InputStream getStreamFromAssets(String imageUri, Object extra)</li>
</ul>
<p>从Assets文件夹中获取图片的InputStream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> InputStream <span class="title">getStreamFromAssets</span><span class="params">(String imageUri, Object extra)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">	String filePath = Scheme.ASSETS.crop(imageUri);</div><div class="line">	<span class="keyword">return</span> context.getAssets().open(filePath);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>InputStream getStreamFromDrawable(String imageUri, Object extra)</li>
</ul>
<p>从Drawable资源中获取图片的InputStream。</p>
<ul>
<li>InputStream getStreamFromOtherSource(String imageUri, Object extra)</li>
</ul>
<p>UNKNOWN类型的处理，目前直接抛出不支持的异常</p>
<h3 id="MemoryCache-java"><a href="#MemoryCache-java" class="headerlink" title="MemoryCache.java"></a>MemoryCache.java</h3><p>Bitmap内存缓存接口，需要实现的接口包括get()、put()、remove()、clear()、keys()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemoryCache</span> </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Puts value into cache by key</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">put</span><span class="params">(String key, Bitmap value)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/** Returns value by key. If there is no value for key then null will be returned. */</span></div><div class="line">	<span class="function">Bitmap <span class="title">get</span><span class="params">(String key)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/** Removes item by key */</span></div><div class="line">	<span class="function">Bitmap <span class="title">remove</span><span class="params">(String key)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/** Returns all keys of cache */</span></div><div class="line">	<span class="function">Collection&lt;String&gt; <span class="title">keys</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/** Remove all items from cache */</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="BaseMemoryCache-java"><a href="#BaseMemoryCache-java" class="headerlink" title="BaseMemoryCache.java"></a>BaseMemoryCache.java</h3><p>实现了MemoryCache主要函数的抽象类，以<code>Map&lt;String, Reference&lt;Bitmap&gt;&gt; softMap</code>作为缓存池，利于虚拟机在内存不足是回收缓存对象。提供抽象函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Reference&lt;Bitmap&gt; <span class="title">createReference</span><span class="params">(Bitmap value)</span></span>;</div></pre></td></tr></table></figure>
<p>表示根据Bitmap创建一个Reference作为缓存对象。Reference可以是WeakReference、SoftReference等。</p>
<h3 id="WeakMemoryCache-java"><a href="#WeakMemoryCache-java" class="headerlink" title="WeakMemoryCache.java"></a>WeakMemoryCache.java</h3><p>以<code>WeakReference&lt;Bitmap&gt;</code>作为缓存value的内存缓存，实现了BaseMemoryCache的<code>createReference(Bitmap value)</code>函数，直接返回一个<code>new WeakReference&lt;Bitmap&gt;(value)</code>作为缓存value。</p>
<h3 id="LimitedMemoryCache-java"><a href="#LimitedMemoryCache-java" class="headerlink" title="LimitedMemoryCache.java"></a>LimitedMemoryCache.java</h3><p>限制总字节大小的内存缓存，继承自BaseMemoryCache抽象类。<br>会在put(…)函数中判断总体大小是否超出上限，超出则循环删除缓存对象直到小于上限。删除顺序由抽象函数<code>protected abstract Bitmap removeNext()</code>决定。抽象函数<code>protected abstract int getSize(Bitmap value)</code>表示每个元素大小。</p>
<h3 id="LargestLimitedMemoryCache-java"><a href="#LargestLimitedMemoryCache-java" class="headerlink" title="LargestLimitedMemoryCache.java"></a>LargestLimitedMemoryCache.java</h3><p>限制总字节大小的内存缓存，会在缓存满时优先删除size最大的元素，继承自LimitedMemoryCache。实现了LimitedMemoryCache的removeNext()函数，总是返回当前缓存中size最大的元素。</p>
<h3 id="UsingFreqLimitedMemoryCache-java"><a href="#UsingFreqLimitedMemoryCache-java" class="headerlink" title="UsingFreqLimitedMemoryCache.java"></a>UsingFreqLimitedMemoryCache.java</h3><p>限制总字节大小的内存缓存，会在缓存满时优先删除使用次数最少的元素，继承自LimitedMemoryCache。实现了LimitedMemoryCache的removeNext()函数，总是返回当前缓存中使用次数最少的元素。</p>
<h3 id="LRULimitedMemoryCache-java"><a href="#LRULimitedMemoryCache-java" class="headerlink" title="LRULimitedMemoryCache.java"></a>LRULimitedMemoryCache.java</h3><p>限制总字节大小的内存缓存，会在缓存满时优先删除最近最少使用的元素，继承自LimitedMemoryCache。通过<code>new LinkedHashMap&lt;String, Bitmap&gt;(10, 1.1f, true)</code>作为缓存池。LinkedHashMap第三个参数表示是否需要根据访问顺序(accessOrder)排序，true表示根据accessOrder排序，最近访问的跟最新加入的一样放到最后面，false表示根据插入顺序排序。这里为true且缓存满时始终删除第一个元素，即始终删除最近最少访问的元素。实现了LimitedMemoryCache的removeNext()函数，总是返回当前缓存中最近最少使用的元素。</p>
<h3 id="FIFOLimitedMemoryCache-java"><a href="#FIFOLimitedMemoryCache-java" class="headerlink" title="FIFOLimitedMemoryCache.java"></a>FIFOLimitedMemoryCache.java</h3><p>限制总字节大小的内存缓存，会在缓存满的时优先删除进入缓存的元素，继承自LimitedMemoryCache。实现了LimitedMemoryCache的removeNext()函数，总是返回当前缓存中最先进入缓存的元素。</p>
<blockquote>
<p><strong>以上所有LimitedMemoryCache子类都有个问题，就是Bitmap虽然通过WeakReference<bitmap>包装，但实际根本不会被虚拟机回收，因为他们子类中同时都保留了Bitmap的强引用。这些大都是UIL早期实现的版本，不推荐使用</bitmap></strong></p>
</blockquote>
<h3 id="LruMemoryCache-java"><a href="#LruMemoryCache-java" class="headerlink" title="LruMemoryCache.java"></a>LruMemoryCache.java</h3><p>限制总字节大小的内存缓存，会在缓存满时优先删除最近最少使用的元素，实现了MemoryCache。LRU(Least Recently Used)为最少使用算法。</p>
<p>通过<code>new LinkedHashMap&lt;String, Bitmap&gt;(0, 0.75f, true)</code>作为缓存池。LinkedHashMap第三个参数表示是否需要根据访问顺序(accessOrder)排序，true表示根据accessOrder排序，最近访问的跟最新加入的一样放到最后面，false表示根据插入顺序排序。这里为true且缓存满时始终删除第一个元素，即始终删除最近最少访问的元素。</p>
<p>在put(..)函数中通过trimToSize(int maxtSize)函数判断总体大小是否超出了上限，是则删除缓存池中第一个元素，即最近最少使用的元素，指导总体大小小于上限。</p>
<p>LruMemory功能上谕LRULimitedMemoryCache类似，不过在实现上更加优雅，用简单的实现接口方式，而不是不断继承的方式。</p>
<h3 id="LimitedAgeMemoryCache-java"><a href="#LimitedAgeMemoryCache-java" class="headerlink" title="LimitedAgeMemoryCache.java"></a>LimitedAgeMemoryCache.java</h3><p>限制类对象最长存活周期的内存缓存。<br>MemoryCache的装饰者，相当于为MemoryCache添加一个特性，以一个MemoryCache内存缓存和一个maxAge作为构造函数参数。在get()中判断如果对象存活时间已经超过设置的最长时间，则删除。</p>
<h3 id="FuzzyKeyMemoryCache-java"><a href="#FuzzyKeyMemoryCache-java" class="headerlink" title="FuzzyKeyMemoryCache.java"></a>FuzzyKeyMemoryCache.java</h3><p>可以将某些原本不同的key看做相等，在put时删除这些相等的key。<br>MemoryCache的装饰者，相当于为MemoryCache添加一个特性，以一个MemoryCache内存缓存和一个 keyComparator作为构造函数参数。在put()函数中判断如果key与缓存中已有key经过Comparator比较后相等，则删除之前的元素。</p>
<h3 id="FileNameGenerator-java"><a href="#FileNameGenerator-java" class="headerlink" title="FileNameGenerator.java"></a>FileNameGenerator.java</h3><p>根据uri得到文件名的接口</p>
<h3 id="HashCodeFileNameGenerator-java"><a href="#HashCodeFileNameGenerator-java" class="headerlink" title="HashCodeFileNameGenerator.java"></a>HashCodeFileNameGenerator.java</h3><p>以uri的hashCode值作为文件名</p>
<h3 id="Md5FileNameGenerator-java"><a href="#Md5FileNameGenerator-java" class="headerlink" title="Md5FileNameGenerator.java"></a>Md5FileNameGenerator.java</h3><p>以uri的MD5值作为文件名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Md5FileNameGenerator</span> <span class="keyword">implements</span> <span class="title">FileNameGenerator</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HASH_ALGORITHM = <span class="string">"MD5"</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RADIX = <span class="number">10</span> + <span class="number">26</span>; <span class="comment">// 10 digits + 26 letters</span></div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">generate</span><span class="params">(String imageUri)</span> </span>&#123;</div><div class="line">		<span class="keyword">byte</span>[] md5 = getMD5(imageUri.getBytes());</div><div class="line">		BigInteger bi = <span class="keyword">new</span> BigInteger(md5).abs();</div><div class="line">		<span class="keyword">return</span> bi.toString(RADIX);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">byte</span>[] getMD5(<span class="keyword">byte</span>[] data) &#123;</div><div class="line">		<span class="keyword">byte</span>[] hash = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			MessageDigest digest = MessageDigest.getInstance(HASH_ALGORITHM);</div><div class="line">			digest.update(data);</div><div class="line">			hash = digest.digest();</div><div class="line">		&#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</div><div class="line">			L.e(e);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> hash;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="DiskCache-java"><a href="#DiskCache-java" class="headerlink" title="DiskCache.java"></a>DiskCache.java</h3><p>图片的磁盘缓存接口。</p>
<p>主要函数：</p>
<ul>
<li>File getDirectory()</li>
</ul>
<p>得到磁盘缓存的根目录</p>
<ul>
<li>File get(String imageUri)</li>
</ul>
<p>根据原始图片uri去获取缓存图片的文件</p>
<ul>
<li>boolean save(String imageUri, InputStream imageStream, IoUtils.CopyListener listener)</li>
</ul>
<p>保存imageStream到磁盘中，listener表示保存进度且可在其中取消某些段的保存。</p>
<ul>
<li>boolean save(String imageUri, Bitmap bitmap)</li>
</ul>
<p>保存图片到磁盘</p>
<ul>
<li>boolean remove(String imageUri)</li>
</ul>
<p>根据图片uri删除缓存图片</p>
<ul>
<li>void close()</li>
</ul>
<p>关闭磁盘缓存，并释放资源</p>
<ul>
<li>void clear()</li>
</ul>
<p>清空磁盘缓存</p>
<h3 id="BaseDiskCache-java"><a href="#BaseDiskCache-java" class="headerlink" title="BaseDiskCache.java"></a>BaseDiskCache.java</h3><p>一个无大小限制的本地图片缓存，实现了DiskCache主要函数的抽象类。<br>图片缓存在cacheDir文件夹内，当cacheDir不可用时，则使用备用库reserveCacheDir。</p>
<p>主要函数：</p>
<ul>
<li>boolean save(String imageUri, InputStream imageStream, IoUtils.CopyListener listener)</li>
</ul>
<p>先根据imageUri得到目标文件，将imageStream先写入与目标文件同一文件夹的.tmp结尾的临时文件内，若未被listener取消且写入成功则将临时文件重命名为目标文件并返回true，否则删除临时文件并返回false。</p>
<ul>
<li>boolean save(String imageUri, Bitmap bitmap)</li>
</ul>
<p>先根据imageUri得到目标文件，通过Bitmap.compress(..)函数将bitmap先写入与目标文件同一文件夹的.tmp结尾的临时文件内，若写入成功则将临时文件名重命名为目标文件并返回true，否则删除临时文件并返回false。</p>
<ul>
<li>File getFile(String imageUri)</li>
</ul>
<p>根据imageUri和fileNameGenerator得到文件名，返回cacheDir文件夹内该文件，若cacheDir不可用，则使用备用库reserveCacheDir。</p>
<h3 id="LimitedAgeDiskCache-java"><a href="#LimitedAgeDiskCache-java" class="headerlink" title="LimitedAgeDiskCache.java"></a>LimitedAgeDiskCache.java</h3><p>限制缓存对象最长存活周期的磁盘缓存，继承自BaseDiskCache。<br>在get()函数判断如果缓存对象存活时间已经超过设置的最长时间，则删除。在save()中保存当前时间作为对象的创建时间。</p>
<h3 id="UnLimitedDiskCache-java"><a href="#UnLimitedDiskCache-java" class="headerlink" title="UnLimitedDiskCache.java"></a>UnLimitedDiskCache.java</h3><p>一个无大小限制的本地图片缓存。与BaseDiskCache无异，只是用了个意思明确的类名。</p>
<h3 id="DiskLruCache-java"><a href="#DiskLruCache-java" class="headerlink" title="DiskLruCache.java"></a>DiskLruCache.java</h3><p>限制总字节大小的磁盘缓存，会在缓存满时优先删除最近最少使用的元素。</p>
<p>通过缓存目录下名为journal的文件记录缓存的所有操作，并在缓存open时读取journal的文件内容存储到<code>LinkedHashMap&lt;String, Bitmap&gt; lruEntries</code>，后面<code>get(String key)</code>获取缓存内容时，会先从lruEntries中得到图片文件名返回文件。</p>
<p>通过<code>new LinkedHashMap&lt;String, Entry&gt;(0, 0.75f, true)</code>作为缓存池。LinkedHashMap第三个参数表示是否需要根据访问顺序(accessOrder)排序，true表示根据accessOrder排序，最近访问的跟最新加入的一样放到最后面，false表示根据插入顺序排序。这里为true且缓存满时trimToSize()函数始终删除第一个元素，即始终删除最近最少访问的元素。</p>
<h3 id="LruDiskCache-java"><a href="#LruDiskCache-java" class="headerlink" title="LruDiskCache.java"></a>LruDiskCache.java</h3><p>限制总字节大小的本地缓存，会在缓存满时优先删除最近最少使用的元素，实现了DiskCache。内部有个DiskLruCache cache、属性，缓存的存、取操作基本都是由该属性代理完成。</p>
<h3 id="StrictLineReader-java"><a href="#StrictLineReader-java" class="headerlink" title="StrictLineReader.java"></a>StrictLineReader.java</h3><p>通过readLine()函数从InputStream中读取一行，目前仅用于磁盘缓存操作记录文件journal的解析。</p>
<h3 id="Util-java"><a href="#Util-java" class="headerlink" title="Util.java"></a>Util.java</h3><p>工具类：</p>
<p>String readFully(Reader reader)读取 reader 中内容。<br>deleteContents(File dir)递归删除文件夹内容。</p>
<h3 id="ContentLengthInputStream-java"><a href="#ContentLengthInputStream-java" class="headerlink" title="ContentLengthInputStream.java"></a>ContentLengthInputStream.java</h3><p>InputStream的装饰者，可通过available()函数得到 InputStream 对应数据源的长度(总字节数)。主要用于计算文件存储进度即图片下载进度时的总进度。</p>
<h3 id="FailReason-java"><a href="#FailReason-java" class="headerlink" title="FailReason.java"></a>FailReason.java</h3><p>图片下载及显示时的错误原因，目前包括：<br>IO_ERROR 网络连接或是磁盘存储错误。<br>DECODING_ERROR decode image 为 Bitmap 时错误。<br>NETWORK_DENIED 当图片不在缓存中，且设置不允许访问网络时的错误。<br>OUT_OF_MEMORY 内存溢出错误。<br>UNKNOWN 未知错误。</p>
<h3 id="FlushedInputStream-java"><a href="#FlushedInputStream-java" class="headerlink" title="FlushedInputStream.java"></a>FlushedInputStream.java</h3><p>为了解决早期 Android 版本BitmapFactory.decodeStream(…)在慢网络情况下 decode image 异常的 Bug。<br>主要通过重写FilterInputStream的 skip(long n) 函数解决，确保 skip(long n) 始终跳过了 n 个字节。如果返回结果即跳过的字节数小于 n，则不断循环直到 skip(long n) 跳过 n 字节或到达文件尾。</p>
<h3 id="ImageScaleType-java"><a href="#ImageScaleType-java" class="headerlink" title="ImageScaleType.java"></a>ImageScaleType.java</h3><p>Image 的缩放类型，目前包括：<br>NONE不缩放。<br>NONE_SAFE根据需要以整数倍缩小图片，使得其尺寸不超过 Texture 可接受最大尺寸。<br>IN_SAMPLE_POWER_OF_2根据需要以 2 的 n 次幂缩小图片，使其尺寸不超过目标大小，比较快的缩小方式。<br>IN_SAMPLE_INT根据需要以整数倍缩小图片，使其尺寸不超过目标大小。<br>EXACTLY根据需要缩小图片到宽或高有一个与目标尺寸一致。<br>EXACTLY_STRETCHED根据需要缩放图片到宽或高有一个与目标尺寸一致。</p>
<h3 id="ViewScaleType-java"><a href="#ViewScaleType-java" class="headerlink" title="ViewScaleType.java"></a>ViewScaleType.java</h3><p>ImageAware的 ScaleType。<br>将 ImageView 的 ScaleType 简化为两种FIT_INSIDE和CROP两种。FIT_INSIDE表示将图片缩放到至少宽度和高度有一个小于等于 View 的对应尺寸，CROP表示将图片缩放到宽度和高度都大于等于 View 的对应尺寸。</p>
<h3 id="ImageSize-java"><a href="#ImageSize-java" class="headerlink" title="ImageSize.java"></a>ImageSize.java</h3><p>表示图片宽高的类。<br>scaleDown(…) 等比缩小宽高。<br>scale(…) 等比放大宽高。</p>
<h3 id="LoadedFrom-java"><a href="#LoadedFrom-java" class="headerlink" title="LoadedFrom.java"></a>LoadedFrom.java</h3><p>图片来源枚举类，包括网络、磁盘缓存、内存缓存。</p>
<h3 id="ImageDecoder-java"><a href="#ImageDecoder-java" class="headerlink" title="ImageDecoder.java"></a>ImageDecoder.java</h3><p>将图片转换为 Bitmap 的接口，抽象函数：<br>Bitmap decode(ImageDecodingInfo imageDecodingInfo) throws IOException;<br>表示根据ImageDecodingInfo信息得到图片并根据参数将其转换为 Bitmap。</p>
<h3 id="BaseImageDecoder-java"><a href="#BaseImageDecoder-java" class="headerlink" title="BaseImageDecoder.java"></a>BaseImageDecoder.java</h3><p>实现类ImageDecoder。调用ImageDownloader获取图片，然后根据ImageDecodingInfo或图片Exif信息处理图片转换为Bitmap。</p>
<p>主要函数：</p>
<ul>
<li>decode(ImageDecodingInfo decodingInfo)</li>
</ul>
<p>调用ImageDownloader获取图片，再调用defineImageSizeAndRotation()函数得到图片的相关信息，调用preparedDecodingOptions()得到图片缩放的比例，调用BitmapFactory.decodeStream()将InputStream转换为Bitmap，最后调用considerExactScaleAndOrientatiton()根据参数将图片放大、翻转、旋转为合适的样子返回。</p>
<ul>
<li>ImageFileInfo defineImageSizeAndRotation(InputStream imageStream, ImageDecodingInfo decodingInfo)</li>
</ul>
<p>得到图片真实大小以及Exif信息（设置考虑Exif的条件下）</p>
<ul>
<li>ExifInfo defineExifOrientation(String imageUri)</li>
</ul>
<p>得到图片Exif信息中的翻转以及旋转角度信息。</p>
<ul>
<li>Options prepareDecodingOptions(ImageSize imageSize, ImageDecodingInfo decodingInfo)</li>
</ul>
<p>得到图片缩放的比例：</p>
<ol>
<li>如果scaleType等于ImageScaleType.NONE，则缩放比例为1；</li>
<li>如果scaleType等于ImageScaleType.NONE_SAFE，则缩放比例为ImageSizeUtils.computeImageSampleSize.computeMinImageSampleSize()的返回值。</li>
<li>否则，调用ImageSizeUtils.computeImageSampleSize()计算返回值。</li>
</ol>
<p>在computeImageSampleSize()中</p>
<ol>
<li><p>如果viewScaleType等于FIT_INSIDE：<br> 1.1 如果scaleType等于ImageScaleType.IN_SAMPLE_POWER_OF_2，则缩放比例从1开始不断*2直到宽或高小于最大尺寸。<br> 1.2 否则，取宽和高分别与最大尺寸比例中较大值，即Math.max(srcWidth / targetWidth, srcHeight / targetHeight)。</p>
</li>
<li><p>如果viewScaleType等于CROP；<br> 2.1 如果scaleType等于ImageScaleType.IN_SAMPLE_POWER_OF_2，则缩放比例从1开始不断*2直到宽或高小于最大尺寸。<br> 2.2 否则，取宽和高分别与最大尺寸比例中较小值，即Math.min(srcWidth / targetWidth, srcHeight / targetHeight)</p>
</li>
<li><p>最后，在considerMaxTextureSize()中判断宽和高是否超过最大值，如果是则*2或是+1缩放。</p>
</li>
</ol>
<ul>
<li>Bitmap considerExactScaleAndOrientatiton(Bitmap subsampledBitmap, ImageDecodingInfo decodingInfo,int rotation, boolean flipHorizontal)</li>
</ul>
<p>根据参数将图片放大、翻转、旋转为合适的样子返回。</p>
<h3 id="ImageDownloadingInfo-java"><a href="#ImageDownloadingInfo-java" class="headerlink" title="ImageDownloadingInfo.java"></a>ImageDownloadingInfo.java</h3><p>Image Decode 需要的信息。<br>String imageKey 图片。<br>String imageUri 图片 uri，可能是缓存文件的 uri。<br>String originalImageUri 图片原 uri。<br>ImageSize targetSize 图片的显示尺寸。<br>imageScaleType 图片的 ScaleType。<br>ImageDownloader downloader 图片的下载器。<br>Object extraForDownloader 下载器需要的辅助信息。<br>boolean considerExifParams 是否需要考虑图片 Exif 信息。<br>Options decodingOptions 图片的解码信息，为 BitmapFactory.Options。</p>
<h3 id="BitmapDisplayer-java"><a href="#BitmapDisplayer-java" class="headerlink" title="BitmapDisplayer.java"></a>BitmapDisplayer.java</h3><p>在ImageAware中显示 bitmap 对象的接口。可在实现中对 bitmap 做一些额外处理，比如加圆角、动画效果。</p>
<h3 id="FadeInBitmapDisplayer-java"><a href="#FadeInBitmapDisplayer-java" class="headerlink" title="FadeInBitmapDisplayer.java"></a>FadeInBitmapDisplayer.java</h3><p>图片淡入方式显示在ImageAware中，实现了BitmapDisplayer接口。</p>
<h3 id="RoundedBitmapDisplayer-java"><a href="#RoundedBitmapDisplayer-java" class="headerlink" title="RoundedBitmapDisplayer.java"></a>RoundedBitmapDisplayer.java</h3><p>为图片添加圆角显示在ImageAware中，实现了BitmapDisplayer接口。主要通过BitmapShader实现。</p>
<h3 id="RoundedVignetteBitmapDisplayer-java"><a href="#RoundedVignetteBitmapDisplayer-java" class="headerlink" title="RoundedVignetteBitmapDisplayer.java"></a>RoundedVignetteBitmapDisplayer.java</h3><p>为图片添加渐变效果的圆角显示在ImageAware中，实现了BitmapDisplayer接口。主要通过RadialGradient实现。</p>
<h3 id="SimpleBitmapDisplayer-java"><a href="#SimpleBitmapDisplayer-java" class="headerlink" title="SimpleBitmapDisplayer.java"></a>SimpleBitmapDisplayer.java</h3><p>直接将图片显示在ImageAware中，实现了BitmapDisplayer接口。</p>
<h3 id="BitmapProcessor-java"><a href="#BitmapProcessor-java" class="headerlink" title="BitmapProcessor.java"></a>BitmapProcessor.java</h3><p>图片处理接口。可用于对图片预处理(Pre-process Bitmap）和后处理(Post-process Bitmap)。抽象函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BitmapProcessor</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function">Bitmap <span class="title">process</span><span class="params">(Bitmap bitmap)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用户可以根据自己的需要去实现它。比如你想要为你的图片添加一个水印，那么可以自己去实现BitmapProcessor接口。在DisplayImageOptions中配置Pre-process阶段预处理图片，这样设置后存储在文件系统以及内存缓存中的图片都是加了水印的。如果只希望在显示时改变不动原图片，可以在BitmapDisplayer中处理。</p>
<h3 id="PauseOnScrollListener-java"><a href="#PauseOnScrollListener-java" class="headerlink" title="PauseOnScrollListener.java"></a>PauseOnScrollListener.java</h3><p>可以在View滚动过程中暂停图片加载的Listener，实现了OnScrollListener接口。<br>它的好处是防止滚动中不必要的图片加载，在ListView或GridView中item加载图片最好使用它，简单的一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gridView.setOnScrollListener(<span class="keyword">new</span> PauseOnScrollListener(ImageLoader.getInstance(), <span class="keyword">false</span>, <span class="keyword">true</span>));</div></pre></td></tr></table></figure>
<p>主要成员变量：</p>
<p>pauseOnScroll; 触摸(手指依然在屏幕上)滑动过程中是否暂停图片加载<br>pauseOnFling;  甩指(手指已离开屏幕)过程中是否暂停图片加载<br>externalListener; 自定义的OnScrollListener接口，适用于View原来就有自定义OnScrollListener情况设置</p>
<p>实现原理：重写onScrollStateChanged(…)函数判断不同的状态下暂停或继续图片加载。</p>
<p>OnScrollListener.SCROLL_STATE_IDLE表示 View 处于空闲状态，没有在滚动，这时候会加载图片。</p>
<p>OnScrollListener.SCROLL_STATE_TOUCH_SCROLL表示 View 处于触摸滑动状态，手指依然在屏幕上，通过pauseOnScroll变量确定是否需要暂停图片加载。这种时候大都属于慢速滚动浏览状态，所以建议继续图片加载。</p>
<p>OnScrollListener.SCROLL_STATE_FLING表示 View 处于甩指滚动状态，手指已离开屏幕，通过pauseOnFling变量确定是否需要暂停图片加载。这种时候大都属于快速滚动状态，所以建议暂停图片加载以节省资源。</p>
<h3 id="QueueProcessingType-java"><a href="#QueueProcessingType-java" class="headerlink" title="QueueProcessingType.java"></a>QueueProcessingType.java</h3><p>任务队列的处理类型，包括FIFO先进先出、LIFO后进先出。</p>
<h3 id="LIFOLinkedBlockingDeque-java"><a href="#LIFOLinkedBlockingDeque-java" class="headerlink" title="LIFOLinkedBlockingDeque.java"></a>LIFOLinkedBlockingDeque.java</h3><p>后进先出阻塞队列。重写LinkedBlockingDeque的offer()函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(T e)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.offerFirst(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>让LinkedBlockingDeque插入总在最前，而remove()本身始终删除第一个元素，所以就变为了后进先出阻塞队列。实际一般情况只重写offer(…)函数是不够的，但因为ThreadPoolExecutor默认只用到了BlockingQueue的offer(…)函数，所以这种简单重写后做为ThreadPoolExecutor的任务队列没问题。</p>
<p>LIFOLinkedBlockingDeque.java包下的LinkedBlockingDeque.java、BlockingDeque.java、Deque.java都是 Java 1.6 源码中的，这里不做分析。</p>
<h3 id="DiskCacheUtils-java"><a href="#DiskCacheUtils-java" class="headerlink" title="DiskCacheUtils.java"></a>DiskCacheUtils.java</h3><p>磁盘缓存工具类，可用于查找或删除某个 uri 对应的磁盘缓存。</p>
<h3 id="MemoryCacheUtils-java"><a href="#MemoryCacheUtils-java" class="headerlink" title="MemoryCacheUtils.java"></a>MemoryCacheUtils.java</h3><p>内存缓存工具类。可用于根据 uri 生成内存缓存 key，缓存 key 比较，根据 uri 得到所有相关的 key 或图片，删除某个 uri 的内存缓存。<br>generateKey(String imageUri, ImageSize targetSize)<br>根据 uri 生成内存缓存 key，key 规则为[imageUri]_[width]x[height]。</p>
<h3 id="StorageUtils-java"><a href="#StorageUtils-java" class="headerlink" title="StorageUtils.java"></a>StorageUtils.java</h3><p>得到图片 SD 卡缓存目录路径。<br>缓存目录优先选择/Android/data/[app_package_name]/cache；若无权限或不可用，则选择 App 在文件系统的缓存目录context.getCacheDir()；若无权限或不可用，则选择/data/data/[app_package_name]/cache。<br>如果缓存目录选择了/Android/data/[app_package_name]/cache，则新建.nomedia文件表示不允许类似 Galley 这些应用显示此文件夹下图片。不过在 4.0 系统有 Bug 这种方式不生效。</p>
<h3 id="ImageSizeUtils-java"><a href="#ImageSizeUtils-java" class="headerlink" title="ImageSizeUtils.java"></a>ImageSizeUtils.java</h3><p>用于计算图片尺寸、缩放比例相关的工具类。</p>
<h3 id="IoUtils-java"><a href="#IoUtils-java" class="headerlink" title="IoUtils.java"></a>IoUtils.java</h3><p>IO 相关工具类，包括 stream 拷贝，关闭等。</p>
<h3 id="L-java"><a href="#L-java" class="headerlink" title="L.java"></a>L.java</h3><p>Log 工具类。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>UIL的内存缓存默认使用了LRU算法，即近期最少使用算法，选用了基于链表结构的LinkedHashMap作为存储结构。</p>
<p>假设情景：内存缓存设置的阈值只够存储两个bitmap对象，当put第三个bitmap对象时，将近期最少使用的bitmap对象移除。</p>
<ol>
<li>初始化LinkedHashMap，并按使用顺序来排序，accessOrder = true</li>
<li>向缓存池中放入bitmap1和bitmap2两个对象</li>
<li>继续放入第三个bitmap3，根据假设情景，将会超过设定缓存池阈值</li>
<li>释放对bitmap1对象的引用</li>
<li>bitmap1对象被GC回收</li>
</ol>
<p>UIL的磁盘缓存默认使用了UnlimitedDiskCache</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2016/04/17/Android-Universal-Image-Loader源码分析/" data-id="cj6esnzbp001bwg19qgbrjqap" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2016/04/17/Android-Universal-Image-Loader源码分析/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/源码分析/">源码分析</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/7/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/9/">下一页&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/21/JavaScript⑦对象/">JavaScript⑦对象</a>
          </li>
        
          <li>
            <a href="/2017/06/19/JavaScript⑥引用类型RegExp/">JavaScript⑥引用类型RegExp</a>
          </li>
        
          <li>
            <a href="/2017/06/19/JavaScript⑥引用类型Global/">JavaScript⑥引用类型Global</a>
          </li>
        
          <li>
            <a href="/2017/06/19/JavaScript⑥引用类型Date/">JavaScript⑥引用类型Date</a>
          </li>
        
          <li>
            <a href="/2017/06/19/JavaScript⑥引用类型Array/">JavaScript⑥引用类型Array</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2017 刘涤生&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;michaelliu0727@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/categories" class="mobile-nav-link">分类</a>
  
    <a href="/tags" class="mobile-nav-link">标签</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>
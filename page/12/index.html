<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>再读斋</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="像外行一样思考,像专家一样实践。">
<meta property="og:type" content="website">
<meta property="og:title" content="再读斋">
<meta property="og:url" content="http://liuguoquan727.github.io/page/12/index.html">
<meta property="og:site_name" content="再读斋">
<meta property="og:description" content="像外行一样思考,像专家一样实践。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="再读斋">
<meta name="twitter:description" content="像外行一样思考,像专家一样实践。">
  
    <link rel="alternate" href="/atom.xml" title="再读斋" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liuguoquan727.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/categories">分类</a>
        
          <a class="main-nav-link" href="/tags">标签</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">再读斋</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">MICHAEL</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java集合之LinkedHashMap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/20/Java集合之LinkedHashMap/" class="article-date">
  <time datetime="2015-12-20T14:35:21.000Z" itemprop="datePublished">2015-12-20 22:35:21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/20/Java集合之LinkedHashMap/">Java集合之LinkedhashMap</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>LinkedHashMap是HashMap的一个子类，它在HashMap的基础上维持了一个双向链表（hash表+双向链表），在遍历的时候可以使用插入顺序（先进先出），或者是最近最少使用（LRU）的顺序。</p>
<p>LinkedHashMap是key键有序的一种集合，使用双向链表来保证key的顺序。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>一般来说，如果需要使用的Map中的key无序，选择HashMap；如果要求key有序，则选择TreeMap。<br>但是选择TreeMap就会有性能问题，因为TreeMap的get操作的时间复杂度是O(log(n))的，相比于HashMap的O(1)还是差不少的，LinkedHashMap的出现就是为了平衡这些因素，使得能够以O(1)时间复杂度增加查找元素，又能够保证key的有序性。</p>
<p>此外，LinkedHashMap提供了两种key的顺序：</p>
<ul>
<li>访问顺序（access order）。可以使用这种顺序实现LRU（Least Recently Used）缓存</li>
<li>插入顺序（insertion orde）。同一key的多次插入，并不会影响其顺序</li>
</ul>
<h1 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</div></pre></td></tr></table></figure>
<p>从定义可以看到LinkedHashMap继承于HashMap，且实现了Map接口。这也就意味着HashMap的一些优秀因素可以被继承下来，比如hash寻址，使用链表解决hash冲突等实现的快速查找，对于HashMap中一些效率较低的内容，比如容器扩容过程，遍历方式，LinkedHashMap是否做了一些优化呢。继续看代码吧。</p>
<h1 id="底层存储"><a href="#底层存储" class="headerlink" title="底层存储"></a>底层存储</h1><p>LinkedHashMap是基于HashMap，并在其基础上维持了一个双向链表，也就是说LinkedHashMap是一个hash表（数组+单向链表） +双向链表的实现，到底实现方式是怎么样的，来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//双向链表的头结点</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; header ;</div><div class="line"></div><div class="line"><span class="comment">//true 表示最近较少使用顺序，false表示插入顺序</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</div></pre></td></tr></table></figure>
<p>下面来看看Entry这个节点类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * LinkedHashMap entry.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="comment">// These fields comprise the doubly linked list used for iteration.</span></div><div class="line">        <span class="comment">// 双向链表的上一个节点before和下一个节点after</span></div><div class="line">        Entry&lt;K,V&gt; before, after ;</div><div class="line"> </div><div class="line">       <span class="comment">// 构造方法直接调用父类HashMap的构造方法（super）</span></div><div class="line">       Entry( <span class="keyword">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</div><div class="line">            <span class="keyword">super</span>(hash, key, value, next);</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 从链表中删除当前节点的方法</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// 改变当前节点前后两个节点的引用关系，当前节点没有被引用后，gc可以回收</span></div><div class="line">            <span class="comment">// 将上一个节点的after指向下一个节点</span></div><div class="line">            before.after = after;</div><div class="line">            <span class="comment">// 将下一个节点的before指向前一个节点</span></div><div class="line">            after.before = before;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 在指定的节点前加入一个节点到链表中（也就是加入到链表尾部）</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;</div><div class="line">            <span class="comment">// 下面改变自己对前后的指向</span></div><div class="line">            <span class="comment">// 将当前节点的after指向给定的节点（加入到existingEntry前面嘛）</span></div><div class="line">            after  = existingEntry;</div><div class="line">            <span class="comment">// 将当前节点的before指向给定节点的上一个节点</span></div><div class="line">            before = existingEntry.before ;</div><div class="line"> </div><div class="line">            <span class="comment">// 下面改变前后最自己的指向</span></div><div class="line">            <span class="comment">// 上一个节点的after指向自己</span></div><div class="line">            before.after = <span class="keyword">this</span>;</div><div class="line">            <span class="comment">// 下一个几点的before指向自己</span></div><div class="line">            after.before = <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// 当向Map中获取查询元素或修改元素（put相同key）的时候调用这个方法</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</div><div class="line">            LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</div><div class="line">            <span class="comment">// 如果accessOrder为true，也就是使用最近较少使用顺序</span></div><div class="line">            <span class="keyword">if</span> (lm.accessOrder ) &#123;</div><div class="line">                lm. modCount++;</div><div class="line">                <span class="comment">// 先删除，再添加，也就相当于移动了</span></div><div class="line">                <span class="comment">// 删除当前元素</span></div><div class="line">                remove();</div><div class="line">                <span class="comment">// 将当前元素加入到header前（也就是链表尾部）</span></div><div class="line">                addBefore(lm. header);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// 当从Map中删除元素的时候调动这个方法</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</div><div class="line">            remove();</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到Entry继承了HashMap中的Entry，但是LinkedHashMap中的Entry多了两个属性指向上一个节点的before和指向下一个节点的after，也正是这两个属性组成了一个双向链表。等等。。。Entry还有一个继承下来的next属性，这个next是单向链表中用来指向下一个节点的，怎么回事嘛，怎么又是单向链表又是双向链表呢，都要晕了对不对，其实想的没错，这里的节点即是Hash表中的单向链表中的一个节点，它又是LinkedHashMap维护的双向链表中的一个节点。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/LinkedHashMap.png" alt=""></p>
<p>注：黑色箭头指向表示单向链表的next指向，红色箭头指向表示双向链表的before指向，蓝色箭头指向表示双向链表的after指向。另外LinkedHashMap种还有一个header节点是不保存数据的，这里没有画出来。</p>
<p>从上图可以看出LinkedHashMap仍然是一个Hash表，底层由一个数组组成，而数组的每一项都是个单向链表，由next指向下一个节点。但是LinkedHashMap所不同的是，在节点中多了两个属性before和after，由这两个属性组成了一个双向循环链表（你怎么知道是循环，下面在说喽），而由这个双向链表维持着Map容器中元素的顺序。看下Entry中的recordRemoval方法，该方法将在节点被删除时候调用，Hash表中链表节点被正常删除后，调用该方法修正由于节点被删除后双向链表的前后指向关系，从这一点来看，LinkedHashMap比HashMap的add、remove、set等操作要慢一些（因为要维护双向链表 ）。</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 构造一个指定初始容量和加载因子的LinkedHashMap，默认accessOrder为false</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">( <span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">        accessOrder = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造一个指定初始容量的LinkedHashMap，默认accessOrder为false</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">( <span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity);</div><div class="line">        accessOrder = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造一个使用默认初始容量(16)和默认加载因子(0.75)的LinkedHashMap，默认accessOrder为false</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        accessOrder = <span class="keyword">false</span>;  <span class="comment">//默认false</span></div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造一个指定map的LinkedHashMap，所创建LinkedHashMap使用默认加载因子(0.75)和足以容纳指定map的初始容量，默认accessOrder为false 。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(m);</div><div class="line">        accessOrder = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造一个指定初始容量、加载因子和accessOrder的LinkedHashMap</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">( <span class="keyword">int</span> initialCapacity,</span></span></div><div class="line">                      <span class="keyword">float</span> loadFactor,</div><div class="line">                         <span class="keyword">boolean</span> accessOrder) &#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//重写了HashMap的init方法</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 初始化话header，将hash设置为-1，key、value、next设置为null</span></div><div class="line">        header = <span class="keyword">new</span> Entry&lt;K,V&gt;(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">        <span class="comment">// header的before和after都指向header自身</span></div><div class="line">        header.before = header. after = header ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><p>LinkedHashMap没有重写HashMap的put方法，只是重写了HashMap被put调用的addEntry方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">( <span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">	<span class="comment">// 调用createEntry方法创建一个新的节点</span></div><div class="line">	createEntry(hash, key, value, bucketIndex);</div><div class="line"></div><div class="line">	<span class="comment">// Remove eldest entry if instructed, else grow capacity if appropriate</span></div><div class="line">	<span class="comment">// 取出header后的第一个节点（因为header不保存数据，所以取header后的第一个节点）</span></div><div class="line">	Entry&lt;K,V&gt; eldest = header.after ;</div><div class="line">	<span class="comment">// 判断是容量不够了是要删除第一个节点还是需要扩容</span></div><div class="line">	<span class="keyword">if</span> (removeEldestEntry(eldest)) &#123;</div><div class="line">		<span class="comment">// 删除第一个节点（可实现FIFO、LRU策略的Cache）</span></div><div class="line">		removeEntryForKey(eldest. key);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">// 和HashMap一样进行扩容</span></div><div class="line">		<span class="keyword">if</span> (size &gt;= threshold)</div><div class="line">			resize(<span class="number">2</span> * table.length );</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * This override differs from addEntry in that it doesn't resize the</div><div class="line"> * table or remove the eldest entry.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">( <span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">	<span class="comment">// 下面三行代码的逻辑是，创建一个新节点放到单向链表的头部</span></div><div class="line">	<span class="comment">// 取出数组bucketIndex位置的旧节点 </span></div><div class="line">	HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</div><div class="line">	<span class="comment">// 创建一个新的节点，并将next指向旧节点</span></div><div class="line">   Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, old);</div><div class="line">	<span class="comment">// 将新创建的节点放到数组的bucketIndex位置</span></div><div class="line">	table[bucketIndex] = e;</div><div class="line"></div><div class="line">	<span class="comment">// 维护双向链表，将新节点添加在双向链表header前面（链表尾部）</span></div><div class="line">	e.addBefore( header);</div><div class="line">	<span class="comment">// 计数器size加1</span></div><div class="line">	size++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 默认返回false，也就是不会进行元素删除了。如果想实现cache功能，只需重写该方法</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，在添加方法上，比HashMap中多了两个逻辑，一个是当Map容量不足后判断是删除第一个元素，还是进行扩容，另一个是维护双向链表。而在判断是否删除元素的时候，我们发现removeEldestEntry这个方法竟然是永远返回false，原来想要实现Cache功能，需要自己继承LinkedHashMap然后重写removeEldestEntry方法，这里默认提供的是容器的功能。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>LinkedHashMap没有重写remove方法，只是在实现了Entry类的recordRemoval方法，该方法是HashMap的提供的一个回调方法，在HashMap的remove方法进行回调，而LinkedHashMap中recordRemoval的主要当然是要维护双向链表了，返回上面去看下Entry类的recordRemoval方法吧。</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>LinkedHashMap重写了get方法，但是的确复用了HashMap中的getEntry方法，LinkedHashMap是在get方法中指加入了调用recoreAccess方法的逻辑，recoreAccess方法的目的当然也是维护双向链表了，具体逻辑返回上面去看下Entry类的recoreAccess方法吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        e.recordAccess( <span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span> e.value ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="是否包含"><a href="#是否包含" class="headerlink" title="是否包含"></a>是否包含</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line">	<span class="comment">// Overridden to take advantage of faster iterator</span></div><div class="line">	<span class="comment">// 遍历双向链表，查找指定的value</span></div><div class="line">	<span class="keyword">if</span> (value==<span class="keyword">null</span>) &#123; </div><div class="line">		<span class="keyword">for</span> (Entry e = header .after; e != header; e = e.after )</div><div class="line">			<span class="keyword">if</span> (e.value ==<span class="keyword">null</span>)</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">for</span> (Entry e = header .after; e != header; e = e.after )</div><div class="line">			<span class="keyword">if</span> (value.equals(e.value ))</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LinkedHashMap对containsValue进行了重写，我们在HashMap中说过，HashMap的containsValue需要遍历整个hash表，这样是十分低效的。而LinkedHashMap中重写后，不再遍历hash表，而是遍历其维护的双向链表，这样在效率上难道就有所改善吗？我们分析下：hash表是由数组+单向链表组成，而由于使用hash算法，可能会导致散列不均匀，甚至数组的有些项是没有元素的（没有hash出对应的散列值），而LinkedHashMap的双向链表呢，是不存在空项的，所以LinkedHashMap的containsValue比HashMap的containsValue效率要好一些。</p>
<h1 id="自定义LruCache"><a href="#自定义LruCache" class="headerlink" title="自定义LruCache"></a>自定义LruCache</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.michael.java.construct;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">String</span>, <span class="title">Object</span>&gt;</span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * </div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2725884916293330545L</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_CAPACITY = <span class="number">1024</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxCapacity;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(DEFAULT_MAX_CAPACITY, DEFAULT_LOAD_FACTOR, accessOrder);</div><div class="line">		<span class="keyword">this</span>.maxCapacity = DEFAULT_MAX_CAPACITY;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> capacity,<span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(DEFAULT_MAX_CAPACITY, DEFAULT_LOAD_FACTOR, accessOrder);</div><div class="line">		<span class="keyword">this</span>.maxCapacity = capacity;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(</span></span></div><div class="line">			java.util.Map.Entry&lt;String, Object&gt; eldest) &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.size() &gt; maxCapacity;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		LruCache cache = <span class="keyword">new</span> LruCache(<span class="number">5</span>, <span class="keyword">true</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>;i++) &#123;</div><div class="line">			cache.put(<span class="string">"k"</span>+i, <span class="string">"v"</span>+i);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		System.out.println(<span class="string">"size: "</span> + cache.size());</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(Map.Entry&lt;String, Object&gt; entry : cache.entrySet()) &#123;</div><div class="line">			System.out.println(entry.getKey() + <span class="string">" = "</span> + entry.getValue());</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(<span class="string">"------------"</span>);</div><div class="line">		System.out.println(<span class="string">"k3 = "</span> + cache.get(<span class="string">"k3"</span>));</div><div class="line">		System.out.println(<span class="string">"------------"</span>);</div><div class="line">		</div><div class="line">		cache.put(<span class="string">"k6"</span>, <span class="string">"v6"</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(Map.Entry&lt;String, Object&gt; entry : cache.entrySet()) &#123;</div><div class="line">			System.out.println(entry.getKey() + <span class="string">" = "</span> + entry.getValue());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">结果打印：</div><div class="line"></div><div class="line">size: <span class="number">5</span></div><div class="line">k1 = v1</div><div class="line">k2 = v2</div><div class="line">k3 = v3</div><div class="line">k4 = v4</div><div class="line">k5 = v5</div><div class="line">------------</div><div class="line">k3 = v3</div><div class="line">------------</div><div class="line">k2 = v2</div><div class="line">k4 = v4</div><div class="line">k5 = v5</div><div class="line">k3 = v3</div><div class="line">k6 = v6</div></pre></td></tr></table></figure>
<p>序列中的第一个元素时最近使用最少的元素</p>
<p>参考文章：</p>
<p><a href="http://www.importnew.com/17561.html" target="_blank" rel="external">给jdk写注释系列之jdk1.6容器(5)-LinkedHashMap源码解析</a></p>
<p><a href="http://liujiacai.net/blog/2015/09/12/java-linkedhashmap/" target="_blank" rel="external">Java LinkedHashMap源码解析</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2015/12/20/Java集合之LinkedHashMap/" data-id="cj6esnzfa007qwg196y2saiot" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2015/12/20/Java集合之LinkedHashMap/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Collection/">Collection</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Java集合之TreeMap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/19/Java集合之TreeMap/" class="article-date">
  <time datetime="2015-12-19T14:35:21.000Z" itemprop="datePublished">2015-12-19 22:35:21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/19/Java集合之TreeMap/">Java集合之TreeMap</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>TreeMap是基于红黑树结构的一种Map，要分析TreeMap的实现首先要了解红黑树这种数据结构。</p>
<h1 id="二叉树、红黑树简介"><a href="#二叉树、红黑树简介" class="headerlink" title="二叉树、红黑树简介"></a>二叉树、红黑树简介</h1><p>先简单总结一下数组，链表，Hash表以及树的优缺点:</p>
<ul>
<li><p>数组</p>
<ul>
<li>优点：随机访问效率高（根据下标查询）；搜索效率较高（可使用折半方法）</li>
<li>缺点：内存连续且固定，存储效率低；插入和删除效率低（可能会进行数组扩容或者拷贝）</li>
</ul>
</li>
<li><p>链表</p>
<ul>
<li>优点：不要求连续内存，存储效率高；插入和删除效率高（只需要改变指针指向）</li>
<li>缺点：不支持随机访问；搜索效率低（需要遍历）</li>
</ul>
</li>
<li><p>哈希表</p>
<ul>
<li>优点：搜索效率高；增删效率高</li>
<li>缺点：内存利用率低（基于数组）；存在散列冲突</li>
</ul>
</li>
<li><p>二叉树</p>
<ul>
<li>优点：查询效率高；增删效率高；存储效率高；</li>
<li>缺点：算法复杂</li>
</ul>
</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树的特点：</p>
<ul>
<li>若左子树不为空，则左子树上所有结点的值均小于它的根结点的值</li>
<li>若右子树不为空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>左右子树也分别为二叉查找树</li>
<li>没有键值相等的节点</li>
</ul>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/treemap-%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="二叉树"></p>
<p>按照二叉查找树存储的数据，对元素的搜索效率是非常高的，比如上图中如果要查找值为48的节点，只需要遍历4个节点就能完成。理论上，一颗平衡的二叉查找树的任意节点平均查找效率为树的高度h，即O(lgn)。但是如果二叉查找树的失去平衡（元素全在一侧），搜索效率就退化为O(n)，因此二叉查找树的平衡是搜索效率的关键所在。而红黑树就是靠红黑规则来维持二叉查找树的平衡性。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/treemap-%E5%A4%B1%E5%8E%BB%E5%B9%B3%E8%A1%A1%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="失去平衡的二叉树"></p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树的红黑规则：</p>
<ul>
<li>节点是红色或黑色</li>
<li>根节点是黑色</li>
<li>每个叶子节点（NIL节点，空节点）是黑色的</li>
<li>每个红色节点的两个子节点都是黑色（从每个叶子到根的所有路径上不能有两个连续的红色节点）</li>
<li>从任意节点到其每个叶子的所有路径都包含相同数目的黑色节点</li>
</ul>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/treemap-%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="s"></p>
<p>第5条规则到底是什么情况，下面简单解释下，比如图中红8到1左边的叶子节点的路径包含两个黑色节点，到6下面的叶子节点的路径也包含两个黑色节点。</p>
<p>但是在在添加或删除节点后，红黑树就发生了变化，可能不再满足上面的5个特性，为了保持红黑树的以上特性，就有了三个动作：左旋、右旋、着色。</p>
<p>下面来看下什么是红黑树的左旋和右旋：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/treemap-%E7%BA%A2%E9%BB%91%E6%A0%91%E5%B7%A6%E6%97%8B.jpg" alt=""></p>
<p>对x进行左旋，意味着将x变成一个左节点。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/treemap-%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8F%B3%E6%97%8B.jpg" alt=""></p>
<p>对y进行右旋，意味着将y变成一个右节点。</p>
<h1 id="TreeMap签名"><a href="#TreeMap签名" class="headerlink" title="TreeMap签名"></a>TreeMap签名</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line">       <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</div><div class="line">       <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div></pre></td></tr></table></figure>
<blockquote>
<p>HashMap是无序的，TreeMap是有序的</p>
</blockquote>
<h2 id="接口NavigableMap"><a href="#接口NavigableMap" class="headerlink" title="接口NavigableMap"></a>接口NavigableMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">SortedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div></pre></td></tr></table></figure>
<p>发现NavigableMap继承了SortedMap，说明这个Map是有序的。这个顺序一般是指由Comparable接口提供的keys自然序，或者也可以在窗口SortedMap时，指定一个Comparator来决定。</p>
<h2 id="Comparator和Comparable的区别"><a href="#Comparator和Comparable的区别" class="headerlink" title="Comparator和Comparable的区别"></a>Comparator和Comparable的区别</h2><ul>
<li>Comparable一般表示类的自然序，比如定义一个Student类，学号为默认排序</li>
<li>Comparator一般表示类在某种场合下的特殊分类，需要定制化排序。比如现在想按照Student类的age来排序。</li>
</ul>
<p>插入SortedMap中的key的类都必须继承Comparable类（或指定一个comparator），这样才能确定如何比较（通过k1.compareTo(k2)或comparator.compare(k1, k2)）两个key，否则，在插入时，会报ClassCastException的异常。</p>
<p>此外，SortedMap中key的顺序性应该与equals方法保持一致。也就是说k1.compareTo(k2)或comparator.compare(k1, k2)为true时，k1.equals(k2)也应该为true。</p>
<p>介绍完了SortedMap，再来回到我们的NavigableMap上面来。<br>NavigableMap是JDK1.6新增的，在SortedMap的基础上，增加了一些“导航方法”（navigation methods）来返回与搜索目标最近的元素。例如下面这些方法：</p>
<ul>
<li>lowerEntry，返回所有比给定Map.Entry小的元素</li>
<li>floorEntry，返回所有比给定Map.Entry小或相等的元素</li>
<li>ceilingEntry，返回所有比给定Map.Entry大或相等的元素</li>
<li>higherEntry，返回所有比给定Map.Entry大的元素</li>
</ul>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>红黑树的算法还没有理解深刻，暂时挖个坑</p>
<p>因为红黑树是平衡的二叉搜索树，所以其put（包含update操作）、get、remove的时间复杂度都为log(n)</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>TreeMap的key是有序的，增删改查操作的时间复杂度为O(log(n))，为了保证红黑树平衡，在必要时会进行旋转</li>
<li>HashMap的key是无序的，增删改查操作的时间复杂度为O(1)，为了做到动态扩容，在必要时会进行resize。</li>
</ul>
<p>参考文章:</p>
<p><a href="http://www.importnew.com/17605.html" target="_blank" rel="external">给jdk写注释系列之jdk1.6容器(7)-TreeMap源码解析</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2015/12/19/Java集合之TreeMap/" data-id="cj6esnzfd007uwg19hr3zrb9c" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2015/12/19/Java集合之TreeMap/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Collection/">Collection</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Java集合之HashMap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/19/Java集合之HashMap/" class="article-date">
  <time datetime="2015-12-19T13:30:21.000Z" itemprop="datePublished">2015-12-19 21:30:21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/19/Java集合之HashMap/">Java集合之HashMap</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="签名（Signature）"><a href="#签名（Signature）" class="headerlink" title="签名（Signature）"></a>签名（Signature）</h1><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line">       <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</div><div class="line">       <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></div></pre></td></tr></table></figure>
<p>可以看到HashMap实现了：</p>
<ul>
<li>接口Cloneable，用于表明HashMap对象会重写<code>java.lang.Object.clone()</code>方法，HashMap实现的是浅拷贝</li>
<li>接口Serializable：表明HashMap对象可以被序列化</li>
</ul>
<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p>Map接口里包含的成员方法不外乎是“增删改查”，Map虽然并不是Collection，但它提供了三种“集合视角”，与下面三个方法一一对应：</p>
<ul>
<li><code>Set&lt;key&gt; keySet()</code>，提供key的集合视角</li>
<li><code>Collection&lt;V&gt; values()</code>，提供value的集合视角</li>
<li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>,提供key-value键值对的集合视角</li>
</ul>
<h1 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h1><h2 id="哈希表（hash-table）"><a href="#哈希表（hash-table）" class="headerlink" title="哈希表（hash table）"></a>哈希表（hash table）</h2><p>HashMap是一种基于哈希表实现的Map，哈希表是一种通用的数据结构，其概念是：key经过hash函数作用后得到一个槽（buckets）的索引（index），槽中保存着我们想要获取的值，如下图所示：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/hashmap-%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="hash table"></p>
<blockquote>
<p>一些不同的key经过同一hash函数后可能产生相同的索引，也就会产生冲突，所以利用哈希表这种数据结构实现具体类时，需要注意两个问题：</p>
<ul>
<li>设计一个好的hash函数，使冲突尽可能的减少</li>
<li>需要解决发生冲突后的处理</li>
</ul>
</blockquote>
<h2 id="HashMap的特点"><a href="#HashMap的特点" class="headerlink" title="HashMap的特点"></a>HashMap的特点</h2><ul>
<li>线程非安全，并且允许key与value都为null值，HashTable与之相反，为线程安全，key与value都不允许null值</li>
<li>不保证其内部元素的顺序，而且随着时间的推移，同一元素的位置也可能改变（resize的情况）</li>
<li>put、get操作的时间复杂度为O（1）</li>
<li>遍历其集合视角的时间复杂度与其容量和现有元素的大小成正比，如果遍历的性能要求很高，不要把capacity设置的过高或者把平衡因子设置的过低。</li>
<li>由于HashMap是线程非安全的，意味着如果有多个线程同时对同一HashMap试图做迭代时有结构上的改变（添加、删除entry，只改变entry的value值不算结构改变），那么会报ConcurrentModificationException异常，专业术语叫fail-fast，尽早报错对应多线程程序来说是很有必要的。</li>
<li><code>Map m = Collections.synchronizedMap(new HashMap(...))</code>;通过这种方式可以得到一个线程安全的Map。</li>
</ul>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>HashMap遵循集合框架的约束，提供一个参数为空的构造函数与有一个参数且参数类型为Map的构造函数。除此之外，还提供了两个构造函数，用于设置HashMap的容量（capacity）和平衡因子（loadFactor）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</div><div class="line">				  DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</div><div class="line">	inflateTable(threshold);</div><div class="line"></div><div class="line">	putAllForCreate(m);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">	<span class="comment">//初始容量和加载因子合法校验</span></div><div class="line">	<span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">										   initialCapacity);</div><div class="line">	<span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">		initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">	<span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">										   loadFactor);</div><div class="line"></div><div class="line">	<span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">	threshold = initialCapacity;</div><div class="line">	init();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>容量与平衡因子都有个默认值，并且容量有个最大值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 默认初始容量为16，必须为2的指数倍</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 最大容量为2的30次方</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 默认加载因子为0.75f</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Entry数组，长度必须为2的n次幂</span></div><div class="line">    <span class="keyword">transient</span> Entry[] table;</div><div class="line"></div><div class="line">	<span class="comment">// 已存储元素的数量</span></div><div class="line">	<span class="keyword">transient</span> <span class="keyword">int</span> size ;</div><div class="line"></div><div class="line">	<span class="comment">// 下次扩容的临界值，size&gt;=threshold就会扩容，threshold等于capacity*load factor</span></div><div class="line">	<span class="keyword">int</span> threshold;</div><div class="line"></div><div class="line">	<span class="comment">// 加载因子</span></div><div class="line">	<span class="keyword">final</span> <span class="keyword">float</span> loadFactor ;</div></pre></td></tr></table></figure>
<p>可以看到，默认的平衡因子为0.75，这是权衡了时间复杂度与空间复杂度之后的最好取值（官方说法），过高的因子会降低存储空间但是查找的时间就会增加。</p>
<p>此外，我们注意到容量必须为2的指数被（默认16），这是为什么呢？解答这个问题，需要了解HashMap中哈希函数的设计原理</p>
<h2 id="哈希函数的设计原理"><a href="#哈希函数的设计原理" class="headerlink" title="哈希函数的设计原理"></a>哈希函数的设计原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> h = hashSeed;</div><div class="line">	<span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</div><div class="line">		<span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	h ^= k.hashCode();</div><div class="line"></div><div class="line">	<span class="comment">// This function ensures that hashCodes that differ only by</span></div><div class="line">	<span class="comment">// constant multiples at each bit position have a bounded</span></div><div class="line">	<span class="comment">// number of collisions (approximately 8 at default load factor).</span></div><div class="line">	h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</div><div class="line">	<span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns index for hash code h.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">	<span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></div><div class="line">	<span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在哈希表容量为length的情况下，为了使key都能在冲突最小的情况下映射到[0,length)的索引（index）内，HasMap让length为2的指数倍，然后用`hashCode(key) &amp; (length -1)的方法得到索引。</p>
<blockquote>
<p>因为length为2的指数倍，所以length-1所对应的二进制位都为1，然后与hashCode(key)坐与运算，即可得到[0,length)内的索引。</p>
</blockquote>
<p>但是这里有个问题，如果HashCode（key)的值大于length的值，举个例子：</p>
<blockquote>
<p>Java中对象的哈希值都是32位整数，而HashMap的默认大小为16，那么如果有两个对象的哈希值为：0xABAB0000与0xBABA0000，它们的后四位都是一样，那么与16异或后得到结果都是一样的为0，也就是产生了冲突。</p>
</blockquote>
<p>造成冲突的原因关键在于16限制了只能用低位来计算，高位直接舍弃了，所以我们需要额外的哈希函数而不只是简单的对象的hashCode方法了。具体来说就是HashMap中hash（）函数所实现的功能了。</p>
<blockquote>
<p>首先有个随机的hashSeed来降低冲突发生的几率<br>然后如果是字符串。则用了sun.misc.Hashing.stringHash32((String) k)来获取索引值<br>最后通过一系列的无符号右移操作，来把高位与地位进行异或操作，来降低冲突发生的几率。</p>
</blockquote>
<p>右移的偏移量20,12,7是怎么来的呢？因为Java中对象的哈希值是32位的，所以这几个数应该就是把高位与地位做异或运算，至于这几个数是如何选取的，就不清楚了。</p>
<h2 id="HashMap-Entry"><a href="#HashMap-Entry" class="headerlink" title="HashMap.Entry"></a>HashMap.Entry</h2><p>HashMap中存放的是HashMap.Entry对象，它继承自Map.Entry，其比较重要的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">	<span class="keyword">final</span> K key;</div><div class="line">	V value;</div><div class="line">	Entry&lt;K,V&gt; next; <span class="comment">//指向下一个节点</span></div><div class="line">	<span class="keyword">int</span> hash;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Creates new entry.</div><div class="line">	 */</div><div class="line">	Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</div><div class="line">		value = v;</div><div class="line">		next = n;</div><div class="line">		key = k;</div><div class="line">		hash = h;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> key;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> value;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</div><div class="line">		V oldValue = value;</div><div class="line">		value = newValue;</div><div class="line">		<span class="keyword">return</span> oldValue;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		Map.Entry e = (Map.Entry)o;</div><div class="line">		Object k1 = getKey();</div><div class="line">		Object k2 = e.getKey();</div><div class="line">		<span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</div><div class="line">			Object v1 = getValue();</div><div class="line">			Object v2 = e.getValue();</div><div class="line">			<span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">//用key的hash值与value的hash值与运算的结果作为Entry的hash值</span></div><div class="line">		<span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 当向HashMap中添加元素时调用这个方法，这里没有实现是供子类回调</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 当从HashMap中删除元素时调用这个方法</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，Entry实现了单向链表的功能，用next成员变量来级联起来。也就是说HashMap的底层结构是一个数组，而数组的元素是一个单向链表。</p>
<p>介绍完Entry，下面介绍一个重要的成员变量</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//HashMap内部维护一个数组类型的<span class="keyword">Entry</span>变量table，用来保存添加进来的<span class="keyword">Entry</span>对象</div><div class="line">transient <span class="keyword">Entry</span>&lt;K,V&gt;[] table = (<span class="keyword">Entry</span>&lt;K,V&gt;[]) EMPTY_TABLE;</div></pre></td></tr></table></figure>
<p>Entry是单链表，怎么这里又需要个数组类型的tabl呢？其实这是解决冲突的一个方式：链地址法（开散列法），效果如下：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/hashmap-%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95.gif" alt=""></p>
<p>就是相同索引值的Entry会以单向链表的形式存在。<br>HashMap采用将相同的散列值存储到一个链表中，也就是说在一个链表中的元素他们的散列值绝对是相同的。</p>
<h2 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h2><p>因为put操作有可能需要对HashMap进行resize，所以实现较复杂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</div><div class="line">    <span class="comment">//辅助函数，用于填充HashMap到指定的capacity</span></div><div class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></div><div class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</div><div class="line">    <span class="comment">//threshold为resize的阈值，超过后HashMap会进行resize，内容的entry会进行rehash</span></div><div class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</div><div class="line">    table = <span class="keyword">new</span> Entry[capacity];</div><div class="line">    initHashSeedAsNeeded(capacity);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Associates the specified value with the specified key in this map.</div><div class="line"> * If the map previously contained a mapping for the key, the old</div><div class="line"> * value is replaced.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</div><div class="line">        inflateTable(threshold);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> putForNullKey(value);</div><div class="line">		</div><div class="line">	<span class="comment">//使用key的hashCode计算key对应的hash值</span></div><div class="line">    <span class="keyword">int</span> hash = hash(key);</div><div class="line">	</div><div class="line">	<span class="comment">//通过key的哈希值查找在数组中的index位置</span></div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">    <span class="comment">//这里的循环是关键</span></div><div class="line">    <span class="comment">//当新增的key所对应的索引i，对应table[i]中已经有值时，进入循环体</span></div><div class="line">	<span class="comment">//取出数组index位置的链表，遍历链表查看是否已经存在相同的key</span></div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="comment">//判断是否存在本次插入的key，如果存在用本次的value替换之前oldValue，相当于update操作</span></div><div class="line">        <span class="comment">//并返回之前的oldValue</span></div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">            V oldValue = e.value;</div><div class="line">            e.value = value;</div><div class="line">            e.recordAccess(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果本次新增key之前不存在于HashMap中，modCount加1，说明结构改变了</span></div><div class="line">    modCount++;</div><div class="line">	<span class="comment">//在数组i位置处添加一个新的链表节点</span></div><div class="line">    addEntry(hash, key, value, i);</div><div class="line">	<span class="comment">//没有相同key的情况，返回null</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">		<span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</div><div class="line">			V oldValue = e.value;</div><div class="line">			e.value = value;</div><div class="line">			e.recordAccess(<span class="keyword">this</span>);</div><div class="line">			<span class="keyword">return</span> oldValue;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	modCount++;</div><div class="line">	addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</div><div class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    <span class="comment">//如果增加一个元素会后，HashMap的大小超过阈值，需要resize</span></div><div class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</div><div class="line">        <span class="comment">//增加的幅度是之前的1倍</span></div><div class="line">        resize(<span class="number">2</span> * table.length);</div><div class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</div><div class="line">        bucketIndex = indexFor(hash, table.length);</div><div class="line">    &#125;</div><div class="line">    createEntry(hash, key, value, bucketIndex);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    <span class="comment">//首先得到该索引处的冲突链Entries，第一次插入bucketIndex位置时冲突链为null，也就是e为null</span></div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">    <span class="comment">//然后把新的Entry添加到冲突链的开头，也就是说，后插入的反而在前面（第一次还真没看明白）</span></div><div class="line">    <span class="comment">//table[bucketIndex]为新加入的Entry，是bucketIndex位置的冲突链的第一个元素</span></div><div class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    size++;</div><div class="line">&#125;</div><div class="line"><span class="comment">//下面看看HashMap是如何进行resize，庐山真面目就要揭晓了😊</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</div><div class="line">    Entry[] oldTable = table;</div><div class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</div><div class="line">    <span class="comment">//如果已经达到最大容量，那么就直接返回</span></div><div class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</div><div class="line">        threshold = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//使用新的容量创建一个新的链表数组</span></div><div class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</div><div class="line">    <span class="comment">//initHashSeedAsNeeded(newCapacity)的返回值决定了是否需要重新计算Entry的hash值</span></div><div class="line">	<span class="comment">//将当前数组的元素移动到新的数组</span></div><div class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</div><div class="line">	<span class="comment">//将当前数组的引用指向新的数组</span></div><div class="line">    table = newTable;</div><div class="line">	<span class="comment">//重新计算临界值</span></div><div class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Transfers all entries from current table to newTable.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</div><div class="line">    <span class="comment">//遍历当前的table，将里面的元素添加到新的newTable中</span></div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</div><div class="line">            Entry&lt;K,V&gt; next = e.next;</div><div class="line">            <span class="keyword">if</span> (rehash) &#123;</div><div class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</div><div class="line">            e.next = newTable[i];</div><div class="line">            <span class="comment">//最后这两句用了与put放过相同的技巧</span></div><div class="line">            <span class="comment">//将后插入的反而在前面</span></div><div class="line">            newTable[i] = e;</div><div class="line">            e = next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Initialize the hashing mask value. We defer initialization until we</div><div class="line"> * really need it.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">initHashSeedAsNeeded</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> currentAltHashing = hashSeed != <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</div><div class="line">            (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</div><div class="line">    <span class="comment">//这里说明了，在hashSeed不为0或满足useAltHash时，会重算Entry的hash值</span></div><div class="line">    <span class="comment">//至于useAltHashing的作用可以参考下面的链接</span></div><div class="line">    <span class="comment">// http://stackoverflow.com/questions/29918624/what-is-the-use-of-holder-class-in-hashmap</span></div><div class="line">    <span class="keyword">boolean</span> switching = currentAltHashing ^ useAltHashing;</div><div class="line">    <span class="keyword">if</span> (switching) &#123;</div><div class="line">        hashSeed = useAltHashing</div><div class="line">            ? sun.misc.Hashing.randomHashSeed(<span class="keyword">this</span>)</div><div class="line">            : <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> switching;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Map中的元素越多，hash冲突的几率也就越大，数组长度是固定的，所以导致链表越来越长，那么查询的效率当然也就越地下了。HasMap的扩容resize，需要将所有的元素重新计算后，一个个重新排列到新的数组中去，这是非常低效的，和ArrayList一样，在可预知容量大小的情况下，提前预设容量会减少HashMap的扩容，提高性能。</p>
</blockquote>
<h2 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="comment">//单独处理key为null的情况</span></div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> getForNullKey();</div><div class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//key为null的Entry用于放在table[0]中，但是在table[0]冲突链中的Entry的key不一定为null</span></div><div class="line">    <span class="comment">//所以需要遍历冲突链，查找key是否存在</span></div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> e.value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">    <span class="comment">//首先定位到索引在table中的位置</span></div><div class="line">    <span class="comment">//然后遍历冲突链，查找key是否存在</span></div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="remove操作"><a href="#remove操作" class="headerlink" title="remove操作"></a>remove操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; e = removeEntryForKey(key);</div><div class="line">    <span class="comment">//可以看到删除的key如果存在，就返回其所对应的value</span></div><div class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">    <span class="comment">//这里用了两个Entry对象，相当于两个指针，为的是防治冲突链发生断裂的情况</span></div><div class="line">    <span class="comment">//这里的思路就是一般的单向链表的删除思路</span></div><div class="line">    Entry&lt;K,V&gt; prev = table[i];</div><div class="line">    Entry&lt;K,V&gt; e = prev;</div><div class="line">    <span class="comment">//当table[i]中存在冲突链时，开始遍历里面的元素</span></div><div class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">        Entry&lt;K,V&gt; next = e.next;</div><div class="line">        Object k;</div><div class="line">		<span class="comment">//如果hash值和key都相等则认为相等</span></div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">            modCount++;</div><div class="line">            size--;</div><div class="line">            <span class="keyword">if</span> (prev == e) <span class="comment">//当冲突链只有一个Entry时</span></div><div class="line">                table[i] = next;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                prev.next = next;</div><div class="line">            e.recordRemoval(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">        &#125;</div><div class="line">        prev = e;</div><div class="line">        e = next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一般而言，认为HashMap的这四种操作时间复杂度O（1），因为它hash函数性质较好，保证了冲突发生的几率较小。</p>
<blockquote>
<p>从删除和查找操作可以看出，在根据key查找元素的时候，还是需要通过遍历，但是由于已经通过hash函数对key散列，要遍历的只是发生冲突后生成的链表，这样遍历的结果就已经少很多了，比完全遍历效率提升了N倍。</p>
</blockquote>
<h2 id="fast-fail的HashIterator"><a href="#fast-fail的HashIterator" class="headerlink" title="fast-fail的HashIterator"></a>fast-fail的HashIterator</h2><p>集合类用Iterator类来遍历其包含的元素，接口Enumeration以及不推荐使用。相比Enumeration，Iterator有下面两个优势：</p>
<ul>
<li>Iterator允许调用者在遍历集合类时删除集合类中包含的元素</li>
<li>比Enumeration命名更简单</li>
</ul>
<p>HashMap中提供的三种集合视角，底层都是用HashIterator是实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></div><div class="line">    <span class="comment">//在初始化Iterator实例时，纪录下当前的修改次数</span></div><div class="line">    <span class="keyword">int</span> expectedModCount;   <span class="comment">// For fast-fail</span></div><div class="line">    <span class="keyword">int</span> index;              <span class="comment">// current slot</span></div><div class="line">    Entry&lt;K,V&gt; current;     <span class="comment">// current entry</span></div><div class="line">    HashIterator() &#123;</div><div class="line">        expectedModCount = modCount;</div><div class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></div><div class="line">            Entry[] t = table;</div><div class="line">            <span class="comment">//遍历HashMap的table，依次查找元素</span></div><div class="line">            <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</div><div class="line">                ;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//在访问下一个Entry时，判断是否有其他线程有对集合的修改</span></div><div class="line">        <span class="comment">//说明HashMap是线程非安全的</span></div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        Entry&lt;K,V&gt; e = next;</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">        <span class="keyword">if</span> ((next = e.next) == <span class="keyword">null</span>) &#123;</div><div class="line">            Entry[] t = table;</div><div class="line">            <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</div><div class="line">                ;</div><div class="line">        &#125;</div><div class="line">        current = e;</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        Object k = current.key;</div><div class="line">        current = <span class="keyword">null</span>;</div><div class="line">        HashMap.<span class="keyword">this</span>.removeEntryForKey(k);</div><div class="line">        expectedModCount = modCount;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> nextEntry().value;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> nextEntry().getKey();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</div><div class="line">    <span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> nextEntry();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>从源码可知，保存Entry的table数组为transient的，也就是说在进行序列化时并不会包含该成员，这是为什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</div></pre></td></tr></table></figure>
<p>为了解答这个问题，我们需要明确下面事实：Object.hasCode方法对于一个类的两个实例返回的是不同的哈希值。</p>
<p>我们可以试想下面的场景：</p>
<blockquote>
<p>我们在机器A上算出对象A的哈希值与索引，然后把它插入到HashMap中，然后把该HashMap序列化后，在机器B上重新算出对象的哈希值与索引，这与机器A上算出的是不一样的，所以我们在机器B上get对象A时，会得到错误的结果。<br>所以说，当序列化一个HashMap对象时，保存Entry的table是不需要序列化进来的，因为它在另一台机器上是错误的。<br>因为这个原因，HashMap重写了writeObject和readObject方法</p>
</blockquote>
<h1 id="HashMap遍历"><a href="#HashMap遍历" class="headerlink" title="HashMap遍历"></a>HashMap遍历</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapDemo</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++ ) &#123;</div><div class="line">			</div><div class="line">			map.put(<span class="string">"name"</span>+i, <span class="string">"liuguoquan"</span>+i);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line"></div><div class="line">		<span class="keyword">long</span> start = System.nanoTime();</div><div class="line">		<span class="comment">//键的集合</span></div><div class="line">		Set&lt;String&gt; set = map.keySet();</div><div class="line">		Iterator&lt;String&gt; iterator = set.iterator();</div><div class="line">		<span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">			String key = (String) iterator.next();</div><div class="line">			String value = map.get(key);</div><div class="line">			System.out.println(key + <span class="string">" = "</span> + value);</div><div class="line">			</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">long</span> end = System.nanoTime();</div><div class="line">		System.out.println(<span class="string">"keySet(): "</span> + (end - start)+<span class="string">"纳秒"</span>);</div><div class="line">		</div><div class="line">		<span class="comment">//foreach keyset</span></div><div class="line">		start = System.nanoTime();</div><div class="line">		<span class="keyword">for</span>(String key : map.keySet()) &#123;</div><div class="line">			String value = map.get(key);</div><div class="line">			System.out.println(key + <span class="string">" = "</span> + value);</div><div class="line">		&#125;</div><div class="line">		end = System.nanoTime();</div><div class="line">		System.out.println(<span class="string">"for keySet(): "</span> + (end - start)+<span class="string">"纳秒"</span>);</div><div class="line">		</div><div class="line">		<span class="comment">//Entry集合 效率较高</span></div><div class="line">		start = System.nanoTime();</div><div class="line">		Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</div><div class="line">		Iterator&lt;Entry&lt;String, String&gt;&gt; it = entrySet.iterator();</div><div class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">			Map.Entry&lt;String, String&gt; entry = (Map.Entry&lt;String, String&gt;) it</div><div class="line">					.next();</div><div class="line">			String key = entry.getKey();</div><div class="line">			String value = entry.getValue();</div><div class="line">			System.out.println(key + <span class="string">" = "</span> + value);</div><div class="line">			</div><div class="line">		&#125;</div><div class="line">		end = System.nanoTime();</div><div class="line">		System.out.println(<span class="string">"entrySet(): "</span>+ (end - start)+<span class="string">"纳秒"</span>);</div><div class="line">		</div><div class="line">		start = System.nanoTime();</div><div class="line">		<span class="comment">//foreach entry </span></div><div class="line">		<span class="keyword">for</span>(Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</div><div class="line">			String key = entry.getKey();</div><div class="line">			String value = entry.getValue();</div><div class="line">			System.out.println(key + <span class="string">" = "</span> + value);</div><div class="line">		&#125;</div><div class="line">		end = System.nanoTime();</div><div class="line">		System.out.println(<span class="string">"for entrySet(): "</span>+ (end - start)+<span class="string">"纳秒"</span>);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">结果打印：</div><div class="line"></div><div class="line">name3 = liuguoquan3</div><div class="line">name2 = liuguoquan2</div><div class="line">name1 = liuguoquan1</div><div class="line">name0 = <span class="function">liuguoquan0</span></div><div class="line"><span class="title">keySet</span><span class="params">()</span>: 403136纳秒</div><div class="line">name3 = liuguoquan3</div><div class="line">name2 = liuguoquan2</div><div class="line">name1 = liuguoquan1</div><div class="line">name0 = <span class="function">liuguoquan0</span></div><div class="line"><span class="keyword">for</span> <span class="title">keySet</span><span class="params">()</span>: 84675纳秒</div><div class="line">name3 = liuguoquan3</div><div class="line">name2 = liuguoquan2</div><div class="line">name1 = liuguoquan1</div><div class="line">name0 = <span class="function">liuguoquan0</span></div><div class="line"><span class="title">entrySet</span><span class="params">()</span>: 109194纳秒</div><div class="line">name3 = liuguoquan3</div><div class="line">name2 = liuguoquan2</div><div class="line">name1 = liuguoquan1</div><div class="line">name0 = <span class="function">liuguoquan0</span></div><div class="line"><span class="keyword">for</span> <span class="title">entrySet</span><span class="params">()</span>: 69850纳秒</div></pre></td></tr></table></figure>
<p>从上面的结果来看：</p>
<ul>
<li>HashMap遍历，如果既需要可以也需要value,直接用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</div><div class="line">	String key = entry.getKey();</div><div class="line">	String value = entry.getValue();</div><div class="line">	System.out.println(key + <span class="string">" = "</span> + value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果只是遍历key而无需value的话，可以直接用<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(String key : map.keySet()) &#123;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>参考文章：</p>
<p><a href="http://www.importnew.com/17559.html" target="_blank" rel="external">给jdk写注释系列之jdk1.6容器(4)-HashMap源码解析</a></p>
<p><a href="http://liujiacai.net/blog/2015/09/03/java-hashmap/" target="_blank" rel="external">Java HashMap 源码解析</a></p>
<p><a href="http://www.importnew.com/16301.html" target="_blank" rel="external">HashMap的实现原理</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2015/12/19/Java集合之HashMap/" data-id="cj6esnzf8007nwg19f08lis0n" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2015/12/19/Java集合之HashMap/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Collection/">Collection</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Java集合之ArrayList和LinkedList" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/18/Java集合之ArrayList和LinkedList/" class="article-date">
  <time datetime="2015-12-18T13:25:21.000Z" itemprop="datePublished">2015-12-18 21:25:21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/18/Java集合之ArrayList和LinkedList/">Java集合之ArrayList和LinkedList</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ArrayList是 Java 集合框架中使用最为普遍的集合类之一。ArrayList 是一种 List 实现，允许包括null在内的所有元素，它的内部用一个动态数组来存储元素，因此 ArrayList 能够在添加和移除元素的时候进行动态的扩展和缩减。</p>
<p>ArrayList有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。</p>
<p>ArrayList按数组下标访问元素–get(i)/set(i,e) 的性能很高，这是数组的基本优势。</p>
<p>ArrayList直接在数组末尾加入元素–add(e)的性能也高，但如果按下标插入、删除元素–add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">	<span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</div><div class="line">	<span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">Serializable</span></div></pre></td></tr></table></figure>
<h2 id="ArrayList实现"><a href="#ArrayList实现" class="headerlink" title="ArrayList实现"></a>ArrayList实现</h2><p>对应ArrayList而言，它实现List接口、底层使用数组保存所有元素，其操作基本上都是对数组的操作。下面我们来分析ArrayList的源码：</p>
<h3 id="底层数组实现"><a href="#底层数组实现" class="headerlink" title="底层数组实现"></a>底层数组实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</div></pre></td></tr></table></figure>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>ArrayList提供了三种方式的构造器：</p>
<ol>
<li>构造一个默认初始容量为10的空列表；</li>
<li>构造一个指定初始容量的空列表；</li>
<li>构造一个包含指定collection集合的元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//指定初始容量的空列表</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">	<span class="keyword">super</span>();</div><div class="line">	<span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</div><div class="line">										   initialCapacity);</div><div class="line">	<span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 初始容量为10的空列表.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">super</span>();</div><div class="line">	<span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">	elementData = c.toArray();</div><div class="line">	size = elementData.length;</div><div class="line">	<span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></div><div class="line">	<span class="keyword">if</span> (elementData.getClass() != Object[].class)</div><div class="line">		elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>ArrayList提供了set、add、addAll这些方法添加元素</p>
<h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;  </div><div class="line">    RangeCheck(index);  </div><div class="line">  </div><div class="line">    E oldValue = (E) elementData[index];  </div><div class="line">    elementData[index] = element;  </div><div class="line">    <span class="keyword">return</span> oldValue;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将指定的元素添加到此列表的尾部。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </div><div class="line">    ensureCapacity(size + <span class="number">1</span>);   </div><div class="line">    elementData[size++] = e;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">// 将指定的元素插入此列表中的指定位置。  </span></div><div class="line"><span class="comment">// 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size);  </div><div class="line">    <span class="comment">// 如果数组长度不足，将进行扩容。  </span></div><div class="line">    ensureCapacity(size+<span class="number">1</span>);  <span class="comment">// Increments modCount!!  </span></div><div class="line">    <span class="comment">// 将 elementData中从Index位置开始、长度为size-index的元素拷贝到从下标为index+1位置开始的新的elementData数组中。即将当前位于该位置的元素以及所有后续元素右移一个位置。  </span></div><div class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);  </div><div class="line">    elementData[index] = element;  </div><div class="line">    size++;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="addAll"><a href="#addAll" class="headerlink" title="addAll()"></a>addAll()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </div><div class="line">    Object[] a = c.toArray();  </div><div class="line">    <span class="keyword">int</span> numNew = a.length;  </div><div class="line">    ensureCapacity(size + numNew);  <span class="comment">// Increments modCount  </span></div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);  </div><div class="line">    size += numNew;  </div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 从指定的位置开始，将指定collection中的所有元素插入到此列表中。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(  </div><div class="line">            <span class="string">"Index: "</span> + index + <span class="string">", Size: "</span> + size);  </div><div class="line">  </div><div class="line">    Object[] a = c.toArray();  </div><div class="line">    <span class="keyword">int</span> numNew = a.length;  </div><div class="line">    ensureCapacity(size + numNew);  <span class="comment">// Increments modCount  </span></div><div class="line">  </div><div class="line">    <span class="keyword">int</span> numMoved = size - index;  </div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </div><div class="line">        System.arraycopy(elementData, index, elementData, index + numNew, numMoved);  </div><div class="line">  </div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);  </div><div class="line">    size += numNew;  </div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="读取元素"><a href="#读取元素" class="headerlink" title="读取元素"></a>读取元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回此列表中指定位置上的元素。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">    RangeCheck(index);  </div><div class="line">  </div><div class="line">    <span class="keyword">return</span> (E) elementData[index];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 移除此列表中指定位置上的元素。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">    RangeCheck(index);  </div><div class="line">  </div><div class="line">    modCount++;  </div><div class="line">    E oldValue = (E) elementData[index];  </div><div class="line">  </div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;  </div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);  </div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work  </span></div><div class="line">  </div><div class="line">    <span class="keyword">return</span> oldValue;  </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">// 移除此列表中首次出现的指定元素（如果存在）。这是应为ArrayList中允许存放重复的元素。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">    <span class="comment">// 由于ArrayList中允许存放null，因此下面通过两种情况来分别处理。  </span></div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)  </div><div class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;  </div><div class="line">                <span class="comment">// 类似remove(int index)，移除列表中指定位置上的元素。  </span></div><div class="line">                fastRemove(index);  </div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">            &#125;  </div><div class="line">&#125; <span class="keyword">else</span> &#123;  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)  </div><div class="line">        <span class="keyword">if</span> (o.equals(elementData[index])) &#123;  </div><div class="line">            fastRemove(index);  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：从数组中移除元素的操作，也会导致被移除的元素以后的所有元素的向左移动一个位置。</p>
<h3 id="调整数组容量"><a href="#调整数组容量" class="headerlink" title="调整数组容量"></a>调整数组容量</h3><p>每次向ArrayList中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法ensureCapacity()来实现。在实际添加大量元素前，我们也可以使用该方法手动增加ArrayList的容量，以减少递增式再分配的数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">	<span class="comment">//是否是默认容量</span></div><div class="line">	<span class="keyword">int</span> minExpand = (elementData != EMPTY_ELEMENTDATA) ? <span class="number">0</span> : DEFAULT_CAPACITY;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</div><div class="line">		<span class="comment">//扩容</span></div><div class="line">		ensureExplicitCapacity(minCapacity);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">	modCount++;</div><div class="line"></div><div class="line">	<span class="comment">//判断是否大于当前容量</span></div><div class="line">	<span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">		grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">	<span class="comment">//</span></div><div class="line">	<span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">	<span class="comment">//扩展容量为当前容量的一半</span></div><div class="line">	<span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">	</div><div class="line">	<span class="comment">//新容量小于最小容量要求</span></div><div class="line">	<span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">		newCapacity = minCapacity;</div><div class="line">	<span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">		newCapacity = hugeCapacity(minCapacity);</div><div class="line">	<span class="comment">//</span></div><div class="line">	elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述代码可以看出，数组进行扩容时，会将老数组中的元素拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素有多少时，要在构造ArrayList实例时就指定其容量大小，以避免数组扩容的发送。或者根据实际需求，通过调用ensureCapacity()方法手动增加ArrayList实例的容量。</p>
<p>ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能，可以通过trimToSize方法来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;  </div><div class="line">    modCount++;  </div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;  </div><div class="line">    <span class="keyword">if</span> (size &lt; oldCapacity) &#123;  </div><div class="line">        elementData = Arrays.copyOf(elementData, size);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Fail-Fast机制"><a href="#Fail-Fast机制" class="headerlink" title="Fail-Fast机制"></a>Fail-Fast机制</h3><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会抛出失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.modCount != l.modCount)</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ArrayList遍历"><a href="#ArrayList遍历" class="headerlink" title="ArrayList遍历"></a>ArrayList遍历</h2><p>有三种方法可以遍历ArrayList数组，分别是for、foreach、Iterator。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">			list.add(<span class="string">"liu"</span> + i);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// for循环  优先用这种方式</span></div><div class="line">		<span class="keyword">int</span> len = list.size();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">			System.out.println(<span class="string">"for: "</span> + list.get(i));</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// foreach语句</span></div><div class="line">		<span class="keyword">for</span> (String str : list) &#123;</div><div class="line"></div><div class="line">			System.out.println(<span class="string">"foreach: "</span> + str);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 显示调用集合迭代器</span></div><div class="line">		Iterator&lt;String&gt; it = list.iterator();</div><div class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">			System.out.println(<span class="string">"iterator while: "</span> + it.next());</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (Iterator&lt;String&gt; iterator = list.iterator(); iterator.hasNext();) &#123;</div><div class="line"></div><div class="line">			System.out.println(<span class="string">"iterator for: "</span> + iterator.next());</div><div class="line"></div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>LinkedList是一种基于链表结构的一中List，具体是基于双向循环列表设计的。</p>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</div><div class="line">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div></pre></td></tr></table></figure>
<h2 id="LinkedList实现"><a href="#LinkedList实现" class="headerlink" title="LinkedList实现"></a>LinkedList实现</h2><h3 id="底层存储"><a href="#底层存储" class="headerlink" title="底层存储"></a>底层存储</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;  <span class="comment">//元素数量</span></div><div class="line"></div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">//链表的头结点</span></div><div class="line"></div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; last; <span class="comment">//链表的尾结点</span></div></pre></td></tr></table></figure>
<p>Node表示链表的节点对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    E item; <span class="comment">//当前存储元素</span></div><div class="line">    Node&lt;E&gt; next; <span class="comment">//下一个元素节点</span></div><div class="line">    Node&lt;E&gt; prev; <span class="comment">//上一个元素节点</span></div><div class="line"></div><div class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</div><div class="line">        <span class="keyword">this</span>.item = element;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">        <span class="keyword">this</span>.prev = prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Node是LinkedList的内部类，其中定义了当前存储的元素，以及该元素的上一个元素和下一个元素。</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">* 构造一个空链表</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>();</div><div class="line">	addAll(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="add-1"><a href="#add-1" class="headerlink" title="add()"></a>add()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//添加到链表末尾</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">	linkLast(e);</div><div class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//在指定位置添加元素</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">	checkPositionIndex(index);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (index == size)</div><div class="line">		linkLast(element);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		linkBefore(element, node(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="addAll-1"><a href="#addAll-1" class="headerlink" title="addAll()"></a>addAll()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//添加一个集合</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> addAll(size, c);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//在指定位置添加一个集合</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">	checkPositionIndex(index);</div><div class="line"></div><div class="line">	Object[] a = c.toArray();</div><div class="line">	<span class="keyword">int</span> numNew = a.length;</div><div class="line">	<span class="keyword">if</span> (numNew == <span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">	Node&lt;E&gt; pred, succ;</div><div class="line">	<span class="keyword">if</span> (index == size) &#123;</div><div class="line">		succ = <span class="keyword">null</span>;</div><div class="line">		pred = last;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		succ = node(index);</div><div class="line">		pred = succ.prev;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (Object o : a) &#123;</div><div class="line">		<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</div><div class="line">		Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</div><div class="line">		<span class="keyword">if</span> (pred == <span class="keyword">null</span>)</div><div class="line">			first = newNode;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			pred.next = newNode;</div><div class="line">		pred = newNode;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</div><div class="line">		last = pred;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		pred.next = succ;</div><div class="line">		succ.prev = pred;</div><div class="line">	&#125;</div><div class="line">`</div><div class="line">	size += numNew;</div><div class="line">	modCount++;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">			<span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</div><div class="line">				unlink(x);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">			<span class="keyword">if</span> (o.equals(x.item)) &#123;</div><div class="line">				unlink(x);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</div><div class="line">	<span class="comment">// assert x != null;</span></div><div class="line">	<span class="keyword">final</span> E element = x.item;</div><div class="line">	<span class="keyword">final</span> Node&lt;E&gt; next = x.next;</div><div class="line">	<span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</div><div class="line">		first = next;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		prev.next = next;</div><div class="line">		x.prev = <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</div><div class="line">		last = prev;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		next.prev = prev;</div><div class="line">		x.next = <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	x.item = <span class="keyword">null</span>;</div><div class="line">	size--;</div><div class="line">	modCount++;</div><div class="line">	<span class="keyword">return</span> element;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">	checkElementIndex(index);</div><div class="line">	<span class="comment">//查找index对应的节点</span></div><div class="line">	Node&lt;E&gt; x = node(index);</div><div class="line">	E oldVal = x.item;</div><div class="line">	<span class="comment">//替换旧元素</span></div><div class="line">	x.item = element;</div><div class="line">	<span class="keyword">return</span> oldVal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">	checkElementIndex(index);</div><div class="line">	<span class="keyword">return</span> node(index).item;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">	<span class="comment">// assert isElementIndex(index);</span></div><div class="line"></div><div class="line">	<span class="comment">// 二分法</span></div><div class="line">	<span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">		Node&lt;E&gt; x = first;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</div><div class="line">			x = x.next;</div><div class="line">		<span class="keyword">return</span> x;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		Node&lt;E&gt; x = last;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</div><div class="line">			x = x.prev;</div><div class="line">		<span class="keyword">return</span> x;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基于双向循环链表实现的LinkedList，通过索引Index的操作时低效的，index所对应的元素越靠近中间所费时间越长。而向链表两端插入和删除元素则是非常高效的（如果不是两端的话，都需要对链表进行遍历查找）。</p>
<h1 id="ArrayList-vs-LinkedList"><a href="#ArrayList-vs-LinkedList" class="headerlink" title="ArrayList vs LinkedList"></a>ArrayList vs LinkedList</h1><ul>
<li>ArrayList底层实现是数组，LinkedList实现是链表</li>
<li>ArrayList的查找效率高于LinkedList</li>
<li>LinkedList的增删效率高于ArrayList</li>
</ul>
<p>ArrayList操作：</p>
<ul>
<li>查询操作的时间复杂度是O(1)</li>
<li>增删操作的时间复杂度是O(n)</li>
</ul>
<p>LinkedList：</p>
<ul>
<li>查询操作的时间复杂度是O(n)</li>
<li>增删操作的时间复杂度是O(1)</li>
</ul>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="ArrayList的大小是如何自动增加的？"><a href="#ArrayList的大小是如何自动增加的？" class="headerlink" title="ArrayList的大小是如何自动增加的？"></a>ArrayList的大小是如何自动增加的？</h2><p>当我们试图在ArrayList中增加一个对象时，首先会检查ArrayList的容量，已确保已存在的数组中有足够的容量来存储新的对象。如果没有足够容量的话，就会新建一个长度更长的数组（长度是原数组长度的1.5倍），然后使用Arrays.copyOf()方法将旧的数组赋值到新的数组中去，并将现有的数组引用指向新的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </div><div class="line">    ensureCapacity(size + <span class="number">1</span>);   </div><div class="line">    elementData[size++] = e;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">	modCount++;</div><div class="line"></div><div class="line">	<span class="comment">//判断是否大于当前容量</span></div><div class="line">	<span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">		grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">	<span class="comment">//</span></div><div class="line">	<span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">	<span class="comment">//扩展容量为当前容量的一半</span></div><div class="line">	<span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">	</div><div class="line">	<span class="comment">//新容量小于最小容量要求</span></div><div class="line">	<span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">		newCapacity = minCapacity;</div><div class="line">	<span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">		newCapacity = hugeCapacity(minCapacity);</div><div class="line">	<span class="comment">//返回一个新的数组对象，包括原数组中的内容</span></div><div class="line">	elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="什么情况下使用ArrayList？什么情况下使用LinkedList？"><a href="#什么情况下使用ArrayList？什么情况下使用LinkedList？" class="headerlink" title="什么情况下使用ArrayList？什么情况下使用LinkedList？"></a>什么情况下使用ArrayList？什么情况下使用LinkedList？</h2><p>多数情况下，当你遇到访问元素比插入或删除元素操作更频繁的时候，你应该使用ArrayList。当你遇到插入或者删除元素操作更加频繁，或者根本不需要访问元素的时候，你应该使用LinkedList。主要原因在于，在ArrayList中访问元素的最糟糕的时间复杂度为1，而在LinkedList中可能就是n；在LinkedList中插入和删除的时间复杂度为1，而在ArrayList中可能就是n。</p>
<h2 id="当传递ArrayList到某个方法中，或者某个方法返回ArrayList，什么时候要考虑安全隐患？如何修护安全违规这个问题？"><a href="#当传递ArrayList到某个方法中，或者某个方法返回ArrayList，什么时候要考虑安全隐患？如何修护安全违规这个问题？" class="headerlink" title="当传递ArrayList到某个方法中，或者某个方法返回ArrayList，什么时候要考虑安全隐患？如何修护安全违规这个问题？"></a>当传递ArrayList到某个方法中，或者某个方法返回ArrayList，什么时候要考虑安全隐患？如何修护安全违规这个问题？</h2><p>当ArrayList被当做参数传递到某个方法中，如果ArrayList在没有被复制的情况下直接被分配给成员变量，那么久可能发生这种情况，即当原始的ArrayList被改变时，传递到这个方法的数组也会改变。下面来看看实例：</p>
<p>安全隐患的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; mList;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">			list.add(<span class="string">"liu"</span> + i);</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">		setList(list);</div><div class="line">		</div><div class="line">		<span class="comment">//改变成员变量</span></div><div class="line">		mList.set(<span class="number">0</span>, <span class="string">"lee"</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(String str : mList) &#123;</div><div class="line">			System.out.println(<span class="string">"mList: "</span>+str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(String str : list) &#123;</div><div class="line">			System.out.println(<span class="string">"list: "</span> + str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(list == mList);</div><div class="line">		</div><div class="line">		<span class="comment">//改变原数组</span></div><div class="line">		list.set(<span class="number">0</span>, <span class="string">"Zhang"</span>);</div><div class="line">		<span class="keyword">for</span>(String str : mList) &#123;</div><div class="line">			System.out.println(<span class="string">"mList: "</span>+str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(String str : list) &#123;</div><div class="line">			System.out.println(<span class="string">"list: "</span> + str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(list == mList);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</div><div class="line">		mList = list;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">结果打印:</div><div class="line"></div><div class="line">mList: lee</div><div class="line">mList: liu1</div><div class="line">mList: liu2</div><div class="line">list: lee</div><div class="line">list: liu1</div><div class="line">list: liu2</div><div class="line"><span class="keyword">true</span></div><div class="line">mList: Zhang</div><div class="line">mList: liu1</div><div class="line">mList: liu2</div><div class="line">list: Zhang</div><div class="line">list: liu1</div><div class="line">list: liu2</div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>
<p>从结果可以看出，原数组和成员变量数组同时发送改变，这是因为在setList()方法中是将数组的引用赋值给了成员变量。</p>
<p>修复安全隐患后的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; mList;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">			list.add(<span class="string">"liu"</span> + i);</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">		setList(list);</div><div class="line">		</div><div class="line">		<span class="comment">//改变成员变量</span></div><div class="line">		mList.set(<span class="number">0</span>, <span class="string">"lee"</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(String str : mList) &#123;</div><div class="line">			System.out.println(<span class="string">"mList: "</span>+str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(String str : list) &#123;</div><div class="line">			System.out.println(<span class="string">"list: "</span> + str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(list == mList);</div><div class="line">		</div><div class="line">		<span class="comment">//改变原数组</span></div><div class="line">		list.set(<span class="number">0</span>, <span class="string">"Zhang"</span>);</div><div class="line">		<span class="keyword">for</span>(String str : mList) &#123;</div><div class="line">			System.out.println(<span class="string">"mList: "</span>+str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(String str : list) &#123;</div><div class="line">			System.out.println(<span class="string">"list: "</span> + str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(list == mList);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</div><div class="line">			mList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">//创建新的对象,并复制个mList</span></div><div class="line">			mList = <span class="keyword">new</span> ArrayList&lt;String&gt;(list);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">打印:</div><div class="line"></div><div class="line">mList: lee</div><div class="line">mList: liu1</div><div class="line">mList: liu2</div><div class="line">list: liu0</div><div class="line">list: liu1</div><div class="line">list: liu2</div><div class="line"><span class="keyword">false</span></div><div class="line">mList: lee</div><div class="line">mList: liu1</div><div class="line">mList: liu2</div><div class="line">list: Zhang</div><div class="line">list: liu1</div><div class="line">list: liu2</div><div class="line"><span class="keyword">false</span></div></pre></td></tr></table></figure>
<p>从结果可以看出，现在原数组和成员变量mList相互独立，改变自己的同时不会改变对方的数组内容。</p>
<blockquote>
<p>数组[]也是如此</p>
</blockquote>
<h2 id="如何复制一个ArrayList到另一个ArrayList中去"><a href="#如何复制一个ArrayList到另一个ArrayList中去" class="headerlink" title="如何复制一个ArrayList到另一个ArrayList中去?"></a>如何复制一个ArrayList到另一个ArrayList中去?</h2><ol>
<li>使用clone()方法，</li>
<li>使用ArrayList构造方法，</li>
<li>使用Collection的copy方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</div><div class="line">	</div><div class="line">	</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">			list.add(<span class="string">"liu"</span> + i);</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">		</div><div class="line">		<span class="comment">//clone()</span></div><div class="line">		ArrayList&lt;String&gt; list1 = (ArrayList&lt;String&gt;) list.clone();</div><div class="line">		</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(String str : list1) &#123;</div><div class="line">			System.out.println(<span class="string">"list1: "</span>+str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(list1 == list);</div><div class="line">		</div><div class="line">		<span class="comment">//构造方法</span></div><div class="line">		ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;(list);</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(String str : list2) &#123;</div><div class="line">			System.out.println(<span class="string">"list2: "</span>+str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(list2 == list);</div><div class="line">		</div><div class="line">		<span class="comment">//</span></div><div class="line">		ArrayList&lt;String&gt; list3 = <span class="keyword">new</span> ArrayList&lt;String&gt;(list.size());</div><div class="line">		list3.add(<span class="string">"1"</span>);</div><div class="line">		list3.add(<span class="string">"2"</span>);</div><div class="line">		list3.add(<span class="string">"3"</span>);</div><div class="line">		</div><div class="line">		Collections.copy(list3, list);</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(String str : list3) &#123;</div><div class="line">			System.out.println(<span class="string">"list3: "</span>+str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(list3 == list);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">结果打印：</div><div class="line"></div><div class="line">list1: liu0</div><div class="line">list1: liu1</div><div class="line">list1: liu2</div><div class="line"><span class="keyword">false</span></div><div class="line">list2: liu0</div><div class="line">list2: liu1</div><div class="line">list2: liu2</div><div class="line"><span class="keyword">false</span></div><div class="line">list3: liu0</div><div class="line">list3: liu1</div><div class="line">list3: liu2</div><div class="line"><span class="keyword">false</span></div></pre></td></tr></table></figure>
<h2 id="在索引中ArrayList的增加或者删除某个对象的运行过程？效率很低吗？解释一下为什么？"><a href="#在索引中ArrayList的增加或者删除某个对象的运行过程？效率很低吗？解释一下为什么？" class="headerlink" title="在索引中ArrayList的增加或者删除某个对象的运行过程？效率很低吗？解释一下为什么？"></a>在索引中ArrayList的增加或者删除某个对象的运行过程？效率很低吗？解释一下为什么？</h2><p>在ArrayList中增加或删除元素的时候要调用System.arrayCopy()这个数值拷贝函数，每次增加或删除元素都要进行数组的拷贝操作，相对效率较低。如果遇到频繁插入或删除操作的时候，可以考虑使用LinkedList来代替。</p>
<p>在ArrayList的某个索引i处添加元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    rangeCheckForAdd(index);</div><div class="line"></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</div><div class="line">                     size - index);</div><div class="line">    elementData[index] = element;</div><div class="line">    size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在ArrayList的某个索引i处删除元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2015/12/18/Java集合之ArrayList和LinkedList/" data-id="cj6esnzf5007gwg197n3nu3zx" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2015/12/18/Java集合之ArrayList和LinkedList/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Collection/">Collection</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Java集合之Arrays和Collections" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/18/Java集合之Arrays和Collections/" class="article-date">
  <time datetime="2015-12-18T13:22:21.000Z" itemprop="datePublished">2015-12-18 21:22:21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/18/Java集合之Arrays和Collections/">Java集合之Arrays和Collections</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h1><p>java.util.Arrays</p>
<p><a href="http://www.apihome.cn/api/java/Arrays.html" target="_blank" rel="external">Arrays详细介绍</a></p>
<p>Array是Java特有的数组。在你知道所要处理数据元素个数的情况下非常好用。java.util.Arrays 包含了许多处理数据的实用方法：</p>
<p>Arrays.asList：可以从 Array 转换成 List。可以作为其他集合类型构造器的参数。</p>
<p>Arrays.binarySearch：在一个已排序的或者其中一段中快速查找。</p>
<p>Arrays.copyOf：如果你想扩大数组容量又不想改变它的内容的时候可以使用这个方法。</p>
<p>Arrays.copyOfRange：可以复制整个数组或其中的一部分。</p>
<p>Arrays.deepEquals、Arrays.deepHashCode：Arrays.equals/hashCode的高级版本，支持子数组的操作。</p>
<p>Arrays.equals：如果你想要比较两个数组是否相等，应该调用这个方法而不是数组对象中的 equals方法（数组对象中没有重写equals()方法，所以这个方法之比较引用而不比较内容）。这个方法集合了Java 5的自动装箱和无参变量的特性，来实现将一个变量快速地传给 equals() 方法——所以这个方法在比较了对象的类型之后是直接传值进去比较的。</p>
<p>Arrays.fill：用一个给定的值填充整个数组或其中的一部分。</p>
<p>Arrays.hashCode：用来根据数组的内容计算其哈希值（数组对象的hashCode()不可用）。这个方法集合了Java 5的自动装箱和无参变量的特性，来实现将一个变量快速地传给 Arrays.hashcode方法——只是传值进去，不是对象。</p>
<p>Arrays.sort：对整个数组或者数组的一部分进行排序。也可以使用此方法用给定的比较器对对象数组进行排序。</p>
<p>Arrays.toString：打印数组的内容。</p>
<p>如果想要复制整个数组或其中一部分到另一个数组，可以调用 System.arraycopy方法。此方法从源数组中指定的位置复制指定个数的元素到目标数组里。这无疑是一个简便的方法。（有时候用 ByteBuffer bulk复制会更快。可以参考这篇文章）.</p>
<p>最后，所有的集合都可以用T[] Collection.toArray( T[] a ) 这个方法复制到数组中。通常会用这样的方式调用：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">return</span> coll.toArray( <span class="keyword">new</span> T[ coll.<span class="built_in">size</span>() ] );</div></pre></td></tr></table></figure></p>
<p>这个方法会分配足够大的数组来储存所有的集合，这样 toArray 在返回值时就不必再分配空间了。</p>
<h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><p>java.util.Collections</p>
<p><a href="http://www.apihome.cn/api/java/Collections.html" target="_blank" rel="external">Collections详细介绍</a></p>
<p>就像有专门的java.util.Arrays来处理数组，Java中对集合也有java.util.Collections来处理。</p>
<p>第一组方法主要返回集合的各种数据：</p>
<p>Collections.checkedCollection / checkedList / checkedMap / checkedSet / checkedSortedMap / checkedSortedSet：检查要添加的元素的类型并返回结果。任何尝试添加非法类型的变量都会抛出一个ClassCastException异常。这个功能可以防止在运行的时候出错。//fixme</p>
<p>Collections.emptyList / emptyMap / emptySet ：返回一个固定的空集合，不能添加任何元素。</p>
<p>Collections.singleton / singletonList / singletonMap：返回一个只有一个入口的 set/list/map 集合。</p>
<p>Collections.synchronizedCollection / synchronizedList / synchronizedMap / synchronizedSet / synchronizedSortedMap / synchronizedSortedSet：获得集合的线程安全版本（多线程操作时开销低但不高效，而且不支持类似put或update这样的复合操作）</p>
<p>Collections.unmodifiableCollection / unmodifiableList / unmodifiableMap / unmodifiableSet / unmodifiableSortedMap / unmodifiableSortedSet：返回一个不可变的集合。当一个不可变对象中包含集合的时候，可以使用此方法。</p>
<p>第二组方法中，其中有一些方法因为某些原因没有加入到集合中：</p>
<p>Collections.addAll：添加一些元素或者一个数组的内容到集合中。</p>
<p>Collections.binarySearch：和数组的Arrays.binarySearch功能相同。</p>
<p>Collections.disjoint：检查两个集合是不是没有相同的元素。</p>
<p>Collections.fill：用一个指定的值代替集合中的所有元素。</p>
<p>Collections.frequency：集合中有多少元素是和给定元素相同的。</p>
<p>Collections.indexOfSubList / lastIndexOfSubList：和String.indexOf(String) / lastIndexOf(String)方法类似——找出给定的List中第一个出现或者最后一个出现的子表。</p>
<p>Collections.max / min：找出基于自然顺序或者比较器排序的集合中，最大的或者最小的元素。</p>
<p>Collections.replaceAll：将集合中的某一元素替换成另一个元素。</p>
<p>Collections.reverse：颠倒排列元素在集合中的顺序。如果你要在排序之后使用这个方法的话，在列表排序时，最好使用Collections.reverseOrder比较器。</p>
<p>Collections.rotate：根据给定的距离旋转元素。</p>
<p>Collections.shuffle：随机排放List集合中的节点，可以给定你自己的生成器——例如java.util.Random / java.util.ThreadLocalRandom or java.security.SecureRandom。</p>
<p>Collections.sort：将集合按照自然顺序或者给定的顺序排序。</p>
<p>Collections.swap：交换集合中两个元素的位置（多数开发者都是自己实现这个操作的）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2015/12/18/Java集合之Arrays和Collections/" data-id="cj6esnzf3007cwg19fd5ptuwv" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2015/12/18/Java集合之Arrays和Collections/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Collection/">Collection</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Java集合框架简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/18/Java集合框架简介/" class="article-date">
  <time datetime="2015-12-18T13:20:21.000Z" itemprop="datePublished">2015-12-18 21:20:21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/18/Java集合框架简介/">Java集合框架简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>Java集合代表了一组对象。Java中的集合框架定义了一套规范，用来表示、操作集合，使具体操作与实现细节解耦。</p>
<h1 id="两大基类Collection与Map"><a href="#两大基类Collection与Map" class="headerlink" title="两大基类Collection与Map"></a>两大基类Collection与Map</h1><p>在集合框架的类继承体系中，最顶层有两个接口：</p>
<ul>
<li>Collection表示一组纯数据</li>
<li>Map表示一组key-value键值对</li>
</ul>
<p>一般继承自Collection或Map的集合类，会提供两个标准的构造函数：</p>
<ul>
<li>没有参数的构造函数，创建一个空的集合类，如ArrayList()</li>
<li>有一个类型与基类（Collection或Map）相同的构造函数，创建一个与给定参数具有相同元素的新集合类，如ArrayList(Collection&lt;? extends E&gt; c)</li>
</ul>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>先看看常用的Collection集合类</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/Collection.png" alt="Collection"></p>
<p>Collection类主要有三个接口：</p>
<ul>
<li>Set表示不允许有重复元素的集合</li>
<li>List表示允许有重复元素的集合</li>
<li>Queue主要用于存储数据而不是处理数据</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>下图为常用的Map集合类</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/Map.png" alt="Map"></p>
<p>Map并不是一个真正意义上的集合，但是这个接口提供了三种“集合视角”，使得可以像操作集合一样操作他们。具体如下：</p>
<ul>
<li>把Map的内容看成key的集合</li>
<li>把Map的内容看成value的集合</li>
<li>把Map的内容看成key-value映射的集合</li>
</ul>
<h1 id="Java集合与数据结构"><a href="#Java集合与数据结构" class="headerlink" title="Java集合与数据结构"></a>Java集合与数据结构</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>特点：可以随机访问，查询效率较高，增删效率较低、内存固定</p>
<p>Java集合：ArrayList、Vector</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>特点：插入和删除效率高，查询效率低</p>
<p>Java集合：LinkedList、LinkedHashMap、LinkedHashSet</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>特点：查找效率高，插入和删除较快，内存固定，存在散列冲突。</p>
<p>Java集合：HashMap、HashSet、HashTable、LinkedHashMap、LinkedHashSet</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>特点：插入、删除效率高，对最大项、最小项存储快，其他项存取较慢。</p>
<p>Java集合：PriorityQueue（二叉堆实现的优先队列）</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>特点：先进后出（FILO）</p>
<p>Java集合：Stack</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>特点：先进先出（FIFO）</p>
<p>Java集合：ArrayDeque（双端队列）、LinkedList（双端队列）</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>特点：查询、删除、插入都比较快，但算法复杂</p>
<p>Java集合：TreeMap（红黑树）、TreeSet（红黑树）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2015/12/18/Java集合框架简介/" data-id="cj6esnzfk008bwg19qayvjdf1" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2015/12/18/Java集合框架简介/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Collection/">Collection</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Http协议详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/18/Http协议详解/" class="article-date">
  <time datetime="2015-12-18T13:08:05.000Z" itemprop="datePublished">2015-12-18 21:08:05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络通信/">网络通信</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/18/Http协议详解/">Http协议详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>HTTP是一种应用层协议，它通过TCP实现了可靠的数据传输，能够保证数据的完整性、正确性，而TCP对于数据传输控制的优点也能够体现在HTTP上，使得HTTP的数据传输吞吐量、效率得到保证。</p>
<p>对于移动开发来说，网络应用基本上都是C/S架构，也就是客户端/服务器架构。客户端通过向服务器发起特定的请求，服务器返回结果，客户端解析结果，再将结果展示在UI上。客户端与服务器的交互如下所示：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/http-%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E4%BA%A4%E4%BA%92.png" alt=""></p>
<p>详细的交互流程有如下几步：</p>
<ol>
<li>客户端执行网络请求，从URL解析出服务器的主机名。</li>
<li>将服务器的主机名转换成服务器的IP地址。</li>
<li>将端口号从URL中解析出来</li>
<li>建立一条客户端与Web服务器的TCP连接；</li>
<li>客户端通过输出流向服务器发送一条HTTP请求；</li>
<li>服务器向客户端返回一条HTTP响应报文；</li>
<li>客户端从输入流获取报文；</li>
<li>客户端解析报文，关闭连接；</li>
<li>客户端将结果显示在UI上；</li>
</ol>
<h1 id="HTTP请求方式"><a href="#HTTP请求方式" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h1><p>HTTP提供了几种请求方式，每种请求方式都有不同的作用。被大家熟知的请求方式有7种GET、POST、DELETE、PUT、HEAD、TRACE、OPTIONS。其中PUT、DELETE、POST、GET分别对应着增、删、该、查4个操作，也是客户端运用最多的4个请求。</p>
<h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><p>GET的作用是获取服务器的某个资源。下图提供一个例子，客户端用GET方法发起一次HTTP请求，然后服务端将对应的资源返回客户端。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/http-Get%E8%AF%B7%E6%B1%82.png" alt=""></p>
<p>需要注意的是：GET请求的参数都需要放到请求的URL中，第一个参数之前有一个？，参数的格式为：参数名=参数值。参数之间通过“&amp;”连接。</p>
<h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><p>POST起初是用来向服务器传递数据的。POST请求通常会用来提交HTML的表单。表单中填好的数据会被传输给服务器，然后由服务器对这些数据进行处理。下图显示一个用POST请求的执行流程。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/http-POST%E8%AF%B7%E6%B1%82.png" alt=""></p>
<h2 id="PUT请求"><a href="#PUT请求" class="headerlink" title="PUT请求"></a>PUT请求</h2><p>与GET从服务器读取资源相反，PUT方法会向服务器写入资源。有些发布系统允许用户创建Web页面，并用PUT直接将其传输到Web服务器上。如下图所示：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/http-PUT%E8%AF%B7%E6%B1%82.png" alt=""></p>
<p>PUT方法的语义就是让服务器用请求的主题部分来创建一个由所请求的URL命名的新文档，如果那个URL已经存在的话，就用这个资源来替代它。</p>
<h2 id="DELETE请求"><a href="#DELETE请求" class="headerlink" title="DELETE请求"></a>DELETE请求</h2><p>DELETE方法所做的事情就是请服务器删除请求URL所指定的资源。但是，客户端无法保证删除操作一定会被执行。因为，HTTP规范允许服务器在不通知客户端的情况下撤销请求。</p>
<p>DELETE方式与GET请求一样，参数都需要放在请求的URL中。下图显示了一个DELETE方法实例。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/http-DELETE%E8%AF%B7%E6%B1%82.png" alt=""></p>
<h2 id="HEAD请求"><a href="#HEAD请求" class="headerlink" title="HEAD请求"></a>HEAD请求</h2><p>HEAD方法与GET方法的行为很类似，但服务器在响应中只返回首部。不会返回实体的主体部分，这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查。使用HEAD可以在不获取资源的情况下了解资源的情况（比如，判断其类型）；通过查看响应中的状态码，看看某个对象是否存在；通过查看首部，测试资源是否被修改了。服务器开发者必须确保返回的首部与GET请求所返回的首部完全相同。遵循HTTP/1.1规范，就必须实现HEAD方法。如下图所示：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/http-HEAD%E8%AF%B7%E6%B1%82.png" alt=""></p>
<h2 id="TRACE请求"><a href="#TRACE请求" class="headerlink" title="TRACE请求"></a>TRACE请求</h2><p>客户端发起一个请求时，这个请求可能要穿越防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的HTTP请求。TRACE方法运行客户端在最终将请求发送给服务器时，看看它变成了什么样子。</p>
<p>TRACE请求会在目的服务端发起一个“环回”诊断。行程最后一站的服务器会弹回一条TRACE响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间HTTP应用程序组成的请求/响应链上，原始报文是否以及如何被毁坏或修改过，如下图所示。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/http-TRACE%E8%AF%B7%E6%B1%82.png" alt=""></p>
<p>TRACE方法主要用于诊断，也就是说，用于验证请求是否如愿穿过了请求/响应链。</p>
<h2 id="OPTIONS请求"><a href="#OPTIONS请求" class="headerlink" title="OPTIONS请求"></a>OPTIONS请求</h2><p>OPTIONS方法请求Web服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法（有些服务器可能只支持对一种特殊类型的对象使用特定的操作）这为客户端应用程序提供了一种手段，使其不用实际访问那些资源就能判定访问各种资源最优方式）。如下图所示：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/http-OPTIONS%E8%AF%B7%E6%B1%82.png" alt=""></p>
<h1 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h1><h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p>通常一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成。下图为请求报文的一般格式。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/http-%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.jpg" alt=""></p>
<ul>
<li><strong>起始行</strong></li>
</ul>
<p>报文的第一行就是起始行，在请求报文中用来说明要以说明方式做什么请求，而在响应报文中初略说明了报文的执行结果。</p>
<ul>
<li><strong>首部字段</strong></li>
</ul>
<p>起始行后面有零个或多个首部字段。每个首部字段都包含一个名字和一个值，为了便于解析，两者之间用冒号（如Connection：keep-Alive）来分隔。首部以一个空行结束。添加一个首部字段和添加新行一样简单。</p>
<ul>
<li><strong>主体</strong></li>
</ul>
<p>首部字段的空行之后就是可选的报文主体了，其中包含了所以类型的数据。请求主体中包括了要发送给Web服务器的数据；响应主体中装载了要返回给客户端的数据。起始行和首部都是结构化的文本形式，而主体则可以包含任意的二进制数据（如图片、视频、音轨、软件程序）。当然，主体中也可以包含文本。</p>
<h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p>HTTP响应也由3个部分组成，分别是：状态行、消息报头、响应正文。如下所示，HTTP响应的格式与请求的格式十分类似：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">状态行</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">响应报文header</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">空行</span>&gt;</span></div><div class="line">[响应报文内容]</div></pre></td></tr></table></figure>
<p>在响应报文中第一行用状态信息代替了请求信息。状态行通过提供一个状态码来说明所请求的资源情况。<br>状态行格式：<br>  HTTP-Version Status-Code Reason-Phrase CRLF</p>
<p>HTTP-Version表示服务器HTTP协议的版本；<br>Status-Code表示服务器发回的响应状态代码；<br>Reason-Phrase表示状态代码的文本描述；</p>
<p>状态码由三位数字组成，第一个数字定义了响应的类别，且有5中可能取值。</p>
<table>
<thead>
<tr>
<th>取值范围</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>100~199</td>
<td>指示信息。表示请求已接收，继续处理</td>
</tr>
<tr>
<td>200~299</td>
<td>请求成功。表示请求已被成功接收理解</td>
</tr>
<tr>
<td>300~399</td>
<td>重定向。要完成请求必须进行更进一步的操作</td>
</tr>
<tr>
<td>400~499</td>
<td>客户端错误。请求有语法错误或请求无法实现</td>
</tr>
<tr>
<td>500~599</td>
<td>服务器端错误。服务器未能实现合法的请求</td>
</tr>
</tbody>
</table>
<p>常见状态代码、状态描述的说明如下：</p>
<ul>
<li>200 OK:客户端请求成功</li>
<li>202 Accepted 服务器已接收请求，但尚未处理。</li>
<li>400 Bad Request：客户端请求有语法错误，不能被服务器所理解</li>
<li>401 Unauthorized：请求未授权，这个状态码必须和WWW-Authenticate报头域一起使用。</li>
<li>403 Forbidden：服务器收到请求，但是拒绝提供服务。</li>
<li>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。</li>
<li>408 Request Timeout 请求超时</li>
<li>500 Internal Server Error：服务器发生不可预期的错误。</li>
<li>502 Bad Gateway 错误的网关</li>
<li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK</li>
<li>504 网关超时</li>
</ul>
<p>下面是一个GET去请求的Response返回示例：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</div><div class="line"><span class="symbol">Date:</span>Sat, <span class="number">31</span> Dec <span class="number">2005</span> <span class="number">23</span>:<span class="number">59</span>:<span class="number">59</span> GMT</div><div class="line">Content-Type: text/html;charset=utf<span class="number">-8</span></div><div class="line">Content-Length: <span class="number">122</span></div><div class="line"></div><div class="line"><span class="params">&lt;html&gt;</span></div><div class="line">	<span class="params">&lt;head&gt;</span></div><div class="line">		<span class="params">&lt;title&gt;</span>开发技术前线<span class="params">&lt;/title&gt;</span></div><div class="line">	<span class="params">&lt;/head&gt;</span></div><div class="line">	</div><div class="line">	<span class="params">&lt;body&gt;</span></div><div class="line">	<span class="params">&lt;/body&gt;</span></div><div class="line"><span class="params">&lt;/html&gt;</span></div></pre></td></tr></table></figure>
<h2 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h2><p>请求头部由键值对组成，每行一对，关键字和值用英文冒号“：”分隔。HTTP规范定义了几种首部字段，应用程序也可以随意发明自己所用的头部。HTTP首部可以分为以下几类，如表所示：</p>
<table>
<thead>
<tr>
<th>首部类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>通用首部</td>
<td>既可以出现在请求报文中，也可以出现在响应报文中</td>
</tr>
<tr>
<td>请求首部</td>
<td>提供更多有关请求的信息</td>
</tr>
<tr>
<td>响应首部</td>
<td>提供更多有关响应的信息</td>
</tr>
<tr>
<td>实体首部</td>
<td>描述主体的长度和内容，或者资源自身</td>
</tr>
<tr>
<td>扩展首部</td>
<td>HTTP规范中没有定义的新首部</td>
</tr>
</tbody>
</table>
<p>请求头部通知服务器关于客户端请求的信息，典型的请求头有。</p>
<ul>
<li>Content-Type：请求数据的格式</li>
<li>Content-Length：消息长度</li>
<li>Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机</li>
<li>User-Agent：发出请求的浏览器类型，可以自行设置</li>
<li>Accept：客户端可识别的内容类型列表</li>
<li>Accept-Encoding：客户端可识别的数据编码</li>
<li>Connection：允许客户端和服务器指定与请求/响应连接有关的选项，例如设置为Keep-Alive则表示保持连接</li>
<li>Transfer-Encoding：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2015/12/18/Http协议详解/" data-id="cj6esnzdm004kwg19fjm1rtra" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2015/12/18/Http协议详解/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络通信/">网络通信</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-TCP-IP5TCP协议详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/17/TCP-IP5TCP协议详解/" class="article-date">
  <time datetime="2015-12-17T13:08:05.000Z" itemprop="datePublished">2015-12-17 21:08:05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络通信/">网络通信</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/17/TCP-IP5TCP协议详解/">TCP/IP（五）TCP协议详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>TCP协议是面向有连接的协议，它具有丢包重发和流量控制的功能，这是它区别UDP协议最大的特点。</p>
<h1 id="数据包重发"><a href="#数据包重发" class="headerlink" title="数据包重发"></a>数据包重发</h1><h2 id="数据发送"><a href="#数据发送" class="headerlink" title="数据发送"></a>数据发送</h2><p>丢包重发的前提是发送方能够知道接收方是否成功的接收了消息。所以，在TCP协议中，接收端会给发送端返回一个消息，也叫确认应答（ACK），这表示接收方已经收到了数据包。</p>
<p>根据上一节对TCP首部的分析得知：ACK的值和下次发送数据包的序列号相等。因此ACK也可以理解为：“发送方，下次你从这个位置开始发送！“。下图表示了数据发送与确认应答的过程：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/tcp_ack%E7%A1%AE%E8%AE%A4.png" alt=""></p>
<p>由于各种原因，数据包和ACK应答包都有可能丢失，在这种情况下，发送方如果在一段时间内没有收到ACK，就会重发数据：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/tcp_%E9%87%8D%E5%8F%91%E6%95%B0%E6%8D%AE.png" alt=""></p>
<p>即使网络正常，由于延迟的存在，接收方也有可能收到重复的数据包，因此接收方通过TCP首部中的SYN判断这个数据包是否曾经接收过。如果已经接收，就会丢弃该数据包。</p>
<h2 id="重传超时时间（RTO）"><a href="#重传超时时间（RTO）" class="headerlink" title="重传超时时间（RTO）"></a>重传超时时间（RTO）</h2><p>如果发送方等待一段时间后，还是没有收到 ACK 确认，就会启动超时重传。这个等待的时间被称为重传超时时间(RTO，Retransmission TimeOut)。RTO 的值具体是多久呢？</p>
<p>首先，RTO 的值不是固定的，它是一个动态变化的时间。这个时间总是略大于连接往返时间（RTT，Round Trip Time）。这个设定可以这样理解：“数据发送给对方，再返回到我这里，假设需要 10 秒，那我就等待 12秒，如果超过 12 秒，那估计就是回不来了。”</p>
<p>RTT 是动态变化的，因为谁也不知道网络下一时刻是否拥堵。而当前的 RTO 需要根据未来的 RTT 估算得出。RTO 不能估算太大，否则会多等待太多时间；也不能太小，否则会因为网络突然变慢而将不该重传的数据进行重传。</p>
<h2 id="TCP窗口"><a href="#TCP窗口" class="headerlink" title="TCP窗口"></a>TCP窗口</h2><p>按照之前的理论，在数据包发出后，直至 ACK 确认返回以前，发送端都无法发送数据，而且包的往返时间越长，网络利用效率和通信性能就越低。前两张图片形象的解释了这一点。</p>
<p>为了解决这个问题，TCP 使用了“窗口”这个概念。窗口具有大小，它表示无需等待确认应答就可以继续发送数据包的最大数量。比如窗口大小为 4 时，数据发送的示意图如下：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/tcp_%E7%AA%97%E5%8F%A3.png" alt=""></p>
<p>不等确认就连续发送若干个数据包会不会有问题呢？我们首先来看数据包丢失问题。</p>
<p>我们知道 TCP 首部中的 ACK 字段表示接收方已经收到数据的最后位置。因此，接收方成功接收到了 1-1000 字节的数据后，它会发送一个 ACK = 1001 的确认包。假设 1001-2000 字节的数据包丢失了，由于窗口长度比较大，发送方会继续发送 2001-3000 字节的数据包。接收端并不会返回这个数据包的确认，因为它最后收到的数据还是 1-1000 字节的数据包。</p>
<p>因此，接收端返回的数据包的 ACK 依然是 1001。这表示：“喂，发数据的，别往后发了，你第 1001 字节开始的数据还没来呢”。可以想见，发送端以后每次发送数据包得到的确认中，ACK 的值都是 1001。当连续收到三次确认之后，发送方会意识到：“对方还没有接收到数据，这个包需要重传”。</p>
<p>因此，引入窗口的概念后，被发送的数据不能立刻丢弃，需要缓存起来以备将来需要重发。</p>
<p>利用窗口发送数据的过程可以用下图表示：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/tcp_%E7%AA%97%E5%8F%A3.png" alt=""></p>
<p>果是数据包没有丢失，但是确认包丢失了呢？这就是窗口最擅长处理的问题了。假设发送发收到的确认包中的 ACK 第一次是 1001，第二次是 4001。那么我们完全可以相信中间的两个包是成功被接收的。因为如果有没接收到的包，接收方是不会增加 ACK 的。</p>
<p>在这种情况下，如果不使用窗口，发送方就需要重传第二、三个数据包，但是有了窗口的概念后，发送方就省略了两次重传。因此使用窗口实际上可以理解为“空间换时间”。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/tcp_%E6%9F%90%E4%BA%9B%E7%A1%AE%E8%AE%A4%E5%8C%85%E4%B8%A2%E5%A4%B1%E6%97%B6%E4%B8%8D%E7%94%A8%E9%87%8D%E5%8F%91.png" alt=""></p>
<h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><h2 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h2><p>如果窗口过大，会导致接收方的缓存区数据溢出。这时候本该被接收的数据反而丢弃了，就会导致无意义的重传。因此，窗口大小是一个可以改变的值，它由接收端主机控制，附加在 TCP 首部的“窗口大小”字段中。</p>
<h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p>在连接建立的初期，如果窗口比较大，发送方可能会突然发送大量数据，导致网络瘫痪。因此，在通信一开始时，TCP 会通过慢启动算法得出窗口的大小，对发送数据量进行控制。</p>
<p>流量控制是由发送方和接收方共同控制的。刚刚我们介绍了接收方会把自己能够承受的最大窗口长度写在 TCP 首部中，实际上在发送方这里，也存在流量控制，它叫拥塞窗口。TCP 协议中的窗口是指发送方窗口和接收方窗口的较小值。</p>
<p>慢启动过程如下：</p>
<ol>
<li>通信开始时，发送方的拥塞窗口大小为 1。每收到一个 ACK 确认后，拥塞窗口翻倍。</li>
<li>由于指数级增长非常快，很快地，就会出现确认包超时。</li>
<li>此时设置一个“慢启动阈值”，它的值是当前拥塞窗口大小的一半。</li>
<li>同时将拥塞窗口大小设置为 1，重新进入慢启动过程。</li>
<li>由于现在“慢启动阈值”已经存在，当拥塞窗口大小达到阈值时，不再翻倍，而是线性增加。</li>
<li>随着窗口大小不断增加，可能收到三次重复确认应答，进入“快速重发”阶段。</li>
<li>这时候，TCP 将“慢启动阈值”设置为当前拥塞窗口大小的一半，再将拥塞窗口大小设置成阈值大小（也有说加 3）。</li>
<li>拥塞窗口又会线性增加，直至下一次出现三次重复确认应答或超时。</li>
</ol>
<p>以上过程可以用下图概括：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/tcp_%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2015/12/17/TCP-IP5TCP协议详解/" data-id="cj6esnzg9009uwg1961ope0fr" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2015/12/17/TCP-IP5TCP协议详解/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络通信/">网络通信</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-TCP-IP4TCP与UDP协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/17/TCP-IP4TCP与UDP协议/" class="article-date">
  <time datetime="2015-12-17T13:07:53.000Z" itemprop="datePublished">2015-12-17 21:07:53</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络通信/">网络通信</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/17/TCP-IP4TCP与UDP协议/">TCP/IP（四）TCP与UDP协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>传输层位于OSI七层模型的第四层，传输层的主要作用是实现应用程序之间的通信。网络层主要是保证不同数据链路下数据的可达性，至于如何传输数据则是由传输层负责。</p>
<h1 id="传输层协议简介"><a href="#传输层协议简介" class="headerlink" title="传输层协议简介"></a>传输层协议简介</h1><p>常见的传输层协议主要有TCP协议和UDP协议。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP协议是面向有连接的协议，也就是说在使用TCP协议传输数据之前一定要在发送方和接收方之间建立连接。一般情况下建立连接需要三步，关闭连接需要四步。</p>
<p>建立TCP连接后，由于有数据重传、流量控制等功能，TCP协议能够正确处理丢包问题，保证接收方能够收到数据，与此同时还能够有效利用网络带宽。然而TCP协议中定义了很多复杂的规范，因此效率不如UDP协议，不适合实时的视频和音频传输。</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP协议是面向无连接的协议，它只会把数据传递给接收端，但是不保证接收端是否真正收到了数据。这种特性适合多播、实时的视频和音频传输，因为个别数据包的丢失并不会影响视频和音频的整体效果。</p>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>IP协议中的两大关键要素是源IP地址和目标IP地址。传输层新增了三个要素：源端口号、目标端口号和协议号。</p>
<p>端口号用于区分同一台主机上不同的应用程序。假设你打开了两个浏览器，浏览器A发出的请求不会被浏览器B接收，就是因为A和B具有不要的端口号。</p>
<p>协议号用于区分使用的是TCP还是UDP。</p>
<p>所以：源IP地址、目标IP地址、源端口号、目标端口号和协议号这五个信息只要有一个不同，都被认为是不同的通信。</p>
<h1 id="UDP首部"><a href="#UDP首部" class="headerlink" title="UDP首部"></a>UDP首部</h1><p>UDP协议的特点就是简单，它的首部如下图所示：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/trans-udp%E9%A6%96%E9%83%A8.png" alt="udp"></p>
<ul>
<li>包长度表示UDP首部长度和UDP数据长度之和</li>
<li>校验和用来判断数据在传输过程中是否丢失。</li>
</ul>
<h1 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h1><p>TCP首部要复杂得多。解析这个首部的时间也相应的增加，这也是导致TCP连接的效率低于UDP的原因之一。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/trans-tcp%E9%A6%96%E9%83%A8.png" alt="tcp"></p>
<p>关键字段解释如下：</p>
<ul>
<li><p>序列号：它表示发送数据的位置，假设当前的序列号为s，发送数据长度为I，则下次发送数据的序列号为S + I。在建立连接时通常由计算机生成一个随机数作为序列号的初始值。</p>
</li>
<li><p>确认应答号：它等于下一次应该接收到的数据的序列号。假设当前的序列号为s，发送数据长度为I，则接收端返回的确认应答号为S + I。发送端接收到这个确认应答后，可以认为这个位置以前所有的数据都已被正常接收。</p>
</li>
<li><p>数据偏移：TCP首部的长度，单位为4个字节。如果没有可选字段，那么这里的值就是5，表示TCP首部的长度为20字节。</p>
</li>
<li><p>控制位：长度为8bit，分别有8个控制标志，依次是CWR、ECE、URG、ACK、PSH、RST、SYN和FIN</p>
<ul>
<li>CWR</li>
<li>ECE</li>
<li>URG</li>
<li>ACK:改位为1时，确认应答的字段变为有效。TCP规定除了最初建立连接时的SYN包之外改位必须设置为1</li>
<li>PSH</li>
<li>RST</li>
<li>SYN：用于建立连接。SYN为1表示希望建立连接</li>
<li>FIN：为1时，表示希望断开连接</li>
</ul>
</li>
<li><p>窗口大小：用于表示从应答号开始能够接收多少个字节。如果窗口为0，可以发送窗口探测</p>
</li>
<li><p>紧急指针：仅仅在URG控制位为1时有效。表示紧急数据的末尾在TCP数据部分中的位置，通常在暂时中断通信时使用（比如Ctrl + C）</p>
</li>
</ul>
<h1 id="TCP握手"><a href="#TCP握手" class="headerlink" title="TCP握手"></a>TCP握手</h1><p>TCP是面向连接的协议，连接在每次通信前被建立，通信结束时被关闭。了解TCP连接建立和关闭的过程通常是考察的重点。TCP连接的建立和关闭过程可用下图表示：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/trans-tcp%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E5%85%B3%E9%97%AD.png" alt=""></p>
<h2 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h2><ol>
<li>客户端请求连接SYN</li>
<li>服务端确认客户端连接请求</li>
<li>客户端确认服务端已收到连接请求，建立连接开始通信</li>
</ol>
<h2 id="为什么是三次握手"><a href="#为什么是三次握手" class="headerlink" title="为什么是三次握手"></a>为什么是三次握手</h2><p>三次握手的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”</p>
<p>这是因为在网络请求时，我们时刻要注意“网络是不可靠的，数据包是可能丢失的”。假设没有第三次确认的情况下，客户端向服务端发送SYN，请求建立连接。由于延迟，服务端没有及时收到这个包。于是客户端重新发送一个SYN包。</p>
<p>假设服务端接收到了第二个SYN包，建立了通信，一段时间后通信结束，连接被关闭。这是最初被发送的SYN包抵达服务端，服务端又会发送一次ACK确认。由于两次握手就建立连接，此时的服务端就会建立一个新的连接，然而客户端认为没有请求建立连接，所以就不会向服务端发送数据，从而导致服务端建立一个空连接，浪费资源。</p>
<h2 id="ACK确认包丢失怎么办？"><a href="#ACK确认包丢失怎么办？" class="headerlink" title="ACK确认包丢失怎么办？"></a>ACK确认包丢失怎么办？</h2><p>三次握手其实解决了第二步的数据包丢失的问题，那么第三步的ACK确认包丢失后，TCP协议是如何处理的呢？</p>
<p>按照TCP协议处理丢包的一般方法，服务端会重新向客户端发送数据包，直至收到ACK确认为止。但实际上这种做法有可能遭到SYN泛洪攻击。泛洪攻击，是指发送方伪造多个IP地址，模拟三个握手的过程。当服务器返回ACK后，攻击方故意不确认，从而使得服务器不断重发，由于服务器长时间出于半连接状态，最后消耗过多的CPU和内存资源导致死机。</p>
<p>正确的处理方法是服务端发送RST报文，进入CLOSE状态。这个RST数据包的TCP首部中，控制位中的RST设置为1.这表示连接信息全部初始化，原有的TCP通信不能继续进行。客户端如果还想重新建立TCP连接，就必须重新开始第一次握手。</p>
<p>##　四次握手关闭连接</p>
<ol>
<li>客户端发送FIN通知服务端 客户端要关闭连接</li>
<li>服务端发送ACK确认客户端关闭连接</li>
<li>服务端发送FIN通知客户端 服务端要关闭连接</li>
<li>客户端发送ACK确认服务端关闭连接</li>
</ol>
<p>由于连接是双向的，所以双方都要主动关闭自己这一侧的连接。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2015/12/17/TCP-IP4TCP与UDP协议/" data-id="cj6esnzg8009rwg19czrcc2cd" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2015/12/17/TCP-IP4TCP与UDP协议/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络通信/">网络通信</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-TCP-IP3IP协议相关技术" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/17/TCP-IP3IP协议相关技术/" class="article-date">
  <time datetime="2015-12-17T13:06:45.000Z" itemprop="datePublished">2015-12-17 21:06:45</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络通信/">网络通信</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/17/TCP-IP3IP协议相关技术/">TCP/IP（三）IP协议相关技术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>IP协议旨在让最终目标主机收到数据包，但是在这一过程中仅仅有IP是无法实现通信的。必须还有能够解析主机名称和MAC地址的功能，以及数据包在发送过程中异常情况处理的功能。本文主要介绍作为IP的辅助和扩展规范的DNS、ARP、ICMP、NAT等协议。</p>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>全称Domain Name System，域名系统</p>
<p>IP地址用于识别通信双方的地址，但它是一串长数字，比方便记忆，人们希望主机有自己的名字，这个名字是唯一的，而且容易记住，于是诞生了“域名”的概念。域名是一种为了识别主机名称和机构名的具有分层的名称，比如在域名neu.edu.cn中，neu是主机名，edu和cn是不同层次下的机构名。</p>
<p>域名和IP地址都可以唯一对应一台主机，DNS的作用就是将域名转换成不容易记住的IP地址。</p>
<p>域名是分层的，每层都有自己的DNS服务器用于处理DNS解析的请求，这样的好处在于每层的服务器不用关注过多的信息，它只要知道自己这一层下的域名服务器信息即可。以解析域名：www.itetf.org为例：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/ip-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png" alt=""></p>
<p>根服务器其实并不知道www.itetf.org的IP地址，但是它知道itetf.org域名服务器的地址，所有它把这条查询请求转发给itetf.org域名服务器。DNS请求被逐层下发，直到找到对应的IP地址为止。</p>
<h1 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h1><p>全称Address Resolution Protocol，地址解析协议</p>
<p>ARP协议用于通用目标IP地址，定位下一个接收数据包的网络设备的MAC地址。如果目标主机处于同一个数据链路上，那么可以直接得到目标主机的MAC地址，否则会得到下一跳路由器的MAC地址。</p>
<p>ARP协议的工作原理可以分为两部分：ARP请求和ARP响应。首先，源主机会通过广播发送一个ARP请求包：“我要与IP地址为XX的主机通话，谁知道它的MAC地址？”。</p>
<p>下图表示ARP协议的工作机制：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/ip-arp.png" alt="ARP"></p>
<p>根据ARP可以动态地进行地址解析，因此，在TCP/IP的网络构造中和网络通信中无需事先知道MAC地址究竟是什么，只要有IP地址即可。</p>
<p>如果每发送一个IP数据报都要进行一个ARP请求以确定MAC地址，那将会造成不必要的网络流量，因此通常的做法是把获取到的MAC地址缓存一段时间。一般来说，发送过一次IP数据包的主机，继续发送多次IP数据包的可能性比较高。因此这种缓存能够有效地减少ARP包的发送。当下一次发送ARP请求或超过一定时间后，缓存都会失效，这保证了即使MAC地址与IP地址对应的关系发送了变化，数据包依然能够被正确的发往目标地址。</p>
<p>MAC地址和IP地址看上起功能相似（都用于唯一区分主机），但是两者缺一不可。如果只有IP地址，虽然可以跳过ARP，直接在链路上发一个广播，但是这仅适应于通信双方处于同一个数据链路情况。如果双方处于不同的数据链路，数据报无法穿透中间的路由器。正因为MAC地址缺一不可，所以才产生了ARP这样的协议将两者关联起来。</p>
<h1 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h1><p>全称：Internet Control Message Protocol，Internet控制报文协议。</p>
<p>ICMP的主要功能：确认IP包是否成功送达目标地址，通知在发送过程中IP包被废弃的具体原因，改善网络等设置。有了这些功能以后，就可以获得网络是否正常、设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断。</p>
<h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><p>全称：Network Address Traslator，网络地址转换</p>
<p>NAT是一种用于将局域网中的私有地址转换成全局IP地址的技术。</p>
<p>在连接上路由器的时候，如果检查一下设备的IP地址，你会发现都是类似于192.168.1.1这样局域网的IP地址。那不同网段中，IP地址都是192.168.1.1的主机该如何通信呢？</p>
<p>下图描述了NAT的工作原理：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/ip-nat%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="nat"></p>
<p>局域网中IP地址为10.0.0.10的主机向全局IP地址163.221.120.9发送数据。NAT路由器将数据包的源地址修改成自己的全局IP地址：202.244.174.37。同理，接收数据时，路由器把目标地址202.244.174.37翻译成内网地址：10.0.0.10。</p>
<p>路由器只有一个对外的全局IP地址，如果有多个内网主机都向外部通讯怎么办呢？这时就要使用NAPT技术，它和NAT从原理上类似，但它可以转换TCP和UDP端口号。</p>
<p>使用NAPT技术时，不同的内网IP被转换成同一个公共IP地址，也就是路由器对外显示的全局IP地址，但是被附加不同的端口号以示区分：如下图所示</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/ip-napt%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="napt"></p>
<p>不管是NAT还是NAPT，都需要路由器内部维护一张自动生成的地址转换表。以TCP为例，建立TCP连接首次握手的SYN包发出时会生成这个表，关闭连接时会发生FIN包，收到这个包的应答时转换表被删除。</p>
<h1 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h1><p>全称：Dynamic Host Configuration Protocol，动态主机配置协议</p>
<p>DHCP的主要用途是实现自动设置IP地址、统一管理IP地址分配。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2015/12/17/TCP-IP3IP协议相关技术/" data-id="cj6esnzg7009pwg19ad46yr2p" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2015/12/17/TCP-IP3IP协议相关技术/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络通信/">网络通信</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/11/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/13/">下一页&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/21/JavaScript⑦对象/">JavaScript⑦对象</a>
          </li>
        
          <li>
            <a href="/2017/06/19/JavaScript⑥引用类型RegExp/">JavaScript⑥引用类型RegExp</a>
          </li>
        
          <li>
            <a href="/2017/06/19/JavaScript⑥引用类型Global/">JavaScript⑥引用类型Global</a>
          </li>
        
          <li>
            <a href="/2017/06/19/JavaScript⑥引用类型Date/">JavaScript⑥引用类型Date</a>
          </li>
        
          <li>
            <a href="/2017/06/19/JavaScript⑥引用类型Array/">JavaScript⑥引用类型Array</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2017 刘涤生&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;michaelliu0727@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/categories" class="mobile-nav-link">分类</a>
  
    <a href="/tags" class="mobile-nav-link">标签</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>
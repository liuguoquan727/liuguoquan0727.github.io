<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>再读斋</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="像外行一样思考,像专家一样实践。">
<meta property="og:type" content="website">
<meta property="og:title" content="再读斋">
<meta property="og:url" content="http://liuguoquan727.github.io/page/23/index.html">
<meta property="og:site_name" content="再读斋">
<meta property="og:description" content="像外行一样思考,像专家一样实践。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="再读斋">
<meta name="twitter:description" content="像外行一样思考,像专家一样实践。">
  
    <link rel="alternate" href="/atom.xml" title="再读斋" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liuguoquan727.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/categories">分类</a>
        
          <a class="main-nav-link" href="/tags">标签</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">再读斋</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">MICHAEL</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java集合之LinkedHashMap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/20/Java集合之LinkedHashMap/" class="article-date">
  <time datetime="2015-12-20T14:35:21.000Z" itemprop="datePublished">2015-12-20 22:35:21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/20/Java集合之LinkedHashMap/">Java集合之LinkedhashMap</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>LinkedHashMap是HashMap的一个子类，它在HashMap的基础上维持了一个双向链表（hash表+双向链表），在遍历的时候可以使用插入顺序（先进先出），或者是最近最少使用（LRU）的顺序。</p>
<p>LinkedHashMap是key键有序的一种集合，使用双向链表来保证key的顺序。</p>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>一般来说，如果需要使用的Map中的key无序，选择HashMap；如果要求key有序，则选择TreeMap。<br>但是选择TreeMap就会有性能问题，因为TreeMap的get操作的时间复杂度是O(log(n))的，相比于HashMap的O(1)还是差不少的，LinkedHashMap的出现就是为了平衡这些因素，使得能够以O(1)时间复杂度增加查找元素，又能够保证key的有序性。</p>
<p>此外，LinkedHashMap提供了两种key的顺序：</p>
<ul>
<li>访问顺序（access order）。可以使用这种顺序实现LRU（Least Recently Used）缓存</li>
<li>插入顺序（insertion orde）。同一key的多次插入，并不会影响其顺序</li>
</ul>
<h1 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</div></pre></td></tr></table></figure>
<p>从定义可以看到LinkedHashMap继承于HashMap，且实现了Map接口。这也就意味着HashMap的一些优秀因素可以被继承下来，比如hash寻址，使用链表解决hash冲突等实现的快速查找，对于HashMap中一些效率较低的内容，比如容器扩容过程，遍历方式，LinkedHashMap是否做了一些优化呢。继续看代码吧。</p>
<h1 id="底层存储"><a href="#底层存储" class="headerlink" title="底层存储"></a>底层存储</h1><p>LinkedHashMap是基于HashMap，并在其基础上维持了一个双向链表，也就是说LinkedHashMap是一个hash表（数组+单向链表） +双向链表的实现，到底实现方式是怎么样的，来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//双向链表的头结点</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; header ;</div><div class="line"></div><div class="line"><span class="comment">//true 表示最近较少使用顺序，false表示插入顺序</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</div></pre></td></tr></table></figure>
<p>下面来看看Entry这个节点类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * LinkedHashMap entry.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="comment">// These fields comprise the doubly linked list used for iteration.</span></div><div class="line">        <span class="comment">// 双向链表的上一个节点before和下一个节点after</span></div><div class="line">        Entry&lt;K,V&gt; before, after ;</div><div class="line"> </div><div class="line">       <span class="comment">// 构造方法直接调用父类HashMap的构造方法（super）</span></div><div class="line">       Entry( <span class="keyword">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</div><div class="line">            <span class="keyword">super</span>(hash, key, value, next);</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 从链表中删除当前节点的方法</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">// 改变当前节点前后两个节点的引用关系，当前节点没有被引用后，gc可以回收</span></div><div class="line">            <span class="comment">// 将上一个节点的after指向下一个节点</span></div><div class="line">            before.after = after;</div><div class="line">            <span class="comment">// 将下一个节点的before指向前一个节点</span></div><div class="line">            after.before = before;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 在指定的节点前加入一个节点到链表中（也就是加入到链表尾部）</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;</div><div class="line">            <span class="comment">// 下面改变自己对前后的指向</span></div><div class="line">            <span class="comment">// 将当前节点的after指向给定的节点（加入到existingEntry前面嘛）</span></div><div class="line">            after  = existingEntry;</div><div class="line">            <span class="comment">// 将当前节点的before指向给定节点的上一个节点</span></div><div class="line">            before = existingEntry.before ;</div><div class="line"> </div><div class="line">            <span class="comment">// 下面改变前后最自己的指向</span></div><div class="line">            <span class="comment">// 上一个节点的after指向自己</span></div><div class="line">            before.after = <span class="keyword">this</span>;</div><div class="line">            <span class="comment">// 下一个几点的before指向自己</span></div><div class="line">            after.before = <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// 当向Map中获取查询元素或修改元素（put相同key）的时候调用这个方法</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</div><div class="line">            LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</div><div class="line">            <span class="comment">// 如果accessOrder为true，也就是使用最近较少使用顺序</span></div><div class="line">            <span class="keyword">if</span> (lm.accessOrder ) &#123;</div><div class="line">                lm. modCount++;</div><div class="line">                <span class="comment">// 先删除，再添加，也就相当于移动了</span></div><div class="line">                <span class="comment">// 删除当前元素</span></div><div class="line">                remove();</div><div class="line">                <span class="comment">// 将当前元素加入到header前（也就是链表尾部）</span></div><div class="line">                addBefore(lm. header);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// 当从Map中删除元素的时候调动这个方法</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</div><div class="line">            remove();</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到Entry继承了HashMap中的Entry，但是LinkedHashMap中的Entry多了两个属性指向上一个节点的before和指向下一个节点的after，也正是这两个属性组成了一个双向链表。等等。。。Entry还有一个继承下来的next属性，这个next是单向链表中用来指向下一个节点的，怎么回事嘛，怎么又是单向链表又是双向链表呢，都要晕了对不对，其实想的没错，这里的节点即是Hash表中的单向链表中的一个节点，它又是LinkedHashMap维护的双向链表中的一个节点。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/LinkedHashMap.png" alt=""></p>
<p>注：黑色箭头指向表示单向链表的next指向，红色箭头指向表示双向链表的before指向，蓝色箭头指向表示双向链表的after指向。另外LinkedHashMap种还有一个header节点是不保存数据的，这里没有画出来。</p>
<p>从上图可以看出LinkedHashMap仍然是一个Hash表，底层由一个数组组成，而数组的每一项都是个单向链表，由next指向下一个节点。但是LinkedHashMap所不同的是，在节点中多了两个属性before和after，由这两个属性组成了一个双向循环链表（你怎么知道是循环，下面在说喽），而由这个双向链表维持着Map容器中元素的顺序。看下Entry中的recordRemoval方法，该方法将在节点被删除时候调用，Hash表中链表节点被正常删除后，调用该方法修正由于节点被删除后双向链表的前后指向关系，从这一点来看，LinkedHashMap比HashMap的add、remove、set等操作要慢一些（因为要维护双向链表 ）。</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 构造一个指定初始容量和加载因子的LinkedHashMap，默认accessOrder为false</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">( <span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">        accessOrder = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造一个指定初始容量的LinkedHashMap，默认accessOrder为false</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">( <span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity);</div><div class="line">        accessOrder = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造一个使用默认初始容量(16)和默认加载因子(0.75)的LinkedHashMap，默认accessOrder为false</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        accessOrder = <span class="keyword">false</span>;  <span class="comment">//默认false</span></div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造一个指定map的LinkedHashMap，所创建LinkedHashMap使用默认加载因子(0.75)和足以容纳指定map的初始容量，默认accessOrder为false 。</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(m);</div><div class="line">        accessOrder = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造一个指定初始容量、加载因子和accessOrder的LinkedHashMap</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">( <span class="keyword">int</span> initialCapacity,</span></span></div><div class="line">                      <span class="keyword">float</span> loadFactor,</div><div class="line">                         <span class="keyword">boolean</span> accessOrder) &#123;</div><div class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//重写了HashMap的init方法</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 初始化话header，将hash设置为-1，key、value、next设置为null</span></div><div class="line">        header = <span class="keyword">new</span> Entry&lt;K,V&gt;(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">        <span class="comment">// header的before和after都指向header自身</span></div><div class="line">        header.before = header. after = header ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><p>LinkedHashMap没有重写HashMap的put方法，只是重写了HashMap被put调用的addEntry方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">( <span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">	<span class="comment">// 调用createEntry方法创建一个新的节点</span></div><div class="line">	createEntry(hash, key, value, bucketIndex);</div><div class="line"></div><div class="line">	<span class="comment">// Remove eldest entry if instructed, else grow capacity if appropriate</span></div><div class="line">	<span class="comment">// 取出header后的第一个节点（因为header不保存数据，所以取header后的第一个节点）</span></div><div class="line">	Entry&lt;K,V&gt; eldest = header.after ;</div><div class="line">	<span class="comment">// 判断是容量不够了是要删除第一个节点还是需要扩容</span></div><div class="line">	<span class="keyword">if</span> (removeEldestEntry(eldest)) &#123;</div><div class="line">		<span class="comment">// 删除第一个节点（可实现FIFO、LRU策略的Cache）</span></div><div class="line">		removeEntryForKey(eldest. key);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">// 和HashMap一样进行扩容</span></div><div class="line">		<span class="keyword">if</span> (size &gt;= threshold)</div><div class="line">			resize(<span class="number">2</span> * table.length );</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * This override differs from addEntry in that it doesn't resize the</div><div class="line"> * table or remove the eldest entry.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">( <span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">	<span class="comment">// 下面三行代码的逻辑是，创建一个新节点放到单向链表的头部</span></div><div class="line">	<span class="comment">// 取出数组bucketIndex位置的旧节点 </span></div><div class="line">	HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</div><div class="line">	<span class="comment">// 创建一个新的节点，并将next指向旧节点</span></div><div class="line">   Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, old);</div><div class="line">	<span class="comment">// 将新创建的节点放到数组的bucketIndex位置</span></div><div class="line">	table[bucketIndex] = e;</div><div class="line"></div><div class="line">	<span class="comment">// 维护双向链表，将新节点添加在双向链表header前面（链表尾部）</span></div><div class="line">	e.addBefore( header);</div><div class="line">	<span class="comment">// 计数器size加1</span></div><div class="line">	size++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 默认返回false，也就是不会进行元素删除了。如果想实现cache功能，只需重写该方法</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，在添加方法上，比HashMap中多了两个逻辑，一个是当Map容量不足后判断是删除第一个元素，还是进行扩容，另一个是维护双向链表。而在判断是否删除元素的时候，我们发现removeEldestEntry这个方法竟然是永远返回false，原来想要实现Cache功能，需要自己继承LinkedHashMap然后重写removeEldestEntry方法，这里默认提供的是容器的功能。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>LinkedHashMap没有重写remove方法，只是在实现了Entry类的recordRemoval方法，该方法是HashMap的提供的一个回调方法，在HashMap的remove方法进行回调，而LinkedHashMap中recordRemoval的主要当然是要维护双向链表了，返回上面去看下Entry类的recordRemoval方法吧。</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>LinkedHashMap重写了get方法，但是的确复用了HashMap中的getEntry方法，LinkedHashMap是在get方法中指加入了调用recoreAccess方法的逻辑，recoreAccess方法的目的当然也是维护双向链表了，具体逻辑返回上面去看下Entry类的recoreAccess方法吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        e.recordAccess( <span class="keyword">this</span>);</div><div class="line">        <span class="keyword">return</span> e.value ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="是否包含"><a href="#是否包含" class="headerlink" title="是否包含"></a>是否包含</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line">	<span class="comment">// Overridden to take advantage of faster iterator</span></div><div class="line">	<span class="comment">// 遍历双向链表，查找指定的value</span></div><div class="line">	<span class="keyword">if</span> (value==<span class="keyword">null</span>) &#123; </div><div class="line">		<span class="keyword">for</span> (Entry e = header .after; e != header; e = e.after )</div><div class="line">			<span class="keyword">if</span> (e.value ==<span class="keyword">null</span>)</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">for</span> (Entry e = header .after; e != header; e = e.after )</div><div class="line">			<span class="keyword">if</span> (value.equals(e.value ))</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LinkedHashMap对containsValue进行了重写，我们在HashMap中说过，HashMap的containsValue需要遍历整个hash表，这样是十分低效的。而LinkedHashMap中重写后，不再遍历hash表，而是遍历其维护的双向链表，这样在效率上难道就有所改善吗？我们分析下：hash表是由数组+单向链表组成，而由于使用hash算法，可能会导致散列不均匀，甚至数组的有些项是没有元素的（没有hash出对应的散列值），而LinkedHashMap的双向链表呢，是不存在空项的，所以LinkedHashMap的containsValue比HashMap的containsValue效率要好一些。</p>
<h1 id="自定义LruCache"><a href="#自定义LruCache" class="headerlink" title="自定义LruCache"></a>自定义LruCache</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.michael.java.construct;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruCache</span> <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">String</span>, <span class="title">Object</span>&gt;</span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * </div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2725884916293330545L</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_CAPACITY = <span class="number">1024</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxCapacity;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(DEFAULT_MAX_CAPACITY, DEFAULT_LOAD_FACTOR, accessOrder);</div><div class="line">		<span class="keyword">this</span>.maxCapacity = DEFAULT_MAX_CAPACITY;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> capacity,<span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(DEFAULT_MAX_CAPACITY, DEFAULT_LOAD_FACTOR, accessOrder);</div><div class="line">		<span class="keyword">this</span>.maxCapacity = capacity;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(</span></span></div><div class="line">			java.util.Map.Entry&lt;String, Object&gt; eldest) &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.size() &gt; maxCapacity;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		LruCache cache = <span class="keyword">new</span> LruCache(<span class="number">5</span>, <span class="keyword">true</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>;i++) &#123;</div><div class="line">			cache.put(<span class="string">"k"</span>+i, <span class="string">"v"</span>+i);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		System.out.println(<span class="string">"size: "</span> + cache.size());</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(Map.Entry&lt;String, Object&gt; entry : cache.entrySet()) &#123;</div><div class="line">			System.out.println(entry.getKey() + <span class="string">" = "</span> + entry.getValue());</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(<span class="string">"------------"</span>);</div><div class="line">		System.out.println(<span class="string">"k3 = "</span> + cache.get(<span class="string">"k3"</span>));</div><div class="line">		System.out.println(<span class="string">"------------"</span>);</div><div class="line">		</div><div class="line">		cache.put(<span class="string">"k6"</span>, <span class="string">"v6"</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(Map.Entry&lt;String, Object&gt; entry : cache.entrySet()) &#123;</div><div class="line">			System.out.println(entry.getKey() + <span class="string">" = "</span> + entry.getValue());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">结果打印：</div><div class="line"></div><div class="line">size: <span class="number">5</span></div><div class="line">k1 = v1</div><div class="line">k2 = v2</div><div class="line">k3 = v3</div><div class="line">k4 = v4</div><div class="line">k5 = v5</div><div class="line">------------</div><div class="line">k3 = v3</div><div class="line">------------</div><div class="line">k2 = v2</div><div class="line">k4 = v4</div><div class="line">k5 = v5</div><div class="line">k3 = v3</div><div class="line">k6 = v6</div></pre></td></tr></table></figure>
<p>序列中的第一个元素时最近使用最少的元素</p>
<p>参考文章：</p>
<p><a href="http://www.importnew.com/17561.html" target="_blank" rel="external">给jdk写注释系列之jdk1.6容器(5)-LinkedHashMap源码解析</a></p>
<p><a href="http://liujiacai.net/blog/2015/09/12/java-linkedhashmap/" target="_blank" rel="external">Java LinkedHashMap源码解析</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2015/12/20/Java集合之LinkedHashMap/" data-id="cj6f0socb007mf519l5i1fkg7" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2015/12/20/Java集合之LinkedHashMap/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Collection/">Collection</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Java集合之TreeMap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/19/Java集合之TreeMap/" class="article-date">
  <time datetime="2015-12-19T14:35:21.000Z" itemprop="datePublished">2015-12-19 22:35:21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/19/Java集合之TreeMap/">Java集合之TreeMap</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>TreeMap是基于红黑树结构的一种Map，要分析TreeMap的实现首先要了解红黑树这种数据结构。</p>
<h1 id="二叉树、红黑树简介"><a href="#二叉树、红黑树简介" class="headerlink" title="二叉树、红黑树简介"></a>二叉树、红黑树简介</h1><p>先简单总结一下数组，链表，Hash表以及树的优缺点:</p>
<ul>
<li><p>数组</p>
<ul>
<li>优点：随机访问效率高（根据下标查询）；搜索效率较高（可使用折半方法）</li>
<li>缺点：内存连续且固定，存储效率低；插入和删除效率低（可能会进行数组扩容或者拷贝）</li>
</ul>
</li>
<li><p>链表</p>
<ul>
<li>优点：不要求连续内存，存储效率高；插入和删除效率高（只需要改变指针指向）</li>
<li>缺点：不支持随机访问；搜索效率低（需要遍历）</li>
</ul>
</li>
<li><p>哈希表</p>
<ul>
<li>优点：搜索效率高；增删效率高</li>
<li>缺点：内存利用率低（基于数组）；存在散列冲突</li>
</ul>
</li>
<li><p>二叉树</p>
<ul>
<li>优点：查询效率高；增删效率高；存储效率高；</li>
<li>缺点：算法复杂</li>
</ul>
</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树的特点：</p>
<ul>
<li>若左子树不为空，则左子树上所有结点的值均小于它的根结点的值</li>
<li>若右子树不为空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>左右子树也分别为二叉查找树</li>
<li>没有键值相等的节点</li>
</ul>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/treemap-%E4%BA%8C%E5%8F%89%E6%A0%91.jpg" alt="二叉树"></p>
<p>按照二叉查找树存储的数据，对元素的搜索效率是非常高的，比如上图中如果要查找值为48的节点，只需要遍历4个节点就能完成。理论上，一颗平衡的二叉查找树的任意节点平均查找效率为树的高度h，即O(lgn)。但是如果二叉查找树的失去平衡（元素全在一侧），搜索效率就退化为O(n)，因此二叉查找树的平衡是搜索效率的关键所在。而红黑树就是靠红黑规则来维持二叉查找树的平衡性。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/treemap-%E5%A4%B1%E5%8E%BB%E5%B9%B3%E8%A1%A1%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="失去平衡的二叉树"></p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树的红黑规则：</p>
<ul>
<li>节点是红色或黑色</li>
<li>根节点是黑色</li>
<li>每个叶子节点（NIL节点，空节点）是黑色的</li>
<li>每个红色节点的两个子节点都是黑色（从每个叶子到根的所有路径上不能有两个连续的红色节点）</li>
<li>从任意节点到其每个叶子的所有路径都包含相同数目的黑色节点</li>
</ul>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/treemap-%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="s"></p>
<p>第5条规则到底是什么情况，下面简单解释下，比如图中红8到1左边的叶子节点的路径包含两个黑色节点，到6下面的叶子节点的路径也包含两个黑色节点。</p>
<p>但是在在添加或删除节点后，红黑树就发生了变化，可能不再满足上面的5个特性，为了保持红黑树的以上特性，就有了三个动作：左旋、右旋、着色。</p>
<p>下面来看下什么是红黑树的左旋和右旋：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/treemap-%E7%BA%A2%E9%BB%91%E6%A0%91%E5%B7%A6%E6%97%8B.jpg" alt=""></p>
<p>对x进行左旋，意味着将x变成一个左节点。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/treemap-%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8F%B3%E6%97%8B.jpg" alt=""></p>
<p>对y进行右旋，意味着将y变成一个右节点。</p>
<h1 id="TreeMap签名"><a href="#TreeMap签名" class="headerlink" title="TreeMap签名"></a>TreeMap签名</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line">       <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</div><div class="line">       <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div></pre></td></tr></table></figure>
<blockquote>
<p>HashMap是无序的，TreeMap是有序的</p>
</blockquote>
<h2 id="接口NavigableMap"><a href="#接口NavigableMap" class="headerlink" title="接口NavigableMap"></a>接口NavigableMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">SortedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div></pre></td></tr></table></figure>
<p>发现NavigableMap继承了SortedMap，说明这个Map是有序的。这个顺序一般是指由Comparable接口提供的keys自然序，或者也可以在窗口SortedMap时，指定一个Comparator来决定。</p>
<h2 id="Comparator和Comparable的区别"><a href="#Comparator和Comparable的区别" class="headerlink" title="Comparator和Comparable的区别"></a>Comparator和Comparable的区别</h2><ul>
<li>Comparable一般表示类的自然序，比如定义一个Student类，学号为默认排序</li>
<li>Comparator一般表示类在某种场合下的特殊分类，需要定制化排序。比如现在想按照Student类的age来排序。</li>
</ul>
<p>插入SortedMap中的key的类都必须继承Comparable类（或指定一个comparator），这样才能确定如何比较（通过k1.compareTo(k2)或comparator.compare(k1, k2)）两个key，否则，在插入时，会报ClassCastException的异常。</p>
<p>此外，SortedMap中key的顺序性应该与equals方法保持一致。也就是说k1.compareTo(k2)或comparator.compare(k1, k2)为true时，k1.equals(k2)也应该为true。</p>
<p>介绍完了SortedMap，再来回到我们的NavigableMap上面来。<br>NavigableMap是JDK1.6新增的，在SortedMap的基础上，增加了一些“导航方法”（navigation methods）来返回与搜索目标最近的元素。例如下面这些方法：</p>
<ul>
<li>lowerEntry，返回所有比给定Map.Entry小的元素</li>
<li>floorEntry，返回所有比给定Map.Entry小或相等的元素</li>
<li>ceilingEntry，返回所有比给定Map.Entry大或相等的元素</li>
<li>higherEntry，返回所有比给定Map.Entry大的元素</li>
</ul>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>红黑树的算法还没有理解深刻，暂时挖个坑</p>
<p>因为红黑树是平衡的二叉搜索树，所以其put（包含update操作）、get、remove的时间复杂度都为log(n)</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>TreeMap的key是有序的，增删改查操作的时间复杂度为O(log(n))，为了保证红黑树平衡，在必要时会进行旋转</li>
<li>HashMap的key是无序的，增删改查操作的时间复杂度为O(1)，为了做到动态扩容，在必要时会进行resize。</li>
</ul>
<p>参考文章:</p>
<p><a href="http://www.importnew.com/17605.html" target="_blank" rel="external">给jdk写注释系列之jdk1.6容器(7)-TreeMap源码解析</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2015/12/19/Java集合之TreeMap/" data-id="cj6f0socd007tf519bqgt5h2o" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2015/12/19/Java集合之TreeMap/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Collection/">Collection</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Java集合之HashMap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/19/Java集合之HashMap/" class="article-date">
  <time datetime="2015-12-19T13:30:21.000Z" itemprop="datePublished">2015-12-19 21:30:21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/19/Java集合之HashMap/">Java集合之HashMap</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="签名（Signature）"><a href="#签名（Signature）" class="headerlink" title="签名（Signature）"></a>签名（Signature）</h1><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line">       <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</div><div class="line">       <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></div></pre></td></tr></table></figure>
<p>可以看到HashMap实现了：</p>
<ul>
<li>接口Cloneable，用于表明HashMap对象会重写<code>java.lang.Object.clone()</code>方法，HashMap实现的是浅拷贝</li>
<li>接口Serializable：表明HashMap对象可以被序列化</li>
</ul>
<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p>Map接口里包含的成员方法不外乎是“增删改查”，Map虽然并不是Collection，但它提供了三种“集合视角”，与下面三个方法一一对应：</p>
<ul>
<li><code>Set&lt;key&gt; keySet()</code>，提供key的集合视角</li>
<li><code>Collection&lt;V&gt; values()</code>，提供value的集合视角</li>
<li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>,提供key-value键值对的集合视角</li>
</ul>
<h1 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h1><h2 id="哈希表（hash-table）"><a href="#哈希表（hash-table）" class="headerlink" title="哈希表（hash table）"></a>哈希表（hash table）</h2><p>HashMap是一种基于哈希表实现的Map，哈希表是一种通用的数据结构，其概念是：key经过hash函数作用后得到一个槽（buckets）的索引（index），槽中保存着我们想要获取的值，如下图所示：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/hashmap-%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="hash table"></p>
<blockquote>
<p>一些不同的key经过同一hash函数后可能产生相同的索引，也就会产生冲突，所以利用哈希表这种数据结构实现具体类时，需要注意两个问题：</p>
<ul>
<li>设计一个好的hash函数，使冲突尽可能的减少</li>
<li>需要解决发生冲突后的处理</li>
</ul>
</blockquote>
<h2 id="HashMap的特点"><a href="#HashMap的特点" class="headerlink" title="HashMap的特点"></a>HashMap的特点</h2><ul>
<li>线程非安全，并且允许key与value都为null值，HashTable与之相反，为线程安全，key与value都不允许null值</li>
<li>不保证其内部元素的顺序，而且随着时间的推移，同一元素的位置也可能改变（resize的情况）</li>
<li>put、get操作的时间复杂度为O（1）</li>
<li>遍历其集合视角的时间复杂度与其容量和现有元素的大小成正比，如果遍历的性能要求很高，不要把capacity设置的过高或者把平衡因子设置的过低。</li>
<li>由于HashMap是线程非安全的，意味着如果有多个线程同时对同一HashMap试图做迭代时有结构上的改变（添加、删除entry，只改变entry的value值不算结构改变），那么会报ConcurrentModificationException异常，专业术语叫fail-fast，尽早报错对应多线程程序来说是很有必要的。</li>
<li><code>Map m = Collections.synchronizedMap(new HashMap(...))</code>;通过这种方式可以得到一个线程安全的Map。</li>
</ul>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>HashMap遵循集合框架的约束，提供一个参数为空的构造函数与有一个参数且参数类型为Map的构造函数。除此之外，还提供了两个构造函数，用于设置HashMap的容量（capacity）和平衡因子（loadFactor）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</div><div class="line">				  DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</div><div class="line">	inflateTable(threshold);</div><div class="line"></div><div class="line">	putAllForCreate(m);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">	<span class="comment">//初始容量和加载因子合法校验</span></div><div class="line">	<span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">										   initialCapacity);</div><div class="line">	<span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">		initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">	<span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">										   loadFactor);</div><div class="line"></div><div class="line">	<span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">	threshold = initialCapacity;</div><div class="line">	init();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>容量与平衡因子都有个默认值，并且容量有个最大值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 默认初始容量为16，必须为2的指数倍</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 最大容量为2的30次方</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 默认加载因子为0.75f</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Entry数组，长度必须为2的n次幂</span></div><div class="line">    <span class="keyword">transient</span> Entry[] table;</div><div class="line"></div><div class="line">	<span class="comment">// 已存储元素的数量</span></div><div class="line">	<span class="keyword">transient</span> <span class="keyword">int</span> size ;</div><div class="line"></div><div class="line">	<span class="comment">// 下次扩容的临界值，size&gt;=threshold就会扩容，threshold等于capacity*load factor</span></div><div class="line">	<span class="keyword">int</span> threshold;</div><div class="line"></div><div class="line">	<span class="comment">// 加载因子</span></div><div class="line">	<span class="keyword">final</span> <span class="keyword">float</span> loadFactor ;</div></pre></td></tr></table></figure>
<p>可以看到，默认的平衡因子为0.75，这是权衡了时间复杂度与空间复杂度之后的最好取值（官方说法），过高的因子会降低存储空间但是查找的时间就会增加。</p>
<p>此外，我们注意到容量必须为2的指数被（默认16），这是为什么呢？解答这个问题，需要了解HashMap中哈希函数的设计原理</p>
<h2 id="哈希函数的设计原理"><a href="#哈希函数的设计原理" class="headerlink" title="哈希函数的设计原理"></a>哈希函数的设计原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> h = hashSeed;</div><div class="line">	<span class="keyword">if</span> (<span class="number">0</span> != h &amp;&amp; k <span class="keyword">instanceof</span> String) &#123;</div><div class="line">		<span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	h ^= k.hashCode();</div><div class="line"></div><div class="line">	<span class="comment">// This function ensures that hashCodes that differ only by</span></div><div class="line">	<span class="comment">// constant multiples at each bit position have a bounded</span></div><div class="line">	<span class="comment">// number of collisions (approximately 8 at default load factor).</span></div><div class="line">	h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</div><div class="line">	<span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns index for hash code h.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">	<span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></div><div class="line">	<span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在哈希表容量为length的情况下，为了使key都能在冲突最小的情况下映射到[0,length)的索引（index）内，HasMap让length为2的指数倍，然后用`hashCode(key) &amp; (length -1)的方法得到索引。</p>
<blockquote>
<p>因为length为2的指数倍，所以length-1所对应的二进制位都为1，然后与hashCode(key)坐与运算，即可得到[0,length)内的索引。</p>
</blockquote>
<p>但是这里有个问题，如果HashCode（key)的值大于length的值，举个例子：</p>
<blockquote>
<p>Java中对象的哈希值都是32位整数，而HashMap的默认大小为16，那么如果有两个对象的哈希值为：0xABAB0000与0xBABA0000，它们的后四位都是一样，那么与16异或后得到结果都是一样的为0，也就是产生了冲突。</p>
</blockquote>
<p>造成冲突的原因关键在于16限制了只能用低位来计算，高位直接舍弃了，所以我们需要额外的哈希函数而不只是简单的对象的hashCode方法了。具体来说就是HashMap中hash（）函数所实现的功能了。</p>
<blockquote>
<p>首先有个随机的hashSeed来降低冲突发生的几率<br>然后如果是字符串。则用了sun.misc.Hashing.stringHash32((String) k)来获取索引值<br>最后通过一系列的无符号右移操作，来把高位与地位进行异或操作，来降低冲突发生的几率。</p>
</blockquote>
<p>右移的偏移量20,12,7是怎么来的呢？因为Java中对象的哈希值是32位的，所以这几个数应该就是把高位与地位做异或运算，至于这几个数是如何选取的，就不清楚了。</p>
<h2 id="HashMap-Entry"><a href="#HashMap-Entry" class="headerlink" title="HashMap.Entry"></a>HashMap.Entry</h2><p>HashMap中存放的是HashMap.Entry对象，它继承自Map.Entry，其比较重要的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">	<span class="keyword">final</span> K key;</div><div class="line">	V value;</div><div class="line">	Entry&lt;K,V&gt; next; <span class="comment">//指向下一个节点</span></div><div class="line">	<span class="keyword">int</span> hash;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Creates new entry.</div><div class="line">	 */</div><div class="line">	Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</div><div class="line">		value = v;</div><div class="line">		next = n;</div><div class="line">		key = k;</div><div class="line">		hash = h;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> key;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> value;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</div><div class="line">		V oldValue = value;</div><div class="line">		value = newValue;</div><div class="line">		<span class="keyword">return</span> oldValue;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		Map.Entry e = (Map.Entry)o;</div><div class="line">		Object k1 = getKey();</div><div class="line">		Object k2 = e.getKey();</div><div class="line">		<span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</div><div class="line">			Object v1 = getValue();</div><div class="line">			Object v2 = e.getValue();</div><div class="line">			<span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">//用key的hash值与value的hash值与运算的结果作为Entry的hash值</span></div><div class="line">		<span class="keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 当向HashMap中添加元素时调用这个方法，这里没有实现是供子类回调</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 当从HashMap中删除元素时调用这个方法</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，Entry实现了单向链表的功能，用next成员变量来级联起来。也就是说HashMap的底层结构是一个数组，而数组的元素是一个单向链表。</p>
<p>介绍完Entry，下面介绍一个重要的成员变量</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//HashMap内部维护一个数组类型的<span class="keyword">Entry</span>变量table，用来保存添加进来的<span class="keyword">Entry</span>对象</div><div class="line">transient <span class="keyword">Entry</span>&lt;K,V&gt;[] table = (<span class="keyword">Entry</span>&lt;K,V&gt;[]) EMPTY_TABLE;</div></pre></td></tr></table></figure>
<p>Entry是单链表，怎么这里又需要个数组类型的tabl呢？其实这是解决冲突的一个方式：链地址法（开散列法），效果如下：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/hashmap-%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95.gif" alt=""></p>
<p>就是相同索引值的Entry会以单向链表的形式存在。<br>HashMap采用将相同的散列值存储到一个链表中，也就是说在一个链表中的元素他们的散列值绝对是相同的。</p>
<h2 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h2><p>因为put操作有可能需要对HashMap进行resize，所以实现较复杂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</div><div class="line">    <span class="comment">//辅助函数，用于填充HashMap到指定的capacity</span></div><div class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></div><div class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</div><div class="line">    <span class="comment">//threshold为resize的阈值，超过后HashMap会进行resize，内容的entry会进行rehash</span></div><div class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</div><div class="line">    table = <span class="keyword">new</span> Entry[capacity];</div><div class="line">    initHashSeedAsNeeded(capacity);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Associates the specified value with the specified key in this map.</div><div class="line"> * If the map previously contained a mapping for the key, the old</div><div class="line"> * value is replaced.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</div><div class="line">        inflateTable(threshold);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> putForNullKey(value);</div><div class="line">		</div><div class="line">	<span class="comment">//使用key的hashCode计算key对应的hash值</span></div><div class="line">    <span class="keyword">int</span> hash = hash(key);</div><div class="line">	</div><div class="line">	<span class="comment">//通过key的哈希值查找在数组中的index位置</span></div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">    <span class="comment">//这里的循环是关键</span></div><div class="line">    <span class="comment">//当新增的key所对应的索引i，对应table[i]中已经有值时，进入循环体</span></div><div class="line">	<span class="comment">//取出数组index位置的链表，遍历链表查看是否已经存在相同的key</span></div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="comment">//判断是否存在本次插入的key，如果存在用本次的value替换之前oldValue，相当于update操作</span></div><div class="line">        <span class="comment">//并返回之前的oldValue</span></div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">            V oldValue = e.value;</div><div class="line">            e.value = value;</div><div class="line">            e.recordAccess(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果本次新增key之前不存在于HashMap中，modCount加1，说明结构改变了</span></div><div class="line">    modCount++;</div><div class="line">	<span class="comment">//在数组i位置处添加一个新的链表节点</span></div><div class="line">    addEntry(hash, key, value, i);</div><div class="line">	<span class="comment">//没有相同key的情况，返回null</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">		<span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</div><div class="line">			V oldValue = e.value;</div><div class="line">			e.value = value;</div><div class="line">			e.recordAccess(<span class="keyword">this</span>);</div><div class="line">			<span class="keyword">return</span> oldValue;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	modCount++;</div><div class="line">	addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</div><div class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    <span class="comment">//如果增加一个元素会后，HashMap的大小超过阈值，需要resize</span></div><div class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</div><div class="line">        <span class="comment">//增加的幅度是之前的1倍</span></div><div class="line">        resize(<span class="number">2</span> * table.length);</div><div class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</div><div class="line">        bucketIndex = indexFor(hash, table.length);</div><div class="line">    &#125;</div><div class="line">    createEntry(hash, key, value, bucketIndex);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    <span class="comment">//首先得到该索引处的冲突链Entries，第一次插入bucketIndex位置时冲突链为null，也就是e为null</span></div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">    <span class="comment">//然后把新的Entry添加到冲突链的开头，也就是说，后插入的反而在前面（第一次还真没看明白）</span></div><div class="line">    <span class="comment">//table[bucketIndex]为新加入的Entry，是bucketIndex位置的冲突链的第一个元素</span></div><div class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    size++;</div><div class="line">&#125;</div><div class="line"><span class="comment">//下面看看HashMap是如何进行resize，庐山真面目就要揭晓了😊</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</div><div class="line">    Entry[] oldTable = table;</div><div class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</div><div class="line">    <span class="comment">//如果已经达到最大容量，那么就直接返回</span></div><div class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</div><div class="line">        threshold = Integer.MAX_VALUE;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//使用新的容量创建一个新的链表数组</span></div><div class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</div><div class="line">    <span class="comment">//initHashSeedAsNeeded(newCapacity)的返回值决定了是否需要重新计算Entry的hash值</span></div><div class="line">	<span class="comment">//将当前数组的元素移动到新的数组</span></div><div class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</div><div class="line">	<span class="comment">//将当前数组的引用指向新的数组</span></div><div class="line">    table = newTable;</div><div class="line">	<span class="comment">//重新计算临界值</span></div><div class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Transfers all entries from current table to newTable.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</div><div class="line">    <span class="comment">//遍历当前的table，将里面的元素添加到新的newTable中</span></div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</div><div class="line">            Entry&lt;K,V&gt; next = e.next;</div><div class="line">            <span class="keyword">if</span> (rehash) &#123;</div><div class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</div><div class="line">            e.next = newTable[i];</div><div class="line">            <span class="comment">//最后这两句用了与put放过相同的技巧</span></div><div class="line">            <span class="comment">//将后插入的反而在前面</span></div><div class="line">            newTable[i] = e;</div><div class="line">            e = next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * Initialize the hashing mask value. We defer initialization until we</div><div class="line"> * really need it.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">initHashSeedAsNeeded</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> currentAltHashing = hashSeed != <span class="number">0</span>;</div><div class="line">    <span class="keyword">boolean</span> useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</div><div class="line">            (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</div><div class="line">    <span class="comment">//这里说明了，在hashSeed不为0或满足useAltHash时，会重算Entry的hash值</span></div><div class="line">    <span class="comment">//至于useAltHashing的作用可以参考下面的链接</span></div><div class="line">    <span class="comment">// http://stackoverflow.com/questions/29918624/what-is-the-use-of-holder-class-in-hashmap</span></div><div class="line">    <span class="keyword">boolean</span> switching = currentAltHashing ^ useAltHashing;</div><div class="line">    <span class="keyword">if</span> (switching) &#123;</div><div class="line">        hashSeed = useAltHashing</div><div class="line">            ? sun.misc.Hashing.randomHashSeed(<span class="keyword">this</span>)</div><div class="line">            : <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> switching;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Map中的元素越多，hash冲突的几率也就越大，数组长度是固定的，所以导致链表越来越长，那么查询的效率当然也就越地下了。HasMap的扩容resize，需要将所有的元素重新计算后，一个个重新排列到新的数组中去，这是非常低效的，和ArrayList一样，在可预知容量大小的情况下，提前预设容量会减少HashMap的扩容，提高性能。</p>
</blockquote>
<h2 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="comment">//单独处理key为null的情况</span></div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> getForNullKey();</div><div class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//key为null的Entry用于放在table[0]中，但是在table[0]冲突链中的Entry的key不一定为null</span></div><div class="line">    <span class="comment">//所以需要遍历冲突链，查找key是否存在</span></div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">        <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> e.value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">    <span class="comment">//首先定位到索引在table中的位置</span></div><div class="line">    <span class="comment">//然后遍历冲突链，查找key是否存在</span></div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="remove操作"><a href="#remove操作" class="headerlink" title="remove操作"></a>remove操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; e = removeEntryForKey(key);</div><div class="line">    <span class="comment">//可以看到删除的key如果存在，就返回其所对应的value</span></div><div class="line">    <span class="keyword">return</span> (e == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">    <span class="comment">//这里用了两个Entry对象，相当于两个指针，为的是防治冲突链发生断裂的情况</span></div><div class="line">    <span class="comment">//这里的思路就是一般的单向链表的删除思路</span></div><div class="line">    Entry&lt;K,V&gt; prev = table[i];</div><div class="line">    Entry&lt;K,V&gt; e = prev;</div><div class="line">    <span class="comment">//当table[i]中存在冲突链时，开始遍历里面的元素</span></div><div class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">        Entry&lt;K,V&gt; next = e.next;</div><div class="line">        Object k;</div><div class="line">		<span class="comment">//如果hash值和key都相等则认为相等</span></div><div class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">            modCount++;</div><div class="line">            size--;</div><div class="line">            <span class="keyword">if</span> (prev == e) <span class="comment">//当冲突链只有一个Entry时</span></div><div class="line">                table[i] = next;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                prev.next = next;</div><div class="line">            e.recordRemoval(<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">        &#125;</div><div class="line">        prev = e;</div><div class="line">        e = next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一般而言，认为HashMap的这四种操作时间复杂度O（1），因为它hash函数性质较好，保证了冲突发生的几率较小。</p>
<blockquote>
<p>从删除和查找操作可以看出，在根据key查找元素的时候，还是需要通过遍历，但是由于已经通过hash函数对key散列，要遍历的只是发生冲突后生成的链表，这样遍历的结果就已经少很多了，比完全遍历效率提升了N倍。</p>
</blockquote>
<h2 id="fast-fail的HashIterator"><a href="#fast-fail的HashIterator" class="headerlink" title="fast-fail的HashIterator"></a>fast-fail的HashIterator</h2><p>集合类用Iterator类来遍历其包含的元素，接口Enumeration以及不推荐使用。相比Enumeration，Iterator有下面两个优势：</p>
<ul>
<li>Iterator允许调用者在遍历集合类时删除集合类中包含的元素</li>
<li>比Enumeration命名更简单</li>
</ul>
<p>HashMap中提供的三种集合视角，底层都是用HashIterator是实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></div><div class="line">    <span class="comment">//在初始化Iterator实例时，纪录下当前的修改次数</span></div><div class="line">    <span class="keyword">int</span> expectedModCount;   <span class="comment">// For fast-fail</span></div><div class="line">    <span class="keyword">int</span> index;              <span class="comment">// current slot</span></div><div class="line">    Entry&lt;K,V&gt; current;     <span class="comment">// current entry</span></div><div class="line">    HashIterator() &#123;</div><div class="line">        expectedModCount = modCount;</div><div class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></div><div class="line">            Entry[] t = table;</div><div class="line">            <span class="comment">//遍历HashMap的table，依次查找元素</span></div><div class="line">            <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</div><div class="line">                ;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//在访问下一个Entry时，判断是否有其他线程有对集合的修改</span></div><div class="line">        <span class="comment">//说明HashMap是线程非安全的</span></div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        Entry&lt;K,V&gt; e = next;</div><div class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">        <span class="keyword">if</span> ((next = e.next) == <span class="keyword">null</span>) &#123;</div><div class="line">            Entry[] t = table;</div><div class="line">            <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</div><div class="line">                ;</div><div class="line">        &#125;</div><div class="line">        current = e;</div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">        Object k = current.key;</div><div class="line">        current = <span class="keyword">null</span>;</div><div class="line">        HashMap.<span class="keyword">this</span>.removeEntryForKey(k);</div><div class="line">        expectedModCount = modCount;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> nextEntry().value;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> nextEntry().getKey();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</div><div class="line">    <span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> nextEntry();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>从源码可知，保存Entry的table数组为transient的，也就是说在进行序列化时并不会包含该成员，这是为什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</div></pre></td></tr></table></figure>
<p>为了解答这个问题，我们需要明确下面事实：Object.hasCode方法对于一个类的两个实例返回的是不同的哈希值。</p>
<p>我们可以试想下面的场景：</p>
<blockquote>
<p>我们在机器A上算出对象A的哈希值与索引，然后把它插入到HashMap中，然后把该HashMap序列化后，在机器B上重新算出对象的哈希值与索引，这与机器A上算出的是不一样的，所以我们在机器B上get对象A时，会得到错误的结果。<br>所以说，当序列化一个HashMap对象时，保存Entry的table是不需要序列化进来的，因为它在另一台机器上是错误的。<br>因为这个原因，HashMap重写了writeObject和readObject方法</p>
</blockquote>
<h1 id="HashMap遍历"><a href="#HashMap遍历" class="headerlink" title="HashMap遍历"></a>HashMap遍历</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapDemo</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++ ) &#123;</div><div class="line">			</div><div class="line">			map.put(<span class="string">"name"</span>+i, <span class="string">"liuguoquan"</span>+i);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line"></div><div class="line">		<span class="keyword">long</span> start = System.nanoTime();</div><div class="line">		<span class="comment">//键的集合</span></div><div class="line">		Set&lt;String&gt; set = map.keySet();</div><div class="line">		Iterator&lt;String&gt; iterator = set.iterator();</div><div class="line">		<span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">			String key = (String) iterator.next();</div><div class="line">			String value = map.get(key);</div><div class="line">			System.out.println(key + <span class="string">" = "</span> + value);</div><div class="line">			</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">long</span> end = System.nanoTime();</div><div class="line">		System.out.println(<span class="string">"keySet(): "</span> + (end - start)+<span class="string">"纳秒"</span>);</div><div class="line">		</div><div class="line">		<span class="comment">//foreach keyset</span></div><div class="line">		start = System.nanoTime();</div><div class="line">		<span class="keyword">for</span>(String key : map.keySet()) &#123;</div><div class="line">			String value = map.get(key);</div><div class="line">			System.out.println(key + <span class="string">" = "</span> + value);</div><div class="line">		&#125;</div><div class="line">		end = System.nanoTime();</div><div class="line">		System.out.println(<span class="string">"for keySet(): "</span> + (end - start)+<span class="string">"纳秒"</span>);</div><div class="line">		</div><div class="line">		<span class="comment">//Entry集合 效率较高</span></div><div class="line">		start = System.nanoTime();</div><div class="line">		Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</div><div class="line">		Iterator&lt;Entry&lt;String, String&gt;&gt; it = entrySet.iterator();</div><div class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">			Map.Entry&lt;String, String&gt; entry = (Map.Entry&lt;String, String&gt;) it</div><div class="line">					.next();</div><div class="line">			String key = entry.getKey();</div><div class="line">			String value = entry.getValue();</div><div class="line">			System.out.println(key + <span class="string">" = "</span> + value);</div><div class="line">			</div><div class="line">		&#125;</div><div class="line">		end = System.nanoTime();</div><div class="line">		System.out.println(<span class="string">"entrySet(): "</span>+ (end - start)+<span class="string">"纳秒"</span>);</div><div class="line">		</div><div class="line">		start = System.nanoTime();</div><div class="line">		<span class="comment">//foreach entry </span></div><div class="line">		<span class="keyword">for</span>(Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</div><div class="line">			String key = entry.getKey();</div><div class="line">			String value = entry.getValue();</div><div class="line">			System.out.println(key + <span class="string">" = "</span> + value);</div><div class="line">		&#125;</div><div class="line">		end = System.nanoTime();</div><div class="line">		System.out.println(<span class="string">"for entrySet(): "</span>+ (end - start)+<span class="string">"纳秒"</span>);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">结果打印：</div><div class="line"></div><div class="line">name3 = liuguoquan3</div><div class="line">name2 = liuguoquan2</div><div class="line">name1 = liuguoquan1</div><div class="line">name0 = <span class="function">liuguoquan0</span></div><div class="line"><span class="title">keySet</span><span class="params">()</span>: 403136纳秒</div><div class="line">name3 = liuguoquan3</div><div class="line">name2 = liuguoquan2</div><div class="line">name1 = liuguoquan1</div><div class="line">name0 = <span class="function">liuguoquan0</span></div><div class="line"><span class="keyword">for</span> <span class="title">keySet</span><span class="params">()</span>: 84675纳秒</div><div class="line">name3 = liuguoquan3</div><div class="line">name2 = liuguoquan2</div><div class="line">name1 = liuguoquan1</div><div class="line">name0 = <span class="function">liuguoquan0</span></div><div class="line"><span class="title">entrySet</span><span class="params">()</span>: 109194纳秒</div><div class="line">name3 = liuguoquan3</div><div class="line">name2 = liuguoquan2</div><div class="line">name1 = liuguoquan1</div><div class="line">name0 = <span class="function">liuguoquan0</span></div><div class="line"><span class="keyword">for</span> <span class="title">entrySet</span><span class="params">()</span>: 69850纳秒</div></pre></td></tr></table></figure>
<p>从上面的结果来看：</p>
<ul>
<li>HashMap遍历，如果既需要可以也需要value,直接用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</div><div class="line">	String key = entry.getKey();</div><div class="line">	String value = entry.getValue();</div><div class="line">	System.out.println(key + <span class="string">" = "</span> + value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果只是遍历key而无需value的话，可以直接用<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(String key : map.keySet()) &#123;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>参考文章：</p>
<p><a href="http://www.importnew.com/17559.html" target="_blank" rel="external">给jdk写注释系列之jdk1.6容器(4)-HashMap源码解析</a></p>
<p><a href="http://liujiacai.net/blog/2015/09/03/java-hashmap/" target="_blank" rel="external">Java HashMap 源码解析</a></p>
<p><a href="http://www.importnew.com/16301.html" target="_blank" rel="external">HashMap的实现原理</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2015/12/19/Java集合之HashMap/" data-id="cj6f0socc007pf519uerr6lbq" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2015/12/19/Java集合之HashMap/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Collection/">Collection</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Java集合之ArrayList和LinkedList" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/18/Java集合之ArrayList和LinkedList/" class="article-date">
  <time datetime="2015-12-18T13:25:21.000Z" itemprop="datePublished">2015-12-18 21:25:21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/18/Java集合之ArrayList和LinkedList/">Java集合之ArrayList和LinkedList</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ArrayList是 Java 集合框架中使用最为普遍的集合类之一。ArrayList 是一种 List 实现，允许包括null在内的所有元素，它的内部用一个动态数组来存储元素，因此 ArrayList 能够在添加和移除元素的时候进行动态的扩展和缩减。</p>
<p>ArrayList有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。</p>
<p>ArrayList按数组下标访问元素–get(i)/set(i,e) 的性能很高，这是数组的基本优势。</p>
<p>ArrayList直接在数组末尾加入元素–add(e)的性能也高，但如果按下标插入、删除元素–add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">	<span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</div><div class="line">	<span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">Serializable</span></div></pre></td></tr></table></figure>
<h2 id="ArrayList实现"><a href="#ArrayList实现" class="headerlink" title="ArrayList实现"></a>ArrayList实现</h2><p>对应ArrayList而言，它实现List接口、底层使用数组保存所有元素，其操作基本上都是对数组的操作。下面我们来分析ArrayList的源码：</p>
<h3 id="底层数组实现"><a href="#底层数组实现" class="headerlink" title="底层数组实现"></a>底层数组实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</div></pre></td></tr></table></figure>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>ArrayList提供了三种方式的构造器：</p>
<ol>
<li>构造一个默认初始容量为10的空列表；</li>
<li>构造一个指定初始容量的空列表；</li>
<li>构造一个包含指定collection集合的元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//指定初始容量的空列表</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">	<span class="keyword">super</span>();</div><div class="line">	<span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</div><div class="line">										   initialCapacity);</div><div class="line">	<span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 初始容量为10的空列表.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">super</span>();</div><div class="line">	<span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">	elementData = c.toArray();</div><div class="line">	size = elementData.length;</div><div class="line">	<span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></div><div class="line">	<span class="keyword">if</span> (elementData.getClass() != Object[].class)</div><div class="line">		elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>ArrayList提供了set、add、addAll这些方法添加元素</p>
<h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;  </div><div class="line">    RangeCheck(index);  </div><div class="line">  </div><div class="line">    E oldValue = (E) elementData[index];  </div><div class="line">    elementData[index] = element;  </div><div class="line">    <span class="keyword">return</span> oldValue;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将指定的元素添加到此列表的尾部。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </div><div class="line">    ensureCapacity(size + <span class="number">1</span>);   </div><div class="line">    elementData[size++] = e;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">// 将指定的元素插入此列表中的指定位置。  </span></div><div class="line"><span class="comment">// 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size);  </div><div class="line">    <span class="comment">// 如果数组长度不足，将进行扩容。  </span></div><div class="line">    ensureCapacity(size+<span class="number">1</span>);  <span class="comment">// Increments modCount!!  </span></div><div class="line">    <span class="comment">// 将 elementData中从Index位置开始、长度为size-index的元素拷贝到从下标为index+1位置开始的新的elementData数组中。即将当前位于该位置的元素以及所有后续元素右移一个位置。  </span></div><div class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);  </div><div class="line">    elementData[index] = element;  </div><div class="line">    size++;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="addAll"><a href="#addAll" class="headerlink" title="addAll()"></a>addAll()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;  </div><div class="line">    Object[] a = c.toArray();  </div><div class="line">    <span class="keyword">int</span> numNew = a.length;  </div><div class="line">    ensureCapacity(size + numNew);  <span class="comment">// Increments modCount  </span></div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);  </div><div class="line">    size += numNew;  </div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 从指定的位置开始，将指定collection中的所有元素插入到此列表中。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)  </div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(  </div><div class="line">            <span class="string">"Index: "</span> + index + <span class="string">", Size: "</span> + size);  </div><div class="line">  </div><div class="line">    Object[] a = c.toArray();  </div><div class="line">    <span class="keyword">int</span> numNew = a.length;  </div><div class="line">    ensureCapacity(size + numNew);  <span class="comment">// Increments modCount  </span></div><div class="line">  </div><div class="line">    <span class="keyword">int</span> numMoved = size - index;  </div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </div><div class="line">        System.arraycopy(elementData, index, elementData, index + numNew, numMoved);  </div><div class="line">  </div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);  </div><div class="line">    size += numNew;  </div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="读取元素"><a href="#读取元素" class="headerlink" title="读取元素"></a>读取元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回此列表中指定位置上的元素。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">    RangeCheck(index);  </div><div class="line">  </div><div class="line">    <span class="keyword">return</span> (E) elementData[index];  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 移除此列表中指定位置上的元素。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">    RangeCheck(index);  </div><div class="line">  </div><div class="line">    modCount++;  </div><div class="line">    E oldValue = (E) elementData[index];  </div><div class="line">  </div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;  </div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)  </div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);  </div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work  </span></div><div class="line">  </div><div class="line">    <span class="keyword">return</span> oldValue;  </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">// 移除此列表中首次出现的指定元素（如果存在）。这是应为ArrayList中允许存放重复的元素。  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">    <span class="comment">// 由于ArrayList中允许存放null，因此下面通过两种情况来分别处理。  </span></div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)  </div><div class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;  </div><div class="line">                <span class="comment">// 类似remove(int index)，移除列表中指定位置上的元素。  </span></div><div class="line">                fastRemove(index);  </div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">            &#125;  </div><div class="line">&#125; <span class="keyword">else</span> &#123;  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)  </div><div class="line">        <span class="keyword">if</span> (o.equals(elementData[index])) &#123;  </div><div class="line">            fastRemove(index);  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意：从数组中移除元素的操作，也会导致被移除的元素以后的所有元素的向左移动一个位置。</p>
<h3 id="调整数组容量"><a href="#调整数组容量" class="headerlink" title="调整数组容量"></a>调整数组容量</h3><p>每次向ArrayList中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法ensureCapacity()来实现。在实际添加大量元素前，我们也可以使用该方法手动增加ArrayList的容量，以减少递增式再分配的数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">	<span class="comment">//是否是默认容量</span></div><div class="line">	<span class="keyword">int</span> minExpand = (elementData != EMPTY_ELEMENTDATA) ? <span class="number">0</span> : DEFAULT_CAPACITY;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</div><div class="line">		<span class="comment">//扩容</span></div><div class="line">		ensureExplicitCapacity(minCapacity);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">	modCount++;</div><div class="line"></div><div class="line">	<span class="comment">//判断是否大于当前容量</span></div><div class="line">	<span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">		grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">	<span class="comment">//</span></div><div class="line">	<span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">	<span class="comment">//扩展容量为当前容量的一半</span></div><div class="line">	<span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">	</div><div class="line">	<span class="comment">//新容量小于最小容量要求</span></div><div class="line">	<span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">		newCapacity = minCapacity;</div><div class="line">	<span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">		newCapacity = hugeCapacity(minCapacity);</div><div class="line">	<span class="comment">//</span></div><div class="line">	elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述代码可以看出，数组进行扩容时，会将老数组中的元素拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素有多少时，要在构造ArrayList实例时就指定其容量大小，以避免数组扩容的发送。或者根据实际需求，通过调用ensureCapacity()方法手动增加ArrayList实例的容量。</p>
<p>ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能，可以通过trimToSize方法来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;  </div><div class="line">    modCount++;  </div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;  </div><div class="line">    <span class="keyword">if</span> (size &lt; oldCapacity) &#123;  </div><div class="line">        elementData = Arrays.copyOf(elementData, size);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Fail-Fast机制"><a href="#Fail-Fast机制" class="headerlink" title="Fail-Fast机制"></a>Fail-Fast机制</h3><p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会抛出失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.modCount != l.modCount)</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ArrayList遍历"><a href="#ArrayList遍历" class="headerlink" title="ArrayList遍历"></a>ArrayList遍历</h2><p>有三种方法可以遍历ArrayList数组，分别是for、foreach、Iterator。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">			list.add(<span class="string">"liu"</span> + i);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// for循环  优先用这种方式</span></div><div class="line">		<span class="keyword">int</span> len = list.size();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">			System.out.println(<span class="string">"for: "</span> + list.get(i));</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// foreach语句</span></div><div class="line">		<span class="keyword">for</span> (String str : list) &#123;</div><div class="line"></div><div class="line">			System.out.println(<span class="string">"foreach: "</span> + str);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 显示调用集合迭代器</span></div><div class="line">		Iterator&lt;String&gt; it = list.iterator();</div><div class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">			System.out.println(<span class="string">"iterator while: "</span> + it.next());</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (Iterator&lt;String&gt; iterator = list.iterator(); iterator.hasNext();) &#123;</div><div class="line"></div><div class="line">			System.out.println(<span class="string">"iterator for: "</span> + iterator.next());</div><div class="line"></div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>LinkedList是一种基于链表结构的一中List，具体是基于双向循环列表设计的。</p>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</div><div class="line">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></div></pre></td></tr></table></figure>
<h2 id="LinkedList实现"><a href="#LinkedList实现" class="headerlink" title="LinkedList实现"></a>LinkedList实现</h2><h3 id="底层存储"><a href="#底层存储" class="headerlink" title="底层存储"></a>底层存储</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;  <span class="comment">//元素数量</span></div><div class="line"></div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">//链表的头结点</span></div><div class="line"></div><div class="line"><span class="keyword">transient</span> Node&lt;E&gt; last; <span class="comment">//链表的尾结点</span></div></pre></td></tr></table></figure>
<p>Node表示链表的节点对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    E item; <span class="comment">//当前存储元素</span></div><div class="line">    Node&lt;E&gt; next; <span class="comment">//下一个元素节点</span></div><div class="line">    Node&lt;E&gt; prev; <span class="comment">//上一个元素节点</span></div><div class="line"></div><div class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</div><div class="line">        <span class="keyword">this</span>.item = element;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">        <span class="keyword">this</span>.prev = prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Node是LinkedList的内部类，其中定义了当前存储的元素，以及该元素的上一个元素和下一个元素。</p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">* 构造一个空链表</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>();</div><div class="line">	addAll(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="add-1"><a href="#add-1" class="headerlink" title="add()"></a>add()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//添加到链表末尾</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">	linkLast(e);</div><div class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//在指定位置添加元素</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">	checkPositionIndex(index);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (index == size)</div><div class="line">		linkLast(element);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		linkBefore(element, node(index));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="addAll-1"><a href="#addAll-1" class="headerlink" title="addAll()"></a>addAll()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//添加一个集合</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> addAll(size, c);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//在指定位置添加一个集合</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">	checkPositionIndex(index);</div><div class="line"></div><div class="line">	Object[] a = c.toArray();</div><div class="line">	<span class="keyword">int</span> numNew = a.length;</div><div class="line">	<span class="keyword">if</span> (numNew == <span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">	Node&lt;E&gt; pred, succ;</div><div class="line">	<span class="keyword">if</span> (index == size) &#123;</div><div class="line">		succ = <span class="keyword">null</span>;</div><div class="line">		pred = last;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		succ = node(index);</div><div class="line">		pred = succ.prev;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (Object o : a) &#123;</div><div class="line">		<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</div><div class="line">		Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</div><div class="line">		<span class="keyword">if</span> (pred == <span class="keyword">null</span>)</div><div class="line">			first = newNode;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			pred.next = newNode;</div><div class="line">		pred = newNode;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</div><div class="line">		last = pred;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		pred.next = succ;</div><div class="line">		succ.prev = pred;</div><div class="line">	&#125;</div><div class="line">`</div><div class="line">	size += numNew;</div><div class="line">	modCount++;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">			<span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</div><div class="line">				unlink(x);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">			<span class="keyword">if</span> (o.equals(x.item)) &#123;</div><div class="line">				unlink(x);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</div><div class="line">	<span class="comment">// assert x != null;</span></div><div class="line">	<span class="keyword">final</span> E element = x.item;</div><div class="line">	<span class="keyword">final</span> Node&lt;E&gt; next = x.next;</div><div class="line">	<span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</div><div class="line">		first = next;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		prev.next = next;</div><div class="line">		x.prev = <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</div><div class="line">		last = prev;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		next.prev = prev;</div><div class="line">		x.next = <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	x.item = <span class="keyword">null</span>;</div><div class="line">	size--;</div><div class="line">	modCount++;</div><div class="line">	<span class="keyword">return</span> element;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">	checkElementIndex(index);</div><div class="line">	<span class="comment">//查找index对应的节点</span></div><div class="line">	Node&lt;E&gt; x = node(index);</div><div class="line">	E oldVal = x.item;</div><div class="line">	<span class="comment">//替换旧元素</span></div><div class="line">	x.item = element;</div><div class="line">	<span class="keyword">return</span> oldVal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">	checkElementIndex(index);</div><div class="line">	<span class="keyword">return</span> node(index).item;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">	<span class="comment">// assert isElementIndex(index);</span></div><div class="line"></div><div class="line">	<span class="comment">// 二分法</span></div><div class="line">	<span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">		Node&lt;E&gt; x = first;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</div><div class="line">			x = x.next;</div><div class="line">		<span class="keyword">return</span> x;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		Node&lt;E&gt; x = last;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</div><div class="line">			x = x.prev;</div><div class="line">		<span class="keyword">return</span> x;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基于双向循环链表实现的LinkedList，通过索引Index的操作时低效的，index所对应的元素越靠近中间所费时间越长。而向链表两端插入和删除元素则是非常高效的（如果不是两端的话，都需要对链表进行遍历查找）。</p>
<h1 id="ArrayList-vs-LinkedList"><a href="#ArrayList-vs-LinkedList" class="headerlink" title="ArrayList vs LinkedList"></a>ArrayList vs LinkedList</h1><ul>
<li>ArrayList底层实现是数组，LinkedList实现是链表</li>
<li>ArrayList的查找效率高于LinkedList</li>
<li>LinkedList的增删效率高于ArrayList</li>
</ul>
<p>ArrayList操作：</p>
<ul>
<li>查询操作的时间复杂度是O(1)</li>
<li>增删操作的时间复杂度是O(n)</li>
</ul>
<p>LinkedList：</p>
<ul>
<li>查询操作的时间复杂度是O(n)</li>
<li>增删操作的时间复杂度是O(1)</li>
</ul>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="ArrayList的大小是如何自动增加的？"><a href="#ArrayList的大小是如何自动增加的？" class="headerlink" title="ArrayList的大小是如何自动增加的？"></a>ArrayList的大小是如何自动增加的？</h2><p>当我们试图在ArrayList中增加一个对象时，首先会检查ArrayList的容量，已确保已存在的数组中有足够的容量来存储新的对象。如果没有足够容量的话，就会新建一个长度更长的数组（长度是原数组长度的1.5倍），然后使用Arrays.copyOf()方法将旧的数组赋值到新的数组中去，并将现有的数组引用指向新的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;  </div><div class="line">    ensureCapacity(size + <span class="number">1</span>);   </div><div class="line">    elementData[size++] = e;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">	modCount++;</div><div class="line"></div><div class="line">	<span class="comment">//判断是否大于当前容量</span></div><div class="line">	<span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">		grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">	<span class="comment">//</span></div><div class="line">	<span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">	<span class="comment">//扩展容量为当前容量的一半</span></div><div class="line">	<span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">	</div><div class="line">	<span class="comment">//新容量小于最小容量要求</span></div><div class="line">	<span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">		newCapacity = minCapacity;</div><div class="line">	<span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">		newCapacity = hugeCapacity(minCapacity);</div><div class="line">	<span class="comment">//返回一个新的数组对象，包括原数组中的内容</span></div><div class="line">	elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="什么情况下使用ArrayList？什么情况下使用LinkedList？"><a href="#什么情况下使用ArrayList？什么情况下使用LinkedList？" class="headerlink" title="什么情况下使用ArrayList？什么情况下使用LinkedList？"></a>什么情况下使用ArrayList？什么情况下使用LinkedList？</h2><p>多数情况下，当你遇到访问元素比插入或删除元素操作更频繁的时候，你应该使用ArrayList。当你遇到插入或者删除元素操作更加频繁，或者根本不需要访问元素的时候，你应该使用LinkedList。主要原因在于，在ArrayList中访问元素的最糟糕的时间复杂度为1，而在LinkedList中可能就是n；在LinkedList中插入和删除的时间复杂度为1，而在ArrayList中可能就是n。</p>
<h2 id="当传递ArrayList到某个方法中，或者某个方法返回ArrayList，什么时候要考虑安全隐患？如何修护安全违规这个问题？"><a href="#当传递ArrayList到某个方法中，或者某个方法返回ArrayList，什么时候要考虑安全隐患？如何修护安全违规这个问题？" class="headerlink" title="当传递ArrayList到某个方法中，或者某个方法返回ArrayList，什么时候要考虑安全隐患？如何修护安全违规这个问题？"></a>当传递ArrayList到某个方法中，或者某个方法返回ArrayList，什么时候要考虑安全隐患？如何修护安全违规这个问题？</h2><p>当ArrayList被当做参数传递到某个方法中，如果ArrayList在没有被复制的情况下直接被分配给成员变量，那么久可能发生这种情况，即当原始的ArrayList被改变时，传递到这个方法的数组也会改变。下面来看看实例：</p>
<p>安全隐患的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; mList;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">			list.add(<span class="string">"liu"</span> + i);</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">		setList(list);</div><div class="line">		</div><div class="line">		<span class="comment">//改变成员变量</span></div><div class="line">		mList.set(<span class="number">0</span>, <span class="string">"lee"</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(String str : mList) &#123;</div><div class="line">			System.out.println(<span class="string">"mList: "</span>+str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(String str : list) &#123;</div><div class="line">			System.out.println(<span class="string">"list: "</span> + str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(list == mList);</div><div class="line">		</div><div class="line">		<span class="comment">//改变原数组</span></div><div class="line">		list.set(<span class="number">0</span>, <span class="string">"Zhang"</span>);</div><div class="line">		<span class="keyword">for</span>(String str : mList) &#123;</div><div class="line">			System.out.println(<span class="string">"mList: "</span>+str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(String str : list) &#123;</div><div class="line">			System.out.println(<span class="string">"list: "</span> + str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(list == mList);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</div><div class="line">		mList = list;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">结果打印:</div><div class="line"></div><div class="line">mList: lee</div><div class="line">mList: liu1</div><div class="line">mList: liu2</div><div class="line">list: lee</div><div class="line">list: liu1</div><div class="line">list: liu2</div><div class="line"><span class="keyword">true</span></div><div class="line">mList: Zhang</div><div class="line">mList: liu1</div><div class="line">mList: liu2</div><div class="line">list: Zhang</div><div class="line">list: liu1</div><div class="line">list: liu2</div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>
<p>从结果可以看出，原数组和成员变量数组同时发送改变，这是因为在setList()方法中是将数组的引用赋值给了成员变量。</p>
<p>修复安全隐患后的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; mList;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">			list.add(<span class="string">"liu"</span> + i);</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">		setList(list);</div><div class="line">		</div><div class="line">		<span class="comment">//改变成员变量</span></div><div class="line">		mList.set(<span class="number">0</span>, <span class="string">"lee"</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(String str : mList) &#123;</div><div class="line">			System.out.println(<span class="string">"mList: "</span>+str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(String str : list) &#123;</div><div class="line">			System.out.println(<span class="string">"list: "</span> + str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(list == mList);</div><div class="line">		</div><div class="line">		<span class="comment">//改变原数组</span></div><div class="line">		list.set(<span class="number">0</span>, <span class="string">"Zhang"</span>);</div><div class="line">		<span class="keyword">for</span>(String str : mList) &#123;</div><div class="line">			System.out.println(<span class="string">"mList: "</span>+str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(String str : list) &#123;</div><div class="line">			System.out.println(<span class="string">"list: "</span> + str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(list == mList);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setList</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</div><div class="line">			mList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">//创建新的对象,并复制个mList</span></div><div class="line">			mList = <span class="keyword">new</span> ArrayList&lt;String&gt;(list);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">打印:</div><div class="line"></div><div class="line">mList: lee</div><div class="line">mList: liu1</div><div class="line">mList: liu2</div><div class="line">list: liu0</div><div class="line">list: liu1</div><div class="line">list: liu2</div><div class="line"><span class="keyword">false</span></div><div class="line">mList: lee</div><div class="line">mList: liu1</div><div class="line">mList: liu2</div><div class="line">list: Zhang</div><div class="line">list: liu1</div><div class="line">list: liu2</div><div class="line"><span class="keyword">false</span></div></pre></td></tr></table></figure>
<p>从结果可以看出，现在原数组和成员变量mList相互独立，改变自己的同时不会改变对方的数组内容。</p>
<blockquote>
<p>数组[]也是如此</p>
</blockquote>
<h2 id="如何复制一个ArrayList到另一个ArrayList中去"><a href="#如何复制一个ArrayList到另一个ArrayList中去" class="headerlink" title="如何复制一个ArrayList到另一个ArrayList中去?"></a>如何复制一个ArrayList到另一个ArrayList中去?</h2><ol>
<li>使用clone()方法，</li>
<li>使用ArrayList构造方法，</li>
<li>使用Collection的copy方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>&#123;</div><div class="line">	</div><div class="line">	</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">			list.add(<span class="string">"liu"</span> + i);</div><div class="line">		&#125;</div><div class="line">	</div><div class="line">		</div><div class="line">		<span class="comment">//clone()</span></div><div class="line">		ArrayList&lt;String&gt; list1 = (ArrayList&lt;String&gt;) list.clone();</div><div class="line">		</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(String str : list1) &#123;</div><div class="line">			System.out.println(<span class="string">"list1: "</span>+str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(list1 == list);</div><div class="line">		</div><div class="line">		<span class="comment">//构造方法</span></div><div class="line">		ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;(list);</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(String str : list2) &#123;</div><div class="line">			System.out.println(<span class="string">"list2: "</span>+str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(list2 == list);</div><div class="line">		</div><div class="line">		<span class="comment">//</span></div><div class="line">		ArrayList&lt;String&gt; list3 = <span class="keyword">new</span> ArrayList&lt;String&gt;(list.size());</div><div class="line">		list3.add(<span class="string">"1"</span>);</div><div class="line">		list3.add(<span class="string">"2"</span>);</div><div class="line">		list3.add(<span class="string">"3"</span>);</div><div class="line">		</div><div class="line">		Collections.copy(list3, list);</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(String str : list3) &#123;</div><div class="line">			System.out.println(<span class="string">"list3: "</span>+str);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(list3 == list);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">结果打印：</div><div class="line"></div><div class="line">list1: liu0</div><div class="line">list1: liu1</div><div class="line">list1: liu2</div><div class="line"><span class="keyword">false</span></div><div class="line">list2: liu0</div><div class="line">list2: liu1</div><div class="line">list2: liu2</div><div class="line"><span class="keyword">false</span></div><div class="line">list3: liu0</div><div class="line">list3: liu1</div><div class="line">list3: liu2</div><div class="line"><span class="keyword">false</span></div></pre></td></tr></table></figure>
<h2 id="在索引中ArrayList的增加或者删除某个对象的运行过程？效率很低吗？解释一下为什么？"><a href="#在索引中ArrayList的增加或者删除某个对象的运行过程？效率很低吗？解释一下为什么？" class="headerlink" title="在索引中ArrayList的增加或者删除某个对象的运行过程？效率很低吗？解释一下为什么？"></a>在索引中ArrayList的增加或者删除某个对象的运行过程？效率很低吗？解释一下为什么？</h2><p>在ArrayList中增加或删除元素的时候要调用System.arrayCopy()这个数值拷贝函数，每次增加或删除元素都要进行数组的拷贝操作，相对效率较低。如果遇到频繁插入或删除操作的时候，可以考虑使用LinkedList来代替。</p>
<p>在ArrayList的某个索引i处添加元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    rangeCheckForAdd(index);</div><div class="line"></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</div><div class="line">                     size - index);</div><div class="line">    elementData[index] = element;</div><div class="line">    size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在ArrayList的某个索引i处删除元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2015/12/18/Java集合之ArrayList和LinkedList/" data-id="cj6f0soc7007ff519rikf9iz6" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2015/12/18/Java集合之ArrayList和LinkedList/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Collection/">Collection</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Java集合之Arrays和Collections" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/18/Java集合之Arrays和Collections/" class="article-date">
  <time datetime="2015-12-18T13:22:21.000Z" itemprop="datePublished">2015-12-18 21:22:21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/18/Java集合之Arrays和Collections/">Java集合之Arrays和Collections</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h1><p>java.util.Arrays</p>
<p><a href="http://www.apihome.cn/api/java/Arrays.html" target="_blank" rel="external">Arrays详细介绍</a></p>
<p>Array是Java特有的数组。在你知道所要处理数据元素个数的情况下非常好用。java.util.Arrays 包含了许多处理数据的实用方法：</p>
<p>Arrays.asList：可以从 Array 转换成 List。可以作为其他集合类型构造器的参数。</p>
<p>Arrays.binarySearch：在一个已排序的或者其中一段中快速查找。</p>
<p>Arrays.copyOf：如果你想扩大数组容量又不想改变它的内容的时候可以使用这个方法。</p>
<p>Arrays.copyOfRange：可以复制整个数组或其中的一部分。</p>
<p>Arrays.deepEquals、Arrays.deepHashCode：Arrays.equals/hashCode的高级版本，支持子数组的操作。</p>
<p>Arrays.equals：如果你想要比较两个数组是否相等，应该调用这个方法而不是数组对象中的 equals方法（数组对象中没有重写equals()方法，所以这个方法之比较引用而不比较内容）。这个方法集合了Java 5的自动装箱和无参变量的特性，来实现将一个变量快速地传给 equals() 方法——所以这个方法在比较了对象的类型之后是直接传值进去比较的。</p>
<p>Arrays.fill：用一个给定的值填充整个数组或其中的一部分。</p>
<p>Arrays.hashCode：用来根据数组的内容计算其哈希值（数组对象的hashCode()不可用）。这个方法集合了Java 5的自动装箱和无参变量的特性，来实现将一个变量快速地传给 Arrays.hashcode方法——只是传值进去，不是对象。</p>
<p>Arrays.sort：对整个数组或者数组的一部分进行排序。也可以使用此方法用给定的比较器对对象数组进行排序。</p>
<p>Arrays.toString：打印数组的内容。</p>
<p>如果想要复制整个数组或其中一部分到另一个数组，可以调用 System.arraycopy方法。此方法从源数组中指定的位置复制指定个数的元素到目标数组里。这无疑是一个简便的方法。（有时候用 ByteBuffer bulk复制会更快。可以参考这篇文章）.</p>
<p>最后，所有的集合都可以用T[] Collection.toArray( T[] a ) 这个方法复制到数组中。通常会用这样的方式调用：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">return</span> coll.toArray( <span class="keyword">new</span> T[ coll.<span class="built_in">size</span>() ] );</div></pre></td></tr></table></figure></p>
<p>这个方法会分配足够大的数组来储存所有的集合，这样 toArray 在返回值时就不必再分配空间了。</p>
<h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><p>java.util.Collections</p>
<p><a href="http://www.apihome.cn/api/java/Collections.html" target="_blank" rel="external">Collections详细介绍</a></p>
<p>就像有专门的java.util.Arrays来处理数组，Java中对集合也有java.util.Collections来处理。</p>
<p>第一组方法主要返回集合的各种数据：</p>
<p>Collections.checkedCollection / checkedList / checkedMap / checkedSet / checkedSortedMap / checkedSortedSet：检查要添加的元素的类型并返回结果。任何尝试添加非法类型的变量都会抛出一个ClassCastException异常。这个功能可以防止在运行的时候出错。//fixme</p>
<p>Collections.emptyList / emptyMap / emptySet ：返回一个固定的空集合，不能添加任何元素。</p>
<p>Collections.singleton / singletonList / singletonMap：返回一个只有一个入口的 set/list/map 集合。</p>
<p>Collections.synchronizedCollection / synchronizedList / synchronizedMap / synchronizedSet / synchronizedSortedMap / synchronizedSortedSet：获得集合的线程安全版本（多线程操作时开销低但不高效，而且不支持类似put或update这样的复合操作）</p>
<p>Collections.unmodifiableCollection / unmodifiableList / unmodifiableMap / unmodifiableSet / unmodifiableSortedMap / unmodifiableSortedSet：返回一个不可变的集合。当一个不可变对象中包含集合的时候，可以使用此方法。</p>
<p>第二组方法中，其中有一些方法因为某些原因没有加入到集合中：</p>
<p>Collections.addAll：添加一些元素或者一个数组的内容到集合中。</p>
<p>Collections.binarySearch：和数组的Arrays.binarySearch功能相同。</p>
<p>Collections.disjoint：检查两个集合是不是没有相同的元素。</p>
<p>Collections.fill：用一个指定的值代替集合中的所有元素。</p>
<p>Collections.frequency：集合中有多少元素是和给定元素相同的。</p>
<p>Collections.indexOfSubList / lastIndexOfSubList：和String.indexOf(String) / lastIndexOf(String)方法类似——找出给定的List中第一个出现或者最后一个出现的子表。</p>
<p>Collections.max / min：找出基于自然顺序或者比较器排序的集合中，最大的或者最小的元素。</p>
<p>Collections.replaceAll：将集合中的某一元素替换成另一个元素。</p>
<p>Collections.reverse：颠倒排列元素在集合中的顺序。如果你要在排序之后使用这个方法的话，在列表排序时，最好使用Collections.reverseOrder比较器。</p>
<p>Collections.rotate：根据给定的距离旋转元素。</p>
<p>Collections.shuffle：随机排放List集合中的节点，可以给定你自己的生成器——例如java.util.Random / java.util.ThreadLocalRandom or java.security.SecureRandom。</p>
<p>Collections.sort：将集合按照自然顺序或者给定的顺序排序。</p>
<p>Collections.swap：交换集合中两个元素的位置（多数开发者都是自己实现这个操作的）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2015/12/18/Java集合之Arrays和Collections/" data-id="cj6f0soc9007if519t61eshd5" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2015/12/18/Java集合之Arrays和Collections/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Collection/">Collection</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/22/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="page-number" href="/page/22/">22</a><span class="page-number current">23</span><a class="page-number" href="/page/24/">24</a><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/24/">下一页&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/06/21/JavaScript⑦对象/">JavaScript⑦对象</a>
          </li>
        
          <li>
            <a href="/2017/06/19/JavaScript⑥引用类型RegExp/">JavaScript⑥引用类型RegExp</a>
          </li>
        
          <li>
            <a href="/2017/06/19/JavaScript⑥引用类型Global/">JavaScript⑥引用类型Global</a>
          </li>
        
          <li>
            <a href="/2017/06/19/JavaScript⑥引用类型Date/">JavaScript⑥引用类型Date</a>
          </li>
        
          <li>
            <a href="/2017/06/19/JavaScript⑥引用类型Array/">JavaScript⑥引用类型Array</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2017 刘涤生&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;michaelliu0727@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/categories" class="mobile-nav-link">分类</a>
  
    <a href="/tags" class="mobile-nav-link">标签</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>
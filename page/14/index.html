<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>再读斋</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="像外行一样思考,像专家一样实践。">
<meta property="og:type" content="website">
<meta property="og:title" content="再读斋">
<meta property="og:url" content="http://liuguoquan727.github.io/page/14/index.html">
<meta property="og:site_name" content="再读斋">
<meta property="og:description" content="像外行一样思考,像专家一样实践。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="再读斋">
<meta name="twitter:description" content="像外行一样思考,像专家一样实践。">
  
    <link rel="alternate" href="/atom.xml" title="再读斋" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liuguoquan727.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/categories">分类</a>
        
          <a class="main-nav-link" href="/tags">标签</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">再读斋</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">MICHAEL</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Android设计模式(四)工厂方法模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/07/Android设计模式(四)工厂方法模式/" class="article-date">
  <time datetime="2016-06-07T12:34:01.000Z" itemprop="datePublished">2016-06-07 20:34:01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/07/Android设计模式(四)工厂方法模式/">Android设计模式(四)工厂方法模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>工厂方法模式是创建型设计模式之一。工厂方法模式是一种结构简单的模式。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>定义一个用于创建对象的接口，让子类决定实例化哪个类。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>在任何需要生成复杂对象的地方，都可以使用工厂方法模式。复杂对象适合使用工厂模式，用new就可以完成创建的对象无需使用工厂对象。</p>
<h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><p>UML类图如下：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/uml-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95UML%E7%B1%BB%E5%9B%BE.png" alt=""></p>
<p>这里的角色主要分为四个模块：</p>
<ol>
<li>抽象工厂Factory，其为工厂方法的核心；</li>
<li>具体工厂ConcreteFactory，实现了具体的业务逻辑；</li>
<li>抽象产品Product，是工厂方法模式所创建的产品的父类；</li>
<li>具体产品ConcreteFactory，实现抽象产品的某个具体产品的对象；</li>
</ol>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>小明是一家汽车厂的厂长，对他来说，组装汽车就是讲一些进口的核心部件，比如发动机和一些零部件组装起来，小明的汽车厂主要组装某款SUV车型，比如Q3、Q5，对于这类车型来说内部结构差异并不是很大，因此小明只需要一条生产线就足以应付这2种车型，对于该类生产线小明提供一个抽象类定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 抽象生产线类</div><div class="line"> * <span class="doctag">@author</span> Administrator</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiFactory</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 某车型的工厂方法</div><div class="line">	 * <span class="doctag">@param</span> clz 具体的车型类</div><div class="line">	 * <span class="doctag">@return</span> 具体型号的车对象</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends AudiCar&gt; <span class="function">T <span class="title">createAudiCar</span><span class="params">(Class&lt;T&gt; clz)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生产线的具体实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 生产线具体类</div><div class="line"> * <span class="doctag">@author</span> Administrator</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiCarFactory</span> <span class="keyword">extends</span> <span class="title">AudiFactory</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="keyword">public</span> &lt;T extends AudiCar&gt; <span class="function">T <span class="title">createAudiCar</span><span class="params">(Class&lt;T&gt; clz)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		AudiCar car = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">			car = (AudiCar) Class.forName(clz.getName()).newInstance();</div><div class="line"></div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> (T) car;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于这两种车型，除了一些车的基本共性之外，还提供了自动导航功能，这些都使用一个抽象的基本类来声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 汽车的抽象产品类</div><div class="line"> * <span class="doctag">@author</span> Administrator</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiCar</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 行为方法，车可以驾驶</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 行为方法，车可以自动导航</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">selfNavigation</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来就是具体的车型了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiQ3</span> <span class="keyword">extends</span> <span class="title">AudiCar</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(<span class="string">"Q3 run"</span>);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfNavigation</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(<span class="string">"Q3 navi"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudiQ5</span> <span class="keyword">extends</span> <span class="title">AudiCar</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(<span class="string">"Q5 run"</span>);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfNavigation</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(<span class="string">"Q5 navi"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后我们将各个类组装起来形成一条完整的流水线：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">		AudiFactory factory = <span class="keyword">new</span> AudiCarFactory();</div><div class="line"></div><div class="line">		AudiQ3 audiQ3 = factory.createAudiCar(AudiQ3.class);</div><div class="line">		audiQ3.drive();</div><div class="line">		audiQ3.selfNavigation();</div><div class="line"></div><div class="line">		AudiQ5 audiQ5 = factory.createAudiCar(AudiQ5.class);</div><div class="line">		audiQ5.drive();</div><div class="line">		audiQ5.selfNavigation();</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">结果打印：</div><div class="line"></div><div class="line">Q3 run</div><div class="line">Q3 navi</div><div class="line">Q5 run</div><div class="line">Q5 navi</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总的来说，工厂方法模式是一个很好的设计模式，但是也存在缺点，就是每次我们为工厂方法模式添加新的产品时就要编写一个新的产品类，同时还要引入抽象层，这必然导致类结构的复杂化，所以工作中需要权衡。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2016/06/07/Android设计模式(四)工厂方法模式/" data-id="cj6f2gfln002l4h19zgmdkthc" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2016/06/07/Android设计模式(四)工厂方法模式/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Android设计模式之(三)原型模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/04/Android设计模式之(三)原型模式/" class="article-date">
  <time datetime="2016-06-04T14:34:01.000Z" itemprop="datePublished">2016-06-04 22:34:01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/04/Android设计模式之(三)原型模式/">Android设计模式之(三)原型模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>原型模式是一种创建型的模式。原型表示该模式有一个样板实例，用户从这个样板对象中复制出一个内部属性一致的对象，被复制的实例就称为原型。原型模式多用于创复杂的或者构造耗时的实例，因为这种情况下，复制一个已经存在的实例可以使程序运行更高效。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ol>
<li>类初始化需要消耗非常多的资源，包括数据、硬件资源等，通过原型拷贝避免这些消耗。</li>
<li>通过new产生一个对象需要非常繁琐的数据准备或访问权限，这时可以使用原型模式。</li>
<li>一个对象需要提供给其他对象访问，而且各个调用者可能需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。</li>
</ol>
<p>需要注意的是，通过实现Cloneable接口的原型模式在调用clone函数构造实例时并不一定比通过new操作速度快，只有当通过new构造对象较为耗时或者资源消耗比较大时，通过clone方法才能获得效率上的提升。因此，使用Cloneable时需要考虑构建对象的成本以及做一些效率上的测试。当然，实现原型模式也并不一定非要实现Cloneable接口，也有其他的实现方式。</p>
<h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><p>原型模式的UML类图如下：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/uml-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8FUML%E7%B1%BB%E5%9B%BE.png" alt="原型模式的UML类图"></p>
<p>角色介绍：</p>
<ul>
<li>Client：客户端用户</li>
<li>Prototype：抽象类或者接口，声明具clone的能力</li>
<li>ConcretePrototype：具体的原型类</li>
</ul>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>下面以简单的文档拷贝为例来演示一下简单的原型模式，例子中首先创建一个文档对象，即WordDocument，这个文档包括文字和图片。用户经过产时间的内容编辑后，打开该文档做进一步的编辑，但是这个文档编辑后是否被采用还不确定，因此为了安全起见，用户需要将当前文档拷贝一份，然后再在这个文档副本上进行修改。如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.lgq.pattern.prototype;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 文档类型，扮演的是ConcretePrototype角色，而Cloneable是代表Prototype角色</div><div class="line"> * <span class="doctag">@author</span> liuguoquan</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordDocument</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//文本</span></div><div class="line">	<span class="keyword">private</span> String text;</div><div class="line"></div><div class="line">	<span class="comment">//图片名列表</span></div><div class="line">	<span class="keyword">private</span> ArrayList&lt;String&gt; images = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WordDocument</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">		System.out.println(<span class="string">"---WordDocument构造函数---"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> text;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.text = text;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">getImages</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> images;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addImage</span><span class="params">(String image)</span> </span>&#123;</div><div class="line">		images.add(image);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> WordDocument <span class="title">clone</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">			WordDocument document = (WordDocument) <span class="keyword">super</span>.clone();</div><div class="line">			document.text = <span class="keyword">this</span>.text;</div><div class="line">			<span class="comment">//浅拷贝</span></div><div class="line">			document.images = <span class="keyword">this</span>.images;</div><div class="line">			<span class="comment">//深拷贝</span></div><div class="line"><span class="comment">//			document.images = (ArrayList&lt;String&gt;) this.images.clone();</span></div><div class="line">			<span class="keyword">return</span> document;</div><div class="line"></div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"WordDocument [text="</span> + text + <span class="string">", images="</span> + images + <span class="string">"]"</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">package</span> com.lgq.pattern.prototype;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">		WordDocument document = <span class="keyword">new</span> WordDocument();</div><div class="line">		document.setText(<span class="string">"这是一篇文档"</span>);</div><div class="line">		document.addImage(<span class="string">"image1"</span>);</div><div class="line">		document.addImage(<span class="string">"image2"</span>);</div><div class="line">		System.out.println(document.toString());</div><div class="line"></div><div class="line">		<span class="comment">//拷贝一份副本</span></div><div class="line">		WordDocument document2 = document.clone();</div><div class="line">		System.out.println(document2.toString());</div><div class="line">		<span class="comment">//修改文档副本，不会影响原始文档</span></div><div class="line">		document2.setText(<span class="string">"这是修改过的document2文档"</span>);</div><div class="line">		System.out.println(document2.toString());</div><div class="line"></div><div class="line">		System.out.println(document.toString());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">打印结果：</div><div class="line"></div><div class="line">---WordDocument构造函数---</div><div class="line">WordDocument [text=这是一篇文档, images=[image1, image2]]</div><div class="line">WordDocument [text=这是一篇文档, images=[image1, image2]]</div><div class="line">WordDocument [text=这是修改过的document2文档, images=[image1, image2]]</div><div class="line">WordDocument [text=这是一篇文档, images=[image1, image2]]</div></pre></td></tr></table></figure>
<p>需要注意的是，<strong>上述的例子中WordDocument的构造函数只运行了一次，通过clone拷贝对象时并不会执行构造函数！</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>原型模式本质上是对象拷贝，容易出现的问题是深拷贝、浅拷贝。使用原型模式可以解决构建复杂对象的资源消耗问题，能够在某些场景下提升创建对象的效率。还有一个重要用途就是保护性拷贝，也就是某个对象对外可能是只读的，为了防止外部对这个只读对象修改，通过可以通过返回一个对象拷贝的形式实现只读的限制。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>原型模式是在内存中二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>直接在内存中拷贝时，构造函数是不会执行的，在实际开发中应该注意这个潜在的问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2016/06/04/Android设计模式之(三)原型模式/" data-id="cj6f2gflr002w4h19daa0w21h" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2016/06/04/Android设计模式之(三)原型模式/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Android设计模式之(二)Builder模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/03/Android设计模式之(二)Builder模式/" class="article-date">
  <time datetime="2016-06-03T13:34:01.000Z" itemprop="datePublished">2016-06-03 21:34:01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/03/Android设计模式之(二)Builder模式/">Android设计模式之(二)Builder模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Builder模式是一步一步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，更精细地控制对象的构造流程。该模式是为了将构建复杂对象的过程和它的部件解耦，使得构建过程和部件的表示隔离开来。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ol>
<li>相同的方法，不同的执行顺序，产生不同的事件结果时；</li>
<li>多个部件或零件都可以装配到一个对象中，但是产生的运行结果又不相同时；</li>
<li>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用，这个时候使用建造者模式非常适合；</li>
<li>当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值的情况下；</li>
</ol>
<h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><p>UML类图角色介绍：</p>
<ul>
<li>Product产品类-产品的抽象类；</li>
<li>Builder-抽象Builder类，规范产品的组建，一般由子类实现具体的组件过程；</li>
<li>ConcreteBuilder-具体的Builder类,组装对象；</li>
</ul>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/uml-Builder%E6%A8%A1%E5%BC%8FUML%E7%B1%BB%E5%9B%BE.png" alt="Builder模式UML"></p>
<h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.lgq.pattern.builder;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Computer抽象类 即 Product角色</div><div class="line"> * <span class="doctag">@author</span> liuguoquan</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">protected</span> String mBoard;</div><div class="line">	<span class="keyword">protected</span> String mDisplay;</div><div class="line">	<span class="keyword">protected</span> String mOS;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//设置主板</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBoard</span><span class="params">(String mBoard)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.mBoard = mBoard;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//设置显示器</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDisplay</span><span class="params">(String mDisplay)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.mDisplay = mDisplay;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//设置操作系统</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setOs</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="string">"Computer [mBoard="</span> + mBoard + <span class="string">", mDisplay="</span> + mDisplay + <span class="string">", mOS="</span> + mOS + <span class="string">"]"</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.lgq.pattern.builder;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 具体的Computer类</div><div class="line"> * <span class="doctag">@author</span> liuguoquan</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MacBookPro</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MacBookPro</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOs</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		mOS = <span class="string">"Mac OS X 10.11"</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.lgq.pattern.builder;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 抽象Builder</div><div class="line"> * <span class="doctag">@author</span> liuguoquan</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Builder <span class="title">setBoard</span><span class="params">(String board)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Builder <span class="title">setDisplay</span><span class="params">(String display)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Builder <span class="title">setOs</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title">create</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.lgq.pattern.builder;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Builder具体实现类</div><div class="line"> * <span class="doctag">@author</span> liuguoquan</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MacBookBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Computer mComputer = <span class="keyword">new</span> MacBookPro();</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Builder <span class="title">setBoard</span><span class="params">(String board)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		mComputer.setBoard(board);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Builder <span class="title">setDisplay</span><span class="params">(String display)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		mComputer.setDisplay(display);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Builder <span class="title">setOs</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		mComputer.setOs();</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Computer <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> mComputer;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">		Computer computer = <span class="keyword">new</span> MacBookBuilder().setBoard(<span class="string">"APPLE"</span>).setDisplay(<span class="string">"Retina"</span>).setOs().create();</div><div class="line"></div><div class="line">		System.out.println(computer.toString());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">结果打印：</div><div class="line"></div><div class="line">Computer [mBoard=APPLE, mDisplay=Retina, mOS=Mac OS X <span class="number">10.11</span>]</div></pre></td></tr></table></figure>
<p>上述示例中，通过具体的MacBookBuilder来构建MacBookPro对象，Builder将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的对象。</p>
<h1 id="Android中应用"><a href="#Android中应用" class="headerlink" title="Android中应用"></a>Android中应用</h1><ul>
<li>AlertDialog</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>良好的封装性，使用建造者模式可以使得客户端不必知道产品内部组成的细节。</li>
<li>建造者独立，容易扩展</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>会产生多余的Builder对象，消耗内存。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2016/06/03/Android设计模式之(二)Builder模式/" data-id="cj6f2gfls002z4h19r9ncooou" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2016/06/03/Android设计模式之(二)Builder模式/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Android设计模式之(一)单例模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/03/Android设计模式之(一)单例模式/" class="article-date">
  <time datetime="2016-06-03T12:34:01.000Z" itemprop="datePublished">2016-06-03 20:34:01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/03/Android设计模式之(一)单例模式/">Android设计模式之(一)单例模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>单例模式是应用最广的模式之一，在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个全局对象，这样有利于我们协调系统整体的行为。如在一个应用中，应该只有一个ImageLoader实例，这个ImageLoader中又含有线程池、缓存系统、网络请求等，很消耗资源。因此不应该让它构造多个实例。这样不能自由构造对象的情况，就是单例模式的使用场景。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>确保某个类有且只要一个对象的场景，避免产生多个对象消耗过多的资源，或者某种类型的对象只应该有且只有一个。例如，创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源，这时就要考虑使用单例模式。</p>
<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p>单例模式的UML类图如下：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/uml-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<p>角色介绍：</p>
<ul>
<li>Client：高层客户端</li>
<li>Singleton：单例类</li>
</ul>
<p>实现单例模式主要有以下几个关键点：</p>
<ul>
<li>构造函数不对外开放，一般为private；</li>
<li>通过一个静态方法或者枚举返回单例类对象；</li>
<li>确保单例类的对象有且只有一个，尤其是在多线程环境下；</li>
<li>确保单例类对象在反序列化时不会重新构建对象；</li>
</ul>
<p>单例模式中实现比较困难的是在多线程环境下构造单例类的对象有且只有一个。</p>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>单例模式在设计模式中是结构比较简单的，只有一个单例类，没有其他层次结构和抽象。该模式需要确保该类只能生成一个对象，通常是该类需要消耗较多的资源或者没有对个实例的情况。例如一个公司只有一个CEO、一个应用只有一个Application对象等。</p>
<p>下面以公司里的CEO为例来简单演示一下，一个公司可以有多个VP、无数个员工，但只有一个CEO，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * </div><div class="line"> * 普通员工</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Staff</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">//干活</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//副总裁</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VP</span> <span class="keyword">extends</span> <span class="title">Staff</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 管理下面的经理</span></div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//CEO，饿汉式单例</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CEO</span> <span class="keyword">extends</span> <span class="title">Staff</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CEO mCEO = <span class="keyword">new</span> CEO();</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">CEO</span><span class="params">()</span> </span>&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//公有的静态函数，对外暴露获取单例对象的接口</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CEO <span class="title">getCeo</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> mCEO;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 管理VP</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//公司类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> List&lt;Staff&gt; mStaffs = <span class="keyword">new</span> ArrayList&lt;Staff&gt;();</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStaff</span><span class="params">(Staff staff)</span> </span>&#123;</div><div class="line">		mStaffs.add(staff);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showStaffs</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span>(Staff staff : mStaffs) &#123;</div><div class="line">			System.out.println(<span class="string">"Obj: "</span> + staff.toString());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		</div><div class="line">		Company company = <span class="keyword">new</span> Company();</div><div class="line">		</div><div class="line">		<span class="comment">//CEO对象只能通过getCeo获取</span></div><div class="line">		Staff ceo1 = CEO.getCeo();</div><div class="line">		Staff ceo2 = CEO.getCeo();</div><div class="line">		company.addStaff(ceo1);</div><div class="line">		company.addStaff(ceo2);</div><div class="line">		</div><div class="line">		Staff vp1 = <span class="keyword">new</span> VP();</div><div class="line">		Staff vp2 = <span class="keyword">new</span> VP();</div><div class="line">		company.addStaff(vp1);</div><div class="line">		company.addStaff(vp2);</div><div class="line">		</div><div class="line">		Staff staff1 = <span class="keyword">new</span> Staff();</div><div class="line">		Staff staff2 = <span class="keyword">new</span> Staff();</div><div class="line">		</div><div class="line">		company.addStaff(staff1);</div><div class="line">		company.addStaff(staff2);</div><div class="line"></div><div class="line">		company.showStaffs();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>运行输出结果如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Obj</span>: com.liuguoquan.design.single.CEO<span class="variable">@15db9742</span></div><div class="line"><span class="attribute">Obj</span>: com.liuguoquan.design.single.CEO<span class="variable">@15db9742</span></div><div class="line"><span class="attribute">Obj</span>: com.liuguoquan.design.single.VP<span class="variable">@6d06d69c</span></div><div class="line"><span class="attribute">Obj</span>: com.liuguoquan.design.single.VP<span class="variable">@7852e922</span></div><div class="line"><span class="attribute">Obj</span>: com.liuguoquan.design.single.Staff<span class="variable">@4e25154f</span></div><div class="line"><span class="attribute">Obj</span>: com.liuguoquan.design.single.Staff<span class="variable">@70dea4e</span></div></pre></td></tr></table></figure>
<p>从上面代码可以看出，CEO类不能通过new的形式构造函数，只能通过CEO.getCeo()方法来获取，而这个CEO对象是静态对象，并且在声明的时候就已经初始化，这就保证类CEO对象的唯一性。</p>
<p>从输出结果中可以看出，CEO两次输出的CEO对象的地址都一样，说明是同一个CEO对象；而VP、Staff等类型的对象都是不同的。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>饿汉式模式是在声明静态对象时就已经初始化，这种方式简单粗暴，如果单例对象初始化非常快，而且占用内存小的时候这种方式是比较适合的，可以直接在应用启动时加载初始化。实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>懒汉模式是声明一个静态对象，并且在用户第一次调用getInstance时进行初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span>(Singleton.class) &#123;</div><div class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">                instance = <span class="keyword">new</span> Singleton();</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getInstance方法中添加了Synchronized关键字，也就是同步类synchronized关键字包含的代码块，这就是上面所说的在多线程中保证单例对象唯一性的手段。但是仍存在一个问题，<strong>即使instance已经初始化，每次调用getInstance方法都会进行同步，这样会消耗不必要的资源，这也是懒汉式存在的最大问题</strong>。</p>
<p>懒汉单例模式的优点是只有在使用时才会被实例化，在一定程度上节约了资源，缺点是第一次加载时需要及时进行实例化，反应稍慢，最大问题是每次调用geInstance都进行同步，造成不必要的同步开销，这样模式一般不建议使用。</p>
<h3 id="Double-CheckLock-双重校验锁"><a href="#Double-CheckLock-双重校验锁" class="headerlink" title="Double CheckLock(双重校验锁)"></a>Double CheckLock(双重校验锁)</h3><p>DCL方式的优点是既能够在需要时才初始化单例，又能够保证线程的安全，且单例对象初始化后调用getInstance不获取同步锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//private static volatile Singleton instance = null;</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//如果已经初始化，不需要每次获取同步锁</span></div><div class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</div><div class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">                    instance = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到getInstance方法对instance进行了两次判空：第一层判断主要是为了避免不必要的同步，第二层判断主要则是为了在null的情况下创建实例。下面，我们来分析一下：</p>
<p>假设线程A执行到instance=new Singleton()语句，这里看起来是一句代码，但实际上它并不是一个原子操作，这局代码最终会被编译成多条汇编指令，它大致做了3件事情：</p>
<ol>
<li>给Singleton的实例分配内存</li>
<li>调用Singleton()的 构造函数，初始化字段成员</li>
<li>将instance对象执行分配的内存空间（此时instance就不是null了）</li>
</ol>
<p>但是，由于Java编译器运行处理器乱序执行，以及jdk1.5之前Java内存模型中Cache、寄存器到主内存会写顺序的规定，上面的第二和第三的顺序是无法保证的。也就是说，执行顺序可能是1-2-3也可能是1-3-2.如果是后者，并且在3执行完毕、2未执行之前，被切换到线程B上，这时候instance因为已经在线程A内执行3了，instance已经是非null，所有线程B直接取走instance，再使用时就会出错，这就是DCL失效问题，而且这种难以跟踪难以重现的问题很可能会隐藏很久。</p>
<p>在jdk1.5之后，官方已经注意到这种问题，调整了JMM、具体化了volatile关键字，因此，如果是1.5或之后的版本，只需要将instance的定义改成<code>private static volatile Singleton instance = null;</code>就可以保证instance对象每次都是从主内存中读取，就可以使用DCL的写法来完成单例模式。当然，volatile多少会影响到性能，但考虑到程序的正确性，牺牲这点性能还是值得的。</p>
<p>DCL的优点：资源利用率高，第一次执行getInstance时单例对象才会被实例化，效率高。</p>
<p>缺点：第一次加载稍慢，也由于Java内存模型的原因偶尔会失败。在高并发的环境下也有一定的缺陷，虽然概率发生很小。</p>
<blockquote>
<p>DCL模式是使用最多的单例实现模式，它能够在需要时才实例化单例对象，并且能够在绝大多数场景下保证单例对象的唯一性，除非你的代码在并发场景比较复杂或者低于jdk1.6版本下使用，否则这种方式一般能够满足需求。</p>
</blockquote>
<h3 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h3><p>在《Java并发编程实战》中谈到不赞成使用DCL的优化方式，而建议使用如下代码替代：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonHolder.instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//静态内部类</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当第一次加载Singleton类时并不会初始化instance，只有第一次调用Singleton的getInstance方法时才会导致instance被初始化。因此，第一次调用getInstance方法会导致虚拟机加载SingletonHolder类，这种方式不仅能够确保线程安全，也能够保证单例对象的唯一性，同时也延迟了单例的实例化，所以这是推荐使用的单例模式实现方式。</p>
<h3 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</div><div class="line"></div><div class="line">    <span class="comment">//定义一个枚举的元素，它就是Singleton的一个实例</span></div><div class="line">    INSTANCE;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">   Singleton singleton = Singleton.instance;</div><div class="line">   singleton.doSomething();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>写法简单是枚举单例最大的优点，枚举在Java中与普通的类是一样的，不仅能够有字段，还能够有自己的方法。最重要的是默认枚举实例的创建时线程安全的，并且在任何情况下它都是一个单例。</p>
<p>为什么这么说呢？在上述的几种单例模式实现中，在一个情况下它们会出现重新创建对象的情况，那就是反序列化。</p>
<p>通过序列化可以将一个单例的实例对象写到磁盘，然后再读回来，从而有效地获得一个实例。即使构造函数时私有的，反序列化时依然可以通过特殊的途径去创建类的一个新的实例，相当于调用该类的构造函数。反序列化操作提供一个很特别的钩子函数，类中具有一个私有的、被实例化的方法readResolve()，这个方法可以让开发人员控制对象的反序列化。例如，上述几个实例中如果要杜绝单例对象在被反序列化时重新生成对象，那么必须加入如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</div><div class="line">	<span class="keyword">return</span> instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是在readResolve方法中将instance对象返回，而不是默认的重新生成一个新的对象。而对于枚举并不存在这样的问题，因为即使反序列化它也不会重新生成新的实例。</p>
<h3 id="容器管理单例"><a href="#容器管理单例" class="headerlink" title="容器管理单例"></a>容器管理单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; objMap = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key,Object instance)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!objMap.containsKey(key)) &#123;</div><div class="line">            objMap.put(key);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> objMap.get(key);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在程序的初始，将多种单例类注入到一个统一的管理类中，在使用根据key获取对应类型的对象，这种方式使得我们可以管理很多类型的单例，并且在使用它们的时候可以通过统一的接口进行获取操作操作，降低用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单例模式是运用频率很高的模式，但是，由于在客户端通常没有高并发的情况，因此，选择哪种实现方式并不会有太大的影响。即便如此，出于效率考虑，推荐使用双重校验锁和静态内部类单例模式。</p>
<p><strong>优点</strong></p>
<ul>
<li><p>由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁创建、销毁时，而且创建或者销毁时性能又无法优化，单例模式的优势就非常明显。</p>
</li>
<li><p>由于单例模式只生成一个实例，所以，减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永驻内存的方式解决。</p>
</li>
<li><p>单例模式可以避免对资源的多重占用，例如一个写文件操作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。</p>
</li>
<li><p>单例模式可以在系统设置全局访问点，优化和共享资源访问，例如，可以设计一个单例类，负责所有数据表的映射处理。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本没有第二种途径可以实现。</p>
</li>
<li><p>在Android中，单例对象如果持有Context，那么很容易引发内存泄露，此时需要注意传给单例对象的Context最好是Application Context。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2016/06/03/Android设计模式之(一)单例模式/" data-id="cj6f2gfln002o4h19vbv2ctq7" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2016/06/03/Android设计模式之(一)单例模式/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Android Context详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/02/Android Context详解/" class="article-date">
  <time datetime="2016-06-02T13:20:28.000Z" itemprop="datePublished">2016-06-02 21:20:28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/02/Android Context详解/">Android Context详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Activity可以new吗？Android的应用程序开发采用Java语言，Activity本质上也是一个对象，那Activity activity = new Activity()这种写法有什么问题吗？Android应用模型是基于组件的设计模式，组件的运行需要有一个完整的Android工程环境，在这个环境下，Activity、Service等系统组件才能够正常工作，而这些组件并不能采用普通的Java对象创建方式，new一下就能创建实例，而是要有它们各自的上下文环境，也就是我们要介绍的Context。可以这样讲，Context是维持Android程序中各组件能够正常工作的一个核心功能类。</p>
<h1 id="源码中的Context"><a href="#源码中的Context" class="headerlink" title="源码中的Context"></a>源码中的Context</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Interface to global information about an application environment.  This is</div><div class="line"> * an abstract class whose implementation is provided by</div><div class="line"> * the Android system.  It</div><div class="line"> * allows access to application-specific resources and classes, as well as</div><div class="line"> * up-calls for application-level operations such as launching activities,</div><div class="line"> * broadcasting and receiving intents, etc.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * File creation mode: the default mode, where the created file can only</div><div class="line">     * be accessed by the calling application (or all applications sharing the</div><div class="line">     * same user ID).</div><div class="line">     * <span class="doctag">@see</span> #MODE_WORLD_READABLE</div><div class="line">     * <span class="doctag">@see</span> #MODE_WORLD_WRITEABLE</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_PRIVATE = <span class="number">0x0000</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_WORLD_WRITEABLE = <span class="number">0x0002</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_APPEND = <span class="number">0x8000</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MULTI_PROCESS = <span class="number">0x0004</span>;</div><div class="line"></div><div class="line">    .</div><div class="line">    .</div><div class="line">    .</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>源码中的注释是这么来解释Context的：Context提供了关于应用环境全局信息的接口。它是一个抽象类，它的执行被Android系统所提供，它允许获取以应用为特征的资源和类型，是一个统领一些资源的上下文。就是说，它描述一个应用程序环境的信息（即上下文），是一个抽象类，Android提供了该抽象类的具体实现类；通过它我们可以获取应用程序的资源和类（包括应用级别操作，如启动Activity，发广播，接受Intent等）。既然上面Context是一个抽象类，那么肯定有他的实现类，Context抽象类的继承关系如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1187237-1b4c0cd31fd0193f.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></p>
<p>Context类本身是一个纯abstract类，它有两个具体的实现子类：ContextImpl和ContextWrapper。其中ContextWrapper类，如其名所言，这只是一个包装而已，ContextWrapper构造函数中必须包含一个真正的Context引用，同时ContextWrapper中提供了attachBaseContext（）用于给ContextWrapper对象中指定真正的Context对象，调用ContextWrapper的方法都会被转向其所包含的真正的Context对象。ContextThemeWrapper类，如其名所言，其内部包含了与主题（Theme）相关的接口，这里所说的主题就是指在AndroidManifest.xml中通过android：theme为Application元素或者Activity元素指定的主题。当然，只有Activity才需要主题，Service是不需要主题的，因为Service是没有界面的后台场景，所以Service直接继承于ContextWrapper，Application同理。而ContextImpl类则真正实现了Context中的所以函数，应用程序中所调用的各种Context类的方法，其实现均来自于该类。一句话总结：Context的两个子类分工明确，其中ContextImpl是Context的具体实现类，ContextWrapper是Context的包装类。Activity，Application，Service虽都继承自ContextWrapper（Activity继承自ContextWrapper的子类ContextThemeWrapper），但它们初始化的过程中都会创建ContextImpl对象，由ContextImpl实现Context中的方法。</p>
<h1 id="一个应用程序有几个Context"><a href="#一个应用程序有几个Context" class="headerlink" title="一个应用程序有几个Context"></a>一个应用程序有几个Context</h1><p>从上面的关系图可知，在应用程序中Context的具体实现子类就是：Activity、Service、Application。那么context数量 = Activity数量 + Service数量 + 1；而四大组件中BroadcastReceiver和ContentProvider并不是Context的子类，他们所持有的Context都是其他地方传过去的，所以并不计入Context总数。</p>
<h1 id="Context作用"><a href="#Context作用" class="headerlink" title="Context作用"></a>Context作用</h1><p>弹出Toast、启动Activity、启动Service、发送广播、操作数据库等都需要用到Context。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实例化控件</span></div><div class="line">TextView tv = <span class="keyword">new</span> TextView(getContext());</div><div class="line"></div><div class="line">ListAdapter adapter = <span class="keyword">new</span> SimpleCursorAdapter(getApplicationContext(), ...);</div><div class="line"></div><div class="line">AudioManager am = (AudioManager) getContext().getSystemService(Context.AUDIO_SERVICE);getApplicationContext().getSharedPreferences(name, mode);</div><div class="line"></div><div class="line">getApplicationContext().getContentResolver().query(uri, ...);</div><div class="line"></div><div class="line">getContext().getResources().getDisplayMetrics().widthPixels * <span class="number">5</span> / <span class="number">8</span>;</div><div class="line"></div><div class="line">getContext().startActivity(intent);</div><div class="line"></div><div class="line">getContext().startService(intent);</div><div class="line"></div><div class="line">getContext().sendBroadcast(intent);</div></pre></td></tr></table></figure>
<h1 id="Context作用域"><a href="#Context作用域" class="headerlink" title="Context作用域"></a>Context作用域</h1><p>由于Context的具体实例是由ContextImpl类去实现的，因此自绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity、还有弹出Dialog，出于安全的考虑，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，形成返回栈，而Dialog则必须在一个Activity上面弹出（除非是System Alert类型的Dialog），因此在这种场景下，我们只能用Activity类型的Context，否则将会出错。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1187237-fb32b0f992da4781.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></p>
<p>这里说一下上图中Application和Service所不推荐的两种使用情况。</p>
<ul>
<li><p>如果我们用ApplicationContext去启动一个LaunchMode为standard的Activity的时候会报错<code>android.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?</code>这是因为非Activity类型的Context并没有所谓的任务栈，所以待启动的Activity就找不到栈了。解决这个问题的方法就是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就为它创建一个新的任务栈，而此时Activity是以singleTask模式启动的。所有这种用Application启动Activity的方式不推荐使用，Service同Application。</p>
</li>
<li><p>在Application和Service中去layout inflate也是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。所以这种方式也不推荐使用。</p>
</li>
</ul>
<p>一句话总结：凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。</p>
<h1 id="获取Context"><a href="#获取Context" class="headerlink" title="获取Context"></a>获取Context</h1><p>通常我们想要获取Context对象，主要有一下四种方法。</p>
<ol>
<li>View.getContext，返回当前View对象的Context对象，通常是正在显示的Activity对象。</li>
<li>Activity.getApplicationContext，获取当前Activity所在的应用进程的Context对象，通常我们使用Context对象时要优先考虑这个全局的进程Context。<br>3.ContextWrapper.getBaseContext()，用来获取一个ContextWrapper进行装饰之前的Context，可以使用这个方法，一般不建议使用</li>
<li>Activity.this，返回当前的Activity实例，如果是UI控件需要使用Activity作为Context对象，但是默认的Toast实际上使用ApplicationContext也可以。</li>
</ol>
<h1 id="getApplication-和getApplicationContext"><a href="#getApplication-和getApplicationContext" class="headerlink" title="getApplication()和getApplicationContext()"></a>getApplication()和getApplicationContext()</h1><p>获取当前Application对象用getApplicationContext，不知道你有没有联想到getApplication()，这两个方法有什么区别？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1187237-593b912ecd199046.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>程序是不会骗人的，我们通过上面的代码，打印得出两者的内存地址都是相同的，看来它们是同一个对象。其实这个结果也很好理解，因为前面已经说过了，Application本身就是一个Context，所以这里获取getApplicationContext()得到的结果就是Application本身的实例。那么问题来了，既然这两个方法得到的结果都是相同的，那么Android为什么要提供两个功能重复的方法呢？实际上这两个方法在作用域上有比较大的区别。<strong>getApplication()方法的语义性非常强，一看就知道是用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。</strong>那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    publicvoidonReceive(Contextcontext,Intentintent)&#123;</div><div class="line">    ApplicationmyApp=(Application)context.getApplicationContext();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Context引起的内存泄露"><a href="#Context引起的内存泄露" class="headerlink" title="Context引起的内存泄露"></a>Context引起的内存泄露</h1><p>Context并不能随便乱用，用的不好有可能会引起内存泄露的问题，下面就示例两种错误的引用方式。</p>
<ul>
<li>错误的单例模式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</div><div class="line">    <span class="keyword">private</span> Context mContext;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mContext = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">            instance = <span class="keyword">new</span> Singleton(context);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个非线程安全的单例模式，instance作为静态对象，其生命周期要长于普通的对象，其中也包含Activity，假如Activity A去getInstance获得instance对象，传入this，常驻内存的Singleton保存了你传入的Activity A对象，并一直持有，即使Activity被销毁掉，但因为它的引用还存在于一个Singleton中，就不可能被GC掉，这样就导致了内存泄漏。</p>
<ul>
<li>View持有Activity的引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Drawable mDrawable;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle saveInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(saveInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        ImageView iv = <span class="keyword">new</span> ImageView(<span class="keyword">this</span>);</div><div class="line">        mDrawable = getResources().getDrawable(R.drawable.ic_launcher);</div><div class="line">        iv.setImageDrawable(mDrawable);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有一个静态的Drawable对象当ImageView设置这个Drawable时，ImageView保存了mDrawable的引用，而ImageView传入的this是MainActivity的mContext，因为被static修饰的mDrawable是常驻内存的，MainActivity是它的间接引用，MainActivity被销毁时，也不能被GC掉，所以造成内存泄漏。</p>
<h1 id="正确使用Context"><a href="#正确使用Context" class="headerlink" title="正确使用Context"></a>正确使用Context</h1><p>一般Context造成的内存泄漏，几乎都是当Context销毁的时候，却因为被引用导致销毁失败，而Application的Context对象可以理解为随着进程存在的，所以我们总结出使用Context的正确姿势：</p>
<ol>
<li>当Application的Context能搞定的情况下，并且生命周期长的对象，优先使用Application的Context。</li>
<li>不要让生命周期长于Activity的对象持有到Activity的引用。</li>
<li>尽量不要在Activity中使用非静态内部类，因为非静态内部类会隐式持有外部类实例的引用，如果使用静态内部类，将外部实例引用作为弱引用持有。</li>
</ol>
<h1 id="获取全局Application"><a href="#获取全局Application" class="headerlink" title="获取全局Application"></a>获取全局Application</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyApplication app;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyApplication <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> app;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">super</span>.onCreate();  </div><div class="line">        app = <span class="keyword">this</span>;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Application全局只有一个，它本身就已经是单例了，无需再用单例模式去为它做多重实例保护了,getInstance()方法里面不要做任何逻辑判断，直接返回app对象就可以了，而app对象又是什么呢？在onCreate()方法中我们将app对象赋值成this，this就是当前Application的实例，那么app也就是当前Application的实例了。</p>
<p>参考文章：</p>
<p><a href="http://www.jianshu.com/p/94e0f9ab3f1d" target="_blank" rel="external">Context都没弄明白，还怎么做Android开发？</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2016/06/02/Android Context详解/" data-id="cj6f2gfkh00084h19yr5dhqs8" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2016/06/02/Android Context详解/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android系统/">Android系统</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/13/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/15/">下一页&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/08/16/Android启动流程①init进程分析/">Android启动流程①init进程分析</a>
          </li>
        
          <li>
            <a href="/2017/08/15/Android系统架构与源码目录/">Android系统架构与源码目录</a>
          </li>
        
          <li>
            <a href="/2017/08/14/Mac编译Android源码/">Mac编译Android源码</a>
          </li>
        
          <li>
            <a href="/2017/06/21/JavaScript⑦对象/">JavaScript⑦对象</a>
          </li>
        
          <li>
            <a href="/2017/06/19/JavaScript⑥引用类型RegExp/">JavaScript⑥引用类型RegExp</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2017 刘涤生&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;michaelliu0727@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/categories" class="mobile-nav-link">分类</a>
  
    <a href="/tags" class="mobile-nav-link">标签</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>
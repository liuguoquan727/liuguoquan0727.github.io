<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>再读斋</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="像外行一样思考,像专家一样实践。">
<meta property="og:type" content="website">
<meta property="og:title" content="再读斋">
<meta property="og:url" content="http://liuguoquan727.github.io/page/25/index.html">
<meta property="og:site_name" content="再读斋">
<meta property="og:description" content="像外行一样思考,像专家一样实践。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="再读斋">
<meta name="twitter:description" content="像外行一样思考,像专家一样实践。">
  
    <link rel="alternate" href="/atom.xml" title="再读斋" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liuguoquan727.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/categories">分类</a>
        
          <a class="main-nav-link" href="/tags">标签</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">再读斋</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">MICHAEL</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-TCP-IP5TCP协议详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/17/TCP-IP5TCP协议详解/" class="article-date">
  <time datetime="2015-12-17T13:08:05.000Z" itemprop="datePublished">2015-12-17 21:08:05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络通信/">网络通信</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/17/TCP-IP5TCP协议详解/">TCP/IP（五）TCP协议详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>TCP协议是面向有连接的协议，它具有丢包重发和流量控制的功能，这是它区别UDP协议最大的特点。</p>
<h1 id="数据包重发"><a href="#数据包重发" class="headerlink" title="数据包重发"></a>数据包重发</h1><h2 id="数据发送"><a href="#数据发送" class="headerlink" title="数据发送"></a>数据发送</h2><p>丢包重发的前提是发送方能够知道接收方是否成功的接收了消息。所以，在TCP协议中，接收端会给发送端返回一个消息，也叫确认应答（ACK），这表示接收方已经收到了数据包。</p>
<p>根据上一节对TCP首部的分析得知：ACK的值和下次发送数据包的序列号相等。因此ACK也可以理解为：“发送方，下次你从这个位置开始发送！“。下图表示了数据发送与确认应答的过程：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/tcp_ack%E7%A1%AE%E8%AE%A4.png" alt=""></p>
<p>由于各种原因，数据包和ACK应答包都有可能丢失，在这种情况下，发送方如果在一段时间内没有收到ACK，就会重发数据：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/tcp_%E9%87%8D%E5%8F%91%E6%95%B0%E6%8D%AE.png" alt=""></p>
<p>即使网络正常，由于延迟的存在，接收方也有可能收到重复的数据包，因此接收方通过TCP首部中的SYN判断这个数据包是否曾经接收过。如果已经接收，就会丢弃该数据包。</p>
<h2 id="重传超时时间（RTO）"><a href="#重传超时时间（RTO）" class="headerlink" title="重传超时时间（RTO）"></a>重传超时时间（RTO）</h2><p>如果发送方等待一段时间后，还是没有收到 ACK 确认，就会启动超时重传。这个等待的时间被称为重传超时时间(RTO，Retransmission TimeOut)。RTO 的值具体是多久呢？</p>
<p>首先，RTO 的值不是固定的，它是一个动态变化的时间。这个时间总是略大于连接往返时间（RTT，Round Trip Time）。这个设定可以这样理解：“数据发送给对方，再返回到我这里，假设需要 10 秒，那我就等待 12秒，如果超过 12 秒，那估计就是回不来了。”</p>
<p>RTT 是动态变化的，因为谁也不知道网络下一时刻是否拥堵。而当前的 RTO 需要根据未来的 RTT 估算得出。RTO 不能估算太大，否则会多等待太多时间；也不能太小，否则会因为网络突然变慢而将不该重传的数据进行重传。</p>
<h2 id="TCP窗口"><a href="#TCP窗口" class="headerlink" title="TCP窗口"></a>TCP窗口</h2><p>按照之前的理论，在数据包发出后，直至 ACK 确认返回以前，发送端都无法发送数据，而且包的往返时间越长，网络利用效率和通信性能就越低。前两张图片形象的解释了这一点。</p>
<p>为了解决这个问题，TCP 使用了“窗口”这个概念。窗口具有大小，它表示无需等待确认应答就可以继续发送数据包的最大数量。比如窗口大小为 4 时，数据发送的示意图如下：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/tcp_%E7%AA%97%E5%8F%A3.png" alt=""></p>
<p>不等确认就连续发送若干个数据包会不会有问题呢？我们首先来看数据包丢失问题。</p>
<p>我们知道 TCP 首部中的 ACK 字段表示接收方已经收到数据的最后位置。因此，接收方成功接收到了 1-1000 字节的数据后，它会发送一个 ACK = 1001 的确认包。假设 1001-2000 字节的数据包丢失了，由于窗口长度比较大，发送方会继续发送 2001-3000 字节的数据包。接收端并不会返回这个数据包的确认，因为它最后收到的数据还是 1-1000 字节的数据包。</p>
<p>因此，接收端返回的数据包的 ACK 依然是 1001。这表示：“喂，发数据的，别往后发了，你第 1001 字节开始的数据还没来呢”。可以想见，发送端以后每次发送数据包得到的确认中，ACK 的值都是 1001。当连续收到三次确认之后，发送方会意识到：“对方还没有接收到数据，这个包需要重传”。</p>
<p>因此，引入窗口的概念后，被发送的数据不能立刻丢弃，需要缓存起来以备将来需要重发。</p>
<p>利用窗口发送数据的过程可以用下图表示：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/tcp_%E7%AA%97%E5%8F%A3.png" alt=""></p>
<p>果是数据包没有丢失，但是确认包丢失了呢？这就是窗口最擅长处理的问题了。假设发送发收到的确认包中的 ACK 第一次是 1001，第二次是 4001。那么我们完全可以相信中间的两个包是成功被接收的。因为如果有没接收到的包，接收方是不会增加 ACK 的。</p>
<p>在这种情况下，如果不使用窗口，发送方就需要重传第二、三个数据包，但是有了窗口的概念后，发送方就省略了两次重传。因此使用窗口实际上可以理解为“空间换时间”。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/tcp_%E6%9F%90%E4%BA%9B%E7%A1%AE%E8%AE%A4%E5%8C%85%E4%B8%A2%E5%A4%B1%E6%97%B6%E4%B8%8D%E7%94%A8%E9%87%8D%E5%8F%91.png" alt=""></p>
<h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><h2 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h2><p>如果窗口过大，会导致接收方的缓存区数据溢出。这时候本该被接收的数据反而丢弃了，就会导致无意义的重传。因此，窗口大小是一个可以改变的值，它由接收端主机控制，附加在 TCP 首部的“窗口大小”字段中。</p>
<h2 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h2><p>在连接建立的初期，如果窗口比较大，发送方可能会突然发送大量数据，导致网络瘫痪。因此，在通信一开始时，TCP 会通过慢启动算法得出窗口的大小，对发送数据量进行控制。</p>
<p>流量控制是由发送方和接收方共同控制的。刚刚我们介绍了接收方会把自己能够承受的最大窗口长度写在 TCP 首部中，实际上在发送方这里，也存在流量控制，它叫拥塞窗口。TCP 协议中的窗口是指发送方窗口和接收方窗口的较小值。</p>
<p>慢启动过程如下：</p>
<ol>
<li>通信开始时，发送方的拥塞窗口大小为 1。每收到一个 ACK 确认后，拥塞窗口翻倍。</li>
<li>由于指数级增长非常快，很快地，就会出现确认包超时。</li>
<li>此时设置一个“慢启动阈值”，它的值是当前拥塞窗口大小的一半。</li>
<li>同时将拥塞窗口大小设置为 1，重新进入慢启动过程。</li>
<li>由于现在“慢启动阈值”已经存在，当拥塞窗口大小达到阈值时，不再翻倍，而是线性增加。</li>
<li>随着窗口大小不断增加，可能收到三次重复确认应答，进入“快速重发”阶段。</li>
<li>这时候，TCP 将“慢启动阈值”设置为当前拥塞窗口大小的一半，再将拥塞窗口大小设置成阈值大小（也有说加 3）。</li>
<li>拥塞窗口又会线性增加，直至下一次出现三次重复确认应答或超时。</li>
</ol>
<p>以上过程可以用下图概括：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/tcp_%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2015/12/17/TCP-IP5TCP协议详解/" data-id="cj6ft5ett00a5qm19bfmfof9c" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2015/12/17/TCP-IP5TCP协议详解/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络通信/">网络通信</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-TCP-IP4TCP与UDP协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/17/TCP-IP4TCP与UDP协议/" class="article-date">
  <time datetime="2015-12-17T13:07:53.000Z" itemprop="datePublished">2015-12-17 21:07:53</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络通信/">网络通信</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/17/TCP-IP4TCP与UDP协议/">TCP/IP（四）TCP与UDP协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>传输层位于OSI七层模型的第四层，传输层的主要作用是实现应用程序之间的通信。网络层主要是保证不同数据链路下数据的可达性，至于如何传输数据则是由传输层负责。</p>
<h1 id="传输层协议简介"><a href="#传输层协议简介" class="headerlink" title="传输层协议简介"></a>传输层协议简介</h1><p>常见的传输层协议主要有TCP协议和UDP协议。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP协议是面向有连接的协议，也就是说在使用TCP协议传输数据之前一定要在发送方和接收方之间建立连接。一般情况下建立连接需要三步，关闭连接需要四步。</p>
<p>建立TCP连接后，由于有数据重传、流量控制等功能，TCP协议能够正确处理丢包问题，保证接收方能够收到数据，与此同时还能够有效利用网络带宽。然而TCP协议中定义了很多复杂的规范，因此效率不如UDP协议，不适合实时的视频和音频传输。</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP协议是面向无连接的协议，它只会把数据传递给接收端，但是不保证接收端是否真正收到了数据。这种特性适合多播、实时的视频和音频传输，因为个别数据包的丢失并不会影响视频和音频的整体效果。</p>
<h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>IP协议中的两大关键要素是源IP地址和目标IP地址。传输层新增了三个要素：源端口号、目标端口号和协议号。</p>
<p>端口号用于区分同一台主机上不同的应用程序。假设你打开了两个浏览器，浏览器A发出的请求不会被浏览器B接收，就是因为A和B具有不要的端口号。</p>
<p>协议号用于区分使用的是TCP还是UDP。</p>
<p>所以：源IP地址、目标IP地址、源端口号、目标端口号和协议号这五个信息只要有一个不同，都被认为是不同的通信。</p>
<h1 id="UDP首部"><a href="#UDP首部" class="headerlink" title="UDP首部"></a>UDP首部</h1><p>UDP协议的特点就是简单，它的首部如下图所示：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/trans-udp%E9%A6%96%E9%83%A8.png" alt="udp"></p>
<ul>
<li>包长度表示UDP首部长度和UDP数据长度之和</li>
<li>校验和用来判断数据在传输过程中是否丢失。</li>
</ul>
<h1 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h1><p>TCP首部要复杂得多。解析这个首部的时间也相应的增加，这也是导致TCP连接的效率低于UDP的原因之一。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/trans-tcp%E9%A6%96%E9%83%A8.png" alt="tcp"></p>
<p>关键字段解释如下：</p>
<ul>
<li><p>序列号：它表示发送数据的位置，假设当前的序列号为s，发送数据长度为I，则下次发送数据的序列号为S + I。在建立连接时通常由计算机生成一个随机数作为序列号的初始值。</p>
</li>
<li><p>确认应答号：它等于下一次应该接收到的数据的序列号。假设当前的序列号为s，发送数据长度为I，则接收端返回的确认应答号为S + I。发送端接收到这个确认应答后，可以认为这个位置以前所有的数据都已被正常接收。</p>
</li>
<li><p>数据偏移：TCP首部的长度，单位为4个字节。如果没有可选字段，那么这里的值就是5，表示TCP首部的长度为20字节。</p>
</li>
<li><p>控制位：长度为8bit，分别有8个控制标志，依次是CWR、ECE、URG、ACK、PSH、RST、SYN和FIN</p>
<ul>
<li>CWR</li>
<li>ECE</li>
<li>URG</li>
<li>ACK:改位为1时，确认应答的字段变为有效。TCP规定除了最初建立连接时的SYN包之外改位必须设置为1</li>
<li>PSH</li>
<li>RST</li>
<li>SYN：用于建立连接。SYN为1表示希望建立连接</li>
<li>FIN：为1时，表示希望断开连接</li>
</ul>
</li>
<li><p>窗口大小：用于表示从应答号开始能够接收多少个字节。如果窗口为0，可以发送窗口探测</p>
</li>
<li><p>紧急指针：仅仅在URG控制位为1时有效。表示紧急数据的末尾在TCP数据部分中的位置，通常在暂时中断通信时使用（比如Ctrl + C）</p>
</li>
</ul>
<h1 id="TCP握手"><a href="#TCP握手" class="headerlink" title="TCP握手"></a>TCP握手</h1><p>TCP是面向连接的协议，连接在每次通信前被建立，通信结束时被关闭。了解TCP连接建立和关闭的过程通常是考察的重点。TCP连接的建立和关闭过程可用下图表示：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/trans-tcp%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E5%85%B3%E9%97%AD.png" alt=""></p>
<h2 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h2><ol>
<li>客户端请求连接SYN</li>
<li>服务端确认客户端连接请求</li>
<li>客户端确认服务端已收到连接请求，建立连接开始通信</li>
</ol>
<h2 id="为什么是三次握手"><a href="#为什么是三次握手" class="headerlink" title="为什么是三次握手"></a>为什么是三次握手</h2><p>三次握手的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”</p>
<p>这是因为在网络请求时，我们时刻要注意“网络是不可靠的，数据包是可能丢失的”。假设没有第三次确认的情况下，客户端向服务端发送SYN，请求建立连接。由于延迟，服务端没有及时收到这个包。于是客户端重新发送一个SYN包。</p>
<p>假设服务端接收到了第二个SYN包，建立了通信，一段时间后通信结束，连接被关闭。这是最初被发送的SYN包抵达服务端，服务端又会发送一次ACK确认。由于两次握手就建立连接，此时的服务端就会建立一个新的连接，然而客户端认为没有请求建立连接，所以就不会向服务端发送数据，从而导致服务端建立一个空连接，浪费资源。</p>
<h2 id="ACK确认包丢失怎么办？"><a href="#ACK确认包丢失怎么办？" class="headerlink" title="ACK确认包丢失怎么办？"></a>ACK确认包丢失怎么办？</h2><p>三次握手其实解决了第二步的数据包丢失的问题，那么第三步的ACK确认包丢失后，TCP协议是如何处理的呢？</p>
<p>按照TCP协议处理丢包的一般方法，服务端会重新向客户端发送数据包，直至收到ACK确认为止。但实际上这种做法有可能遭到SYN泛洪攻击。泛洪攻击，是指发送方伪造多个IP地址，模拟三个握手的过程。当服务器返回ACK后，攻击方故意不确认，从而使得服务器不断重发，由于服务器长时间出于半连接状态，最后消耗过多的CPU和内存资源导致死机。</p>
<p>正确的处理方法是服务端发送RST报文，进入CLOSE状态。这个RST数据包的TCP首部中，控制位中的RST设置为1.这表示连接信息全部初始化，原有的TCP通信不能继续进行。客户端如果还想重新建立TCP连接，就必须重新开始第一次握手。</p>
<p>##　四次握手关闭连接</p>
<ol>
<li>客户端发送FIN通知服务端 客户端要关闭连接</li>
<li>服务端发送ACK确认客户端关闭连接</li>
<li>服务端发送FIN通知客户端 服务端要关闭连接</li>
<li>客户端发送ACK确认服务端关闭连接</li>
</ol>
<p>由于连接是双向的，所以双方都要主动关闭自己这一侧的连接。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2015/12/17/TCP-IP4TCP与UDP协议/" data-id="cj6ft5etq009vqm19181vcqeu" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2015/12/17/TCP-IP4TCP与UDP协议/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络通信/">网络通信</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-TCP-IP3IP协议相关技术" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/17/TCP-IP3IP协议相关技术/" class="article-date">
  <time datetime="2015-12-17T13:06:45.000Z" itemprop="datePublished">2015-12-17 21:06:45</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络通信/">网络通信</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/17/TCP-IP3IP协议相关技术/">TCP/IP（三）IP协议相关技术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>IP协议旨在让最终目标主机收到数据包，但是在这一过程中仅仅有IP是无法实现通信的。必须还有能够解析主机名称和MAC地址的功能，以及数据包在发送过程中异常情况处理的功能。本文主要介绍作为IP的辅助和扩展规范的DNS、ARP、ICMP、NAT等协议。</p>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>全称Domain Name System，域名系统</p>
<p>IP地址用于识别通信双方的地址，但它是一串长数字，比方便记忆，人们希望主机有自己的名字，这个名字是唯一的，而且容易记住，于是诞生了“域名”的概念。域名是一种为了识别主机名称和机构名的具有分层的名称，比如在域名neu.edu.cn中，neu是主机名，edu和cn是不同层次下的机构名。</p>
<p>域名和IP地址都可以唯一对应一台主机，DNS的作用就是将域名转换成不容易记住的IP地址。</p>
<p>域名是分层的，每层都有自己的DNS服务器用于处理DNS解析的请求，这样的好处在于每层的服务器不用关注过多的信息，它只要知道自己这一层下的域名服务器信息即可。以解析域名：www.itetf.org为例：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/ip-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.png" alt=""></p>
<p>根服务器其实并不知道www.itetf.org的IP地址，但是它知道itetf.org域名服务器的地址，所有它把这条查询请求转发给itetf.org域名服务器。DNS请求被逐层下发，直到找到对应的IP地址为止。</p>
<h1 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h1><p>全称Address Resolution Protocol，地址解析协议</p>
<p>ARP协议用于通用目标IP地址，定位下一个接收数据包的网络设备的MAC地址。如果目标主机处于同一个数据链路上，那么可以直接得到目标主机的MAC地址，否则会得到下一跳路由器的MAC地址。</p>
<p>ARP协议的工作原理可以分为两部分：ARP请求和ARP响应。首先，源主机会通过广播发送一个ARP请求包：“我要与IP地址为XX的主机通话，谁知道它的MAC地址？”。</p>
<p>下图表示ARP协议的工作机制：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/ip-arp.png" alt="ARP"></p>
<p>根据ARP可以动态地进行地址解析，因此，在TCP/IP的网络构造中和网络通信中无需事先知道MAC地址究竟是什么，只要有IP地址即可。</p>
<p>如果每发送一个IP数据报都要进行一个ARP请求以确定MAC地址，那将会造成不必要的网络流量，因此通常的做法是把获取到的MAC地址缓存一段时间。一般来说，发送过一次IP数据包的主机，继续发送多次IP数据包的可能性比较高。因此这种缓存能够有效地减少ARP包的发送。当下一次发送ARP请求或超过一定时间后，缓存都会失效，这保证了即使MAC地址与IP地址对应的关系发送了变化，数据包依然能够被正确的发往目标地址。</p>
<p>MAC地址和IP地址看上起功能相似（都用于唯一区分主机），但是两者缺一不可。如果只有IP地址，虽然可以跳过ARP，直接在链路上发一个广播，但是这仅适应于通信双方处于同一个数据链路情况。如果双方处于不同的数据链路，数据报无法穿透中间的路由器。正因为MAC地址缺一不可，所以才产生了ARP这样的协议将两者关联起来。</p>
<h1 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h1><p>全称：Internet Control Message Protocol，Internet控制报文协议。</p>
<p>ICMP的主要功能：确认IP包是否成功送达目标地址，通知在发送过程中IP包被废弃的具体原因，改善网络等设置。有了这些功能以后，就可以获得网络是否正常、设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断。</p>
<h1 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h1><p>全称：Network Address Traslator，网络地址转换</p>
<p>NAT是一种用于将局域网中的私有地址转换成全局IP地址的技术。</p>
<p>在连接上路由器的时候，如果检查一下设备的IP地址，你会发现都是类似于192.168.1.1这样局域网的IP地址。那不同网段中，IP地址都是192.168.1.1的主机该如何通信呢？</p>
<p>下图描述了NAT的工作原理：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/ip-nat%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="nat"></p>
<p>局域网中IP地址为10.0.0.10的主机向全局IP地址163.221.120.9发送数据。NAT路由器将数据包的源地址修改成自己的全局IP地址：202.244.174.37。同理，接收数据时，路由器把目标地址202.244.174.37翻译成内网地址：10.0.0.10。</p>
<p>路由器只有一个对外的全局IP地址，如果有多个内网主机都向外部通讯怎么办呢？这时就要使用NAPT技术，它和NAT从原理上类似，但它可以转换TCP和UDP端口号。</p>
<p>使用NAPT技术时，不同的内网IP被转换成同一个公共IP地址，也就是路由器对外显示的全局IP地址，但是被附加不同的端口号以示区分：如下图所示</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/ip-napt%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="napt"></p>
<p>不管是NAT还是NAPT，都需要路由器内部维护一张自动生成的地址转换表。以TCP为例，建立TCP连接首次握手的SYN包发出时会生成这个表，关闭连接时会发生FIN包，收到这个包的应答时转换表被删除。</p>
<h1 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h1><p>全称：Dynamic Host Configuration Protocol，动态主机配置协议</p>
<p>DHCP的主要用途是实现自动设置IP地址、统一管理IP地址分配。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2015/12/17/TCP-IP3IP协议相关技术/" data-id="cj6ft5ets00a2qm19mgcqlbb2" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2015/12/17/TCP-IP3IP协议相关技术/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络通信/">网络通信</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-TCP-IP2IP协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/17/TCP-IP2IP协议/" class="article-date">
  <time datetime="2015-12-17T13:05:33.000Z" itemprop="datePublished">2015-12-17 21:05:33</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络通信/">网络通信</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/17/TCP-IP2IP协议/">TCP/IP（二）IP协议</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>IP协议属于TCP/IP网络模型的第三层-网络层，它的主要作用是实现终端节点之间的通信。IP协议是网络层的一个重要协议，网络层中还有ARP协议（获取MAC地址）和ICMP协议（数据发送异常通知）。</p>
<p>数据链路层的作用在于实现同一中数据链路下的包传递，而网络层则可以实现跨越不同数据链的包传递。比如主机A通过WI-FI连接到路由器B，路由器B通过以太网连接到路由器C，而路由器C又通过WI-FI与主机D保持连接，这时主机A向D发送的数据包就依赖于网络层进行传输。</p>
<p>IP大致分为三大作用模块：IP寻址、路由以及IP分包和组包</p>
<h1 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h1><p>IP地址是一种在网络层用于识别通信对端信息的地址，它有别于数据链路层中的MAC地址，后者用于标识同一链路下不同的计算机。</p>
<p>IP地址由32为正整数表示，为了直观的表示，我们把它分成4个部分，每个部分由8位整数组成，对应十进制的范围就是0-255。比如172.20.1.1可以表示为：10101100 00010100 00000001 00000001.转换规则很简单，就是分别把四个部分的十进制（0-255）与8位二进制数进行转换。</p>
<p>从功能上看，IP地址由两部分组成：网络标识和主机标识。</p>
<ul>
<li>网络标识用于区分不同的网段，相同段内的主机必须拥有相同的网络标识，不同段内的主机不能拥有相同的网络标识。</li>
<li>主机标识用于区分同一网段下不同的主机，它不能在同一网段内重复出现。</li>
</ul>
<p>32为IP地址被分为两个部分，到底前多少为是网络标识呢？一般有两种方法表示：IP地址分类、子网掩码</p>
<h2 id="IP分类"><a href="#IP分类" class="headerlink" title="IP分类"></a>IP分类</h2><p>IP地址分为四个级别，分为A类、B类、C类和D类。分类的依据是IP地址的前四位。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/ip%E5%9C%B0%E5%9D%80-ip%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB.png" alt=""></p>
<ul>
<li>A类地址</li>
</ul>
<p>A类IP地址是第一位是0的地址。从第1位到第8位是A类IP地址的网络标识，用十进制标识的0.0.0.0~127.0.0.0是A类IP地址的理论范围。A类地址的后24位相当于主机标识。因此一个网段内可容纳的主机地址上线为2的24次方个。</p>
<ul>
<li>B类地址</li>
</ul>
<p>B类IP地址是前两位为“10”的地址。B类地址的前16位是网络标识，用十进制标识的话是128.0.0.0~191.255.0.0是B类地址的范围。B类地址的后16位是主机标识，因此一个网段可容纳主机地址上限为65534个。</p>
<ul>
<li>C类地址</li>
</ul>
<p>C类IP地址是前三位是“110”的地址。C类地址的前24位是网络标识，用十进制标识的话192.0.0.0~223.255.255.0是C类地址的范围。C类地址的后8位是主机标识，因此一个网段可容纳主机地址上限为254个。</p>
<ul>
<li>D类地址</li>
</ul>
<p>D类IP地址是前四位是“1110”的地址。D类地址的前32位是网络标识。用十进制表示的话224.0.0.0~239.255.255.255是D类地址的网络地址，D类地址没有主机标识，因此常用于多播。</p>
<ul>
<li>关于分配IP主句地址的注意事项</li>
</ul>
<p>在分配IP地址时关于主机标识有一点需要注意，即要用比特位表示主机地址时，不可以全部为0或者全部为1.因为全部为0只有在表示对应的网络地址或IP地址不可或知的情况下才使用，而全部为1的主机地址通常作为广播地址。</p>
<p>因为在分配过程中，应该去掉这两种情况，这也是为什么C类地址每个网段最多只能有254（2^8 - 2）个主机地址的原因。</p>
<h2 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h2><p>广播地址用于在同一个链路中相互连接的主机之间发送数据的发送端IP地址中的主机地址部分全部设置为1，就是广播地址。例如把172.20.0.0用二进制表示如下：<br>10101100.00010100.00000000.00000000<br>将这个地址的主机部分全部改为1，形成广播地址：<br>10101100.00010100.11111111.11111111<br>再将这个地址用十进制表示，则为172.20.255.255</p>
<p>广播分为本地广播和直接广播</p>
<ul>
<li>本地广播</li>
</ul>
<p>在本网络内的广播叫做本地广播。例如网络地址为192.168.0.4的情况下，广播地址是192.168.0.255.因为这个广播地址的IP包会被路由器屏蔽，所以不会到达192.168.0.4以外（如192.168.1.4）的其他链路上。</p>
<ul>
<li>直接广播</li>
</ul>
<p>在不同网络之间的广播叫做直接广播。例如网络地址192.168.0.4的主机地址想192.168.1.255的目标地址发送IP包。收到这个包的路由器，将数据转发给192.168.1.0，从而使得所以192.168.1.1~192.168.1.254的主机都能收到这个包。</p>
<h2 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h2><p>多播用于将数据包发送给特定组内的所有主机。由于其直接使用IP协议，因此是不可靠的传输。</p>
<p>多播使用D类地址。因此，如果IP地址的前四位是“1110”，就可以认为是多播地址，而剩下的28位可以成为多播的组编号。</p>
<h2 id="子网编码"><a href="#子网编码" class="headerlink" title="子网编码"></a>子网编码</h2><p>一个IP地址有两种识别码：一是IP地址本身，而是表示网络部分的子网掩码。子网掩码用二进制表示的话也是一个32位的数字。它对应IP地址网络标识部分的位全部为“1”，对应IP地址主机标识的部分则全部为“0”。由此，一个IP地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是IP地址的首位开始连续的“1”。</p>
<p>以IP地址172.20.100.52为例，它本来是一个B类IP地址（前16位是网络标识），但通过子网掩码，它可以扩展为前26位是网络标识的IP地址，其中定义类10位子网掩码，如图所示。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/ip%E5%9C%B0%E5%9D%80-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81.jpg" alt=""></p>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="路由控制表"><a href="#路由控制表" class="headerlink" title="路由控制表"></a>路由控制表</h2><p>发送数据包时所使用的地址是网络层的地址，即IP地址。然而仅仅有IP地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表（Routing Table）。实现IP通信的主机和路由器都必须持有一张这样的表，它们也正是在这个表格的基础上才得以进行数据包发送的。</p>
<p>路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫静态路由控制，而后者叫做动态路由控制。为了让动态路由及时刷新路由表，在网络上互连的路由器之间必须设置好路由协议，保证正常读取路由控制信息。</p>
<p>IP协议始终认为路由表是正确的。然而，IP本身并没有定义制作路由控制表的协议。即IP没有制作路由控制表的机制。该表是由一个叫做“路由协议”的协议制作而成。</p>
<h2 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h2><p>路由器中保存着路由控制表，它在路由控制表中查找目标IP地址对应的下一个路由器地址。</p>
<p>IP地址的网络地址部分用于进行路由控制，如下图所示</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/%E8%B7%AF%E7%94%B1-%E8%B7%AF%E7%94%B1%E6%8E%A7%E5%88%B6%E8%A1%A8%E4%B8%8EIP%E5%8C%85%E5%8F%91%E9%80%81.png" alt=""></p>
<p>主机A的地址是10.1.1.30，要把数据发往地址为10.1.2.10的主机。在主机A的路由表中，保存了两个字段，由于目标地址10.1.2.10与10.1.1.0/24段不匹配，所以它被发往默认路由10.1.1.1也就是图中路由器1的IP地址。</p>
<p>路由器1继续在它自己的路由控制表中查找目标地址10.1.2.10，它发现目标地址属于10.1.2.0/24这一段，因此将数据转发至下一个路由器10.1.0.2，也就是路由器2的左侧网卡IP地址</p>
<p>路由器在自己的路由控制表中查找目标地址10.1.2.10，根据表中记录将数据发往10.1.2.1接口，也就是路由器右侧网卡的IP地址，主机B检查目标IP地址和自己相同，于是接收数据。</p>
<h2 id="环路"><a href="#环路" class="headerlink" title="环路"></a>环路</h2><p>上图中，假设主机A向一个不存在的IP地址发送数据，并且路由器1、2、3设置的默认路由形成了一个循环，那么数据将在网络中不断转发最终导致网络拥堵，这个问题将在下文分析IP首部时得到解决。</p>
<h2 id="IP报文分割与重组"><a href="#IP报文分割与重组" class="headerlink" title="IP报文分割与重组"></a>IP报文分割与重组</h2><p>在数据链路层中，我们已经提到过不同的数据链路有不同的最大传输单元（MTU）。因此IP协议的一个任务是对数据进行分片和重组，分片由发送端主机和路由器负责，重组由接收端主机负责。</p>
<h3 id="路径MTU发现"><a href="#路径MTU发现" class="headerlink" title="路径MTU发现"></a>路径MTU发现</h3><p>分片会加重路由器的负担，因此只要条件允许，我们都不希望路由器对IP数据包进行分片处理。另外，如果一个分片丢失，整个IP数据报都会作废。</p>
<p>解决以上问题的技术是“路径MTU发现”。主机首先获取整个路径中所有数据链路的最小MTU，并按照整个大小将数据分片。因此传输过程中的任何一个路由器都不用进行分片工作。</p>
<p>为了找到路径MTU，主机首先发送整个数据包，并将IP首部的禁止分片标志设为1.这样路由器在遇到需要分片才能处理的包时不会分片，而是直接丢弃数据并通过ICMP协议将整个不可达的消息发回主机。主机将ICMP通知中的MTU设置为当前MTU，根据真个MTU对数据进行分片处理。如此反复下去，直到不再收到ICMP通知，此时的MTU就是路径MTU。</p>
<p>以UDP协议发送数据为例：</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/%E8%B7%AF%E7%94%B1-%E8%B7%AF%E5%BE%84MTU%E5%8F%91%E7%8E%B0.png" alt=""></p>
<h3 id="重组"><a href="#重组" class="headerlink" title="重组"></a>重组</h3><p>接收端根据IP首部中的标志（Flag）和片偏移（Fragment Offset）进行数据重组。</p>
<h2 id="IP首部（IPv4）"><a href="#IP首部（IPv4）" class="headerlink" title="IP首部（IPv4）"></a>IP首部（IPv4）</h2><p>IP首部是一个有些复杂的结构，我们不用记忆它的结构，只需了解每个部分的作用即可，这样可以加深对IP协议的理解。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/%E8%B7%AF%E7%94%B1-Ip%E9%A6%96%E9%83%A8.jpg" alt=""></p>
<ul>
<li>版本</li>
</ul>
<p>由4比特构成，表示标识IP首部的版本号。IPv4的版本号即为4</p>
<ul>
<li>首部长度（IHL，Internet Header Length）</li>
</ul>
<p>由4比特构成，表明IP首部的大小，单位为4字节。对于没有可选项的IP包，首部长度则设置为5.也就是说，当没有可选项时，IP首部的长度为20字节（4 * 5 = 20）</p>
<ul>
<li>区分服务（TOS：Type of Service）</li>
</ul>
<p>由8比特组成，用来表明服务质量</p>
<p>DSCP（Differential Services Codepoint，差分服务代码点）是TOS的一部分，用来进行质量控制，由6个字节组成。<br>ECN（Explicit Congestion Nofication，显示拥塞通告），用来报告网络拥堵情况，由2bit构成。</p>
<ul>
<li>总长度</li>
</ul>
<p>表示IP首部与数据部分结合起来的总字节数。该字段为16bit。因此IP包的最大长度为65535（2^16）个字节。虽然不同数据链路的MTU不同，但是IP协议屏蔽了这些区别，通过自己实现的数据分片功能，从上层的角度来看，IP协议总是能够以65535为最大包长进行传输。</p>
<ul>
<li>标识（ID）</li>
</ul>
<p>由16比特组成，用于分片重组。同一分片的标识值相同，不同分片的标识值不同。通过每发送一个IP包，它的值也逐渐递增。此外即使ID相同，如果目标地址、源地址或协议不同的话，也会被认为是不同的分片。</p>
<ul>
<li>标志（Flags）</li>
</ul>
<p>由3bit组成，表示包被分片的相关信息</p>
<ul>
<li>片偏移（FO，Fragment Offset）</li>
</ul>
<p>由13bit构成，用来标识被分片的每一个分段相对于原始数据的位置。第一个分片对应的值为0.由于FO域占13位，因此最多可以表示8192（2^13）个相对位置。单位为8字节，因此最大可表示原始数据8 * 8192 = 65536字节的位置。</p>
<ul>
<li>生存时间（TTL：Time To Live）</li>
</ul>
<p>由8比特构成，以秒为单位记录当前包在网络上应该生存的时间。在实际中它是指可以中转多少个路由器的意思。每经过一个路由器，TTL会减少1，直到变成0则丢弃该包。</p>
<ul>
<li>协议（Protocol）</li>
</ul>
<p>由8bit构成，表示IP首部的下一个首部隶属于哪个协议。</p>
<ul>
<li>首部校验和（Header Checksum）</li>
</ul>
<p>由16比特构成，也叫IP首部校验和。该字段只校验首部，不校验数据部分，主要用来确保IP数据包不被破坏。</p>
<ul>
<li>源地址（Source Address）</li>
</ul>
<p>由32bit构成，表示发送端IP地址</p>
<ul>
<li>目标地址（Destination Address）</li>
</ul>
<p>由32bit构成，表示接收端IP地址</p>
<ul>
<li>可选项（Options）</li>
</ul>
<p>长度可变，通常只在进行实验或诊断时使用</p>
<ul>
<li>填充（Padding）</li>
</ul>
<p>在有可选项的情况下，首部长度可能不是32bit的整数倍。为此，通过向字段填充0，调整32bit的整数倍。</p>
<ul>
<li>数据（Data）</li>
</ul>
<p>存入数据。将IP协议的首部也作为数据进行处理。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2015/12/17/TCP-IP2IP协议/" data-id="cj6ft5etr009zqm191q0zr5dr" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2015/12/17/TCP-IP2IP协议/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络通信/">网络通信</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-TCP-IP1模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/17/TCP-IP1模型/" class="article-date">
  <time datetime="2015-12-17T13:04:06.000Z" itemprop="datePublished">2015-12-17 21:04:06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/网络通信/">网络通信</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/12/17/TCP-IP1模型/">TCP/IP（一）分层模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h1><p>在OSI参考模型中，网络被分为七层，从下到上依次是：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/tcpip-osi.png" alt="osi七层模型"></p>
<ul>
<li><p>物理层：负责0、1比特流（0、1序列）与电压的高低、光的闪灭（电信号）之间的互换。</p>
</li>
<li><p>数据链路层：负责物理层上互连的、节点之间的通信传输。例如一个与以太网相连的2个节点之间的通信</p>
</li>
<li><p>网络层：将数据传输到目标地址。目标地址可以是多个网络通过路由器连接而成的某一个地址。因此这一层主要是负责寻址和路由选择。</p>
</li>
<li><p>传输层：可靠地传输数据。只在通信双方节点上进行处理，而无需在路由器上处理。</p>
</li>
<li><p>会话层：负责建立和断开通信连接，以及数据的分割等数据传输相关的管理。</p>
</li>
<li><p>表示层：将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式。因此它主要负责数据格式的转换。</p>
</li>
<li><p>应用层：为应用程序提供服务并规定应用程序中通信相关的细节。包括文件传输、电子邮件、远程登录等协议。</p>
</li>
</ul>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>数据链路层中有两个重要的概念：MAC 地址和分组交换</p>
<h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>MAC 地址是被烧录到网卡 ROM 中的一串数字，长度为 48 比特，它在世界范围内唯一(不考虑虚拟机自定义 MAC 地址)。由于 MAC 地址的唯一性，它可以被用来区分不同的节点，一旦指定了 MAC 地址，就不可能出现不知道往哪个设备传输数据的情况。</p>
<h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p>分组交换是指将大数据分割为一个个叫做包的较小单位进行传输的方法。使用分组交换的原因是不同的数据链路有各自的最大传输单元（MTU）。以以太网为例，它的MTU是1500字节，也就是通过以太网的数据，必须分割为若干帧，每个帧的数据长度不超过1500字节。如果上层传来的数据超过这个长度，数据链路层需要分割后再发送。</p>
<h1 id="传输方式的分类"><a href="#传输方式的分类" class="headerlink" title="传输方式的分类"></a>传输方式的分类</h1><ul>
<li>面向连接型和面向无连接型（网络数据传输方式）</li>
<li>电路交换和分组交换（网络通信方式）</li>
<li>单播、广播、多播、任播（根据接收端数量分类）<ul>
<li>单播：一对一通信</li>
<li>广播：将消息从1台主机发送给与之相连的所有其他主机，典型例子就是电视播放</li>
<li>多播（组播）：有一台主机发送消息给特定的多台主机</li>
<li>任播：从目标主机群中选择一台最符合网络条件的主机作为目标主机发送消息，发送端将只会跟这台主机进行通信。</li>
</ul>
</li>
</ul>
<h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h1><h2 id="TCP-IP的具体含义"><a href="#TCP-IP的具体含义" class="headerlink" title="TCP/IP的具体含义"></a>TCP/IP的具体含义</h2><p>全称：Transmission Control Protocol/Internet Protocol</p>
<p>TCP/IP是指利用IP进行通信时所必须用到的协议群的统称。具体来说，IP或ICMP、TCP或UDP、TELNET或FTP、以及HTTP等都属于TCP/IP协议。它们与TCP或IP的关系密切，是互联网必不可少的组成部分。TCP/IP泛指这些协议，有时也称为TCP/IP为网际协议族。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/tcpip-tcpip%E5%8D%8F%E8%AE%AE%E6%97%8F.png" alt=""></p>
<h2 id="TCP-IP规范-RFC"><a href="#TCP-IP规范-RFC" class="headerlink" title="TCP/IP规范-RFC"></a>TCP/IP规范-RFC</h2><p>那些需要标准化的协议被列入RFC（Request for Comment）文档并在互联网上公布。RFC不仅记录了协议规范内容，还包含了协议的实现和运用的相关信息以及实验方面的信息。</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>RFC</th>
</tr>
</thead>
<tbody>
<tr>
<td>IPv4</td>
<td>RFC791</td>
</tr>
<tr>
<td>IPv6</td>
<td>RFC2460</td>
</tr>
<tr>
<td>TCP</td>
<td>RFC793</td>
</tr>
<tr>
<td>UDP</td>
<td>RFC768</td>
</tr>
<tr>
<td>HTTP(1.1)</td>
<td>RFC2616</td>
</tr>
<tr>
<td>FTP</td>
<td>RFC959</td>
</tr>
<tr>
<td>TELNET</td>
<td>RFC 854</td>
</tr>
</tbody>
</table>
<h2 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h2><p>TCP/IP参考模型中，网络分为五层，从下到上依次为：物理层、网络接口层、网络层、传输层、应用层。TCP/IP更强调“在计算机上实现协议应该开发哪种程序”。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/tcpip-tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.png" alt="tcpip参考模型"></p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>TCP/IP物理层是负责数据传输的硬件。</p>
<h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>网络接口层利用以太网的数据链路层进行通信</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>网络层使用IP协议，相当于OSI参考模型的第三层网络层。IP协议基于IP地址转发分包数据，作用是将分组数据报发送到目的主机。</p>
<p>TCP/IP分层中的网络层与传输层的功能通常由操作系统提供。尤其是路由器，它必须实现通过网络层转发分组数据包的功能。此外，连接互联网的所有主机跟路由器都必须实现IP的功能。</p>
<ul>
<li>IP</li>
</ul>
<p>IP是跨越网络传送数据包，使整个互联网都能收到数据的协议。IP协议使数据能够发送到地球的另一端，这期间它使用IP地址作为主机的标识。</p>
<p>IP还隐含着数据链路层的功能。通过IP相互通信的主机之间不论经过怎样的底层数据链路都能够实现通信</p>
<p>IP也是分组交换的一种协议，但是它不具有重发机制。即使分组数据包未能到达对端主机也不会重发，因此属于非可靠性传输协议。</p>
<ul>
<li>ICMP</li>
</ul>
<p>IP数据包在发送过程中一旦发生异常导致无法到达对端目标地址时，需要给发送方发送一个发送异常的通知。ICMP就是为这一功能而制定的，它有时也被用来诊断网络的健康状况。</p>
<ul>
<li>ARP</li>
</ul>
<p>从分组数据包中的IP地址中解析出物理地址（MAC地址）的一种协议。</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>传输层的主要功能就是让应用程序之间实现通信。</p>
<ul>
<li>TCP传输控制协议</li>
</ul>
<p>TCP是一种面向有连接的传输层协议，它可以保证两端通信主机之间的数据完整性。TCP能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况。此外TCP还能够有效利用宽带，缓解网络拥堵。然而，为了建立与断开连接，有时它需要至少7次的发包收包，导致网络流量的浪费。</p>
<ul>
<li>UDP用户数据包协议</li>
</ul>
<p>UDP是一种面向无连接的传输层协议。它不能保证两端通信主机之间的数据完整性，它是不可靠的。</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>TCP/IP应用的架构大多数属于客户端/服务器模型。常见的应用有www、E-mail、FTP、TELNET、SNMP（网络管理）。</p>
<h2 id="TCP-IP通信示例"><a href="#TCP-IP通信示例" class="headerlink" title="TCP/IP通信示例"></a>TCP/IP通信示例</h2><h3 id="数据包首部"><a href="#数据包首部" class="headerlink" title="数据包首部"></a>数据包首部</h3><p>每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。如下图所示，在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/tcpip-%E6%95%B0%E6%8D%AE%E5%8C%85%E9%A6%96%E9%83%A8.png" alt=""></p>
<h3 id="发送数据包"><a href="#发送数据包" class="headerlink" title="发送数据包"></a>发送数据包</h3><p>假设甲给乙发送电子邮件，内容为：“早上好”。而从TCP/IP通信上看，是从一台计算机A向另一台计算机B发送电子邮件。下面，我们通过这个例子来讲解一下TCP/IP通信的过程。</p>
<ul>
<li>[1]应用程序处理</li>
</ul>
<p>启动应用程序新建邮件，将收件人邮箱填好，再由键盘输入邮件内容“早上好”，鼠标点击“发送”按钮就可以开始TCP/IP通信了。</p>
<p>首先应用程序会进行编码处理。例如，电子邮件使用UTF-8进行编码，这些编码相当于OSI的表示层功能。</p>
<p>应用在发送邮件的那一刻建立TCP连接，从而利用这个TCP连接发送数据。它的过程首先是将应用的数据发送给下一层的TCP，再做实际的转发处理。</p>
<ul>
<li>[2]TCP模块的处理</li>
</ul>
<p>TCP根据应用的指示，负责建立连接、发送数据以及断开连接。TCP提供将应用层发来的数据顺利发送至对端的可靠传输。</p>
<p>为了实现TCP的这一功能，需要在应用层数据的前端附加一个TCP首部。TCP首部中包括源端口号和目标端口号（用以识别发送主机跟接收主机上的应用）、序号（用以识别发送的包中哪部分是数据）以及校验码。随后将附加类TCP首部的包再发送给IP。</p>
<ul>
<li>[3]IP模块的处理</li>
</ul>
<p>IP将TCP传过来的TCP首部和TCP数据组合起来作为IP包的数据，并在TCP首部的前端加上IP包的首部。因此，IP数据包中IP首部后面紧跟着TCP首部，然后才是应用的数据首部和数据本身。IP首部中包含数据接收端IP地址以及发送端IP地址。紧随IP首部的还有用来判断数据时TCP还是UDP的信息。</p>
<p>IP包生成后，参考路由控制表决定接受此IP包的路由或主机。随后，IP包将被发送给连接这些路由器或主机网络接口的驱动程序，以实现真正发送数据。</p>
<p>如果不知道接收端的MAC地址，可以利用ARP查找。只要知道了对端的MAC地址，就可以将MAC地址和IP地址交给以太网驱动程序，实现数据传输。</p>
<ul>
<li>[4]网络接口层的处理</li>
</ul>
<p>从IP传过来的包，对于以太网驱动来说不过就是数据。给这数据附加上以太网首部并进行发送处理。以太网首部中包含接收端MAC地址、发送端MAC地址以及标志以太网类型的以太网数据的协议。根据上述信息产生的以太网数据包将通过物理层传输给接收端。发送处理中的FCS由硬件计算，添加到包的最后。设置FCS的目的是为了判断数据包是否由于噪声而被破坏。</p>
<p>下图为展示TCP/IP各层对邮件的收发处理</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/tcpip-%E9%82%AE%E4%BB%B6%E6%94%B6%E5%8F%91%E5%A4%84%E7%90%86.png" alt=""></p>
<h3 id="经过数据链路的包"><a href="#经过数据链路的包" class="headerlink" title="经过数据链路的包"></a>经过数据链路的包</h3><p>分组数据包经过以太网的数据链路时的大致流程如下图所示。</p>
<p><img src="http://7xs7a3.com1.z0.glb.clouddn.com/tcpip-%E5%88%86%E5%B1%82%E4%B8%AD%E5%8C%85%E7%9A%84%E7%BB%93%E6%9E%84.png" alt=""></p>
<p>包流动时，从前往后依次被附加了以太网包首部、IP包首部、TCP包首部以及应用自己的包首部和数据。而包的最后则追加以太网包尾。</p>
<p>每个包首部中至少都会包含两个信息：一是发送端和接收端的地址，另一个是上一层的协议类型。</p>
<p>经过每个协议层时，都必须有识别包发送端和接收端的信息。以太网会用MAC地址，IP会用IP地址，而TCP/UDP则会用端口号作为识别两端主机的地址。即使在应用程序中，像电子邮件地址这样的信息也是一种地址标识。这些地址信息都在每个包经由各个分层时，附加到协议对应的包首部里面。</p>
<p>此外，每个分层的包首部中还包含一个识别位，它是用来标识上一层协议的种类信息。例如以太网的包首部中的以太网类型，IP中的协议类型以及TCP/UDP中两个端口的端口号等都起着识别协议类型的作用。就是在应用的首部信息中，有时也会包含一个用来识别其数据类型的标签。</p>
<h3 id="数据包接收处理"><a href="#数据包接收处理" class="headerlink" title="数据包接收处理"></a>数据包接收处理</h3><p>包的接收流程是发送流程的逆序过程。</p>
<ul>
<li>[5]网络接口层的处理</li>
</ul>
<p>主机收到以太网包以后，首先以太网的包首部找到MAC地址判断是否为发给自己的包。如果不是发给自己的包则丢弃数据。</p>
<p>而如果接收到了恰好是发给自己的包，就查找以太网包首部中的类型域从而确定以太网协议所传送过来的数据类型。在这个例子中数据类型显然是IP包，因此再将数据传给处理IP的子程序，如果这时不是IP而是其他诸如ARP的协议，就把数据传给ARP处理。总之，如果以太网包首部的类型域包含了一个无法识别的协议类型，则丢弃数据。</p>
<ul>
<li>[6]IP模块的处理</li>
</ul>
<p>IP模块接收到IP包首部及后面的数据部分以后，也做类似的处理。如果判断得出包首部中的IP地址与自己的IP地址匹配，则可接收数据并从中查找上一层的协议。如果上一层是TCP就将IP包首部之后的部分传给TCP处理；如果是UDP则将IP包首部后面的部分传给UDP处理。对于有路由器的情况下，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送达的主机或路由器以后再转发数据。</p>
<ul>
<li>[7]TCP模块的处理</li>
</ul>
<p>在TCP模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。</p>
<p>数据接收完毕后，接收端则发送一个“确定回执”给发送端。如果这个回执信息未能达到发送端，那么发送端会认为接收端没有接收到数据而一直反复发送。</p>
<p>数据被完整地接收以后，会传给由端口号识别的应用程序。</p>
<ul>
<li>[8]应用程序的处理</li>
</ul>
<p>接收端应用程序会直接接收发送端发送的数据。通过解析数据可以获知邮件的收件人地址是乙的地址。如果主机B上没有乙的邮件信箱，那么主机B返回给发送端一个“无此收件地址”的报错信箱。</p>
<p>但在这个例子中，主机B上有乙的收件箱，所有主机B和收件人乙能够收到电子邮箱的正文。邮件会被保存到本机的硬盘上。如果保存也能正常进行，那么接收端会返回一个“处理正常”的回执给发送端。反之，一旦出现磁盘满、邮件未能成功保存等问题，就会发送一个“处理异常”的回执给发送端。</p>
<p>由此，用户以就可以利用主机B的邮件客户端，接收并阅读由主机A上的用户甲所发送过来的电子邮件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2015/12/17/TCP-IP1模型/" data-id="cj6ft5etp009sqm195n2bepfv" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2015/12/17/TCP-IP1模型/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络通信/">网络通信</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/24/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="page-number" href="/page/24/">24</a><span class="page-number current">25</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/26/">下一页&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/08/16/Android启动流程①init进程分析/">Android启动流程①init进程分析</a>
          </li>
        
          <li>
            <a href="/2017/08/15/Android系统架构与源码目录/">Android系统架构与源码目录</a>
          </li>
        
          <li>
            <a href="/2017/08/14/Mac编译Android源码/">Mac编译Android源码</a>
          </li>
        
          <li>
            <a href="/2017/06/21/JavaScript⑦对象/">JavaScript⑦对象</a>
          </li>
        
          <li>
            <a href="/2017/06/19/JavaScript⑥引用类型RegExp/">JavaScript⑥引用类型RegExp</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2017 刘涤生&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;michaelliu0727@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/categories" class="mobile-nav-link">分类</a>
  
    <a href="/tags" class="mobile-nav-link">标签</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>
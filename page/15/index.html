<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>再读斋</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="像外行一样思考,像专家一样实践。">
<meta property="og:type" content="website">
<meta property="og:title" content="再读斋">
<meta property="og:url" content="http://liuguoquan727.github.io/page/15/index.html">
<meta property="og:site_name" content="再读斋">
<meta property="og:description" content="像外行一样思考,像专家一样实践。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="再读斋">
<meta name="twitter:description" content="像外行一样思考,像专家一样实践。">
  
    <link rel="alternate" href="/atom.xml" title="再读斋" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liuguoquan727.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/categories">分类</a>
        
          <a class="main-nav-link" href="/tags">标签</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">再读斋</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">MICHAEL</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Android-View的事件分发机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/26/Android-View的事件分发机制/" class="article-date">
  <time datetime="2016-04-26T13:22:52.000Z" itemprop="datePublished">2016-04-26 21:22:52</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/26/Android-View的事件分发机制/">View的事件分发机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="点击事件的传递规则"><a href="#点击事件的传递规则" class="headerlink" title="点击事件的传递规则"></a>点击事件的传递规则</h1><p>首先明确我们这里要分析的对象就是MotionEvent，及点击事件。所谓点击事件的事件分发，其实就是对MotionEvent事件的分发过程，即当一个MotionEvent事件产生了以后，系统需要把这个事件传递给一个具体的View，而这个传递的过程就是分发过程。点击事件的分发过程由三个很重要的方法来共同完成：dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent。</p>
<ul>
<li><strong>public boolean dispatchTouchEvent(MotionEvent event)</strong></li>
</ul>
<p>用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级的dispatchTouchEvent方法的影响，表示是否消耗此事件</p>
<ul>
<li><strong>public boolean onInterceptTouchEvent(MotionEvent event)</strong> //view无此方法，存在于ViewGroup中</li>
</ul>
<p>用来判断是否拦截某个事件，如果当前View拦截某个事件，那么在同一个事件序列中，次方法将不会被再次调用，返回结果表示是否拦截某个事件。</p>
<ul>
<li><strong>public boolean onTouchEvent(MotionEvent event)</strong></li>
</ul>
<p>在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件</p>
<p>上述三个方法到底有什么区别呢？它们是什么关系呢？下面通过一段伪代码来表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> consume = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(onInterceptTouchEvent(ev)) &#123;</div><div class="line"></div><div class="line">		consume = onTouchEvent(ev);</div><div class="line"></div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">		consume = chiled.dispatchTouchEvent(ev);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> consume;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面的伪代码，我们可以大致了解点击事件的传递规则：对已一个跟ViewGroup来说，点击事件产生以后，首先会传递给它，这是它的dispatchTouchEvent就会被调用，如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup的onTouchEvent方法就会被调用；如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此反复直到事件被最终处理。</p>
<p>当一个View需要处理事件时，如果它设置了OnTouchListener，那么OnTouchListener中的OnTouch方法就会被回调，事件如何处理还要看onTouch的返回值，如果返回值为false，则当前View的OnTouchEvent方法会被调用；如果返回为true，则当前View的OnTouchEvent方法不会被调用。由此可见，给View设置的OnTouchListener，其优先级比onTouchEvent要高。在OnTouchEvent方法中，如果当前设置的有OnClickListener，那么它的onClick方法会被调用。可以看出，平时使用的OnClickListener其优先级最低，即处于事件的尾端。</p>
<p>当一个点击事件产生后，它的传递过程遵循如下顺序：Activity &gt; Window &gt; View，即事件总是先传递到Activity。Activity再传递给Window，最后Window再传递给顶级View，顶级View接收到事件后，就会按照事件分发机制去分发事件。</p>
<p>考虑一种情况，如果一个View的OnTouchEvent都返回false，那么它的父容器的OnTouchEvent将会被调用，依次类推，如果所有的子元素都不处理这个事件，那么这个事件将会最终传递给Activity处理，即Activity的OnTouchEvent将会被调用。我们可以用实际生活的例子来描述：假如点击事件是一个难题，这个难题最终被上级领导分给了一个程序员去处理（这是事件分发过程），结果这个程序员搞不定（OnTouchEvent返回false），现在该怎么办呢？程序员只能交给水平更高的程序员去解决（上级的OnTouchEvent被调用），如果上级再搞不定，那只能交给上级的上级去解决，这样就将难题一层层的向上抛，这是公司内部一种很常见的处理问题的过程。</p>
<p>关于事件传递的机制，这里给出一些结论，根据这些揭露可以更好地理解整个传递机制：</p>
<ul>
<li><p>（1）同一个事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束。在这个过程中产生了一系列事件，这个时间序列以down事件开始，中间含有数量不定的move事件，最终以up事件结束。</p>
</li>
<li><p>（2）正常情况下，一个事件序列只能被一个View拦截并且消耗。这一条的原因可以参考（3），因为一旦一个元素拦截了某此事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一个事件序列中的事件不能分别由两个View同时处理，但是通过特殊手段可以做到，比如一个View将本该自己处理的事件通过OnTouchEvent强行传递给其他View处理。</p>
</li>
<li><p>（3）某个View一旦决定拦截，那么这个事件的序列的搜只能由它来处理（如果事件序列能够传递给它的话），并且它的onInterceptTouchEvent方法不会再被调用。就是说当一个View决定拦截一个事件后，那么系统会把同一个事件序列的其他方法都直接交给它来处理，因此就不用再调用这个View的OnInterceptTouchEvent其询问它是否要拦截了。</p>
</li>
<li><p>（4）某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件（onTouchEvent返回了false），那么同一个事件序列中的其他事件都不会再交给它来处理。并且事件将重新交由它的父元素去处理，即父元素的OnTouchEvent会被调用。意思就是事件一旦交给一个View处理，那么它就必须消耗掉，否则同一事件序列中剩下的事件就不再交给它来处理了。</p>
</li>
<li><p>（5）如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件将会消失，此时父元素的OnTouchEvent并不会被调用，并且当前View可以持续受到后续的事件，最终这些消失的点击事件会传递给Activity处理。</p>
</li>
<li><p>（6）ViewGroup默认不拦截任何事件。Android源码中ViewGroup的OnInterceptTouchEvent方法默认返回false</p>
</li>
<li><p>（7）View没有OnInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的OnTouchEvent方法就会被调用</p>
</li>
<li><p>（8）View的OnTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable默认为true，而TextView的clickable属性默认为false。</p>
</li>
<li><p>（9）View的enable属性不影响OnTouchEvent的默认返回值，哪怕一个View是disable状态的，只要它的clickable和longClickable有一个为true，那么它的OnTouchEvent就返回true。</p>
</li>
<li><p>（10）onClick会发生的前提是当前View是可点击的，并且收到了down和up事件</p>
</li>
<li><p>（11）事件传递过程是由外向内的，即事件总是先传递给父元素，然后再有父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</p>
</li>
</ul>
<h1 id="事件分发的源码解析"><a href="#事件分发的源码解析" class="headerlink" title="事件分发的源码解析"></a>事件分发的源码解析</h1><h2 id="Activity对点击事件的分发过程"><a href="#Activity对点击事件的分发过程" class="headerlink" title="Activity对点击事件的分发过程"></a>Activity对点击事件的分发过程</h2><p>点击事件用MotionEvent来表示，当一个点击操作发生时，事件最先传递给当前Activity，由Activity的dispatchTouchEvent来进行事件分发，具体的工作是由Activity内部的Window来完成的。Window会将事件传递给decor view，decor view一般就是当前界面的底层容器（即setContentView所设置的View的父容器），通过Activity.getWindow。getDecorView()可以获得。先从Activity的dispatchTouchEvent开始分析。</p>
<p>源码：Activity#dispatchTouchEvent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">		onUserInteraction();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> onTouchEvent(ev);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析上面的代码。首先事件交给Activity所附属的Window进行分发，如果返回true，整个事件就循环结束了，返回false以为着事件没人处理，所有View的onTouchEvent都返回了false，那么Activity的onTouchEvent就会被调用</p>
<p>接下里看Window是如何将事件传递给ViewGroup的。Window是是个抽象类，而Window的superDispatchTouchEvent方法也是个抽象方法，因此我们必须找到Window的实现类才行</p>
<p>源码：Window#superDispatchTouchEvent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span></span>;</div></pre></td></tr></table></figure>
<p>到底Window的实现类是什么呢？其实是PhoneWindow，Window的唯一实现是android.policy.Window，接下来看一下PhoneWindow是如何处理点击事件的，</p>
<p>源码：PhoneWindow#superDispatchTouchEvent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> DecorView mDecor;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PhoneWindow将事件直接传递给了DecorView，这个DecorView是什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DecorView</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> <span class="keyword">implements</span> <span class="title">RootViewSurfaceTaker</span></span></div><div class="line"></div><div class="line">@<span class="title">Override</span></div><div class="line"><span class="title">public</span> <span class="title">final</span> <span class="title">View</span> <span class="title">getDecorView</span>() &#123;</div><div class="line">	<span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</div><div class="line">		installDecor();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> mDecor;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，这个mDecor就是通过getWindow().getDecor()返回的View，而我们通过setContentView设置的View是它的一个子View。目前事件传递到了DecorView这里，由于DecorView继承自FrameLayout且是父View，所有最终事件会传递到View。换句话说，事件肯定会传递到View，不然应用如何响应点击事件呢？重点是事件到了View以后该如何传递。从这里开始，事件已经传递到顶级View了，即在Activity中通过setContentView所设置的View，另外顶级View也叫根View，顶级View一般来说都是ViewGroup。</p>
<h2 id="顶级View对点击事件的分发过程"><a href="#顶级View对点击事件的分发过程" class="headerlink" title="顶级View对点击事件的分发过程"></a>顶级View对点击事件的分发过程</h2><p>点击事件达到顶级View以后，会调用ViewGroup的dispatchTouchEvent方法，然后逻辑是这样的：如果顶级ViewGroup拦截事件即OnInterceptTouchEvent返回true，则事件由ViewGroup处理，这时如果ViewGroup的OnTouchListener被设置，则onTouch被调用，否则onTouchEvent被调用，也就是说两者都设置的话，onTouch会屏蔽掉OnTouchEvent。在OnTouchEvent中如果设置了OnClickListener，则OnClick会被调用。如果顶级ViewGroup不拦截事件，则事件会传递给它所在的点击事件链上的子View，这时子View的dispatchTouchEvent会被调用。到此，事件已经从顶级View传递给下一层View，接下来的传递过程和顶级View是一致的，如此循环完成整个事件的分发。</p>
<p>首先看ViewGroup对点击事件的分发过程，其主要实现在ViewGroup的dispatchTouchEvent方法中，这个方法较长。先看下面一段，它描述的是View是否拦截点击事件这个逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Check for interception.</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</div><div class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">		|| mFirstTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span> (!disallowIntercept) &#123;</div><div class="line">		intercepted = onInterceptTouchEvent(ev);</div><div class="line">		ev.setAction(action); <span class="comment">// restore action in case it was changed</span></div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		intercepted = <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	<span class="comment">// There are no touch targets and this action is not an initial down</span></div><div class="line">	<span class="comment">// so this view group continues to intercept touches.</span></div><div class="line">	intercepted = <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line">`</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出，ViewGroup在如下两种情况下会判断是否要拦截当前事件：事件类为ACTION_DOWN或者mFirstTouchTarget ！= null，mFirstTouchTarget ！= null是什么意思了？当ViewGroup不拦截事件并将事件交由子元素处理时mFirstTouchTarget ！= null 。反过来，一旦事件由当前ViewGroup拦截时，mFirstTouchTarget ！= null就不成立，那么当ACTION_DWON和ACTION_UP事件到来时，由于(actionMasked == MotionEvent.ACTION_DOWN|| mFirstTouchTarget != null)为false，将导致ViewGroup的OnInterceptTouchEvent不会再调用，并且同一序列中的其他事件都会默认交由给它处理。</p>
<p>这里有一种特使情况，那就是FLAG_DISALLOW_INTERCEPT标记位，这个标记位是通过requestDisallowInterceptTouchEvent设置的，一般用于子View中。FLAG_DISALLOW_INTERCEPT一旦设置后，ViewGroup将无法拦截除了ACTION_DOWN以外的其他事件。为什么说是除了ACTION_DOWN意外的其他事件了？这是因为ViewGroup在分发事件时，如果是ACTION_DOWN就会重置FLAG_DISALLOW_INTERCEPT这个标记位，将导致子View中设置的这个标记位无效。因此，当面对ACTION_DOWN事件时，ViewGroup总是会调用自己的OnInterceptTouchEvent方法来询问自己是否要拦截事件。在下面的代码中，ViewGroup会在ACTION_DOWN事件到来时做重置状态的操作，而在resetTouchState方法中会对FLAG_DISALLOW_INTERCEPT进行重置，因此子View调用requestDisallowInterceptTouchEvent方法并不能影响ViewGroup对ACTION_DOWN的处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">	<span class="comment">// Throw away all previous state when starting a new touch gesture.</span></div><div class="line">	<span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></div><div class="line">	<span class="comment">// due to an app switch, ANR, or some other state change.</span></div><div class="line">	cancelAndClearTouchTargets(ev);</div><div class="line">	resetTouchState();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的源码分析，我们可以得出结论：当ViewGroup决定拦截事件后，那么后续的点击事件将会默认交给它处理，并且不再调用它的OnInterceptTouchEvent方法。FLAG_DISALLOW_INTERCEPT这个标志的作用是ViewGroup不再拦截事件，当前前提是ViewGroup不拦截ACTION_DOWN事件。那么这段分析有什么价值呢？总结起来有两点：第一，OnInterceptTouchEvent不是每次事件都会被调用的，如果我们想提前处理所有的点击事件，要选择dispatchTouchEvent方法，只有这个方法能确保每次都会调用，当然前提是事件能够传递到当前的ViewGroup；第二点：FLAG_DISALLOW_INTERCEPT标记位的作用给我们提供了一个思路，当面对滑动冲突时，我们可以是不是考虑用这种方法去解决问题？</p>
<p>接着再看当ViewGroup不拦截事件的时候，事件会向下分发交由它的子View进行处理，这段源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</div><div class="line"><span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</div><div class="line">	<span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</div><div class="line">	<span class="comment">// Find a child that can receive the event.</span></div><div class="line">	<span class="comment">// Scan children from front to back.</span></div><div class="line">	<span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();</div><div class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></div><div class="line">			&amp;&amp; isChildrenDrawingOrderEnabled();</div><div class="line">	<span class="keyword">final</span> View[] children = mChildren;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">		<span class="keyword">final</span> <span class="keyword">int</span> childIndex = customOrder</div><div class="line">				? getChildDrawingOrder(childrenCount, i) : i;</div><div class="line">		<span class="keyword">final</span> View child = (preorderedList == <span class="keyword">null</span>)</div><div class="line">				? children[childIndex] : preorderedList.get(childIndex);</div><div class="line"></div><div class="line">		<span class="comment">// If there is a view that has accessibility focus we want it</span></div><div class="line">		<span class="comment">// to get the event first and if not handled we will perform a</span></div><div class="line">		<span class="comment">// normal dispatch. We may do a double iteration but this is</span></div><div class="line">		<span class="comment">// safer given the timeframe.</span></div><div class="line">		<span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</div><div class="line">				<span class="keyword">continue</span>;</div><div class="line">			&#125;</div><div class="line">			childWithAccessibilityFocus = <span class="keyword">null</span>;</div><div class="line">			i = childrenCount - <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (!canViewReceivePointerEvents(child)</div><div class="line">				|| !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</div><div class="line">			ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		newTouchTarget = getTouchTarget(child);</div><div class="line">		<span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="comment">// Child is already receiving touch within its bounds.</span></div><div class="line">			<span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></div><div class="line">			newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		resetCancelNextUpFlag(child);</div><div class="line">		<span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</div><div class="line">			<span class="comment">// Child wants to receive touch within its bounds.</span></div><div class="line">			mLastTouchDownTime = ev.getDownTime();</div><div class="line">			<span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="comment">// childIndex points into presorted list, find original index</span></div><div class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</div><div class="line">					<span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</div><div class="line">						mLastTouchDownIndex = j;</div><div class="line">						<span class="keyword">break</span>;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				mLastTouchDownIndex = childIndex;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		mLastTouchDownX = ev.getX();</div><div class="line">		mLastTouchDownY = ev.getY();</div><div class="line">		newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">		alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先遍历ViewGroup的所有子元素，然后判断子元素是否能够接收到点击事件。是否能够接收到点击事件主要由两点来衡量：子元素是否在播动画和点击事件的坐标是否落在子元素的区域内。如果某个子元素满足这两个条件，那么事件就会传递给它来处理。可以看到dispatchTransformedTouchEvent实际上调用的就是子元素的dispatchTouchEvent方法，在它的内部有一段内容：而在上面的代码中child传递的不是null，因此它会直接调用子元素的dispatchTouchEvent，这样事件就交由子元素处理，从而完成了一轮事件分发。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</div><div class="line">	handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	handled = child.dispatchTouchEvent(event);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果子元素的dispatchTouchEvent返回true，那么，FirstTouchTarget就会被赋值同时跳出for循环，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line"><span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<p>这几行代码就完成了mFirstTouchTarget的赋值并终止对子元素的遍历。如果子元素的dispatchTouchEvent返回false，ViewGroup就会把事件分发给下一个子元素。</p>
<p>其实mFirstTouchTarget真正的赋值过程是在addTouchTarget内部完成的，从下面的addTouchTarget方法的内部结构可以看出，mFirstTouchTarget其实是一种单链表结构。mFirstTouchTarget是否被赋值，将直接影响到ViewGroup对事件的拦截策略，如果mFirstTouchTarget为null，那么ViewGroup就默认拦截接下来同一序列中所有的点击事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> TouchTarget <span class="title">addTouchTarget</span><span class="params">(View child, <span class="keyword">int</span> pointerIdBits)</span> </span>&#123;</div><div class="line">	TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</div><div class="line">	target.next = mFirstTouchTarget;</div><div class="line">	mFirstTouchTarget = target;</div><div class="line">	<span class="keyword">return</span> target;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果遍历所有的子元素后事件都没有合适地处理，这包含两种情况：第一种是ViewGroup没有子元素；第二种是子元素处理了点击事件，但是再dispatchTouchEvent中返回了false，这一般式因为子元素在OnTouchEvent中返回了false。在这两种情况下ViewGroup会自己处理点击事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Dispatch to touch targets.</span></div><div class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</div><div class="line">	<span class="comment">// No touch targets so treat this as an ordinary view.</span></div><div class="line">	handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</div><div class="line">			TouchTarget.ALL_POINTER_IDS);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第三个参数child为null，它会调用super.dispatchTouchEvent(event)，很显然，这里就转到了View（不包括ViewGroup）的dispatchTouchEvent方法，即点击事件开始交由View来处理。</p>
<h2 id="View对点击事件的处理过程"><a href="#View对点击事件的处理过程" class="headerlink" title="View对点击事件的处理过程"></a>View对点击事件的处理过程</h2><p>View点击事件的处理过程简单一些，这里的View不包含ViewGroup。先看它的dispatchTouchEvent方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">	<span class="comment">// If the event should be handled by accessibility focus first.</span></div><div class="line">	...</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</div><div class="line">		<span class="comment">//noinspection SimplifiableIfStatement</span></div><div class="line">		ListenerInfo li = mListenerInfo;</div><div class="line">		<span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></div><div class="line">				&amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class="line">				&amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</div><div class="line">			result = <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</div><div class="line">			result = <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	...</div><div class="line"></div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>View对点击事件的处理就比较简单了因为View是一个单独的元素，它没有子元素因此无法向下传递事件，所以它只能自己处理事件。从上面的源码可以看出View对点击事件的处理过程，首先会判断有没有设置OnTouchListener，如果OnTouchListener中的OnTouch方法返回true，那么OnTouchEvent就不会被调用，可见OnTouchListener的优先级高于OnTouchEvent。</p>
<p>接着再分析OnTouchEvent的实现。先看当View出于不可用状态下的点击事件的处理过程，如下所示，不可用状态下的View照样会消耗点击事件，尽管它看起来不可用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</div><div class="line">	<span class="keyword">if</span> (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">		setPressed(<span class="keyword">false</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// A disabled view that is clickable still consumes the touch</span></div><div class="line">	<span class="comment">// events, it just doesn't respond to them.</span></div><div class="line">	<span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">			(viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着，如果View设置有代理，那么还会执行TouchDelegate的onTouchEvent方法，这个OnTouchEvent的工作机制看起来和OnTouchListener类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</div><div class="line">	<span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面再看一下OnTouchEvent中堆点击事件的具体处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">          (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123;</div><div class="line">      <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">          <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">              <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</div><div class="line">              <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</div><div class="line">                  <span class="comment">// take focus if we don't have it already and we should in</span></div><div class="line">                  <span class="comment">// touch mode.</span></div><div class="line">                  <span class="keyword">boolean</span> focusTaken = <span class="keyword">false</span>;</div><div class="line">                  <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</div><div class="line">                      focusTaken = requestFocus();</div><div class="line">                  &#125;</div><div class="line">	</div><div class="line">                  <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                      <span class="comment">// The button is being released before we actually</span></div><div class="line">                      <span class="comment">// showed it as pressed.  Make it show the pressed</span></div><div class="line">                      <span class="comment">// state now (before scheduling the click) to ensure</span></div><div class="line">                      <span class="comment">// the user sees it.</span></div><div class="line">                      setPressed(<span class="keyword">true</span>, x, y);</div><div class="line">                 &#125;</div><div class="line">	</div><div class="line">                  <span class="keyword">if</span> (!mHasPerformedLongPress) &#123;</div><div class="line">                      <span class="comment">// This is a tap, so remove the longpress check</span></div><div class="line">                      removeLongPressCallback();</div><div class="line">	</div><div class="line">                      <span class="comment">// Only perform take click actions if we were in the pressed state</span></div><div class="line">                      <span class="keyword">if</span> (!focusTaken) &#123;</div><div class="line">                          <span class="comment">// Use a Runnable and post this rather than calling</span></div><div class="line">                          <span class="comment">// performClick directly. This lets other visual state</span></div><div class="line">                          <span class="comment">// of the view update before click actions start.</span></div><div class="line">                          <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</div><div class="line">                              mPerformClick = <span class="keyword">new</span> PerformClick();</div><div class="line">                          &#125;</div><div class="line">                          <span class="keyword">if</span> (!post(mPerformClick)) &#123;</div><div class="line">                              performClick();</div><div class="line">                          &#125;</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">	</div><div class="line">                  <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;</div><div class="line">                      mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();</div><div class="line">                  &#125;</div><div class="line">	</div><div class="line">                  <span class="keyword">if</span> (prepressed) &#123;</div><div class="line">                      postDelayed(mUnsetPressedState,</div><div class="line">                              ViewConfiguration.getPressedStateDuration());</div><div class="line">                  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!post(mUnsetPressedState)) &#123;</div><div class="line">                      <span class="comment">// If the post failed, unpress right now</span></div><div class="line">                      mUnsetPressedState.run();</div><div class="line">                  &#125;</div><div class="line">	</div><div class="line">                  removeTapCallback();</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">	</div><div class="line">          <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">              mHasPerformedLongPress = <span class="keyword">false</span>;</div><div class="line">	</div><div class="line">              <span class="keyword">if</span> (performButtonActionOnTouchDown(event)) &#123;</div><div class="line">                  <span class="keyword">break</span>;</div><div class="line">              &#125;</div><div class="line">	</div><div class="line">              <span class="comment">// Walk up the hierarchy to determine if we're inside a scrolling container.</span></div><div class="line">              <span class="keyword">boolean</span> isInScrollingContainer = isInScrollingContainer();</div><div class="line">	</div><div class="line">              <span class="comment">// For views inside a scrolling container, delay the pressed feedback for</span></div><div class="line">              <span class="comment">// a short period in case this is a scroll.</span></div><div class="line">              <span class="keyword">if</span> (isInScrollingContainer) &#123;</div><div class="line">                  mPrivateFlags |= PFLAG_PREPRESSED;</div><div class="line">                  <span class="keyword">if</span> (mPendingCheckForTap == <span class="keyword">null</span>) &#123;</div><div class="line">                      mPendingCheckForTap = <span class="keyword">new</span> CheckForTap();</div><div class="line">                  &#125;</div><div class="line">                  mPendingCheckForTap.x = event.getX();</div><div class="line">                  mPendingCheckForTap.y = event.getY();</div><div class="line">                  postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</div><div class="line">              &#125; <span class="keyword">else</span> &#123;</div><div class="line">                  <span class="comment">// Not inside a scrolling container, so show the feedback right away</span></div><div class="line">                  setPressed(<span class="keyword">true</span>, x, y);</div><div class="line">                  checkForLongClick(<span class="number">0</span>);</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">	</div><div class="line">          <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</div><div class="line">              setPressed(<span class="keyword">false</span>);</div><div class="line">              removeTapCallback();</div><div class="line">              removeLongPressCallback();</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">	</div><div class="line">          <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">              drawableHotspotChanged(x, y);</div><div class="line">	</div><div class="line">              <span class="comment">// Be lenient about moving outside of buttons</span></div><div class="line">              <span class="keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</div><div class="line">                  <span class="comment">// Outside button</span></div><div class="line">                  removeTapCallback();</div><div class="line">                  <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</div><div class="line">                      <span class="comment">// Remove any future long press/tap checks</span></div><div class="line">                      removeLongPressCallback();</div><div class="line">	</div><div class="line">                      setPressed(<span class="keyword">false</span>);</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">	</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>只要View的Clickable和longClickable有一个为true，那么就会消耗这个事件，即OnTouchEvent返回true，不管它是不是disable状态。然后就是当ACTION_UP事件发生时会触发performClick方法，如果View设置了OnClickListener，那么performClick方法内部会调用它的onClick方法，如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> result;</div><div class="line">	<span class="keyword">final</span> ListenerInfo li = mListenerInfo;</div><div class="line">	<span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</div><div class="line">		playSoundEffect(SoundEffectConstants.CLICK);</div><div class="line">		li.mOnClickListener.onClick(<span class="keyword">this</span>);</div><div class="line">		result = <span class="keyword">true</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		result = <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>View的LONG_CLICKABLE属性默认为false，而CLICKABLE属性是否为false和具体的View有关，确切来说是可点击的View其CLICKABLE为true，不可点击的View其CLICKABLE为false。通过setClickable和setLongClickable可以改变View的LONG_CLICKABLE、CLICKABLE属性。另外，setOnClickListener和setOnLongClickListener会自动将View的LONG_CLICKABLE、CLICKABLE属性设置为true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnClickListener</span><span class="params">(OnClickListener l)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (!isClickable()) &#123;</div><div class="line">		setClickable(<span class="keyword">true</span>);</div><div class="line">	&#125;</div><div class="line">	getListenerInfo().mOnClickListener = l;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnLongClickListener</span><span class="params">(OnLongClickListener l)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (!isLongClickable()) &#123;</div><div class="line">		setLongClickable(<span class="keyword">true</span>);</div><div class="line">	&#125;</div><div class="line">	getListenerInfo().mOnLongClickListener = l;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2016/04/26/Android-View的事件分发机制/" data-id="cj6ft5eqd0019qm19mgm1n0ug" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2016/04/26/Android-View的事件分发机制/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android系统/">Android系统</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Android-View的工作流程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/26/Android-View的工作流程/" class="article-date">
  <time datetime="2016-04-26T13:22:34.000Z" itemprop="datePublished">2016-04-26 21:22:34</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/26/Android-View的工作流程/">View的工作流程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>View的工作流程主要指measure、layout、draw这三大流程，即测量、布局和绘制，其中measure确定View的测量宽/高，layout确定View的最终宽/高和四个顶点的位置（即View在父容器中的放置位置），draw则将View绘制到屏幕上。</p>
<h1 id="measure过程"><a href="#measure过程" class="headerlink" title="measure过程"></a>measure过程</h1><p>measure过程要分情况来看，如果只是一个原始的View，那么通过measure方法就完成了其测量的过程，如果是一个ViewGroup，除了完成自己的测量过程外，还会遍历去调用所有子元素的measure方法，各个子元素再递归去执行这个流程。</p>
<h2 id="View的测量过程"><a href="#View的测量过程" class="headerlink" title="View的测量过程"></a>View的测量过程</h2><p>View的measure过程是由其measure方法来完成，measure方法是一个final类型的方法，这意味着子类不能重写此方法，在View的measure方法中会去调用View的onMeasure方法，因此只需要看onMeasure的实现即可，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">	setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</div><div class="line">			getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上所示，setMeasuredDimension方法会设置View宽/高的测量值，因此我们只需要看getDefaultSize这个方法即可：</p>
<h2 id="测量的三种模式"><a href="#测量的三种模式" class="headerlink" title="测量的三种模式"></a>测量的三种模式</h2><ol>
<li><p>EXACTLY：精确值模式<br>当我们将控件的layout_width或layout_height属性指定为具体的数值时，或指定为match_parent属性时，系统使用的是EXACTLY模式。</p>
</li>
<li><p>AT_MOST：最大值模式<br>当我们将控件的layout_width或layout_height属性指定为wrap_content时,系统使用的是AT_MOST模式  </p>
</li>
<li><p>UNSPECIFIED：<br>此模式不指定其大小测量模式，View想多大就多大，通常情况系统绘制自定义View时才会使用  </p>
</li>
</ol>
<p><strong>Note:: View类默认的onMeasure()方法只支持EXACTLY模式，而如果要让自定义View支持wrap_content属性时，那么必须重写onMeasure()方法来指定wrap_content的大小</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> result = size;</div><div class="line">	<span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec); <span class="comment">//测量模式</span></div><div class="line">	<span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec); <span class="comment">//绘制的大小</span></div><div class="line"></div><div class="line">	<span class="keyword">switch</span> (specMode) &#123;</div><div class="line">	<span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</div><div class="line">		result = size;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	<span class="keyword">case</span> MeasureSpec.AT_MOST: <span class="comment">//重写指定AT_MOST模式的值</span></div><div class="line">	<span class="keyword">case</span> MeasureSpec.EXACTLY:</div><div class="line">		result = specSize;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，其实getDefaultSize返回的大小就是measureSpec中的specSize，而这个specSize就是View测量后的大小，这里多次提到测量后的大小是因为View的最终大小是在layout阶段确定的，所以必须加以区分，但是几乎所有情况下View的测量大小和最终大小是相等的。</p>
<p>在上述情况下，View的大小为getDefaultSize的第一个参数size，及宽高分别为getSuggestedMinimumWidth和getSuggestedMinimumHeight的返回值，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="layout过程"><a href="#layout过程" class="headerlink" title="layout过程"></a>layout过程</h1><p>Layout的作用是ViewGroup用来确定子元素的位置，当ViewGroup的位置被确定后，它在onLayout中会遍历所有子元素并调用其layout方法，View的layout方法中onLayout方法又会被调用。layout方法确定View本身的位置，而onLayout方法则会确定所有子元素的位置，View的layout方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</div><div class="line">		onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</div><div class="line">		mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">int</span> oldL = mLeft;</div><div class="line">	<span class="keyword">int</span> oldT = mTop;</div><div class="line">	<span class="keyword">int</span> oldB = mBottom;</div><div class="line">	<span class="keyword">int</span> oldR = mRight;</div><div class="line"></div><div class="line">	<span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</div><div class="line">			setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</div><div class="line">		onLayout(changed, l, t, r, b);</div><div class="line">		mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</div><div class="line"></div><div class="line">		ListenerInfo li = mListenerInfo;</div><div class="line">		<span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</div><div class="line">			ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</div><div class="line">					(ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</div><div class="line">			<span class="keyword">int</span> numListeners = listenersCopy.size();</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</div><div class="line">				listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</div><div class="line">	mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>layout方法大致流程如下：首先通过setFrame方法设定View的四个顶点的位置，即初始化mLeft、mTop、mBottom、mRight这四个值，View的四个顶点一旦确定，那么View在父容器的位置也就确定了；接着会调用onLayout方法，用途是父容器确定子元素的位置，和onMeasure方法类似，onLayout的具体实现同样和具体的布局有关，所以View和ViewGroup均没有真正的实现。我们可以看一下TextView的onLayout方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</div><div class="line">	<span class="keyword">super</span>.onLayout(changed, left, top, right, bottom);</div><div class="line">	<span class="keyword">if</span> (mDeferScroll &gt;= <span class="number">0</span>) &#123;</div><div class="line">		<span class="keyword">int</span> curs = mDeferScroll;</div><div class="line">		mDeferScroll = -<span class="number">1</span>;</div><div class="line">		bringPointIntoView(Math.min(curs, mText.length()));</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="draw过程"><a href="#draw过程" class="headerlink" title="draw过程"></a>draw过程</h1><p>Draw过程较简单，作用是将View绘制到屏幕上面。</p>
<p>当测量好一个View之后，我们就可以重写onDraw方法，并在Canvas对象上绘制所需要的图形，最终显示在屏幕上。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2016/04/26/Android-View的工作流程/" data-id="cj6ft5eqa0013qm19metqe8dw" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2016/04/26/Android-View的工作流程/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android系统/">Android系统</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Android的消息机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/26/Android的消息机制/" class="article-date">
  <time datetime="2016-04-26T13:20:28.000Z" itemprop="datePublished">2016-04-26 21:20:28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/26/Android的消息机制/">Android的消息机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="Android的消息机制概述"><a href="#Android的消息机制概述" class="headerlink" title="Android的消息机制概述"></a>Android的消息机制概述</h1><p>Android的消息机制主要是指Handler的运行机制，Handler的运行机制需要底层的MessageQueue和Looper的支撑。</p>
<p>MessageQueue的中文为消息队列，顾名思义，它的内部存储了一组消息，以队列的形式对外提供插入和删除的方法。虽然称为消息队列，但是它的<strong>内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息列表</strong>。</p>
<p>Looper的中文翻译是循环，这里可以理解为消息循环。由于MessageQueue只是一个消息的存储单元，它不能去处理消息，而Looper会以无限循环的形式其查询是否有新的消息，如果有的话就处理消息，否则就一直等待。</p>
<p>Looper中还有一个特殊的概念，那就是ThreadLocal，ThreadLocal并不是线程，它的作用是可以在每个线程中存储数据。我们知道，Handler创建的时候会采用当前线程的Looper来构造消息循环系统，那么Handler内部如何获取到当前线程的Looper呢？这就要使用ThreadLocal了，ThreadLocal可以在不同的线程中互不干扰地存储并提供数据，通过ThreadLocal就可以轻松地获取每个线程的Looper。</p>
<p>需要注意的是，线程是默认没有Looper的，如果需要使用Handler就必须为线程创建Looper。而主线程，即UI线程，它就是ActivityThread，ActivityThread被创建时就会初始化Looper，这也是在主线程中默认可以使用Handler的原因。</p>
<h1 id="Android消息机制分析"><a href="#Android消息机制分析" class="headerlink" title="Android消息机制分析"></a>Android消息机制分析</h1><p>Android消息机制主要是指Handler的运行机制以及Handler所附带的MessageQueue和Looper的工作过程，这三者实际上是一个整体。<strong>Handler的作用</strong>主要是将一个任务切换到某个指定的线程中去执行，那么Android为什么要提供这个功能呢？<strong>这是因为Android规定UI只能在主线程中进行，如果在子线程中访问UI，那么程序就会抛出运行时异常。</strong>ViewRootImp对UI操作做了验证，这个验证工作是由ViewRootImpl的checkThread方法来完成的，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(mThread != Thread.currentThread()) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(<span class="string">"Only the original thread that created a view hiearachy can touch its view"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Android建议我们不要在主线程中进行耗时的操作，否则会导致程序无法响应ANR。考虑一种情况，假如我们需要从服务器拉取一些信息并将其显示在UI上，这个时候必须在子线程中进行拉取工作，拉取完毕之后又不能在子线程中直接访问UI，如果没有Handler，那么我们确实没有办法将访问UI的工作切换到主线程中执行，因此，系统提供Handler的主要原因及时为了解决在子线程中无法访问UI的矛盾。</p>
<p><strong>系统为什么不允许在子线程中访问UI呢？</strong>这是 因为Android的UI控件不是线程安全的，如果在多线程中并发访问可能会导致UI控件处于不可预期的状态，而为什么系统不对UI控件的访问加上锁机制呢？缺点有两个：首先加上锁机制会让UI访问的逻辑变得复杂，其次锁机制会降低UI访问的效率，因为锁机制会阻塞某些线程的执行。因此最简单最高效的方法就是采用单线程模型来处理UI操作，对于开发者来说也不是很麻烦，只是需要通过Handler切换到UI访问的执行线程即可。</p>
<p>Handler的工作过程：Handler创建时会采用当前线程的Looper来构建内部的消息循环系统，如果当前线程没有Looper，那么就会报错；Handler创建完毕后，这个时候其内部的MessageQueue和Looper就可以协同工作了，然后通过Handler的post方法将一个Runnable传递到Handler内部的Looper中去处理，也可以通过Handler的send方法来发送一个消息，这个消息同样会在Looper中去处理。其实post方法最终也是在send方法中完成的。当Handler的send方法被调用时，它会调用MessageQueue的enqueueMessage方法将这个消息放入消息队列中，然后Looper发现有新消息到来时，就会处理这个消息，最终消息中的Runnable或者Handler的handleMessage方法就会被调用。</p>
<p>注意：Looper是运行在创建Handler所在的线程中的，这样一来Handler中的业务逻辑就被切换到创建Handler所在的线程中去执行了。</p>
<h2 id="ThreadLocal的工作原理"><a href="#ThreadLocal的工作原理" class="headerlink" title="ThreadLocal的工作原理"></a>ThreadLocal的工作原理</h2><p>ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。</p>
<p>下面通过实际的例子来演示ThreadLocal的作用。首先定义一个ThreadLocal对象，这里选择Boolean类型的，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ThreadLocal&lt;Boolean&gt; mThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Boolean&gt;();</div></pre></td></tr></table></figure></p>
<p>然后在主线程、子线程1和子线程2中设置和访问它的值，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">   mThreadLocal.set(<span class="keyword">true</span>);</div><div class="line">   System.out.println(<span class="string">"main thread: "</span> + mThreadLocal.get()); <span class="comment">//true</span></div><div class="line">   </div><div class="line">   <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		mThreadLocal.set(<span class="keyword">false</span>);</div><div class="line">		System.out.println(<span class="string">"thread 1: "</span> + mThreadLocal.get()); <span class="comment">//false</span></div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;).start();</div><div class="line">   </div><div class="line">   <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		</div><div class="line">		System.out.println(<span class="string">"thread 2: "</span> + mThreadLocal.get()); <span class="comment">//null，没有设置值</span></div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;).start();</div></pre></td></tr></table></figure>
<p>上述代码中，根据对ThreadLocal的描述，主线中mThreadLocal.get()为true，子线程1中mThreadLocal.get()为false，子线程2中mThreadLocal.get()为null。代码运行打印如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">15</span>:54:55.478: I/System.out(11711): main thread: <span class="keyword">true</span></div><div class="line">01-09 15:54:55.479: I/System.out(11711): thread 1: <span class="keyword">false</span></div><div class="line">01-09 15:54:55.480: I/System.out(11711): thread 2: <span class="keyword">null</span></div></pre></td></tr></table></figure>
<p><strong>从上面的打印可以看出</strong>，虽然不同的线程访问的是同一个ThreadLocal对象，但是它们通过ThreadLocal获取的值却是不一样的，这就是ThreadLocal的特点。ThreadLocal之所以有如此特点，是因为不同线程访问同一个ThreadLocal的get方法，ThreadLocal内部会从各自的线程中取出一个数组，然后再从数组中根据当前的ThreadLocal索引去查找对应的value值。很显然，不同线程中的数组是不同的，这就是为什么通过ThreadLocal可以在不同的线程中维护一套数据的副本并且互不干扰。</p>
<p>上面描述的ThreadLocal的使用方法和工作过程，下面分析ThreadLocal的内部实现，ThreadLocal是一个泛型类，它的定义为<code>public class ThreadLocal&lt;T&gt;</code>，只要弄清楚ThreadLocal的get和set方法就可以明白它的工作原理。</p>
<p>首先看get和set方法，如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">    Thread currentThread = Thread.currentThread();</div><div class="line">    Values values = values(currentThread);</div><div class="line">    <span class="keyword">if</span> (values == <span class="keyword">null</span>) &#123;</div><div class="line">        values = initializeValues(currentThread);</div><div class="line">    &#125;</div><div class="line">    values.put(<span class="keyword">this</span>, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Values <span class="title">initializeValues</span><span class="params">(Thread current)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> current.localValues = <span class="keyword">new</span> Values();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Gets Values instance for this thread and variable type.</div><div class="line"> */</div><div class="line"><span class="function">Values <span class="title">values</span><span class="params">(Thread current)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> current.localValues;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的set方法中，首先会通过values方法来获取当前线程中的ThreadLocal数据，<strong>如何获取呢？</strong>在Thread内部有一个成员变量专门用于存储线程的ThreadLocal数据：ThreadLocal.Values localValues;因此获取当前线程的ThreadLocal数据就变得异常简单。如果localValues的值为null，那么久需要对其进行初始化化，初始化后再将ThreadLocal的值进行存储。</p>
<p>下面看一下ThreadLocal的值到底是如何在localValues中进行存储的。在localValues内部有一个数组：private Object[] table;ThreadLocal的值就存储在这个table数组中。下面看一下localValues是如何使用put方法将ThreadLocal的值存储到table数组中的，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Sets entry for given ThreadLocal to given value, creating an</div><div class="line"> * entry if necessary.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</div><div class="line">    cleanUp();</div><div class="line"></div><div class="line">    <span class="comment">// Keep track of first tombstone. That's where we want to go back</span></div><div class="line">    <span class="comment">// and add an entry if necessary.</span></div><div class="line">    <span class="keyword">int</span> firstTombstone = -<span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = key.hash &amp; mask;; index = next(index)) &#123;</div><div class="line">        Object k = table[index];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (k == key.reference) &#123;</div><div class="line">            <span class="comment">// Replace existing entry.</span></div><div class="line">            table[index + <span class="number">1</span>] = value;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (firstTombstone == -<span class="number">1</span>) &#123;</div><div class="line">                <span class="comment">// Fill in null slot.</span></div><div class="line">                table[index] = key.reference;</div><div class="line">                table[index + <span class="number">1</span>] = value;</div><div class="line">                size++;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Go back and replace first tombstone.</span></div><div class="line">            table[firstTombstone] = key.reference;</div><div class="line">            table[firstTombstone + <span class="number">1</span>] = value;</div><div class="line">            tombstones--;</div><div class="line">            size++;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Remember first tombstone.</span></div><div class="line">        <span class="keyword">if</span> (firstTombstone == -<span class="number">1</span> &amp;&amp; k == TOMBSTONE) &#123;</div><div class="line">            firstTombstone = index;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码实现了数据的存储过程，我们可以由上可以得出一个存储规则，那就是ThreadLocal的值在table数组中的存储位置总是为ThreadLocal的reference字段所标识的对象的下一个位置，比如ThreadLocal的reference对在table数组中的索引为index，那么ThreadLocal的值在table数组中的索引就是index+1.最终ThreadLocal的值会被存储在table数组中：table[index + 1] = value;</p>
<p>接下来，分析get方法，如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Optimized for the fast path.</span></div><div class="line">    Thread currentThread = Thread.currentThread();</div><div class="line">    Values values = values(currentThread);</div><div class="line">    <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;</div><div class="line">        Object[] table = values.table;</div><div class="line">        <span class="keyword">int</span> index = hash &amp; values.mask;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.reference == table[index]) &#123;</div><div class="line">            <span class="keyword">return</span> (T) table[index + <span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        values = initializeValues(currentThread);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (T) values.getAfterMiss(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现，ThreadLocal的get方法同样是取出当前线程的localValues对象，如果这个对象不为null，那就取出它的table数组并找出ThreadLocal的reference对象在table数组中的位置，然后table数组中下一个位置所存储的数据就是ThreadLocal的值。如果这个对象为null，则返回初始值，初始值由ThreadLocal的initialValue方法来描述，默认情况下为null，当然也可以重写这个方法，它的默认实现如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function">Object <span class="title">getAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</div><div class="line">    Object[] table = <span class="keyword">this</span>.table;</div><div class="line">    <span class="keyword">int</span> index = key.hash &amp; mask;</div><div class="line"></div><div class="line">    <span class="comment">// If the first slot is empty, the search is over.</span></div><div class="line">    <span class="keyword">if</span> (table[index] == <span class="keyword">null</span>) &#123;</div><div class="line">        Object value = key.initialValue();</div><div class="line"></div><div class="line">        <span class="comment">// If the table is still the same and the slot is still empty...</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.table == table &amp;&amp; table[index] == <span class="keyword">null</span>) &#123;</div><div class="line">            table[index] = key.reference;</div><div class="line">            table[index + <span class="number">1</span>] = value;</div><div class="line">            size++;</div><div class="line"></div><div class="line">            cleanUp();</div><div class="line">            <span class="keyword">return</span> value;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// The table changed during initialValue().</span></div><div class="line">        put(key, value);</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>从ThreadLocal的set和get方法可以看出，它们所操作的对象都是当前线程的Values对象的table数组，因此在不同的线程中访问同一个ThreadLocal的set和get方法，它们对ThreadLocal所在的读/写权限仅限各自线程的内部，这就是ThreadLocal可以在不同线程中互不干扰的储存和修改数据的原因，理解ThreadLocal的工作方式有助于理解Looper的工作原理。</p>
</blockquote>
<h2 id="MessageQueue的工作原理"><a href="#MessageQueue的工作原理" class="headerlink" title="MessageQueue的工作原理"></a>MessageQueue的工作原理</h2><p>消息队列在Android中指的是MessageQueue，MessageQueue主要包括两个操作：插入和读取，读取操作会伴随着删除操作，插入和读取的方法分别是enqueueMessage和next，其中enqueueMessage的作用往往是往消息队列中插入一条消息，而next的作用是往消息队列中取出一条消息并将其从消息队列中移除。尽管MessageQueue叫消息队列，但是它的内部实现不是用的队列，而是通过一个单链表的数据结构来维护消息列表，单链表在插入和删除上效率较高。enqueueMessage的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (msg.isInUse()) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">		<span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">			IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</div><div class="line">					msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</div><div class="line">			Log.w(<span class="string">"MessageQueue"</span>, e.getMessage(), e);</div><div class="line">			msg.recycle();</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		msg.markInUse();</div><div class="line">		msg.when = when;</div><div class="line">		Message p = mMessages;</div><div class="line">		<span class="keyword">boolean</span> needWake;</div><div class="line">		<span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</div><div class="line">			<span class="comment">// New head, wake up the event queue if blocked.</span></div><div class="line">			msg.next = p;</div><div class="line">			mMessages = msg;</div><div class="line">			needWake = mBlocked;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">// Inserted within the middle of the queue.  Usually we don not have to wake</span></div><div class="line">			<span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></div><div class="line">			<span class="comment">// and the message is the earliest asynchronous message in the queue.</span></div><div class="line"></div><div class="line">			needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</div><div class="line">			Message prev;</div><div class="line">			<span class="keyword">for</span> (;;) &#123;</div><div class="line">				prev = p;</div><div class="line">				p = p.next;</div><div class="line">				<span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">					needWake = <span class="keyword">false</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			msg.next = p; <span class="comment">// invariant: p == prev.next</span></div><div class="line">			prev.next = msg;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></div><div class="line">		<span class="keyword">if</span> (needWake) &#123;</div><div class="line">			nativeWake(mPtr);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从enqueueMessage的实现来看，它的主要操作就是单链表的插入和删除，下面看一下next方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"> <span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">// Return here if the message loop has already quit and been disposed.</span></div><div class="line">      <span class="comment">// This can happen if the application tries to restart a looper after quit</span></div><div class="line">      <span class="comment">// which is not supported.</span></div><div class="line">      <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</div><div class="line">      <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></div><div class="line">      <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line"><span class="comment">//死循环</span></div><div class="line">      <span class="keyword">for</span> (;;) &#123;</div><div class="line">          <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</div><div class="line">              Binder.flushPendingCommands();</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class="line"></div><div class="line">          <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">              <span class="comment">// Try to retrieve the next message.  Return if found.</span></div><div class="line">              <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</div><div class="line">              Message prevMsg = <span class="keyword">null</span>;</div><div class="line">              Message msg = mMessages;</div><div class="line">              <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</div><div class="line">                  <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></div><div class="line">                  <span class="keyword">do</span> &#123;</div><div class="line">                      prevMsg = msg;</div><div class="line">                      msg = msg.next;</div><div class="line">                  &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</div><div class="line">                  <span class="keyword">if</span> (now &lt; msg.when) &#123;</div><div class="line">                      <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></div><div class="line">                      nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                  &#125; <span class="keyword">else</span> &#123;</div><div class="line">                      <span class="comment">// Got a message.</span></div><div class="line">                      mBlocked = <span class="keyword">false</span>;</div><div class="line">                      <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</div><div class="line">                          prevMsg.next = msg.next;</div><div class="line">                      &#125; <span class="keyword">else</span> &#123;</div><div class="line">                          mMessages = msg.next;</div><div class="line">                      &#125;</div><div class="line">                      msg.next = <span class="keyword">null</span>;</div><div class="line">                      <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(<span class="string">"MessageQueue"</span>, <span class="string">"Returning message: "</span> + msg);</div><div class="line">                      <span class="keyword">return</span> msg;</div><div class="line">                  &#125;</div><div class="line">              &#125; <span class="keyword">else</span> &#123;</div><div class="line">                  <span class="comment">// No more messages.</span></div><div class="line">                  nextPollTimeoutMillis = -<span class="number">1</span>;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="comment">// Process the quit message now that all pending messages have been handled.</span></div><div class="line">              <span class="keyword">if</span> (mQuitting) &#123;</div><div class="line">                  dispose();</div><div class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="comment">// If first time idle, then get the number of idlers to run.</span></div><div class="line">              <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></div><div class="line">              <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></div><div class="line">              <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></div><div class="line">                      &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</div><div class="line">                  pendingIdleHandlerCount = mIdleHandlers.size();</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</div><div class="line">                  <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></div><div class="line">                  mBlocked = <span class="keyword">true</span>;</div><div class="line">                  <span class="keyword">continue</span>;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</div><div class="line">                  mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</div><div class="line">              &#125;</div><div class="line">              mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="comment">// Run the idle handlers.</span></div><div class="line">          <span class="comment">// We only ever reach this code block during the first iteration.</span></div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</div><div class="line">              <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</div><div class="line">              mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></div><div class="line"></div><div class="line">              <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</div><div class="line">              <span class="keyword">try</span> &#123;</div><div class="line">                  keep = idler.queueIdle();</div><div class="line">              &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">                  Log.wtf(<span class="string">"MessageQueue"</span>, <span class="string">"IdleHandler threw exception"</span>, t);</div><div class="line">              &#125;</div><div class="line"></div><div class="line">              <span class="keyword">if</span> (!keep) &#123;</div><div class="line">                  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                      mIdleHandlers.remove(idler);</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></div><div class="line">          pendingIdleHandlerCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">          <span class="comment">// While calling an idle handler, a new message could have been delivered</span></div><div class="line">          <span class="comment">// so go back and look again for a pending message without waiting.</span></div><div class="line">          nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>可以发现next方法是一个无限循环的过程，如果消息队列中没有消息，那么next方法会一直阻塞在这里。当有新的消息到来时，next方法会返回这条消息并将其从单链表中移除。</p>
<h2 id="Looper的工作原理"><a href="#Looper的工作原理" class="headerlink" title="Looper的工作原理"></a>Looper的工作原理</h2><p>Looper在Android消息机制里面扮演着消息循环的角色，具体来说它会不停地从MessageQueue中查看是否有新消息，如有有新消息就会立刻处理，否则就会一直阻塞在那里。<br>首先看一下Looper的构造函数，在构造方法中它会创建一个MessageQueue即消息队列，然后将当前线程的对象存储起来，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">	&#125;</div><div class="line">	sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">	mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</div><div class="line">	mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Handler的工作需要Looper，没有Looper的线程就会报错，那么如何为一个线程创建Looper呢？通过Looper.prepare()即可为当前线程创建一个Looper，接着通过Looper.loop()来开启消息循环，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">   <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		Looper.prepare(); <span class="comment">//创建Looper</span></div><div class="line">		mHandler = <span class="keyword">new</span> Handler()&#123;</div><div class="line">			</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				<span class="keyword">super</span>.handleMessage(msg);</div><div class="line">				</div><div class="line">				<span class="keyword">if</span> (msg.what == <span class="number">0</span>) &#123;</div><div class="line">					</div><div class="line">					System.out.println(<span class="string">"msg: "</span> + <span class="string">"123456"</span>); </div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">		Looper.loop(); <span class="comment">//开启Looper循环</span></div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;).start();</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 发送消息</div><div class="line">    * <span class="doctag">@param</span> view</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">   	</div><div class="line">   	mHandler.sendEmptyMessage(<span class="number">0</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 退出Looper循环</div><div class="line">    * <span class="doctag">@param</span> view</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">   	mHandler.getLooper().quit();</div><div class="line">	mHandler.getLooper().quitSafely(); <span class="comment">//API18</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>Looper除了prepare方法外，还提供了prepareMainLooper()方法，这个方法主要是给主线程也就是ActivityThread创建Looper使用的，其本质也是通过prepare方法创建的。由于主线程的Looper比较特殊，所以Looper提供了一个getMainLooper方法，通过它可以在任何位置获取主线程Looper。</p>
<p>Looper也是可以退出的，Looper提供了quit和quitSafely来退出一个Looper，二者的区别在于：quit会直接退出Looper，而quitSafely只是设定一个退出标志，然后把消息队列中的已有消息处理完毕后才安全地退出。Looper退出后，提供Handler发送的消息会失败，这时Handler的send方法返回false。在子线程中，如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来终止消息循环，否则这个子线程会一直处于等待状态，而如果推出Looper以后，这个线程就会立刻终止，因此建议不需要的时候终止Looper。</p>
<p>Looper最重要的一个方法是loop方法，只有调用了loop后，消息循环系统才会真正的运行，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">  * Run the message queue in this thread. Be sure to call</div><div class="line">  * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">final</span> Looper me = myLooper();</div><div class="line">     <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">final</span> MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">     <span class="comment">// Make sure the identity of this thread is that of the local process,</span></div><div class="line">     <span class="comment">// and keep track of what that identity token actually is.</span></div><div class="line">     Binder.clearCallingIdentity();</div><div class="line">     <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">     <span class="keyword">for</span> (;;) &#123;</div><div class="line">         Message msg = queue.next(); <span class="comment">// might bloc  退出时返回null</span></div><div class="line">         <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</div><div class="line">             <span class="comment">// No message indicates that the message queue is quitting. </span></div><div class="line">             <span class="keyword">return</span>; <span class="comment">//位移跳出循环的方式</span></div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></div><div class="line">         Printer logging = me.mLogging;</div><div class="line">         <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">             logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</div><div class="line">                     msg.callback + <span class="string">": "</span> + msg.what);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         msg.target.dispatchMessage(msg); <span class="comment">//分发消息 msg.target = Handler</span></div><div class="line"></div><div class="line">         <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">             logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="comment">// Make sure that during the course of dispatching the</span></div><div class="line">         <span class="comment">// identity of the thread wasn't corrupted.</span></div><div class="line">         <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</div><div class="line">         <span class="keyword">if</span> (ident != newIdent) &#123;</div><div class="line">             Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></div><div class="line">                     + Long.toHexString(ident) + <span class="string">" to 0x"</span></div><div class="line">                     + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></div><div class="line">                     + msg.target.getClass().getName() + <span class="string">" "</span></div><div class="line">                     + msg.callback + <span class="string">" what="</span> + msg.what);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         msg.recycleUnchecked();</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>Looper的loop方法工作过程，loop方法是一个死循环，位移跳出循环的方式是MessageQueue的next方法返回null。当Looper的quit方法被调用时，Looper就会调用MessageQueue的quit或者quitSafely方法来通知消息队列退出，当消息队列表计为退出状态时，它的next方法就返回null。</p>
<p>Looper必须退出，否则loop方法会无线循环下去。loop方法会调用MessageQueue的next方法来获取新的消息，而next是一个阻塞操作，当没有消息时，next方法会一直阻塞在那里，这也导致loop方法一直阻塞在那里。如果MessageQueue的next方法返回了新的消息，Looper就会处理这条消息：msg.target.dispatchMessage(msg);这里的msg.target是发送这条消息的Handler对象，这样Handler的发送的消息最终在它的dispatchMessage中处理了。</p>
<h2 id="Handler的工作原理"><a href="#Handler的工作原理" class="headerlink" title="Handler的工作原理"></a>Handler的工作原理</h2><p>Handler的主要工作包含消息的发送和接收过程。消息的发送可以通过post的一系列方法以及send的一系列方法实现，post的一系列方法最终是通过send的一系列方法来实现的。发送一条消息典型过程如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</div><div class="line">			delayMillis = <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">	MessageQueue queue = mQueue;</div><div class="line">	<span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</div><div class="line">		RuntimeException e = <span class="keyword">new</span> RuntimeException(</div><div class="line">				<span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</div><div class="line">		Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//送入消息队列</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</div><div class="line">	msg.target = <span class="keyword">this</span>;</div><div class="line">	<span class="keyword">if</span> (mAsynchronous) &#123;</div><div class="line">		msg.setAsynchronous(<span class="keyword">true</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现，Handler发送消息的过程仅仅是向消息队列插入了一条消息，MessageQueue的next方法就会返回这条消息给Looper，Looper收到消息后就开始处理了，最终消息由Looper交由Handler处理，即Handler的dispatchMessage方法会被调用，这是Handler就进入了消息处理阶段。dispatchMessage实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">		handleCallback(msg);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		handleMessage(msg);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Handler处理消息的过程如下：</p>
<p>首先，检查Message的Callback是否为null，不为null则通过handleCallback来处理消息，Message的callback是一个Runnable对象，实际上就是Handler的post方法所传递的Runnable参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</div><div class="line">	message.callback.run();  <span class="comment">//messge.callback = Runnable对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其次，若Message的Callback是为null，则检查mCallback是否为null，不为null就调用mCallback的handleMessage方法来处理消息，Callback是个接口，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过Callback框图用如下方式创建Handler对象：Handler mHandler = new Handler(mCallback)。那么Callback的意义是什么了？可以用来创建一个Handler的实例但并不需要派生Handler的子类。</p>
<p>最后，若都为null，则直接调用Handler中的handlerMessage方法来处理消息。</p>
<p>Handler还有一种特使的构造函数，那就是通过一个特定的Looper来构造Handler，通过这个构造方法可以实现一些特殊的功能如IntentService，它的实现如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Handler的一个默认构造方法public Handler()，这个构造方法会调用下面的的构造方法。很明显，如果当前线程没有Looper的话，就会抛出异常，这也解释了在没有Looper的子线程创建Handler会引发程序异常的原因。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</div><div class="line"></div><div class="line">	...</div><div class="line"></div><div class="line">	mLooper = Looper.myLooper();</div><div class="line">	<span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">			<span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">	&#125;</div><div class="line">	mQueue = mLooper.mQueue;</div><div class="line">	mCallback = callback;</div><div class="line">	mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="主线程的消息循环"><a href="#主线程的消息循环" class="headerlink" title="主线程的消息循环"></a>主线程的消息循环</h1><p>Android的主线程就是ActivityThread，主线程的入口方法为main，在main方法中系统会通过Looper.prepareMainLooper()来创建主线程的Looper以及MessageQueue，并通过Looper.loop()开启主线程的消息循环，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	SamplingProfilerIntegration.start();</div><div class="line"></div><div class="line">	<span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></div><div class="line">	<span class="comment">// disable it here, but selectively enable it later (via</span></div><div class="line">	<span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></div><div class="line">	CloseGuard.setEnabled(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">	Environment.initForCurrentUser();</div><div class="line"></div><div class="line">	<span class="comment">// Set the reporter for event logging in libcore</span></div><div class="line">	EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</div><div class="line"></div><div class="line">	Security.addProvider(<span class="keyword">new</span> AndroidKeyStoreProvider());</div><div class="line"></div><div class="line">	Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</div><div class="line"></div><div class="line">	Looper.prepareMainLooper(); <span class="comment">//</span></div><div class="line"></div><div class="line">	ActivityThread thread = <span class="keyword">new</span> ActivityThread();</div><div class="line">	thread.attach(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</div><div class="line">		sMainThreadHandler = thread.getHandler();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	AsyncTask.init();</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</div><div class="line">		Looper.myLooper().setMessageLogging(<span class="keyword">new</span></div><div class="line">				LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	Looper.loop(); <span class="comment">//无限循环</span></div><div class="line"></div><div class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主线程的消息循环开始以后，ActivityThread需要一个Handler来和消息队列进行交互，这个Handler就是ActivityThread.H，它内部定义了一组消息类型，主要包含了四大组件的启动和停止等过程，如下所示</p>
<p>ActivityThread通过ApplicationThread和AMS进行进程间通信，AMS以进程间通信的方式完成ActivityThread的请求后回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程中执行，这个过程就是主线程的消息循环模型。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2016/04/26/Android的消息机制/" data-id="cj6ft5er0002pqm19cgvowblu" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2016/04/26/Android的消息机制/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android系统/">Android系统</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Android的线程和线程池" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/25/Android的线程和线程池/" class="article-date">
  <time datetime="2016-04-25T13:06:06.000Z" itemprop="datePublished">2016-04-25 21:06:06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/25/Android的线程和线程池/">Android的线程和线程池</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>线程在Android中是一个很重要的概念，从用途上来说，线程分为主线程和子线程，主线程主要处理和界面相关的事情，而子线程则往往用于执行耗时操作。由于Android的特性，如果在主线程中执行耗时操作那么就会导致程序无法及时地响应，因此耗时操作必须放在子线程中去执行。</p>
<p>在操作系统中，线程是操作系统调度的最小单元，同时线程又是一种受限的系统资源，即线程不可能无限制的产生，并且线程的创建和销毁都会有相应的开销。档系统中存在大量的线程时，系统会通过时间片轮转的方式调度每个线程，因此线程不可能做到绝对的并行，除非线程数量小于等于CPU核心数，一般来说这是不可能的。正确的做法是采用线程池，一个线程池会缓存一定数量的线程，通过线程池就可以避免因为频繁创建和销毁线程所带来的系统开销。</p>
<h1 id="主线程和子线程"><a href="#主线程和子线程" class="headerlink" title="主线程和子线程"></a>主线程和子线程</h1><p>Android沿用了Java的线程模型，其中的线程也分为主线程和子线程，其中主线程也叫UI线程。主线程的作用是运行四大组件以及处理它们和用户的交互，而子线程的作用则是执行耗时任务，比如网络请求、I/O操作等。从Android3.0开始系统要求网络访问必须在子线程中进行，否则网络访问将会失败并抛出NetworkOnMainThreadException这个异常，这样做事为了避免主线程由于耗时操作所阻塞而出现ANR异常。</p>
<h1 id="Android中的线程形态"><a href="#Android中的线程形态" class="headerlink" title="Android中的线程形态"></a>Android中的线程形态</h1><p>除了传统的Thread线程外，Android还提供了AsyncTask、HandlerTask以及IntentService，这三者的底层实现也是线程，但它们具有特殊的表现形式，同时在使用上也各有优缺点。</p>
<h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><p>AsyncTask是一种轻量级的异步任务类，它可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程并在主线程上更新UI。是实现上来说，<strong>AsyncTask封装了Thread和Handler</strong>，通过AsyncTask可以更加方便地执行后台任务以及在主线程中访问UI，但是AsyncTask并不适合进行特别耗时的任务，对应特别耗时的任务来说，建议使用线程池。</p>
<h3 id="AsyncTask使用"><a href="#AsyncTask使用" class="headerlink" title="AsyncTask使用"></a>AsyncTask使用</h3><p>AsyncTask是一个抽象的泛型类，它提供了Params、Progress和Result这三个泛型参数，其中Params表示输入参数的类型，Progress表示后台任务的执行进度的类型，而Result则表示后台任务返回结果的类型，如果AsyncTask确实不需要传递具体的参数，那么这三个泛型可以用Void来代替。声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>,<span class="title">Progress</span>,<span class="title">Result</span>&gt;</span></div></pre></td></tr></table></figure>
<p>AsyncTask提供了4个核心方法，它们的含义如下图所示</p>
<ol>
<li><p>onPreExecute()，在主线程中执行，在异步任务执行之前会调用此方法，一般可以用于做一些准备工作。</p>
</li>
<li><p>doInBackground(Params…params)，在线程池中执行，用于执行异步任务，params表示异步任务的输入参数。在该方法中可以通过调用publishProgress方法来更新任务的进度，因为publishProgress会调用onProgressUpdate方法。</p>
</li>
<li><p>onProgressUpdate(Progress…values)，在主线程中执行，当后台任务的执行进度发生改变时此方法会被调用。</p>
</li>
<li><p>onPostExecute(Result result)，在主线程中执行，在异步任务执行之后，次方法会被调用，其中result参数是后台任务的返回值，即doInBackground的返回值。  </p>
</li>
</ol>
<p>上述方法中，onPreExecute先执行，然后是doInBackground，最后才是onPostExecute。此外AsyncTask还提供了onCancelled()方法，它同样在主线程中执行，当异步任务被取消时，onCancelled()方法会被调用，这个时候onPostExecute则不会被调用。</p>
<p>下面代码为AsyncTask的一个应用实例： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadRecordTask</span> <span class="keyword">extends</span></span></div><div class="line">		<span class="title">AsyncTask</span>&lt;<span class="title">Object</span>, <span class="title">VideoInfo</span>, <span class="title">List</span>&lt;<span class="title">VideoInfo</span>&gt;&gt; &#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.onPreExecute();</div><div class="line">		mDescLoad.setVisibility(View.VISIBLE);</div><div class="line">		mDescLoad.setText(R.string.refreshing);</div><div class="line">		mVideoRecords.setEnabled(<span class="keyword">false</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> List&lt;VideoInfo&gt; <span class="title">doInBackground</span><span class="params">(Object... params)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		videoInfos = (ArrayList&lt;VideoInfo&gt;) MediaContentResolverUtils</div><div class="line">				.getVideoInfoList(RecordVideoActivity.<span class="keyword">this</span>);</div><div class="line"></div><div class="line">		mVideoThumbnailMap = (HashMap&lt;String, String&gt;) mVideoThumbnailDao</div><div class="line">				.findAllToMap();</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (videoInfos == <span class="keyword">null</span> || videoInfos.size() == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> videoInfos;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 没有缩略图 获取缩略图</span></div><div class="line">		<span class="keyword">for</span> (VideoInfo info : videoInfos) &#123;</div><div class="line"></div><div class="line">			String md5Name = Md5Utils.encode(info.getFileTitle());</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (!mVideoThumbnailMap.containsKey(md5Name)) &#123;</div><div class="line">				<span class="comment">//数据处理</span></div><div class="line">			&#125;</div><div class="line"></div><div class="line">			publishProgress(info);</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (isCancelled()) &#123; <span class="comment">//异步任务取消时会调用</span></div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> videoInfos;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(VideoInfo... values)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.onProgressUpdate(values);</div><div class="line"></div><div class="line">		<span class="keyword">for</span> (VideoInfo info : values) &#123;</div><div class="line">			<span class="comment">//UI更新进度</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(List&lt;VideoInfo&gt; result)</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="comment">//取得后台任务的结果，更新UI</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 运行在UI线程，调用cancel()方法后触发，在doInBackground()方法结束后执行</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancelled</span><span class="params">(List&lt;VideoInfo&gt; result)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.onCancelled(result);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行和取消该任务的代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mLoadRecordTask = <span class="keyword">new</span> LoadRecordTask();</div><div class="line">mLoadRecordTask.execute();</div><div class="line">mLoadRecordTask.cancel(<span class="keyword">true</span>); <span class="comment">//结束任务</span></div></pre></td></tr></table></figure>
<h3 id="AsyncTask条件限制"><a href="#AsyncTask条件限制" class="headerlink" title="AsyncTask条件限制"></a>AsyncTask条件限制</h3><ul>
<li>AsyncTask的类必须在主线程中加载</li>
<li>AsyncTask的对象必须在主线程中创建</li>
<li>execute方法必须在UI线程调用</li>
<li>不要在程序中直接调用onPreExecute()、onPostExecute()、doInBackgroud()和onProgressUpdate()</li>
<li>一个AsyncTask对象只能执行一次，即只能调用一次execute方法，否则会报运行时异常</li>
<li>在Android1.6之前，AsyncTask是串行执行任务的，Android1.6的时候AsyncTask开始采用线程池里处理并行任务，但从Android3.0开始，为了避免AsyncTask所带来的并发错误，AsyncTask又采用一个线程来串行执行任务。<strong>尽管如此，在Android3.0及以后版本中，我们仍然可以通过AsyncTask的executeOnExecutor方法（不能向下兼容）来并行的执行任务</strong></li>
</ul>
<h3 id="AsyncTask工作原理"><a href="#AsyncTask工作原理" class="headerlink" title="AsyncTask工作原理"></a>AsyncTask工作原理</h3><p>我们从AsyncTask的execute方法开始分析，execute方法又会调用ecuteOnExecutor方法，它们的实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">execute</span><span class="params">(Params... params)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> executeOnExecutor(sDefaultExecutor, params);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></div><div class="line">        Params... params) &#123;</div><div class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</div><div class="line">        <span class="keyword">switch</span> (mStatus) &#123;</div><div class="line">            <span class="keyword">case</span> RUNNING:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span> <span class="comment">//异步任务执行一次</span></div><div class="line">                        + <span class="string">" the task is already running."</span>); </div><div class="line">            <span class="keyword">case</span> FINISHED:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span> <span class="comment">//异步任务执行一次</span></div><div class="line">                        + <span class="string">" the task has already been executed "</span></div><div class="line">                        + <span class="string">"(a task can be executed only once)"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mStatus = Status.RUNNING;</div><div class="line"></div><div class="line">    onPreExecute(); <span class="comment">//最先执行</span></div><div class="line"></div><div class="line">    mWorker.mParams = params;</div><div class="line">    exec.execute(mFuture); <span class="comment">//线程池开始执行</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中，sDefaultExecutor实际上是一个串行的线程池，<strong>一个进程中所有的AsyncTask全部在这个串行的线程池中排队执行</strong>。在executeOnExecutor方法中，AsyncTask的onPreExecute()最先执行，然后线程池开始执行。下面分析线程池的执行过程，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">       mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">           <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">               mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">               Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">               <span class="comment">//noinspection unchecked</span></div><div class="line">               <span class="keyword">return</span> postResult(doInBackground(mParams));</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line">	</div><div class="line">	<span class="comment">//将AsyncTask的Params参数封装到FutureTask对象中，FutureTask的run方法会调用mWorker的call方法</span></div><div class="line">       mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="keyword">try</span> &#123;</div><div class="line">                   postResultIfNotInvoked(get());</div><div class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                   android.util.Log.w(LOG_TAG, e);</div><div class="line">               &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occured while executing doInBackground()"</span>,</div><div class="line">                           e.getCause());</div><div class="line">               &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                   postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors(); <span class="comment">//CPU核心数</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = CPU_COUNT + <span class="number">1</span>; <span class="comment">//核心工作线程</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">//最多工作线程</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE = <span class="number">1</span>; <span class="comment">//空闲线程的超时时间为1秒</span></div><div class="line"></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR</div><div class="line">           = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</div><div class="line">                   TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor SERIAL_EXECUTOR = <span class="keyword">new</span> SerialExecutor();  </div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Executor sDefaultExecutor = SERIAL_EXECUTOR;</div><div class="line"></div><div class="line"><span class="comment">//实现一个线程池</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">       <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</div><div class="line">       Runnable mActive;</div><div class="line"></div><div class="line">	<span class="comment">//线程同步</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</div><div class="line">		<span class="comment">//将任务r插入mTasks任务队列中</span></div><div class="line">           mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                   <span class="keyword">try</span> &#123;</div><div class="line">                       r.run(); <span class="comment">//执行任务</span></div><div class="line">                   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                       scheduleNext(); <span class="comment">//继续执行下一个任务</span></div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">           &#125;);</div><div class="line">		</div><div class="line">		<span class="comment">//没有真正活动的AsyncTask时调用</span></div><div class="line">           <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</div><div class="line">               scheduleNext(); </div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">               THREAD_POOL_EXECUTOR.execute(mActive); <span class="comment">//真正执行任务</span></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>从SerialExecutor的实现可以分析AsyncTask的排队执行情况。首先系统会将AsyncTask的Params参数封装到FutureTask对象中，FutureTask是一个并发类，在这里它充当了Runnable的作用(FutureTask实现了Runnable方法)。接着这个FutureTask即mFuture会交给SerialExecutor的execute方法去处理。SerialExecutor的execute方法首先会把FutureTask对象添加到任务队列mTasks中，如果当前没有正在活动的AsyncTask任务，那么就会调用SerialExecutor的scheduleNext方法来执行下一个AsyncTask任务，否则等待当前AsyncTask任务完成再继续执行新的AsyncTask任务，直到所有的AsyncTask任务执行完毕。<strong>从这可以看出，AsyncTask是串行执行任务的</strong></p>
<p>AsyncTask中有两个线程池（SerialExecutor和THREAD_POOL_EXECUTOR）和一个Handler（InternalHandler），其中线程池SerialExecutor用于执行任务的排队，线程池THREAD_POOL_EXECUTOR用于真正地执行AsyncTask任务，InternalHandler用于将执行环境从线程池切换到主线程。在AsyncTask的构造方法中有如下这么一段代码，由于FutureTask的run方法调用mWorker的call方法，因此mWorker的call方法最终会在线程池中执行。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            mTaskInvoked.set(<span class="keyword">true</span>); <span class="comment">//表示当前任务以及调用过了</span></div><div class="line"></div><div class="line">            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">            <span class="comment">//noinspection unchecked</span></div><div class="line">            <span class="keyword">return</span> postResult(doInBackground(mParams)); <span class="comment">//执行doInBackground方法</span></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">	</div><div class="line">	<span class="comment">//将AsyncTask的Params参数封装到FutureTask对象中，FutureTask的run方法会调用mWorker的call方法</span></div><div class="line">    mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                postResultIfNotInvoked(get());</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                android.util.Log.w(LOG_TAG, e);</div><div class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occured while executing doInBackground()"</span>,</div><div class="line">                        e.getCause());</div><div class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在mWorker的call方法中，首先将mTaskInvoked设为true，表示当前任务以及被调用了，然后执行AsyncTask的doInBackground方法，接着将其返回值传递给postResult方法，它的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</div><div class="line">    message.sendToTarget();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的代码中，postResult方法会通过sHandler发送一个MESSAGE_POST_RESULT的消息，这个sHandler的定义如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> InternalHandler sHandler;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">synchronized</span> (AsyncTask.class) &#123;</div><div class="line">           <span class="keyword">if</span> (sHandler == <span class="keyword">null</span>) &#123;</div><div class="line">               sHandler = <span class="keyword">new</span> InternalHandler();</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> sHandler;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(Looper.getMainLooper());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</div><div class="line">                <span class="comment">// There is only one result</span></div><div class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</div><div class="line">                result.mTask.onProgressUpdate(result.mData);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现，sHandler是一个静态的Handler类对象，为了能够将执行环境切换到主线程，这就sHandler这个对象必须在主线程中创建。<strong>由于静态成员会在加载类的时候进行初始化，因此这就变相要求AsyncTask的类必须在主线程中加载，否则同一进程中的AsyncTask都将无法正常工作</strong>。sHandler收到sHandlerMESSAGE_POST_PROGRESS会调用onProgressUpdate方法更新进度，收到MESSAGE_POST_RESULT这个消息后会调用AsyncTask的finish方法，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</div><div class="line">        onCancelled(result);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        onPostExecute(result);</div><div class="line">    &#125;</div><div class="line">    mStatus = Status.FINISHED;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AsyncTask的finish方法会判断AsyncTask是否取消执行了，是则调用onCancelled方法，否则调用onPostExecute(result)，此时doInBackground的返回结果会传递给onPostExecute方法，最后将任务状态mStatus置为完成。至此AsyncTask的整个过程就分析完成了。</p>
<p><strong>通过分析AsyncTask的源码，可以进一步确定，从Android3.0开始，默认情况下AsyncTask的确是串行执行。</strong>我们仍然可以通过AsyncTask的executeOnExecutor方法（不能向下兼容）来并行的执行任务。</p>
<h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><p>HandlerThread继承了Thread，它是一种可以使用Handler的Thread，它的实现也很简单，就是在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许HandlerThread中创建Handler。HandlerThread的run方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">	mTid = Process.myTid();</div><div class="line">	Looper.prepare();</div><div class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">		mLooper = Looper.myLooper();</div><div class="line">		notifyAll();</div><div class="line">	&#125;</div><div class="line">	Process.setThreadPriority(mPriority);</div><div class="line">	onLooperPrepared();</div><div class="line">	Looper.loop();</div><div class="line">	mTid = -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从HandlerThread的实现来看，它和普通的Thread有显著的不同之处。普通Thread主要同于run方法中执行一个耗时任务，而HandlerThread在内部创建了消息队列，外界需要通过Handler的消息方式来通知HandlerThread执行一个具体任务。HandlerThread是个很有用的类，它在Android中的一个具体的使用场景是IntentService。由于HandlerThread的run方法是一个无限循环，因此当明确不需要再使用HandlerThread时，可以通过它的quit或者quitSafely方法来终止线程的执行，这是一个好的编程习惯。示例代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThreadDemo</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Looper mLooper;</div><div class="line">	<span class="keyword">private</span> MyHandlerThread mHandlerThread;</div><div class="line">	<span class="keyword">private</span> TextView mInfoTxt;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Handler mHandler;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_thread);</div><div class="line">		</div><div class="line">		mInfoTxt  = (TextView) findViewById(R.id.tv_info);</div><div class="line">		</div><div class="line">		mHandlerThread = <span class="keyword">new</span> MyHandlerThread(<span class="string">"mHandlerThread"</span>);</div><div class="line">		mHandlerThread.start(); <span class="comment">//先start</span></div><div class="line">		mLooper = mHandlerThread.getLooper();</div><div class="line">		</div><div class="line">		<span class="comment">//注册到Handler，通过Handler发送消息</span></div><div class="line">		mHandler = <span class="keyword">new</span> Handler(mLooper,mHandlerThread);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">		</div><div class="line">		mHandler.sendEmptyMessage(<span class="number">1</span>);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandlerThread</span> <span class="keyword">extends</span> <span class="title">HandlerThread</span> <span class="keyword">implements</span> <span class="title">Callback</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyHandlerThread</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">			<span class="keyword">super</span>(name);</div><div class="line">			<span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			</div><div class="line">			<span class="keyword">if</span> (msg.what == <span class="number">1</span>) &#123;</div><div class="line">				System.out.println(<span class="string">"mHandlerThread"</span>);</div><div class="line">				mInfoTxt.setText(<span class="string">"mHandlerThread"</span>);</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>IntentService是一种特殊的Service，它继承了Service并且它是一个抽象类，因此必须创建它的子类才能使用IntentService。IntentService可用于执行后台耗时的后台，当任务执行后它会自动停止，同时由于IntentService是服务的原因，这导致它的优先级比单纯的线程要高很多，所以IntentService比较适合执行一些高优先级的后台任务，因为它的优先级高不容易被系统杀死。在实现上，IntentService封装了HandlerThread和Handler，这一点可以在它的onCreate方法中看出来，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> It would be nice to have an option to hold a partial wakelock</span></div><div class="line">    <span class="comment">// during processing, and to have a static startService(Context, Intent)</span></div><div class="line">    <span class="comment">// method that would launch the service &amp; hand off a wakelock.</span></div><div class="line"></div><div class="line">    <span class="keyword">super</span>.onCreate();</div><div class="line">    HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</div><div class="line">    thread.start();</div><div class="line"></div><div class="line">    mServiceLooper = thread.getLooper();</div><div class="line">    mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当IntentService被第一次启动时，它的onCreate方法会被调用，onCreate方法会创建一个HandlerThread，然后使用它的Looper来构造一个Handler对象mServiceHandler，这样通过mServiceHandler发送的消息最终都会在HandlerThread中执行，从这个角度来看，IntentService也可以用于执行后台任务。<strong>每次启动IntentService，它的onStartCommand方法就会调用一次</strong>，IntentService在onStartCommand中处理每个后台任务的Intent。下面看一下onStartCommand方法是如何处理外界Intent的，onStartCommand调用了onStart，onStart方法的实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">	Message msg = mServiceHandler.obtainMessage();</div><div class="line">	msg.arg1 = startId;</div><div class="line">	msg.obj = intent;</div><div class="line">	mServiceHandler.sendMessage(msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，IntentService仅仅是通过mServiceHandler发送了一个消息，这个消息会在HandlerThread中去处理。mServiceHandler收到消息后，会将Intent对象对象传递给onHandleIntent方法去处理。注意这个Intent对象的内容和外界的startService(intent)中的intent的内容是完全一致的，通过这个Intent对象即可解析出外界启动IntentService时所传递的参数，通过这些参数就可以区分具体的后台任务，这样在onHandleIntent方法中就可以对不同的后台任务做处理了。当onHandleIntent方法执行结束后，IntentService会通过stopSelf（int startId）来尝试停止服务。<strong>这里之所以采用stopSelf（int startId）而不是stopSelf（）来停止服务，是因为stopSelf（）会立刻停止服务，而这个时候还可能有其他消息未处理，stopSelf（int startId）则会等待所有的消息都处理完毕后才终止服务</strong>。一般来说，stopSelf（int startId）在尝试停止服务之前会判断最近启动服务的次数是否和startId相等，如果相等就立刻停止服务，不相等则不停止服务，这个策略可以从AMS的stopServiceToken方法的实现中找到依据。ServiceHandler的实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(looper);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">		onHandleIntent((Intent)msg.obj);</div><div class="line">		stopSelf(msg.arg1);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>IntentService的onHandleIntent方法是一个抽象方法，它需要我们在子类中实现，它的作用是从Intent参数中区分具体的任务并执行这些任务。如果目前只存在一个后台任务，那么onHandleIntent(Intent)方法执行完这个任务后，stopSelf（int startId）就会直接停止服务；如果目前存在多个后台任务，那么当onHandleIntent方法执行完最后一个任务时，stopSelf（int startId）才会直接停止服务。另外，由于没执行一个后台任务就必须启动一次IntentService，而IntentService内部则通过消息的方式向HandlerThread请求执行任务，Handler中的Looper是顺序处理消息的，这就意味着IntentService也是顺序执行后台任务，当有多个后台任务同时存在时，这些后台任务会按照外界发起的顺序排队执行。</p>
<p>下面通过一个示例来说明IntentService的工作方式，首先派生一个IntentService的子类，它的实现如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LocalIntentService</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(<span class="string">"LocalIntentService"</span>);</div><div class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(<span class="string">"onStartCommand"</span>);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		String action = intent.getStringExtra(<span class="string">"task"</span>);</div><div class="line">		System.out.println(<span class="string">"action: "</span> + action);</div><div class="line">		SystemClock.sleep(<span class="number">3000</span>); <span class="comment">//休眠模拟耗时的后台任务</span></div><div class="line">		<span class="keyword">if</span> (action.equals(<span class="string">"task1"</span>)) &#123;</div><div class="line">			System.out.println(<span class="string">"handle action: "</span> + action);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (action.equals(<span class="string">"task2"</span>)) &#123;</div><div class="line">			System.out.println(<span class="string">"handle action: "</span> + action);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (action.equals(<span class="string">"task3"</span>)) &#123;</div><div class="line">			System.out.println(<span class="string">"handle action: "</span> + action);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(<span class="string">"onDestroy"</span>);</div><div class="line">		<span class="keyword">super</span>.onDestroy();</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LocalIntentService实现完成以后，就可以在外界请求执行后台任务了，下面在Activity中发起3个后台任务的请求，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Intent service = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, LocalIntentService.class);</div><div class="line">service.putExtra(<span class="string">"task"</span>, <span class="string">"task1"</span>);</div><div class="line">startService(service);</div><div class="line">service.putExtra(<span class="string">"task"</span>, <span class="string">"task2"</span>);</div><div class="line">startService(service);</div><div class="line">service.putExtra(<span class="string">"task"</span>, <span class="string">"task3"</span>);</div><div class="line">startService(service);</div></pre></td></tr></table></figure>
<p>运行程序，观察日记如下</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">22</span>:<span class="number">14</span>:<span class="number">19.407</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): onStartCommand</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">19.407</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): action: task1</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">19.407</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): onStartCommand</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">19.408</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): onStartCommand</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">22.407</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): handle action: task1</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">22.409</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): action: task2</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">25.410</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): handle action: task2</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">25.418</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): action: task3</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">28.418</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): handle action: task3</div><div class="line"><span class="number">01</span>-<span class="number">08</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">28.429</span>: I/<span class="keyword">System</span>.<span class="keyword">out</span>(<span class="number">16384</span>): onDestroy</div></pre></td></tr></table></figure>
<p>从日志可以看出，三个后台任务是排队执行的，它们的执行顺序就是它们发起请求对的顺序。当task3执行完毕后，LocalIntentService才真正地停止，执行了onDestroy方法。</p>
<h1 id="Android中的线程池"><a href="#Android中的线程池" class="headerlink" title="Android中的线程池"></a>Android中的线程池</h1><p>线程池的有点主要有三点：</p>
<ul>
<li><p>重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销</p>
</li>
<li><p>能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致的阻塞现象。</p>
</li>
<li><p>能够对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。</p>
</li>
</ul>
<p>Android中的线程池概念来源于Java中的Executor，Executor是一个接口，真正的线程池的实现为ThreadPoolExecutor。ThreadPoolExecutor提供了一系列参数来配置线程池，通过不同的参数可以创建不同的线程池。由于Android中的线程池都是直接或者间接通过配置ThreadPoolExecutor来实现的，因此需要先介绍ThreadPoolExecutor。</p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p>ThreadPoolExecutor是线程池的真正实现，它的构造方法提供了一系列参数来配置线程池，下面介绍ThreadPoolExecutor的构造方法中各个参数的含义，这些参数将会直接影响到线程池的功能特性，下面是ThreadPoolExecutor的一个比较常用的构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                          <span class="keyword">int</span> maximumPoolSize,</div><div class="line">                          <span class="keyword">long</span> keepAliveTime,</div><div class="line">                          TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                          ThreadFactory threadFactory) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>corePoolSize</strong>  </li>
</ul>
<p>线程池的核心线程数，默认情况下，核心线程会在线程池中一直存活，即使他们处于闲置状态。如果将ThreadPoolExecutor的allowCoreThreadTimeout属性设置为true，那么闲置的核心线程在等待新任务到来会有超时策略，这个时间间隔由keepAliveTime所指定，当等待时间超时keepAliveTime所指定的时长后，核心线程会被终止。</p>
<ul>
<li><strong>maximumPoolSize</strong></li>
</ul>
<p>线程池所能容纳的最大线程数，当活动线程达到这个数值后，后续的新任务将会被阻塞。</p>
<ul>
<li><strong>keepAliveTime</strong></li>
</ul>
<p>非核心线程闲置时的超时时长，超过这个时间，非核心线程就会被收回。当ThreadPoolExecutor的allowCoreThreadTimeout属性设置为true时，keepAliveTime同样会作用于核心线程。</p>
<ul>
<li><strong>unit</strong></li>
</ul>
<p>用于指定keepAliveTime参数的时间单位，这是一个枚举，常用的有TimeUnit.MILLISECONDS;TimeUnit.SECONDS;TimeUnit.MINUTES等</p>
<ul>
<li><strong>workQueue</strong></li>
</ul>
<p>线程池的任务队列，通过线程池的execute方法提交的Runnable对象会存储在这个参数中。</p>
<ul>
<li><strong>ThreadFactory</strong></li>
</ul>
<p>线程工厂，为线程池提供创建新线程的功能。ThreadFactory是一个接口，它只有一个方法：Thread newThread(Runnable r);</p>
<p>除上面的这些主要的参数外，ThreadPoolExecutor还有一个不常用的参数RejectedExecutionHandler。当线程池无法执行新的任务时，这可能是由于任务队列已满或者是无法成功执行任务，这个时候ThreadPoolExecutor回调用RejectedExecutionHandler的rejectedExecution(Runnable r, ThreadPoolExecutor executor)方法来通知调用者，默认情况下rejectedExecution会直接抛出一个RejectedExecutionException的运行时异常。ThreadPoolExecutor为RejectedExectutionHandler提供了几个可选值：CallerRunsPolicy、AbortPolicy、DiscardPolicy、DiscardOldestPolicy，其中AbortPolicy是默认值，但是RejectedExecutionHandler这个参数不常用。</p>
<p>ThreadPoolExecutor执行任务时大致遵循如下规则：</p>
<ul>
<li><p>如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务</p>
</li>
<li><p>如果线程池中的线程数量已经达到或超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行。</p>
</li>
<li><p>如果在步骤2中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务。</p>
</li>
<li><p>如果步骤3中线程数量已经达到线程池中规定的最大值，那么就拒绝执行此任务，ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution方法来通知调用者。</p>
</li>
</ul>
<p>ThreadPoolExecutor的参数配置在AsyncTask中有明显的体现，下面是AsyncTask中的线程池配置情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors();</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = CPU_COUNT + <span class="number">1</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadFactory sThreadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mCount = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"AsyncTask #"</span> + mCount.getAndIncrement());</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =</div><div class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">128</span>);</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * An &#123;<span class="doctag">@link</span> Executor&#125; that can be used to execute tasks in parallel.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR</div><div class="line">        = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</div><div class="line">                TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</div></pre></td></tr></table></figure>
<p>AsyncTask线程池配置后的规格如下：</p>
<ul>
<li>核心线程数等于CPU核心数+1</li>
<li>线程池的最大线程数为CPU的核心数的2倍 + 1</li>
<li>核心线程无超时机制，非核心线程在闲置时的超时时间为1秒</li>
<li>任务队列的容量为128</li>
</ul>
<h2 id="线程池的分类"><a href="#线程池的分类" class="headerlink" title="线程池的分类"></a>线程池的分类</h2><ul>
<li><strong>FixedThreadPool</strong></li>
</ul>
<p>通过Executors的newFixedThreadPool方法来创建。它是一种线程数量固定的线程池，当线程处于空闲状态时，它们并不会被收回，除非线程池关闭了。当所有的线程都处于活动状态时，新任务都会处于等待状态，直到有线程空闲出来。由于FixedThreadPool只有核心线程并且这些核心线程都不会被回收，<strong>这意味着它能够更加快速的响应外界的请求</strong>。实现如下，可以发现FixedThreadPool中只有核心线程并且这些核心线程没有超时机制，另外任务队列也是没有大小限制的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">    * @param nThreads the number of threads in the pool</div><div class="line">    * @return the newly created thread pool</div><div class="line">    * </div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                     <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                     <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>CachedThreadPool</strong></li>
</ul>
<p>通过Executors的newCachedThreadPool方法来创建。它是一种线程数量不定的线程池，它只有非核心线程，并且最大线程数为Integer.MAX_VALUE。由于Integer.MAX_VALUE是一个很大的数，实际上就相当于最大线程数可以任意大。当线程池中的线程都处于活动状态时，线程池会创建新的线程来处理新任务，否则就会利用空闲的线程来处理新的任务。线程池中的空闲线程都有超时机制，这个超时时长为60秒，超过60秒闲置线程就会被回收。和FixedThreadPool不同的是，CachedThreadPool的任务队列其实相当于一个空集合，这将导致任何任务都会立即被执行，因为这种情况下SynchronousQueue是无法插入任务的。SynchronousQueue是一个非常特殊的队列，很多情况下可以理解为一个无法存储元素的队列（实际中很少使用）。从CachedThreadPool的特性来看<strong>这类线程池比较适合执行大量的耗时较少的任务</strong>。当整个线程池都处于闲置状态时，线程池中的线程都会超时而被停止，这个时候CachedThreadPool之中是没有任何线程的，它几乎不占用任何系统资源的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</div><div class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>ScheduledThreadPoll</strong></li>
</ul>
<p>通过Executors的newScheduledThreadPool方法来创建。它的核心线程数量是固定的，而非核心线程数量是没有限制的，并且当核心线程闲置时会被立即收回。ScheduledThreadPoll这类线程<strong>主要用于执行定时任务和具有固定周期的重复任务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">								   ThreadFactory threadFactory) &#123;</div><div class="line">	<span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</div><div class="line">		  <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>SingleThreadExecutor</strong></li>
</ul>
<p>通过Executors的newSingleThreadExecutor方法来创建。这类线程池内部只有一个核心线程，它确保所有的任务都在同一个线程中顺序执行。SingleThreadExecutor的意义在于统一所有的外界任务到一个线程中，这使得在这些任务之间不需要处理线程同步的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</div><div class="line">		(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</div><div class="line">								<span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">								<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2016/04/25/Android的线程和线程池/" data-id="cj6ft5eqs0027qm19wylewkt6" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2016/04/25/Android的线程和线程池/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android系统/">Android系统</a></li></ul>

    </footer>
  </div>
  
</article>
 


  
    <article id="post-Android的IPC方式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/19/Android的IPC方式/" class="article-date">
  <time datetime="2016-04-19T14:49:47.000Z" itemprop="datePublished">2016-04-19 22:49:47</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/19/Android的IPC方式/">Android的IPC方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h1><p>四大组件中的三大组件（Activity、Service、BroadcastReceiver）都是支持在Intent中传递Bundle数据的，由于Bundle实现了Parcelable接口，所以它可以方便地在不同的进程间传输，基于这一点，当我们在一个进程中启动了另一个进程的Activity、Service和BroadcastReceiver，我们就可以在Bundle中附加我们需要传输给远程进程的信息并通过Intent发送出去。当然，我们传输的数据必须能够被序列化，比如基本类型、实现了Parcelable接口的对象、实现了Serializable接口的对象以及一些Android所支持的特殊对象（如Bundle、Size、SizeF、IBinder）。</p>
<h1 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h1><p>共享文件也是一种不错的进程间通信方式，两个进程提供读/写同一个文件来交换数据，比如A进程把数据写入文件，B进程提供读取这个文件来获取数据。通过文件交换数据很好使用，除了可以交换一些文本信息外，我们还可以序列化一个对象到文件中，从另一进程中恢复这个对象。</p>
<p>通过文件共享方式来共享数据对文件格式是没有具体要求的，比如可以是文本文件，也可以是XML文件，只要读写双方约定数据格式即可。通过文件共享的方式是有局限性的，比如并发读/写的问题，因此我们要尽量避免并发写这种情况的发生或者考虑使用线程同步来限制多个线程的写操作。通过上面的分析可以知道，<strong>文件共享方式适合在对数据同步要求不高的进程之间进行通信</strong>，并且要妥善处理并发读/写的问题。</p>
<p>SharedPreference是个特例，SharedPreference是Android中提供的轻量级存储方案，它通过键值对的方式来存储数据，在底层实现上采用XML文件来存储键值对，每个应用的SharedPreference文件都可以在当前包所在的data目录下查到，一般来说，它的目录位于/data/data/package name/shared_prefs目录下。<strong>从本质上来说，</strong>SharedPreference属于文件的一种，但是由于系统对它的读/写有一定的缓存策略2，即在内存中会有一份SharedPreference文件的缓存。因此在多进程模式下，系统对它的读/写变得不可靠，当面对搞并发的读/写访问时，SharedPreference有很大几率会丢失数据，因此不建议在进程间通信中使用SharedPreference。</p>
<h1 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h1><p>Messenger可以翻译为信使，通过它可以在不同进程中传递Message对象，在Message中放入我们需要传递的数据，就可以轻松实现数据的进程间传递,也可以在同一个进程中使用。Messenger是一种轻量级的IPC方案，它的底层实现是AIDL。Messenger类的构造方法如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(Handler target)</span> </span>&#123;</div><div class="line">	mTarget = target.getIMessenger();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(IBinder target)</span> </span>&#123;</div><div class="line">	mTarget = IMessenger.Stub.asInterface(target);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Messenger使用简单，它对AIDL做了封装。同时，由于它一次处理一个请求，因此在服务端我们不用考虑线程同步的问题，这是因为服务端不存在并发执行的情形。实现一个Messenger由如下几个步骤，分为服务端和客户端。</p>
<ul>
<li><strong>1. 服务端进程</strong></li>
</ul>
<p>首先，我们需要在服务端创建一个Service来处理客户端的连接请求，同时创建一个Handler，并通过它来创建一个Messenger对象，然后在Service的onBind中返回这个Messenger对象底层的Binder即可。</p>
<ul>
<li><strong>2. 客户端进程</strong></li>
</ul>
<p>客户端进程中，首先要绑定服务端的Servcie，绑定成功后用服务端返回的IBinder对象创建一个Messenger，通过这个Messenger就可以向服务器发送消息了，发送消息类型为Message对象。如果需要服务端回应客户端蛮久和服务端一样，我们还需要创建一个Handler并创建一个新的Messenger，并把这个Messenger对象通过Messge的replyTo参数传递给服务端，服务端通过这个replyTo参数就可以回应客户端。</p>
<p>首先是服务端的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="comment">//1.创建Handler对象处理Message</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			<span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">			</div><div class="line">			<span class="keyword">case</span> Constants.MSG_FROM_CLIENT:</div><div class="line">				</div><div class="line">				System.out.println(<span class="string">"receiver msg from client: "</span> + msg.getData().get(<span class="string">"msg"</span>));</div><div class="line">				</div><div class="line">				<span class="comment">//返回信息到服务端</span></div><div class="line">				<span class="comment">//获取客户端接收消息的Messenger</span></div><div class="line">				Messenger client = msg.replyTo;</div><div class="line">				Message replyMessage = Message.obtain();</div><div class="line">				replyMessage.what = Constants.MSG_FROM_SERVER;</div><div class="line">				Bundle data = <span class="keyword">new</span> Bundle();</div><div class="line">				data.putString(<span class="string">"reply"</span>, <span class="string">"嗯，你的消息我已经收到!"</span>);</div><div class="line">				replyMessage.setData(data);</div><div class="line">				</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					client.send(replyMessage);</div><div class="line">				&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">					<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">				<span class="keyword">break</span>;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			</div><div class="line">			<span class="keyword">super</span>.handleMessage(msg);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">//2.创建一个Messenger,将客户端发送的消息传递给MessengerHandler处理</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Messenger mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHandler());</div><div class="line"></div><div class="line">	<span class="comment">//3.返回Messenger对象底层Binder</span></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> mMessenger.getBinder();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，注册Service</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;service</div><div class="line">    android:name="com.ryg.chapter_2.messenger.MessengerService"</div><div class="line">    android:process=":remote" &gt;</div><div class="line">&lt;/service&gt;</div></pre></td></tr></table></figure>
<p>最后是客户端代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Messenger mService;</div><div class="line">	</div><div class="line">	<span class="comment">//将服务端返回的消息传递MessengerHandler处理</span></div><div class="line">	<span class="keyword">private</span> Messenger mGetReplyMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHandler());</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			</div><div class="line">			<span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">			</div><div class="line">			<span class="keyword">case</span> Constants.MSG_FROM_SERVER:</div><div class="line">				</div><div class="line">				System.out.println(<span class="string">"receiv msg from server: "</span> + msg.getData().getString(<span class="string">"reply"</span>));</div><div class="line">				</div><div class="line">				<span class="keyword">break</span>;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			<span class="keyword">super</span>.handleMessage(msg);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			<span class="comment">//2.创建一个Messenger</span></div><div class="line">			mService = <span class="keyword">new</span> Messenger(service);</div><div class="line">			</div><div class="line">	    	<span class="comment">//3.通过Messenger发送Message消息到服务端</span></div><div class="line">	    	<span class="keyword">if</span> (mService != <span class="keyword">null</span>) &#123;</div><div class="line">				Message msg = Message.obtain();</div><div class="line">				msg.what = Constants.MSG_FROM_CLIENT;</div><div class="line">				Bundle data = <span class="keyword">new</span> Bundle();</div><div class="line">				data.putString(<span class="string">"msg"</span>, <span class="string">"hello,this is client"</span>);</div><div class="line">				msg.setData(data);</div><div class="line">				</div><div class="line">				<span class="comment">//将接收服务端回复的Messenger传递给服务端，必须要传递过去，否则收不到回复</span></div><div class="line">				msg.replyTo = mGetReplyMessenger;</div><div class="line">				</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					mService.send(msg);</div><div class="line">				&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">					<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        </div><div class="line">        <span class="comment">//1.绑定服务</span></div><div class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MessengerService.class);</div><div class="line">        bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    	<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">    	<span class="keyword">if</span> (mConnection != <span class="keyword">null</span>) &#123;</div><div class="line">			</div><div class="line">    		unbindService(mConnection);</div><div class="line">		&#125;</div><div class="line">    	<span class="keyword">super</span>.onDestroy();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> <span class="number">13</span>:<span class="number">20</span>:<span class="number">43.218</span>: I/System.<span class="keyword">out</span>(<span class="number">3280</span>): receiver msg <span class="keyword">from</span> client: hello,<span class="keyword">this</span> <span class="keyword">is</span> client</div><div class="line"><span class="number">01</span><span class="number">-11</span> <span class="number">13</span>:<span class="number">20</span>:<span class="number">43.234</span>: I/System.<span class="keyword">out</span>(<span class="number">3222</span>): receiv msg <span class="keyword">from</span> server: 嗯，你的消息我已经收到!</div></pre></td></tr></table></figure>
<p>通过上面的例子可以看出，在Messenger中进行数据传递必须将数据放入Message中，而Messenger和Message都实现了Parcelable接口，因此可以跨进程传输。简单来说，Message中所支持的数据类型就是Messenger中所支持的传输类型。实际上，通过Messenger来传输Message，Message中能使用的载体只有what、arg1、arg2、Bundle以及reply。Message中的另一个字段object在同一进程中的很实用的，但是再进程间通信的时候，在Android2.2以前object字段不支持跨进程传输，即便是android2.2以后，也仅仅是系统提供的实现了Parcelable接口的对象才能通过它来传输，这就意味着我们自定义的Parcelable对象无法通过object字段来传输。因此使用Bundle可以支持大量的数据类型。</p>
<h1 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h1><p>Messenger是以串行的方式处理客户端发来的消息，如果大量的消息同时发送到服务器，服务端仍然只能一个一个处理,（1）如果有大量的并发请求，那么用Messenger就不太合适了。同时，Messenger的作用仅仅是为了传递消息，（2）很多时候我们可能需要跨进程调用服务端的方法，这种情形用Messenger就无法做到了，但是我们可以使用AIDL来实现跨进程的方法调用。</p>
<p>下面介绍使用AIDL来进行进程间通信的流畅，分为服务端和客户端两个方面</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>服务端要首先创建一个Service用来监听客户端的连接，然后创建一个AIDL文件，将暴露给客户端的接口再这个AIDL文件中声明，最后在Service中实现这个AIDL接口。</p>
<p>（1）AIDL接口的创建<br>创建一个后缀为aidl的文件，在里面声明了一个接口和两个接口方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//IBookManager.aidl</span></div><div class="line"></div><div class="line"><span class="keyword">package</span> com.ryg.chapter_2.aidl;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.ryg.chapter_2.aidl.Book;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在AIDL文件中，并不是所有的数据类型都是可以使用的，AIDL到底支持哪些数据类型呢？如下所示</p>
<ul>
<li>基本数据类型</li>
<li>String和CharSequence</li>
<li>List：只支持ArrayList，并且里面的每个元素必须能够被AIDL支持</li>
<li>Map： 只支持HashMap，并且里面的每个元素都必须能够被AIDL文件支持，包括key和value</li>
<li>Parcelable：所有实现了Parcelable接口的对象</li>
<li>AIDL：所有的AIDL接口本身也可以在AIDL文件中使用</li>
</ul>
<p>以上6中就是AIDL支持的数据类型，其中自定义的Parcelable对象和AIDL对象必须要显示的import进来，不管它们是否和当前的AIDL文件位于同一个文件夹内。</p>
<p>IBookManager.aidl文件中引用了Book这个类，Book类是一个自定义的Parcelable对象，所以必须新建一个与它同名的AIDL文件，并在其中声明它为Parcelable，如下所示：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//Book.aidl</div><div class="line"></div><div class="line">package com.ryg.chapter_2.aidl<span class="comment">;</span></div><div class="line"></div><div class="line">parcelable Book<span class="comment">;</span></div></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<p>除此之外，AIDL中除了基本数据类型，其他类型的参数必须标上方向：in、out或者inout，in表示输入型参数，out表示输出型参数，inout表示输入输出型参数。</p>
<p>AIDL的包结构在客户端工程和服务端工程中要保持一致，否则会运行出错，这是因为客户端需要反序列化服务端中和AIDL接口相关的所有类，如果类的完整路径不一致，就无法成功反序列化，程序也就无法正常运行。</p>
<p>（2）远程服务端service的实现  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookManagerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> CopyOnWriteArrayList&lt;Book&gt; mBookList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;Book&gt;();</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Binder mBinder = <span class="keyword">new</span> IBookManager.Stub() &#123;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			<span class="keyword">return</span> mBookList;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			<span class="keyword">if</span> (!mBookList.contains(book)) &#123;</div><div class="line">				mBookList.add(book);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.onCreate();</div><div class="line">		</div><div class="line">		mBookList.add(<span class="keyword">new</span> Book(<span class="number">1</span>, <span class="string">"Android"</span>));</div><div class="line">		mBookList.add(<span class="keyword">new</span> Book(<span class="number">2</span>, <span class="string">"IOS"</span>));</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> mBinder;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是一个服务端Service的典型实现，首先在onCreate中初始化添加两本书的信息，然后创建一个Binder对象并在Binder中返回次对象，这个对象继承自IBookManager.Stub并实现了内部的AIDL方法。这里采用了CopyOnWriteArrayList，这个CopyOnWriteArrayList支持并发读/写。AIDL方法是在服务端的Binder线程池中执行的，因此当多个客户端同时连接的时候，会存在多个线程同时访问的情形，所以我们要在AISL方法中处理线程的同步，这里使用CopyOnWriteArrayList来进行自动的线程同步。</p>
<p>AIDL中能够使用的List只有ArrayList，但是我们这里使用的CopyOnWriteArrayList不是继承自ArrayList，为什么能够正常工作呢？这是因为AIDL所支持的是抽象的List，而List只是一个接口，因此虽然服务端返回的是CopyOnWriteArrayList，但在Binder中会按照List的规范去访问数据并最终形成一个ArrayList传递给客户端。所以，在服务端采用CopyOnWriteArrayList是完全可行的，与此类似的类还有ConCureentHashMap。</p>
<p>注册Service</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">service</span></span></div><div class="line">    <span class="attr">android:name</span>=<span class="string">"com.ryg.chapter_2.aidl.BookManagerService"</span></div><div class="line">    <span class="attr">android:process</span>=<span class="string">":remote1"</span> &gt;</div><div class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端首先要绑定远程服务，绑定成功后将服务端返回的Binder对象转换成AIDL接口，然后就可以通过这个接口去调用服务端的远程方法了，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		IBookManager bookManager = IBookManager.Stub.asInterface(service);</div><div class="line">		</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			List&lt;Book&gt; list = bookManager.getBookList();</div><div class="line">			System.out.println(<span class="string">"query book list type: "</span> + list.getClass().getCanonicalName());</div><div class="line">			System.out.println(<span class="string">"query book list: "</span> + list.toString());</div><div class="line">			</div><div class="line">			bookManager.addBook(<span class="keyword">new</span> Book(<span class="number">3</span>, <span class="string">"Windows Phone"</span>));</div><div class="line">			list = bookManager.getBookList();</div><div class="line">			System.out.println(<span class="string">"query book list: "</span> + list.toString());</div><div class="line">			</div><div class="line">		&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">	<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">	<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">	setContentView(R.layout.activity_main);</div><div class="line">	Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, BookManagerService.class);</div><div class="line">	bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> <span class="number">14</span>:<span class="number">51</span>:<span class="number">36</span>.<span class="number">937</span>: I/System.out(<span class="number">24841</span>): query <span class="keyword">book </span>list type: java.util.ArrayList  //CopyOnWriteArrayList转为Arraylist</div><div class="line"><span class="number">01</span>-<span class="number">11</span> <span class="number">14</span>:<span class="number">51</span>:<span class="number">36</span>.<span class="number">937</span>: I/System.out(<span class="number">24841</span>): query <span class="keyword">book </span>list: [<span class="keyword">Book </span>[<span class="keyword">bookId=1, </span><span class="keyword">bookName=Android], </span><span class="keyword">Book </span>[<span class="keyword">bookId=2, </span><span class="keyword">bookName=IOS]]</span></div><div class="line"><span class="number">01</span>-<span class="number">11</span> <span class="number">14</span>:<span class="number">51</span>:<span class="number">36</span>.<span class="number">939</span>: I/System.out(<span class="number">24841</span>): query <span class="keyword">book </span>list: [<span class="keyword">Book </span>[<span class="keyword">bookId=1, </span><span class="keyword">bookName=Android], </span><span class="keyword">Book </span>[<span class="keyword">bookId=2, </span><span class="keyword">bookName=IOS], </span><span class="keyword">Book </span>[<span class="keyword">bookId=3, </span><span class="keyword">bookName=Windows </span>Phone]]</div></pre></td></tr></table></figure>
<h2 id="Binder意外死亡的处理办法"><a href="#Binder意外死亡的处理办法" class="headerlink" title="Binder意外死亡的处理办法"></a>Binder意外死亡的处理办法</h2><p>（1）给Binder设置DeathRecipinent监听，当Binder死亡时，会收到binderDied的回调，在此回调中重新连接远程服务，次方法在客户端的Binder线程池中调用，不能直接访问UI  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> IBinder.DeathRecipient mDeathRecipient = <span class="keyword">new</span> IBinder.DeathRecipient() &#123;</div><div class="line">	</div><div class="line">	<span class="comment">//Binder死亡时的回调方法</span></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">if</span> (bookManager == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		bookManager.asBinder().unlinkToDeath(mDeathRecipient, <span class="number">0</span>);</div><div class="line">		bookManager = <span class="keyword">null</span>;</div><div class="line">		</div><div class="line">		<span class="comment">//重新绑定远程服务</span></div><div class="line">		Intent intent = <span class="keyword">new</span> Intent(BookManagerActivity.<span class="keyword">this</span>, BookManagerService.class);</div><div class="line">		bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		bookManager = IBookManager.Stub.asInterface(service);</div><div class="line">		<span class="comment">//给binder设置死亡代理</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			service.linkToDeath(mDeathRecipient, <span class="number">0</span>);</div><div class="line">		&#125; <span class="keyword">catch</span> (RemoteException e1) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			e1.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>（2）在onServiceDisconnected中重连远程服务，此方法在客户端的UI线程中调用  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="comment">//重新绑定远程服务</span></div><div class="line">		Intent intent = <span class="keyword">new</span> Intent(BookManagerActivity.<span class="keyword">this</span>, BookManagerService.class);</div><div class="line">		bindService(intent, mConnection, Context.BIND_AUTO_CREATE);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		bookManager = IBookManager.Stub.asInterface(service);</div><div class="line">		<span class="comment">//给binder设置死亡代理</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			service.linkToDeath(mDeathRecipient, <span class="number">0</span>);</div><div class="line">		&#125; <span class="keyword">catch</span> (RemoteException e1) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			e1.printStackTrace();</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="AIDL中使用权限验证功能"><a href="#AIDL中使用权限验证功能" class="headerlink" title="AIDL中使用权限验证功能"></a>AIDL中使用权限验证功能</h2><p>默认情况下，我们的远程服务任何人都可以连接，所以我们必须给服务加入权限验证功能，权限验证失败则无法调用服务的方法，这里介绍两种常用的方法。</p>
<ul>
<li><strong>onBind中验证</strong></li>
</ul>
<p>早onBind中进行验证，验证不通过就直接返回null，这样验证失败的客户端无法绑定服务，比如使用permission验证。首先，在Manifest.xml中声明所需要的权限，比如：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;permission </div><div class="line">    android:<span class="built_in">name</span>=<span class="string">"com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE"</span></div><div class="line">    android:protectionLevel=<span class="string">"normal"</span>&gt;</div></pre></td></tr></table></figure>
<p>然后在BookManagerService的onBind做权限验证，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">	<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">	<span class="keyword">int</span> check = checkCallingOrSelfPermission(<span class="string">"com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE"</span>);</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> (check == PackageManager.PERMISSION_DENIED) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//客户端就无法绑定到此服务</span></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> mBinder;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方法同样适用于Messenger中。如果我们自己内部的应用想绑定到我们的服务中，只需要在它的AndroidManifest文件中使用permission即可</p>
<uses-permission android:name="com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE">

<ul>
<li><strong>服务端的onTransact方法中验证</strong></li>
</ul>
<p>在服务端的onTransact方法中进行权限验证，验证失败就返回false，这样服务端就不会终止执行AIDL中的方法从而达到保护服务端的效果。至于验证的方式有很多，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Binder mBinder = <span class="keyword">new</span> IBookManager.Stub() &#123;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> mBookList;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">if</span> (!mBookList.contains(book)) &#123;</div><div class="line">			mBookList.add(book);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></div><div class="line">			<span class="keyword">throws</span> RemoteException &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		</div><div class="line">		<span class="comment">//1.通过permission验证</span></div><div class="line">		<span class="keyword">int</span> check = checkCallingOrSelfPermission(<span class="string">"com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE"</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (check == PackageManager.PERMISSION_DENIED) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="comment">//2.验证包名</span></div><div class="line">		String packageName = <span class="keyword">null</span>;</div><div class="line">		String[] packages = getPackageManager().getPackagesForUid(getCallingUid());</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (packages != <span class="keyword">null</span> &amp;&amp; packages.length &gt; <span class="number">0</span>) &#123;</div><div class="line">			packageName = packages[<span class="number">0</span>];</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (!packageName.startsWith(<span class="string">"com.ryg"</span>)) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面介绍了常用的两种权限验证方式，但是还有其他方式做权限验证，比如为Service指定android:permission属性等。</p>
<h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><p>ContentProvider是Android中专门用于不同应用间进行数据共享的方式，从这一点来看，它天生适合进程间通信。和Messenger一样，ContentProvider的底层实现同样是Binder。</p>
<p>系统预置了许多ContentProvider，比如通讯录信息<br>日程表信息等，要跨进程访问这些信息，只需要通过ContentResolver的query、update、insert和delete方法。下面我们演示实现一个自定义的ContentProvider，并演示如何在其他应用中获取ContentProvider中的数据从而实现进行间通信的目的。首先，创建一个ContentProvider的类，叫BookProvider，并实现6个抽象方法即可onCreate、query、delete、update、insert和getType。onCreate代表ContentProvider的创建，需要做一些初始化的工作；getType用来返回一个Uri请求所对应的MIME类型，比如视频、图片、等，如果应用不关心这个选项，可以直接在方法中返回null或者“*/*”剩下的四个方法对应于CRUD操作，对数据表的增删改查功能。</p>
<p>根据Binder的工作原理，这留个方法均运行在ContentProvider的进程中，除了onCreate有系统回调运行在主线程里，其他无非方法由外界回调并运行在Binder线程池中。</p>
<p>示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//BookProvider.java</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(<span class="string">"onCreate current thread:"</span> + Thread.currentThread().getName());</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection,</span></span></div><div class="line">			String[] selectionArgs, String sortOrder) &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		System.out.println(<span class="string">"query current thread:"</span> + Thread.currentThread().getName());</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection,</span></span></div><div class="line">			String[] selectionArgs) &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们需要注册这个BookProvider，如下所示。其中android:anthorities是ContentProvider的唯一标识，通过这个属性外部应用就可以访问我们的BookProvide。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;provider</div><div class="line">    android:name=<span class="string">"com.ryg.chapter_2.provider.BookProvider"</span></div><div class="line">    android:authorities=<span class="string">"com.ryg.chapter_2.provider.book.provider"</span> <span class="regexp">//</span>标识</div><div class="line">    android:permission=<span class="string">"com.ryg.PROVIDER"</span> <span class="regexp">//</span>权限</div><div class="line">    android:process=<span class="string">":provider"</span></div><div class="line">    <span class="regexp">//</span>ndroid:readPermission=<span class="string">"com.ryg.PROVIDER.READ"</span> <span class="regexp">//</span>读权限</div><div class="line">    <span class="regexp">//</span>android:writePermission=<span class="string">"com.ryg.PROVIDER.WRITE"</span> &gt;  <span class="regexp">//</span>写权限</div><div class="line">&lt;<span class="regexp">/provider&gt;</span></div></pre></td></tr></table></figure>
<p>然后声明权限和加入权限</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:<span class="built_in">name</span>=<span class="string">"com.ryg.PROVIDER"</span> /&gt;</div><div class="line"></div><div class="line">  &lt;permission</div><div class="line">      android:<span class="built_in">name</span>=<span class="string">"com.ryg.PROVIDER"</span></div><div class="line">      android:protectionLevel=<span class="string">"normal"</span> /&gt;</div></pre></td></tr></table></figure>
<p>创建BookActivity.java访问这个ContentProvider，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		</div><div class="line">		Uri uri = Uri.parse(<span class="string">"content://com.ryg.chapter_2.provider.book.provider"</span>);</div><div class="line">		getContentResolver().query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">		getContentResolver().query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">		getContentResolver().query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">		getContentResolver().query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码中，我们提供ContentResolver对象的query方法查询BookProvider中的数据，其中”content://com.ryg.chapter_2.provider.book.provider”位移标识了BookProvider，这个标识正式为BookProvider的android:authorities属性所指定的值。</p>
<p>运行结果如下</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> 16:50:31.678: I/System.<span class="keyword">out</span>(22482): onCreate current thread:main        <span class="comment">//主线程</span></div><div class="line">01-11 16:50:31.680: I/System.<span class="keyword">out</span>(22482): <span class="keyword">query</span> current thread:Binder_2  <span class="comment">//Binder线程池中</span></div><div class="line">01-11 16:50:31.681: I/System.<span class="keyword">out</span>(22482): <span class="keyword">query</span> current thread:Binder_1</div><div class="line">01-11 16:50:31.682: I/System.<span class="keyword">out</span>(22482): <span class="keyword">query</span> current thread:Binder_2</div><div class="line">01-11 16:50:31.682: I/System.<span class="keyword">out</span>(22482): <span class="keyword">query</span> current thread:Binder_1</div></pre></td></tr></table></figure>
<p>从结果可以看出，onCreate运行于主线程中，所以不能在onCreate中做耗时操作，query方法的四次调用不在同一个线程中，但是在同一个Binder线程池中。</p>
<p>接下来，我们继续完善BookProvider，从而使其对外界的应用提供数据。为了完成上述功能，我们需要一个数据库来管理图示和用户信息，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookOpenHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DB_NAME = <span class="string">"book_provider.db"</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BOOK_TABLE_NAME = <span class="string">"book"</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_TABLE_NAME = <span class="string">"user"</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DB_VERSION = <span class="number">1</span>;</div><div class="line">	</div><div class="line">	<span class="comment">//图书列表</span></div><div class="line">	<span class="keyword">private</span> String CREATE_BOOK_TABLE = <span class="string">"CREATE TABLE IF NOT EXISTS "</span> + BOOK_TABLE_NAME +<span class="string">"(_id INTEGER PRIMARY KEY, name TEXT)"</span>;</div><div class="line">	<span class="comment">//用户列表</span></div><div class="line">	<span class="keyword">private</span> String CREATE_USER_TABLE = <span class="string">"CREATE TABLE IF NOT EXISTS "</span> + USER_TABLE_NAME +<span class="string">"(_id INTEGER PRIMARY KEY, name TEXT, sex INT)"</span>;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BookOpenHelper</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(context, DB_NAME, <span class="keyword">null</span>, DB_VERSION);</div><div class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		db.execSQL(CREATE_BOOK_TABLE);</div><div class="line">		db.execSQL(CREATE_USER_TABLE);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，分别为book表和user表指定Uri，并关联对应的uri——code</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookOpenHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DB_NAME = <span class="string">"book_provider.db"</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BOOK_TABLE_NAME = <span class="string">"book"</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_TABLE_NAME = <span class="string">"user"</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DB_VERSION = <span class="number">1</span>;</div><div class="line">	</div><div class="line">	<span class="comment">//图书列表</span></div><div class="line">	<span class="keyword">private</span> String CREATE_BOOK_TABLE = <span class="string">"CREATE TABLE IF NOT EXISTS "</span> + BOOK_TABLE_NAME +<span class="string">"(_id INTEGER PRIMARY KEY, name TEXT)"</span>;</div><div class="line">	<span class="comment">//用户列表</span></div><div class="line">	<span class="keyword">private</span> String CREATE_USER_TABLE = <span class="string">"CREATE TABLE IF NOT EXISTS "</span> + USER_TABLE_NAME +<span class="string">"(_id INTEGER PRIMARY KEY, name TEXT, sex INT)"</span>;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BookOpenHelper</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(context, DB_NAME, <span class="keyword">null</span>, DB_VERSION);</div><div class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	.......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们就可以通过如下方式获取外界要访问点饿数据源，根据Uri取出Uri_code，根据Uri_code得到数据表的名称</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span> </span>&#123;</div><div class="line"></div><div class="line">	String tableName = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="keyword">switch</span> (sUriMatcher.match(uri)) &#123;</div><div class="line"></div><div class="line">	<span class="keyword">case</span> BOOK_URI_CODE:</div><div class="line"></div><div class="line">		tableName = BookOpenHelper.BOOK_TABLE_NAME;</div><div class="line">		</div><div class="line">		<span class="keyword">break</span>;</div><div class="line"></div><div class="line">	<span class="keyword">case</span> USER_URI_CODE:</div><div class="line">		</div><div class="line">		tableName = BookOpenHelper.USER_TABLE_NAME;</div><div class="line">		<span class="keyword">break</span>;</div><div class="line"></div><div class="line">	<span class="keyword">default</span>:</div><div class="line">		<span class="keyword">break</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> tableName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，我们就实现query、update、insert、delete方法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORITY = <span class="string">"com.ryg.chapter_2.provider.book.provider"</span>;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri BOOK_CONTENT_URI = Uri.parse(<span class="string">"content://"</span></div><div class="line">			+ AUTHORITY + <span class="string">"/book"</span>);</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOOK_URI_CODE = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri USER_CONTENT_URI = Uri.parse(<span class="string">"content://"</span></div><div class="line">			+ AUTHORITY + <span class="string">"/user"</span>);</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> USER_URI_CODE = <span class="number">1</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> UriMatcher sUriMatcher = <span class="keyword">new</span> UriMatcher(</div><div class="line">			UriMatcher.NO_MATCH);</div><div class="line"></div><div class="line">	<span class="keyword">static</span> &#123;</div><div class="line">		<span class="comment">// 将Uri和Uri_Code关联起来</span></div><div class="line">		sUriMatcher.addURI(AUTHORITY, <span class="string">"book"</span>, <span class="number">0</span>);</div><div class="line">		sUriMatcher.addURI(AUTHORITY, <span class="string">"book"</span>, <span class="number">1</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Context mContext;</div><div class="line">	<span class="keyword">private</span> SQLiteDatabase db;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">		mContext = getContext();</div><div class="line">		initData();</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		db = <span class="keyword">new</span> BookOpenHelper(mContext).getWritableDatabase();</div><div class="line">		db.execSQL(<span class="string">"delete from "</span> + BookOpenHelper.BOOK_TABLE_NAME);</div><div class="line">		db.execSQL(<span class="string">"delete from "</span> + BookOpenHelper.USER_TABLE_NAME);</div><div class="line">		db.execSQL(<span class="string">"insert into book values(2,'Android');"</span>);</div><div class="line">		db.execSQL(<span class="string">"insert into book values(3,'IOS');"</span>);</div><div class="line">		db.execSQL(<span class="string">"insert into book values(4,'Window Phone');"</span>);</div><div class="line">		db.execSQL(<span class="string">"insert into user values(6,'lee',1);"</span>);</div><div class="line">		db.execSQL(<span class="string">"insert into book values(7,'lau',0);"</span>);</div><div class="line">		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection,</span></span></div><div class="line">			String[] selectionArgs, String sortOrder) &#123;</div><div class="line">		</div><div class="line">		String table = getTableName(uri);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported URI: "</span> + uri);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> db.query(table, projection, selection, selectionArgs, <span class="keyword">null</span>, <span class="keyword">null</span>, sortOrder, <span class="keyword">null</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		String table = getTableName(uri);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported URI: "</span> + uri);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		db.insert(table, <span class="keyword">null</span>, values);</div><div class="line">		mContext.getContentResolver().notifyChange(uri, <span class="keyword">null</span>); <span class="comment">//通过数据源变化</span></div><div class="line">		</div><div class="line">		<span class="keyword">return</span> uri;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		String table = getTableName(uri);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported URI: "</span> + uri);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> count = db.delete(table, selection, selectionArgs);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (count &gt;<span class="number">0</span>) &#123;</div><div class="line">			mContext.getContentResolver().notifyChange(uri, <span class="keyword">null</span>);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> count;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection,</span></span></div><div class="line">			String[] selectionArgs) &#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		</div><div class="line">		String table = getTableName(uri);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported URI: "</span> + uri);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> row = db.update(table, values, selection, selectionArgs);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (row &gt; <span class="number">0</span>) &#123;</div><div class="line">			mContext.getContentResolver().notifyChange(uri, <span class="keyword">null</span>);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> row;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span> </span>&#123;</div><div class="line"></div><div class="line">		String tableName = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">		<span class="keyword">switch</span> (sUriMatcher.match(uri)) &#123;</div><div class="line"></div><div class="line">		<span class="keyword">case</span> BOOK_URI_CODE:</div><div class="line"></div><div class="line">			tableName = BookOpenHelper.BOOK_TABLE_NAME;</div><div class="line">			</div><div class="line">			<span class="keyword">break</span>;</div><div class="line"></div><div class="line">		<span class="keyword">case</span> USER_URI_CODE:</div><div class="line">			</div><div class="line">			tableName = BookOpenHelper.USER_TABLE_NAME;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line"></div><div class="line">		<span class="keyword">default</span>:</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> tableName;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>访问BookProvider</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> ContentObserver mObserver = <span class="keyword">new</span> ContentObserver(<span class="keyword">new</span> Handler()) &#123;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange, Uri uri)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			System.out.println(uri);</div><div class="line">			<span class="keyword">super</span>.onChange(selfChange, uri);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		</div><div class="line">		</div><div class="line">		Uri uri = Uri.parse(<span class="string">"content://com.ryg.chapter_2.provider.book.provider/book"</span>);</div><div class="line">		getContentResolver().registerContentObserver(uri, <span class="keyword">false</span>, mObserver);</div><div class="line">		ContentValues values = <span class="keyword">new</span> ContentValues();</div><div class="line">		values.put(<span class="string">"_id"</span>, <span class="number">7</span>);</div><div class="line">		values.put(<span class="string">"name"</span>, <span class="string">"Html"</span>);</div><div class="line">		getContentResolver().insert(uri, values);</div><div class="line">		</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要注意的是，query、update、insert、delete四大方法是存在多线程并发访问的，因此方法内部要做好线程同步本例中，由于采用的是SQLite并且只有一个SQLiteDataBase的连接，所以可以正确应对多线程的情况。具体原因是SQLiteDatabase内部对数据库的操作是有同步处理的，但是如果通过多个SQLiteDatabase对象来操作数据库就无法保证线程同步，因为SQLiteDatabase对象之间无法进行线程同步。如果ContentProvider的底层数据是一块内存的话，比如List，在这种情况下同List的遍历、插入、删除操作就需要进行线程同步，否则就会引起并发错误。</p>
<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p>Socket又称为套接字，是网络通信的概念，它分为流式套接字和用户数据报套接字，分别对应于网络传输层的TCP和UDP协议。TCP是面向连接的协议，提供稳定的双向通信功能，TCP连接的建立需要经过“三次握手”才能完成，为了提供稳定的数据传输功能，其本身提供了超时重传机制，因此具有很高的稳定性；而UDP是面向无连接的协议，提供不稳定的单向通信功能，当然UDP也可以实现双向通信功能。在性能上，UDP具有更高的效率，其缺点是不能保证数据一定能够正确传输，尤其是在网络拥塞的情况下。</p>
<p>下面示例一个聊天室程序，首先是服务端的设计，当Service启动时，会在线程中建立TCP服务，这里监听的是8688端口，然后就可以等待客户端的连接请求。当有客户端连接时，就会生成一个新的Socket，通过每次新创建的Socket就可以分别和不同的客户端通信了。当客户端断开连接时，服务端这边也会关闭对应Socket并结束通话线程。这点是如何做到的呢？这里是通过判断服务端输入流的返回值来确定的，当客户端断开连接后，服务端这边的输入流会返回null，这个时候我们就知道客户端退出了。服务端代码如下：</p>
<h1 id="选用合适的IPC方式"><a href="#选用合适的IPC方式" class="headerlink" title="选用合适的IPC方式"></a>选用合适的IPC方式</h1><table>
<thead>
<tr>
<th>名称</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bundle</td>
<td>简单易用</td>
<td>只能传输Bundle支持的数据类型</td>
<td>四大组件间的进程间通信</td>
</tr>
<tr>
<td>文件共享</td>
<td>简单易用</td>
<td>不适合高并发场景，并且无法做到进程间的即时通信</td>
<td>无并发访问情形，交换简单的数据实时性不高的场景</td>
</tr>
<tr>
<td>AIDL</td>
<td>功能强大，支持一对多并发通信，支持实时通信</td>
<td>使用稍复杂，需要处理好现场同步</td>
<td>一对多通信且有RPC需求</td>
</tr>
<tr>
<td>Messenger</td>
<td>功能一般，支持一对多串行通信，支持实时通信</td>
<td>不能很好地处理搞并发情形，不支持RPC，数据通过Messenger进行传输，因此只能传输Bundle支持的数据类型</td>
<td>低并发的一对多即时通信，无RPC需求，或者无需要返回结果的RPC需求</td>
</tr>
<tr>
<td>ContentProvider</td>
<td>在数据源访问方面功能强大，支持一对多并发数据共享，可通过Call方法扩展其他操作</td>
<td>可以理解为受约束的AIDL，主要提供数据源的CRUD操作</td>
<td>一对多的进程间的数据共享</td>
</tr>
<tr>
<td>Socket</td>
<td>功能强大，可通过网络传输字节流，支持一对多并发实时通信</td>
<td>实现细节稍微有些烦琐，不支持直接的RPC</td>
<td>网络数据交换</td>
</tr>
</tbody>
</table>
</uses-permission>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2016/04/19/Android的IPC方式/" data-id="cj6ft5eqp0020qm19ch5ovwae" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2016/04/19/Android的IPC方式/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android系统/">Android系统</a></li></ul>

    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/14/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/16/">下一页&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/08/16/Android启动流程①init进程分析/">Android启动流程①init进程分析</a>
          </li>
        
          <li>
            <a href="/2017/08/15/Android系统架构与源码目录/">Android系统架构与源码目录</a>
          </li>
        
          <li>
            <a href="/2017/08/14/Mac编译Android源码/">Mac编译Android源码</a>
          </li>
        
          <li>
            <a href="/2017/06/21/JavaScript⑦对象/">JavaScript⑦对象</a>
          </li>
        
          <li>
            <a href="/2017/06/19/JavaScript⑥引用类型RegExp/">JavaScript⑥引用类型RegExp</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2017 刘涤生&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;michaelliu0727@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/categories" class="mobile-nav-link">分类</a>
  
    <a href="/tags" class="mobile-nav-link">标签</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>
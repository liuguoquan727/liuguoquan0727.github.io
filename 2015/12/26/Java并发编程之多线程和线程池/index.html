<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java并发编程之多线程和线程池 | 再读斋</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="线程允许在同一个进程中同时存在多个程序控制流，即通过线程可以实现同时处理多个任务的功能。线程会共享进程范围内的资源，例如内存句柄和文件句柄，但每个线程都有各自的程序计数器、栈以及局部变量。
多线程的实现实现方式对于Java的多线程来说，我们学习的一般都是Thread和Runnable，通过我们使用如下代码启动一个新的线程：
1234567891011121314151617181920212223">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程之多线程和线程池">
<meta property="og:url" content="http://liuguoquan727.github.io/2015/12/26/Java并发编程之多线程和线程池/index.html">
<meta property="og:site_name" content="再读斋">
<meta property="og:description" content="线程允许在同一个进程中同时存在多个程序控制流，即通过线程可以实现同时处理多个任务的功能。线程会共享进程范围内的资源，例如内存句柄和文件句柄，但每个线程都有各自的程序计数器、栈以及局部变量。
多线程的实现实现方式对于Java的多线程来说，我们学习的一般都是Thread和Runnable，通过我们使用如下代码启动一个新的线程：
1234567891011121314151617181920212223">
<meta property="og:updated_time" content="2016-05-03T14:42:06.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java并发编程之多线程和线程池">
<meta name="twitter:description" content="线程允许在同一个进程中同时存在多个程序控制流，即通过线程可以实现同时处理多个任务的功能。线程会共享进程范围内的资源，例如内存句柄和文件句柄，但每个线程都有各自的程序计数器、栈以及局部变量。
多线程的实现实现方式对于Java的多线程来说，我们学习的一般都是Thread和Runnable，通过我们使用如下代码启动一个新的线程：
1234567891011121314151617181920212223">
  
    <link rel="alternate" href="/atom.xml" title="再读斋" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://liuguoquan727.github.io"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/categories">分类</a>
        
          <a class="main-nav-link" href="/tags">标签</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">再读斋</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">MICHAEL</a>
        </h2>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java并发编程之多线程和线程池" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/26/Java并发编程之多线程和线程池/" class="article-date">
  <time datetime="2015-12-26T13:04:06.000Z" itemprop="datePublished">2015-12-26 21:04:06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java并发编程之多线程和线程池
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>线程允许在同一个进程中同时存在多个程序控制流，即通过线程可以实现同时处理多个任务的功能。线程会共享进程范围内的资源，例如内存句柄和文件句柄，但每个线程都有各自的程序计数器、栈以及局部变量。</p>
<h1 id="多线程的实现"><a href="#多线程的实现" class="headerlink" title="多线程的实现"></a>多线程的实现</h1><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>对于Java的多线程来说，我们学习的一般都是Thread和Runnable，通过我们使用如下代码启动一个新的线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startewThread</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">new</span> Thread()&#123;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">			<span class="comment">// 耗时任务</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;.start();</div><div class="line">&#125;</div><div class="line">或者</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startewThread1</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="comment">// 耗时任务</span></div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一种是覆写了Thread类中的run方法执行任务；第二种是实现Runnable接口中的run方法执行任务。</p>
<p>那么Thread和Runnable是什么关系呢？</p>
<h2 id="Thread和Runnable的关系"><a href="#Thread和Runnable的关系" class="headerlink" title="Thread和Runnable的关系"></a>Thread和Runnable的关系</h2><p>实际上Thread也是一个Runnable，它实现了Runnable接口，在Thread类中有一个Runnable类型的target字段，代表要被执行在这个子线程的任务。相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//要执行的目标任务</span></div><div class="line">    <span class="keyword">private</span> Runnable target;</div><div class="line">	<span class="comment">//线程所属的线程组</span></div><div class="line">    <span class="keyword">private</span> ThreadGroup group;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</div><div class="line">		init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</div><div class="line">        init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></div><div class="line">                      <span class="keyword">long</span> stackSize, AccessControlContext acc) &#123;</div><div class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.name = name.toCharArray();</div><div class="line"></div><div class="line">        Thread parent = currentThread();</div><div class="line">        SecurityManager security = System.getSecurityManager();</div><div class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">/* Determine if it's an applet or not */</span></div><div class="line"></div><div class="line">            <span class="comment">/* If there is a security manager, ask the security manager</span></div><div class="line">               what to do. */</div><div class="line">            <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</div><div class="line">                g = security.getThreadGroup();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /group为<span class="keyword">null</span>则获取当前线程的线程组</div><div class="line">               use the parent thread group. */</div><div class="line">            <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</div><div class="line">                g = parent.getThreadGroup();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></div><div class="line">           explicitly passed in. */</div><div class="line">        g.checkAccess();</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Do we have the required permissions?</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</div><div class="line">                security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        g.addUnstarted();</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.group = g;</div><div class="line">        <span class="keyword">this</span>.daemon = parent.isDaemon();</div><div class="line">        <span class="keyword">this</span>.priority = parent.getPriority();</div><div class="line">        <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</div><div class="line">            <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</div><div class="line">        <span class="keyword">this</span>.inheritedAccessControlContext =</div><div class="line">                acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</div><div class="line">		<span class="comment">//设置target</span></div><div class="line">        <span class="keyword">this</span>.target = target;</div><div class="line">        setPriority(priority);</div><div class="line">        <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">this</span>.inheritableThreadLocals =</div><div class="line">                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</div><div class="line">        <span class="comment">/* Stash the specified stack size in case the VM cares */</span></div><div class="line">        <span class="keyword">this</span>.stackSize = stackSize;</div><div class="line"></div><div class="line">        <span class="comment">/* Set thread ID */</span></div><div class="line">        tid = nextThreadID();</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * This method is not invoked for the main method thread or "system"</div><div class="line">         * group threads created/set up by the VM. Any new functionality added</div><div class="line">         * to this method in the future may have to also be added to the VM.</div><div class="line">         *</div><div class="line">         * A zero status value corresponds to state "NEW".</div><div class="line">         */</div><div class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</div><div class="line"></div><div class="line">        <span class="comment">/* Notify the group that this thread is about to be started</span></div><div class="line">         * so that it can be added to the group's list of threads</div><div class="line">         * and the group's unstarted count can be decremented. */</div><div class="line">        group.add(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">//调用native函数启动线程</span></div><div class="line">            start0();</div><div class="line">            started = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (!started) &#123;</div><div class="line">                    group.threadStartFailed(<span class="keyword">this</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</div><div class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></div><div class="line">                  it will be passed up the call stack */</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</div><div class="line">            target.run();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上最终被线程执行的任务是Runnable，而非Thread。Thread 只是对Runnable的包装，并且通过一些状态对Thread进行管理和调度。Runnable的声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当启动一个线程时，如果Thread的target不为空，则会在子线程中执行这个target的run方法，否则虚拟机就会执行该线程自身的run方法。</p>
<h1 id="线程的wait、sleep、join和yield"><a href="#线程的wait、sleep、join和yield" class="headerlink" title="线程的wait、sleep、join和yield"></a>线程的wait、sleep、join和yield</h1><p>先通过下面的表格来了解他们的区别：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>wait</td>
<td>当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时释放了对象的锁，使得其他线程可以访问。用户可以使用notify、notifyAll或指定睡眠时间来唤醒当前等待池中的线程。  注意：wait、notify、notifyAll方法必须放在synchronized block中，否则则会抛出异常。</td>
</tr>
<tr>
<td>sleep</td>
<td>该函数时Thread的静态函数，作用是使调用线程进入睡眠状态。因为sleep()Thread的静态函数，因此它不能改变对象的锁。所以当一个synchronized块中调用sleep方法时，线程虽然休眠了，但是对象的锁并没有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）</td>
</tr>
<tr>
<td>join</td>
<td>等待目标线程执行完成之后再继续执行</td>
</tr>
<tr>
<td>yield</td>
<td>线程礼让。目标线程由运行状态转换为就绪状态，也就是让出执行权限，让其他线程得以优先执行，但其他线程能否优先执行时未知的。</td>
</tr>
</tbody>
</table>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h2><p>下面来看看wait、notify、notifyAll的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitDemo</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Object lockObject = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitAndNotifAll</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">		System.out.println(<span class="string">"主线程运行"</span>);</div><div class="line"></div><div class="line">		<span class="comment">//创建并启动子线程</span></div><div class="line">		Thread thread = <span class="keyword">new</span> WaitThread();</div><div class="line">		thread.start();</div><div class="line"></div><div class="line">		<span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">//必须在synchronized块中</span></div><div class="line">			<span class="keyword">synchronized</span> (lockObject) &#123;</div><div class="line">				System.out.println(<span class="string">"主线程等待"</span>);</div><div class="line">				lockObject.wait();</div><div class="line"></div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//被唤醒后继续执行</span></div><div class="line">		<span class="keyword">long</span> endTime = System.currentTimeMillis() - startTime;</div><div class="line">		</div><div class="line">		System.out.println(<span class="string">"主线程继续---&gt;等待耗时： "</span> + endTime + <span class="string">"ms"</span>);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			<span class="keyword">synchronized</span> (lockObject) &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					Thread.sleep(<span class="number">3000</span>);</div><div class="line">					<span class="comment">//唤醒正在等待中的线程</span></div><div class="line">					lockObject.notifyAll();</div><div class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">					<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		waitAndNotifAll();</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">运行结果：</div><div class="line"></div><div class="line">主线程运行</div><div class="line">主线程等待</div><div class="line">...</div><div class="line">...</div><div class="line"></div><div class="line">主线程继续---&gt;等待耗时： <span class="number">3001</span>ms</div></pre></td></tr></table></figure>
<p>wait、notify机制通常用于等待机制的实现，当条件未满足时调用wait进入等待状态，一旦条件满足，调用notify或notifyAll唤醒等待的线程继续执行。</p>
<h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>join函数的原始解释为“Block the cuurent thread(Thread.currentThread()) untile the receiver finishes its execution and dies。意思就是阻塞当前调用join函数的任务所在的线程，直到该任务执行完成后再继续执行所在线程的任务。下面我们来看看一个具体是实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span> </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line"></div><div class="line">		joinDemo();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">joinDemo</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">		System.out.println(<span class="string">"主线程开始执行"</span>);</div><div class="line">		</div><div class="line">		Worker worker1 = <span class="keyword">new</span> Worker(<span class="string">"worker-1"</span>);</div><div class="line">		Worker worker2 = <span class="keyword">new</span> Worker(<span class="string">"worker-2"</span>);</div><div class="line"></div><div class="line">		worker1.start();</div><div class="line"></div><div class="line">		System.out.println(<span class="string">"启动线程1--执行完毕"</span>);</div><div class="line"></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">//等待worker1任务执行完成</span></div><div class="line">			worker1.join();</div><div class="line">			</div><div class="line">			System.out.println(<span class="string">"启动线程2--执行完毕"</span>);</div><div class="line">			</div><div class="line">			worker2.start();</div><div class="line">			</div><div class="line">			<span class="comment">//等待worker2任务执行完成</span></div><div class="line">			worker2.join();</div><div class="line">			</div><div class="line">			</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		System.out.println(<span class="string">"主线程继续执行"</span>);</div><div class="line">		</div><div class="line">		System.out.println(<span class="string">"主线程执行完毕"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">			<span class="keyword">super</span>(name);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Thread.sleep(<span class="number">3000</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			System.out.println(<span class="string">"Work in "</span> + getName());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">结果打印：</div><div class="line"></div><div class="line">主线程开始执行</div><div class="line">启动线程<span class="number">1</span>--执行完毕</div><div class="line">Work in worker-<span class="number">1</span></div><div class="line">启动线程<span class="number">2</span>--执行完毕</div><div class="line">Work in worker-<span class="number">2</span></div><div class="line">主线程继续执行</div><div class="line">主线程执行完毕</div></pre></td></tr></table></figure>
<p>上述代码的逻辑是主线程开始执行、启动线程1、等待线程1执行完毕、启动线程2、等待线程2执行完毕、继续执行主线程任务。</p>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>yield函数的官方解释是”Causes the calling Thread to yiled execution time to another Thread that is ready to run”,意思是使调用该函数的线程让出执行时间给其他已就绪状态的线程。</p>
<p>线程的执行是有时间片的，每个线程轮流占用CPU固定的时间，执行周期到了之后就让出执行权给其他线程，而yield函数的功能就是主动让出线程的执行权给其他线程，其他线程能否得到优先权就得看各个线程的状态了。下面来看看一个具体的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldDemo</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		YieldThread t1 = <span class="keyword">new</span> YieldThread(<span class="string">"thread-1"</span>);</div><div class="line">		YieldThread t2 = <span class="keyword">new</span> YieldThread(<span class="string">"thread-2"</span>);</div><div class="line">		t1.start();</div><div class="line">		t2.start();</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">		</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="title">YieldThread</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">			<span class="keyword">super</span>(name);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;i++) &#123;</div><div class="line">				System.out.println(<span class="keyword">this</span>.getName() + <span class="string">" ; "</span> + <span class="string">"线程优先级为： "</span> + <span class="keyword">this</span>.getPriority()+ <span class="string">"---&gt;"</span> + i);</div><div class="line">				</div><div class="line">				<span class="comment">//当i为2时 调用当前线程yield函数</span></div><div class="line">				<span class="keyword">if</span> (i== <span class="number">2</span>) &#123;</div><div class="line">					Thread.yield();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">打印结果：</div><div class="line"></div><div class="line">thread-<span class="number">1</span> ; 线程优先级为： <span class="number">5</span>---&gt;<span class="number">0</span></div><div class="line">thread-<span class="number">2</span> ; 线程优先级为： <span class="number">5</span>---&gt;<span class="number">0</span></div><div class="line">thread-<span class="number">2</span> ; 线程优先级为： <span class="number">5</span>---&gt;<span class="number">1</span></div><div class="line">thread-<span class="number">2</span> ; 线程优先级为： <span class="number">5</span>---&gt;<span class="number">2</span></div><div class="line">thread-<span class="number">1</span> ; 线程优先级为： <span class="number">5</span>---&gt;<span class="number">1</span></div><div class="line">thread-<span class="number">1</span> ; 线程优先级为： <span class="number">5</span>---&gt;<span class="number">2</span></div><div class="line">thread-<span class="number">2</span> ; 线程优先级为： <span class="number">5</span>---&gt;<span class="number">3</span></div><div class="line">thread-<span class="number">2</span> ; 线程优先级为： <span class="number">5</span>---&gt;<span class="number">4</span></div><div class="line">thread-<span class="number">1</span> ; 线程优先级为： <span class="number">5</span>---&gt;<span class="number">3</span></div><div class="line">thread-<span class="number">1</span> ; 线程优先级为： <span class="number">5</span>---&gt;<span class="number">4</span></div></pre></td></tr></table></figure>
<p>从结果可知，thread-2首先执行到i的值为2，此时让出执行权，thread-1得到执行权运行到i的值为2时让出执行权，thread-2得到执行权执行任务结束，然后thread-1再继续执行任务。</p>
<p>注意：yield仅在一个时间片内有效。</p>
<h2 id="Callable、Future和FutureTask"><a href="#Callable、Future和FutureTask" class="headerlink" title="Callable、Future和FutureTask"></a>Callable、Future和FutureTask</h2><p>除了Runnable之外，Java还有Callable、Future和FutureTask这几个与多线程相关的概念，与Runnable不同的是这个类型都只能运用到线程池中，而Runnable既能运用在Thread中，还能运用在线程池中。</p>
<h3 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h3><p>Callable与Runnable的功能大致相似不同的是Callable是一个泛型接口，它有一个泛型参数V，该接口中有一个返回值（类型为V）的Call函数，而Runnable中的run方法不能将结果返回至调用者。Callable的声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Computes a result, or throws an exception if unable to do so.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> computed result</div><div class="line">     * <span class="doctag">@throws</span> Exception if unable to compute a result</div><div class="line">     */</div><div class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future为线程池制定了一个可管理的任务标准。它提供了对Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果、设置结果操作，分别对应cancel、isDone、get、set函数。get方法会阻塞，直到任务返回结果。Future的声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//取消任务</span></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">//判断任务是否已经取消</span></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">//判断任务是否已经完成</span></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">//获取结果，如果任务未完成则等待，直到完成，因此该函数会阻塞</span></div><div class="line">	<span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</div><div class="line"></div><div class="line">	<span class="comment">//获取结果，如果未完成则等待，直到返回结果或timeout，该函数会阻塞</span></div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>Future只是定义了一些规范的接口，而FutureTask则是它的实现类。FutureTask实现了<code>RunnableFuture&lt;V&gt;</code>，而RunnableFuture实现了Runnable又实现了Future<v>这两个接口，因此FutureTask同时具备他们的功能。FutureTask的代码如下：</v></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">	.....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RunnableFuture<v>类的定义</v></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Sets this Future to the result of its computation</div><div class="line">     * unless it has been cancelled.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>FutureTask像Thread那样包装Runnable那样对Runnable和<code>Callable&lt;V&gt;</code>进行包装，Runnable与Callable由构造函数注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">this</span>.callable = callable;</div><div class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</div><div class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述代码可以看出，如果注入的是Runnable则会被Executors.callable()函数转换为Callable类型，即FutureTask最终都是执行Callable类型的任务，该转换函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* Runnable适配器，将Runnable转换为Callable</div><div class="line">*/</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> Runnable task;</div><div class="line">    <span class="keyword">final</span> T result;</div><div class="line">    RunnableAdapter(Runnable task, T result) &#123;</div><div class="line">        <span class="keyword">this</span>.task = task;</div><div class="line">        <span class="keyword">this</span>.result = result;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">        task.run();</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于FutureTask实现了Runnable，因此它既可以通过Thread包装来执行，也可以提交给ExecuteService来执行，并且还可以通过get()函数来获取执行结果，该函数会阻塞，直到结果返回。因此，FutureTask既是Future、Runnable，又是包装了Callable（Runnable最终也会被转换为Callable），它是这两者的合体。</p>
<p>下面示例演示Runnable、Callable、FutureTask的运用，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskDemo</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//线程池</span></div><div class="line">	<span class="keyword">static</span> ExecutorService mExecutor = Executors.newSingleThreadExecutor();</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 向线程池提交Runnable对象</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">taskRunnable</span><span class="params">()</span> </span>&#123;</div><div class="line">		</div><div class="line">		<span class="comment">//无返回值</span></div><div class="line">		Future&lt;?&gt; future = mExecutor.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				fibc(<span class="number">20</span>);</div><div class="line">				</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line"></div><div class="line">		System.out.println(<span class="string">"taskRunnable: "</span> + future.get());</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 向线程池提交Callable对象</div><div class="line">	 * <span class="doctag">@throws</span> ExecutionException </div><div class="line">	 * <span class="doctag">@throws</span> InterruptedException </div><div class="line">	 */	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">taskCallable</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">		</div><div class="line">		Future&lt;Integer&gt; future = mExecutor.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				<span class="keyword">return</span> fibc(<span class="number">20</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		</div><div class="line">		<span class="comment">//返回值</span></div><div class="line">		Integer result = future.get();</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">			System.out.println(<span class="string">"taskCallable: "</span> + result);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 向线程池提交FutureTask对象</div><div class="line">	 * <span class="doctag">@throws</span> ExecutionException </div><div class="line">	 * <span class="doctag">@throws</span> InterruptedException </div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">taskFutureTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">		</div><div class="line">		FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				<span class="keyword">return</span> fibc(<span class="number">20</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		</div><div class="line">		mExecutor.submit(futureTask);</div><div class="line">		</div><div class="line">		Integer result = futureTask.get();</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">			System.out.println(<span class="string">"taskFutureTask: "</span> + result);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Thread包装FutureTask</div><div class="line">	 * <span class="doctag">@throws</span> InterruptedException</div><div class="line">	 * <span class="doctag">@throws</span> ExecutionException</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">taskThread</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">		</div><div class="line">		FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				<span class="keyword">return</span> fibc(<span class="number">20</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		</div><div class="line">		<span class="keyword">new</span> Thread(futureTask).start();</div><div class="line">		</div><div class="line">		Integer result = futureTask.get();</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</div><div class="line">			System.out.println(<span class="string">"taskThread: "</span> + result);</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 斐波那契数列</div><div class="line">	 * <span class="doctag">@param</span> num</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibc</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> fibc(num - <span class="number">1</span>) + fibc(num - <span class="number">2</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			taskRunnable();</div><div class="line">			taskCallable();</div><div class="line">			taskFutureTask();</div><div class="line">			taskThread();</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; </div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">打印结果：</div><div class="line"></div><div class="line">taskRunnable: <span class="keyword">null</span></div><div class="line">taskCallable: <span class="number">6765</span></div><div class="line">taskFutureTask: <span class="number">6765</span></div><div class="line">taskThread: <span class="number">6765</span></div></pre></td></tr></table></figure>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>当我们需要频繁地创建多个线程进行耗时操作时，每次都通过new Thread实现并不是一种好的方式，每次new Thread新建销毁对象性能较差，线程缺乏统一的管理，可能会无限制地创建新的线程，线程之间相互竞争从而占用过多系统资源导致死锁，并且缺乏定期执行、定时执行、线程中断等功能。</p>
<p>Java提供了4中线程池，它能够有效地管理、调度线程，避免过多的资源消耗，它强大到几乎不需要开发人员自定义的程序。它的优点如下：</p>
<ul>
<li>重用存在的线程，减少对象创建、销毁的开销；</li>
<li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞；</li>
<li>提供定时执行、定期执行、单线程、并发数控制等功能；</li>
</ul>
<p>线程池的原理就是会创建创建多个线程并且对这些线程进行管理，提交给线程的任务 会被线程池指派给其中的线程执行，提供线程池的统一调度、管理。使得多线程的使用更简单、高效。</p>
<p>线程池都实现了ExecutorService接口，该接口定义了线程池需要实现的接口，如submit、execute、shutdown等。它的实现有ThreadPoolExecutor和ScheduledPoolExecutor，ThreadPoolExecutor是运行最多的线程池实现，ScheduledPoolExecutor则用于执行周期性任务。</p>
<h2 id="启动指定数量的线程-ThreadPoolExecutor"><a href="#启动指定数量的线程-ThreadPoolExecutor" class="headerlink" title="启动指定数量的线程-ThreadPoolExecutor"></a>启动指定数量的线程-ThreadPoolExecutor</h2><p>ThreadPoolExecutor的功能是启动指定数量的线程以及将任务添加到一个队列中，并且将任务分发给空闲的线程。</p>
<p>ExecutorService的生命周期包括3中状态：运行、关闭、终止，创建后进入运行状态，调用shutdown()方法时便进入了关闭状态，此时ExecutorService不再接受新的任务，但它继续执行完已经提交的任务，当所有已经提交的任务都执行完后，就变成终止状态。</p>
<p>ThreadPoolExecutor的构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">						  <span class="keyword">int</span> maximumPoolSize,</div><div class="line">						  <span class="keyword">long</span> keepAliveTime,</div><div class="line">						  TimeUnit unit,</div><div class="line">						  BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">						  ThreadFactory threadFactory,</div><div class="line">						  RejectedExecutionHandler handler)</div></pre></td></tr></table></figure>
<p>下面对参数进行详细说明:</p>
<table>
<thead>
<tr>
<th>参 数 名</th>
<th>作  用</th>
</tr>
</thead>
<tbody>
<tr>
<td>corePoolSize</td>
<td>线程池中所保存的核心线程数。</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>线程池所容纳的最大线程数，当活动线程达到这个数值后，后续的任务将会被阻塞</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>非核心线程闲置时的超时时间，超出这个时长，非核心线程就会被回收</td>
</tr>
<tr>
<td>unit</td>
<td>用于指定keepAliveTime参数的时间单位，有毫秒、秒、分钟等</td>
</tr>
<tr>
<td>workQueue</td>
<td>线程池中的任务队列，如果线程池的线程数量已经达到核心线程数并且当前所有线程都处于活动状态时，则将新任务放到此队列中等待执行</td>
</tr>
<tr>
<td>threadFactory</td>
<td>线程工厂，为线程池提供创建新线程的功能，通常不需要设置</td>
</tr>
<tr>
<td>handler</td>
<td>拒绝策略，当线程池与workQueue队列都满了的情况下，对新任务采取的处理策略</td>
</tr>
</tbody>
</table>
<p><a href="http://liuguoquan727.github.io/2016/04/25/Android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池参数也可以参考这篇文章http://liuguoquan727.github.io/2016/04/25/Android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/:</a></p>
<p>其中workQueue有下列几个常用的实现：</p>
<ul>
<li>ArrayBlockingQueue</li>
</ul>
<p>基于数组结构的有界队列，此队列按FIFO原则对任务进行排序。如果队列满了还有任务进来，则调用拒绝策略</p>
<ul>
<li>LinkedBlockingQueue</li>
</ul>
<p>基于链表结构的无界队列，此队列按FIFO原则对任务进行排序。因为它是无界的，所以才有此队列后线程池将忽略handler参数。</p>
<ul>
<li>SynchronousQueue</li>
</ul>
<p>直接将任务提交给线程而不是将它加入到队列，实际上该队列是空的。每个插入的操作必须等到另一个调用移除的操作，如果新任务来了线程池没有任何可用线程处理的话，则调用拒绝策略。</p>
<ul>
<li>PriorityBlockingQueue</li>
</ul>
<p>具有优先级的队列的有界队列，可用自定义优先级，默认是按自然排序的。</p>
<p>此外，当线程池与workQueue队列都满了的情况下，对新加任务采取的处理策略也有几个默认实现：</p>
<ul>
<li>AbortPolicy</li>
</ul>
<p>拒绝任务，抛出RejectedExecutionException异常，线程池默认策略</p>
<ul>
<li>CallerRunsPolicy</li>
</ul>
<p>拒绝新任务加入，如果该线程池还没有被关闭，那么将这个新任务执行在调用线程中</p>
<ul>
<li>DiscardOldestPolicy</li>
</ul>
<p>如果执行程序还没有关闭，则将位于工作队列头部的任务删除，然后重试执行程序（如果再次失败，则重复此过程）</p>
<ul>
<li>DiscardPolicy</li>
</ul>
<p>加不进的任务都被抛弃了，同时没有异常抛出</p>
<h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>对应Android平台来说，最常使用的就是通过Executors.newFixedThreadPool(int size)函数来启动固定数量的线程池，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExectorsDemo</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">10</span>;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@param</span> args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			fixedThreadPool(MAX);</div><div class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">			<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fixedThreadPool</span><span class="params">(<span class="keyword">int</span> size)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">		</div><div class="line">		ExecutorService service = Executors.newFixedThreadPool(size);</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; MAX;i++) &#123;</div><div class="line">			</div><div class="line">			<span class="comment">//提交任务</span></div><div class="line">			Future&lt;Integer&gt; task = service.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line"></div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">					<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">					System.out.println(<span class="string">"执行线程: "</span> + Thread.currentThread().getName());</div><div class="line">					<span class="keyword">return</span> fibc(<span class="number">20</span>);</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">			</div><div class="line">			<span class="comment">//获取结果</span></div><div class="line">			System.out.println(<span class="string">"第"</span>+i+<span class="string">"次计算结果: "</span> + task.get());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 斐波那契数列</div><div class="line">	 * <span class="doctag">@param</span> num</div><div class="line">	 * <span class="doctag">@return</span></div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibc</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> fibc(num - <span class="number">1</span>) + fibc(num - <span class="number">2</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">结果打印：</div><div class="line"></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">1</span></div><div class="line">第<span class="number">0</span>次计算结果: <span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">2</span></div><div class="line">第<span class="number">1</span>次计算结果: <span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">3</span></div><div class="line">第<span class="number">2</span>次计算结果: <span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">1</span></div><div class="line">第<span class="number">3</span>次计算结果: <span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">2</span></div><div class="line">第<span class="number">4</span>次计算结果: <span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">3</span></div><div class="line">第<span class="number">5</span>次计算结果: <span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">1</span></div><div class="line">第<span class="number">6</span>次计算结果: <span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">2</span></div><div class="line">第<span class="number">7</span>次计算结果: <span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">3</span></div><div class="line">第<span class="number">8</span>次计算结果: <span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">1</span></div><div class="line">第<span class="number">9</span>次计算结果: <span class="number">6765</span></div></pre></td></tr></table></figure>
<p>在上述例子中，我们启动了含有3个线程的线程池，调用的是Executors的newFixedThreadPool函数，该函数的实现为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可知它的corePoolSize和MaxnumPoolSize值都是nThreads，并且设置keepAliveTime为0毫秒，最后设置无界任务队列，这样该线程池中就含有固定个数的线程，并且能够容纳无数个任务。</p>
<h3 id="newCacheThreadPool"><a href="#newCacheThreadPool" class="headerlink" title="newCacheThreadPool"></a>newCacheThreadPool</h3><p>有时可能需要任务尽可能快地被执行，这就需要线程池中的线程足够多也就是说此时需要拿空间来换时间，线程越多占用的内存消耗就越大。因此，我们可能需要一种场景，如果来了一个新的任务，并且没有空闲线程可用，此时必须马上创建一个线程来立即执行任务。我们可以通过Executors的newCacheThreadPool函数来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">newCacheThreadPool</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line"></div><div class="line">	ExecutorService service = Executors.newCachedThreadPool();</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; MAX;i++) &#123;</div><div class="line"></div><div class="line">		<span class="comment">//提交任务</span></div><div class="line">		service.submit(<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				System.out.println(<span class="string">"执行线程: "</span> + Thread.currentThread().getName() + <span class="string">",结果:"</span> + fibc(<span class="number">20</span>));</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">结果打印</div><div class="line"></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">1</span>,结果:<span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">2</span>,结果:<span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">4</span>,结果:<span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">6</span>,结果:<span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">8</span>,结果:<span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">5</span>,结果:<span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">3</span>,结果:<span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">7</span>,结果:<span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">10</span>,结果:<span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">9</span>,结果:<span class="number">6765</span></div></pre></td></tr></table></figure>
<p>从上述结果可以看出，为了保证吞吐量，该线程池为每个任务都创建了一个线程，当然这是在没有线程空闲的情况下创建的新的线程。假设执行前5个任务时都创建了一个线程，执行到底6个任务时刚好前面的第一个任务执行完毕，此时线程1空闲，那么第六个任务就会被执行在第一个线程中，而不是重新创建。</p>
<h2 id="执行周期性任务的线程-ScheduledPoolExecutor"><a href="#执行周期性任务的线程-ScheduledPoolExecutor" class="headerlink" title="执行周期性任务的线程-ScheduledPoolExecutor"></a>执行周期性任务的线程-ScheduledPoolExecutor</h2><p>通过Executors的newScheduledThreadPool函数即可创建定时执行任务的线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">newScheduledThreadPool</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException,</span></div><div class="line">		ExecutionException &#123;</div><div class="line"></div><div class="line">	ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">4</span>);</div><div class="line"></div><div class="line">	<span class="comment">// 参数2为第一次延迟的时间，参数2为执行周期</span></div><div class="line">	service.scheduleAtFixedRate((<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			System.out.println(<span class="string">"执行线程: "</span> + Thread.currentThread().getName()</div><div class="line">					+ <span class="string">",定时计算 1结果:"</span> + fibc(<span class="number">20</span>));</div><div class="line">		&#125;</div><div class="line">	&#125;), <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS);</div><div class="line"></div><div class="line">	<span class="comment">// 参数2为第一次延迟的时间，参数2为执行周期</span></div><div class="line">	service.scheduleAtFixedRate((<span class="keyword">new</span> Runnable() &#123;</div><div class="line"></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">			System.out.println(<span class="string">"执行线程: "</span> + Thread.currentThread().getName()</div><div class="line">					+ <span class="string">",定时计算2结果:"</span> + fibc(<span class="number">30</span>));</div><div class="line">		&#125;</div><div class="line">	&#125;), <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">打印结果：</div><div class="line"></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">1</span>,定时计算 <span class="number">1</span>结果:<span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">2</span>,定时计算<span class="number">2</span>结果:<span class="number">832040</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">1</span>,定时计算 <span class="number">1</span>结果:<span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">3</span>,定时计算<span class="number">2</span>结果:<span class="number">832040</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">1</span>,定时计算 <span class="number">1</span>结果:<span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">4</span>,定时计算<span class="number">2</span>结果:<span class="number">832040</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">1</span>,定时计算 <span class="number">1</span>结果:<span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">3</span>,定时计算<span class="number">2</span>结果:<span class="number">832040</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">2</span>,定时计算 <span class="number">1</span>结果:<span class="number">6765</span></div><div class="line">执行线程: pool-<span class="number">1</span>-thread-<span class="number">4</span>,定时计算<span class="number">2</span>结果:<span class="number">832040</span></div></pre></td></tr></table></figure>
<p>该线程池有4个线程，我们指定了两个定时任务，因此该线程池中有两个线程来定时执行任务，哪个线程空闲就调度哪个线程来执行任务。</p>
<h1 id="同步集合"><a href="#同步集合" class="headerlink" title="同步集合"></a>同步集合</h1><h2 id="程序中的优化策略-CopyOnWrite"><a href="#程序中的优化策略-CopyOnWrite" class="headerlink" title="程序中的优化策略-CopyOnWrite"></a>程序中的优化策略-CopyOnWrite</h2><p>Copy-On-Write是一种用于程序设计中的优化策略，其基本思路是，从多个线程共享同一个列表，当某个线程想要修改这个列表的元素时，会把列表中的元素复制一份，然后进行修改，修改完成之后再将新的元素设置给这个列表，这是一种延时懒惰策略。这样做的好处是我们可以对CopyOnWrite容器进行并发的读而不需要加锁，因为当前容器不会添加、移除任何元素。所有CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。从JDK1.5起Java并发包提供了两个使用CopyOnWrite机制实现的并发容器，它们是CopyOnWriteArrayList和CopyOnWriteSet。</p>
<p>通过这种写时拷贝的原理可以将读、写分离，使并发场景下对列表的操作效率得到提高，但它的缺点是，在添加、移除元素时占用的内存空间翻了一倍，因此，这是以空间换时间的策略。</p>
<h2 id="提高并发效率-ConcurrentHasMap"><a href="#提高并发效率-ConcurrentHasMap" class="headerlink" title="提高并发效率-ConcurrentHasMap"></a>提高并发效率-ConcurrentHasMap</h2><p>HashTable使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用个图方法来获取元素，所以竞争越激烈效率越低。</p>
<p>HashTable在竞争激烈的并发环境下表现出效率低下的原因是因为所有访问HashTable的线程都必须竞争同一把锁。<br>假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHasMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。有些方法需要跨段，如size()和containsValue()，它们可能需要锁定整个表而不仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。</p>
<h2 id="有效的方法-BlockingQueue"><a href="#有效的方法-BlockingQueue" class="headerlink" title="有效的方法-BlockingQueue"></a>有效的方法-BlockingQueue</h2><p>BlockingQueue的重要方法:</p>
<table>
<thead>
<tr>
<th>函 数 名</th>
<th>作   用</th>
</tr>
</thead>
<tbody>
<tr>
<td>add(e)</td>
<td>把元素e添加到队列中，成功返回true，否则抛出异常</td>
</tr>
<tr>
<td>offer(e)</td>
<td>把元素e添加到队列中，成功返回true，否则返回false</td>
</tr>
<tr>
<td>offer(e,time,unit)</td>
<td>把元素e添加到队列中，成功返回true，否则在等待指定的时间之后继续尝试添加，如果失败则返回false</td>
</tr>
<tr>
<td>put(e)</td>
<td></td>
<td>把元素e添加到队列中，如果队列不能容纳，则调用此方法的线程被阻塞直到队列里面有空间再继续添加</td>
</tr>
<tr>
<td>take()</td>
<td></td>
<td>取出队列中的首个元素，若队列为空，则线程进入等待直到队列中新的元素加入为止</td>
</tr>
<tr>
<td>poll(time,unit)</td>
<td>取出并移除队列中的首个元素，如果在指定的时间内没有获取元素，则返回null</td>
</tr>
<tr>
<td>element()</td>
<td></td>
<td>获取队首元素，如果队列为null，那么抛出NoSuchElementException异常</td>
</tr>
<tr>
<td>peek()</td>
<td></td>
<td>获取队首元素，如果队列为空，那么返回null</td>
</tr>
<tr>
<td>remove()</td>
<td></td>
<td>获取并移除队首元素，如果队列为空，那么抛出NoSuchElementException异常</td>
</tr>
</tbody>
</table>
<p>BlockingQueue常用的实现有：</p>
<ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>LinkedBlockingDequeue</li>
<li>ConcurrentLinkedQueue</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://liuguoquan727.github.io/2015/12/26/Java并发编程之多线程和线程池/" data-id="cj6epj8v3006tqm19i31hons7" class="article-share-link">分享</a>
      
        <a href="http://liuguoquan727.github.io/2015/12/26/Java并发编程之多线程和线程池/#ds-thread" class="article-comment-link">留言</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发编程/">并发编程</a></li></ul>

    </footer>
  </div>
  
    
 <script src="/jquery/jquery.min.js"></script>
  <div id="random_posts">
    <h2>推荐文章</h2>
    <div class="random_posts_ul">
      <script>
          var random_count =4
          var site = {BASE_URI:'/'};
          function load_random_posts(obj) {
              var arr=site.posts;
              if (!obj) return;
              // var count = $(obj).attr('data-count') || 6;
              for (var i, tmp, n = arr.length; n; i = Math.floor(Math.random() * n), tmp = arr[--n], arr[n] = arr[i], arr[i] = tmp);
              arr = arr.slice(0, random_count);
              var html = '<ul>';
            
              for(var j=0;j<arr.length;j++){
                var item=arr[j];
                html += '<li><strong>' + 
                item.date + ':&nbsp;&nbsp;<a href="' + (site.BASE_URI+item.uri) + '">' + 
                (item.title || item.uri) + '</a></strong>';
                if(item.excerpt){
                  html +='<div class="post-excerpt">'+item.excerpt+'</div>';
                }
                html +='</li>';
                
              }
              $(obj).html(html + '</ul>');
          }
          $('.random_posts_ul').each(function () {
              var c = this;
              if (!site.posts || !site.posts.length){
                  $.getJSON(site.BASE_URI + 'js/posts.js',function(json){site.posts = json;load_random_posts(c)});
              } 
               else{
                load_random_posts(c);
              }
          });
      </script>
    </div>
  </div>

    
<nav id="article-nav">
  
    <a href="/2015/12/26/Java并发编程之线程同步/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          Java并发编程之多线程同步
        
      </div>
    </a>
  
  
    <a href="/2015/12/25/Java注解Annotation和依赖注入/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">Java注解Annotation和依赖注入</div>
    </a>
  
</nav>

  
</article>
 
     
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2015/12/26/Java并发编程之多线程和线程池/"
           data-title="Java并发编程之多线程和线程池" data-url="http://liuguoquan727.github.io/2015/12/26/Java并发编程之多线程和线程池/">
      </div>
      
     
       
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
       
      
      
  </div>
 
  

</section>
           
    <aside id="sidebar">
  
    

  
    
    <div class="widget-wrap">
    
      <div class="widget" id="toc-widget-fixed">
      
        <strong class="toc-title">文章目录</strong>
        <div class="toc-widget-list">
              <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#多线程的实现"><span class="toc-number">1.</span> <span class="toc-text">多线程的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#实现方式"><span class="toc-number">1.1.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread和Runnable的关系"><span class="toc-number">1.2.</span> <span class="toc-text">Thread和Runnable的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程的wait、sleep、join和yield"><span class="toc-number">2.</span> <span class="toc-text">线程的wait、sleep、join和yield</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#wait"><span class="toc-number">2.1.</span> <span class="toc-text">wait()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#join"><span class="toc-number">2.2.</span> <span class="toc-text">join()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#yield"><span class="toc-number">2.3.</span> <span class="toc-text">yield()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Callable、Future和FutureTask"><span class="toc-number">2.4.</span> <span class="toc-text">Callable、Future和FutureTask</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Callable"><span class="toc-number">2.4.1.</span> <span class="toc-text">Callable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future"><span class="toc-number">2.4.2.</span> <span class="toc-text">Future</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FutureTask"><span class="toc-number">2.4.3.</span> <span class="toc-text">FutureTask</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程池"><span class="toc-number">3.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#启动指定数量的线程-ThreadPoolExecutor"><span class="toc-number">3.1.</span> <span class="toc-text">启动指定数量的线程-ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#newFixedThreadPool"><span class="toc-number">3.1.1.</span> <span class="toc-text">newFixedThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newCacheThreadPool"><span class="toc-number">3.1.2.</span> <span class="toc-text">newCacheThreadPool</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#执行周期性任务的线程-ScheduledPoolExecutor"><span class="toc-number">3.2.</span> <span class="toc-text">执行周期性任务的线程-ScheduledPoolExecutor</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#同步集合"><span class="toc-number">4.</span> <span class="toc-text">同步集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#程序中的优化策略-CopyOnWrite"><span class="toc-number">4.1.</span> <span class="toc-text">程序中的优化策略-CopyOnWrite</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#提高并发效率-ConcurrentHasMap"><span class="toc-number">4.2.</span> <span class="toc-text">提高并发效率-ConcurrentHasMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#有效的方法-BlockingQueue"><span class="toc-number">4.3.</span> <span class="toc-text">有效的方法-BlockingQueue</span></a></li></ol></li></ol>
          </div>
      </div>
    </div>

  
    

  
    
  
    
  
    

  
    
  
    <!--微信公众号二维码-->


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2017 刘涤生&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;michaelliu0727@gmail.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/categories" class="mobile-nav-link">分类</a>
  
    <a href="/tags" class="mobile-nav-link">标签</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>
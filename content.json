[{"title":"Java8特性②Stream简介","date":"2017-04-27T07:52:53.000Z","path":"2017/04/27/Java8特性②Stream简介/","text":"流是什么流是Java API的新成员，它允许你以声明性方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。可以把它们看成遍历数据集的高级迭代器。此外流还可以透明地并行处理，无需写任何多线程代码了。如下面代码所示： 12345678910public static List&lt;String&gt; getLowCalorisInJava8(List&lt;Dish&gt; dishes) &#123; List&lt;String&gt; lowColorisDish = dishes.stream() //parallelStream() 并行流 .filter((Dish d) -&gt; d.getCalories() &lt; 400) //筛选 .sorted(Comparator.comparing(Dish::getCalories)) //排序 .map(Dish::getName) //提取名称 .collect(Collectors.toList()); //将所有名称存入List中 return lowColorisDish;&#125; Dish类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.company.bean;import java.util.Arrays;import java.util.List;/** * Created by liuguoquan on 2017/4/26. */public class Dish &#123; private String name; private boolean vegetarian; private int calories; private Type type; public enum Type &#123; MEAT, FISH, OTHER &#125; public Dish(String name, boolean vegetarian, int calories, Type type) &#123; this.name = name; this.vegetarian = vegetarian; this.calories = calories; this.type = type; &#125; public String getName() &#123; return name; &#125; public boolean isVegetarian() &#123; return vegetarian; &#125; public int getCalories() &#123; return calories; &#125; public Type getType() &#123; return type; &#125; @Override public String toString() &#123; return name; &#125; public static final List&lt;Dish&gt; menu = Arrays.asList( new Dish(\"pork\", false, 800, Dish.Type.MEAT), new Dish(\"beef\", false, 700, Dish.Type.MEAT), new Dish(\"chicken\", false, 400, Dish.Type.MEAT), new Dish(\"french fries\", true, 530, Dish.Type.OTHER), new Dish(\"rice\", true, 350, Dish.Type.OTHER), new Dish(\"season fruit\", true, 120, Dish.Type.OTHER), new Dish(\"pizza\", true, 550, Dish.Type.OTHER), new Dish(\"prawns\", false, 400, Dish.Type.FISH), new Dish(\"salmon\", false, 450, Dish.Type.FISH));&#125; 流简介流就是从支持数据处理操作的源生成的元素序列。 元素序列：流也提供了一个接口，可以访问特定元素类型的一组有序 值。因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元 素（如 ArrayList 与 LinkedList ）。但流的目的在于表达计算， 比如你前面见到的 filter、sorted和map。集合讲的是数据，流讲的是计算。 源：流会使用一个提供数据的源，如集合、数组或输入/输出资源。 请注意，从有序集 合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。 数据处理操作：流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中 的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执 行，也可并行执行。 流操作的两个重要的特点： 流水线：很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。流水线的操作可以 看作对数据源进行数据库式查询。 内部迭代：与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。 流与集合集合与流之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构， 它包含数据结构中目前所有的值——集合中的每个元素都得先算出来才能添加到集合中。流则是在概念上固定的数据结构（你不能添加或删除元素），其元素则是按需计算的。 流只能遍历一次。遍历完之后，这个流已经被消费掉了。可以从原始数据源那里再获得一个新的流来重新遍历一遍。 123List&lt;String&gt; title = Arrays.asList(\"Java8\", \"In\", \"Action\"); Stream&lt;String&gt; s = title.stream()s.forEach(System.out::println); s.forEach(System.out::println); //java.lang.IllegalStateException:流已被操作 Collection接口需要用户去做迭代（比如用for-each），这称为外部迭代。Streams库使用内部迭代——它帮你把迭代做了，还把得到的流值存在了某个地方，你只要给出一个函数说要干什么就可以了。Streams库的内部迭代可以自动选择一种适 合你硬件的数据表示和并行实现。与此相反，一旦通过写for-each而选择了外部迭代，那你基 本上就要自己管理所有的并行问题了。 流操作java.util.stream.Stream 中的 Stream 接口定义了许多操作。它们可以分为两大类。 中间操作：filter、map、limit等可以连成一条流水线的操作； 终端操作：collect等触发流水线执行并关闭流的操作； 中间操作诸如filter或sorted等中间操作会返回另一个流。这让多个操作可以连接起来形成一个查 询。重要的是，除非流水线上触发一个终端操作，否则中间操作不会执行任何处理，这是因为中间操作一般都可以合并起来，在终端操作时一次性全部处理。尽管filter和map是两个独立的操作，但它们合并到同一次遍历中了（我们把这种技术叫作循环 合并）。 终端操作终端操作会从流的流水线生成结果。其结果是任何不是流的值，比如List、Integer，甚至void。 使用流流的使用一般包括三件事： 一个数据源（如集合）来执行一个查询； 一个中间操作链，形成一条流的流水线； 一个终端操作，执行流水线，并能生成结果； 流的流水线背后的理念类似于构建器模式。在构建器模式中有一个调用链用来设置一套配置（对流来说这就是一个中间操作链），接着是调用built方法（对流来说就是终端操作）。 参考资料《Java 8 实战》","tags":[{"name":"Java8","slug":"Java8","permalink":"http://liuguoquan727.github.io/tags/Java8/"}]},{"title":"Java8特性①Lambda表达式","date":"2017-04-24T08:15:16.000Z","path":"2017/04/24/Java8特性①Lambda表达式/","text":"简介概念Lambda 表达式可以理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。 匿名：它不像普通方法那样有一个明确的名称； 函数：Lambda 表达式是函数是因为它不像方法那样属于某个特定的类，但和方法一样，Lambda 有参数列表、函数主体、返回类型，还可能有可以抛出的异常列表； 传递：Lambda 表达式可以作为参数传递给方法或存储在变量中； 简洁：无需像匿名类那样写很多模板代码； 组成Lambda 表达式由参数列表、箭头和 Lambda 主体组成。 1(Apple o1, Apple o2) -&gt; Integer.valueOf(o1.getWeight()).compareTo(Integer.valueOf(o2.getWeight())) 参数列表：这里采用了 Comparator 中 compareTo 方法的参数； 箭头：箭头把参数列表和 Lambda 主体分开； Lambda 主体：表达式就是 Lambda 的返回值； 表达式Java8中有效的 Lambda 表达式如下： Lambda 表达式 含义 (String s) -&gt; s.length() 表达式具有一个 String 类型的参数并返回一个 int。 Lambda 没有 return 语句，因为已经隐含的 return，可以显示调用 return。 (Apple a) -&gt; a.getWeight() &gt; 150 表达式有一个 Apple 类型的参数并返回一个 boolean 值 (int x, int y) -&gt; { System.out.printn(&quot;Result&quot;};System.out.printn(x + y}; 表达式具有两个 int 类型的参数而没有返回值（void返回），Lambda 表达式可以包含多行语句，但必须要使用大括号包起来。 () -&gt; 42 表达式没有参数，返回一个 int 类型的值。 (Apple o1, Apple o2) -&gt; Integer.valueOf(o1.getWeight()).compareTo(Integer.valueOf(o2.getWeight())) 表达式具有两个 Apple 类型的参数，返回一个 int 比较重要。 下面提供一些 Lambda 表达式的使用案例： 使用案例 Lambda 示例 布尔表达式 (List&lt;String&gt; list) -&gt; list.isEmpty() 创建对象 () -&gt; new Apple(10) 消费对象 (Apple a) -&gt; { System.out.println(a.getWeight) } 从一个对象中选择/抽取 (String s) -&gt; s.lenght() 组合两个值 (int a, int b) -&gt; a * b 比较两个对象 `(Apple o1, Apple o2) -&gt; Integer.valueOf(o1.getWeight()).compareTo(Integer.valueOf(o2.getWeight())) 如何使用 Lambda到底在哪里可以使用 Lambda 呢？你可以在函数式接口上使用 Lambda 表达式。 函数式接口函数式接口就是只定义一个抽象方法的接口，比如 Java API 中的 Predicate、Comparator 和 Runnable 等。 123456789101112public interface Predicate&lt;T&gt; &#123; boolean test(T t);&#125;public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2);&#125;public interface Runnable &#123; void run();&#125; 用函数式接口可以干什么呢？Lambda 表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例（具体说来，是函数式接口一个具体实现 的实例）。你用匿名内部类也可以完成同样的事情，只不过比较笨拙：需要提供一个实现，然后 再直接内联将它实例化。下面的代码是有效的，因为Runnable是一个只定义了一个抽象方法run 的函数式接口： 12345678910111213141516171819//使用LambdaRunnable r1 = () -&gt; System.out.println(\"Hello World 1\");//匿名类Runnable r2 = new Runnable()&#123; public void run()&#123; System.out.println(\"Hello World 2\"); &#125; &#125;;public static void process(Runnable r)&#123; r.run(); &#125; process(r1); //打印 \"Hello World 1\"process(r2); //打印 \"Hello World 2\"//利用直接传递的 Lambda 打印 \"Hello World 3\"process(() -&gt; System.out.println(\"Hello World 3\")); 函数描述符函数式接口的抽象方法的签名基本上就是 Lambda 表达式的签名。我们将这种抽象方法叫作函数描述符。例如，Runnable 接口可以看作一个什么也不接受什么也不返回（void）的函数的签名，因为它只有一个叫作 run 的抽象方法，这个方法什么也不接受，什么也不返回（void）。 Lambda 实践让我们通过一个例子，看看在实践中如何利用Lambda和行为参数化来让代码更为灵活，更为简洁。 资源处理（例如处理文件或数据库）时一个常见的模式就是打开一个资源，做一些处理，然后关闭资源。这个设置和清理阶段总是很类似，并且会围绕着执行处理的那些重要代码。这就是所谓的环绕执行（execute around）模式。 例如，在以下代码中，高亮显示的BufferedReader reader = new BufferedReader(new FileReader(&quot;data.txt&quot;))就是从一个文件中读取一行所需的模板代码（注意你使用了Java 7中的带资源的try语句，它已经简化了代码，因为你不需要显式地关闭资源了）。 123456public static String processFile() throws IOException &#123; try (BufferedReader reader = new BufferedReader(new FileReader(\"data.txt\"))) &#123; return reader.readLine(); &#125;&#125; 第1步：行为参数化现在上述代码是有局限的。你只能读文件的第一行。如果你想要返回头两行，甚至是返回使用最频繁的词， 该怎么办呢？在理想的情况下， 你要重用执行设置和清理的代码， 并告诉 processFile 方法对文件执行不同的操作。是的，你需要把 processFile 的行为参数化，你需要一种方法把行为传递给 processFile ， 以便它可以利用 BufferedReader执行不同的行为。 传递行为正是 Lambda 的优势。那要是想一次读两行，这个新的processFile方法看起来又该是什么样的呢? 你需要一个接收BufferedReader并返回String的Lambda。例如，下面就是从 BufferedReader 中打印两行的写法： 1String result = processFile((BufferedReader r) -&gt; r.readLine() +r.readLine()); 第2步：函数式接口传递行为Lambda 仅可用于上下文是函数式接口的情况。你需要创建一个能匹配 BufferedReader -&gt; String，还可以抛出 IOException 异常的接口。让我们把这一接口称为 BufferedReaderProcessor。 1234@FunctionalInterfacepublic interface BufferedReaderProcessor &#123; String process(BufferedReader reader) throws IOException;&#125; 第3步：执行一个行为任何BufferedReader -&gt; String形式的 Lambda 都可以作为参数来传递，因为它们符合 BufferedReaderProcessor 接口中定义的 process 方法的签名。现在只需要编写一种方法在 processFile主体内执行 Lambda 所代表的代码。 123456public static String processFile(BufferedReaderProcessor processor) throws IOException &#123; try (BufferedReader reader = new BufferedReader(new FileReader(\"data.txt\"))) &#123; return processor.process(reader); //处理 BufferedReader 对象 &#125;&#125; 第4步：传递 Lambda现在就可以通过传递不同的 Lambda 重用 processFile 方法，并以不同的方式处理文件了。 123456//打印一行String result = processFile((BufferedReader r) -&gt; r.readLine());System.out.println(result);//打印2行result = processFile((BufferedReader r) -&gt; r.readLine() +r.readLine()); 使用函数式接口Java 8的库帮你在java.util.function包中引入了几个新的函数式接口。我们接下来介绍 Predicate、Consumer和Function 三种函数式接口。 Predicatejava.util.function.Predicate&lt;T&gt;接口定义了一个名叫 test 的抽象方法，它接受泛型 T对象，并返回一个 boolean。这恰恰和你先前创建的一样，现在就可以直接使用了。在你需要 表示一个涉及类型T的布尔表达式时，就可以使用这个接口。比如，你可以定义一个接受String 对象的Lambda表达式，如下所示。 12345678910111213141516@FunctionalInterface public interface Predicate&lt;T&gt;&#123; boolean test(T t); &#125;public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p) &#123; List&lt;T&gt; results = new ArrayList&lt;&gt;(); for(T s: list)&#123; if(p.test(s))&#123; results.add(s); &#125; &#125; return results;&#125;Predicate&lt;String&gt; nonEmptyStringPredicate = (String s) -&gt; !s.isEmpty();List&lt;String&gt; nonEmpty = filter(listOfStrings, nonEmptyStringPredicate); Consumerjava.util.function.Consumer&lt;T&gt; 定义了一个名叫 accept 的抽象方法，它接受泛型 T 的对象，没有返回（void）。你如果需要访问类型T的对象，并对其执行某些操作，就可以使用 这个接口。比如，你可以用它来创建一个forEach方法，接受一个Integers的列表，并对其中 每个元素执行操作。在下面的代码中，你就可以使用这个forEach方法，并配合Lambda来打印 列表中的所有元素。 123456789101112@FunctionalInterface public interface Consumer&lt;T&gt; &#123; void accept(T t); &#125; public static &lt;T&gt; void forEach(List&lt;T&gt; list, Consumer&lt;T&gt; c)&#123; for(T i: list)&#123; c.accept(i); &#125;&#125;forEach(Arrays.asList(1,2,3,4,5), (Integer i) -&gt; System.out.println(i) ); Functionjava.util.function.Function&lt;T, R&gt;接口定义了一个叫作apply的方法，它接受一个泛型 T 的对象，并返回一个泛型 R 的对象。如果你需要定义一个Lambda，将输入对象的信息映射到输出，就可以使用这个接口（比如提取苹果的重量，或把字符串映射为它的长度）。在下面的代码中，我们向你展示如何利用它来创建一个map方法，以将一个String列表映射到包含每个 String长度的Integer列表。 1234567891011121314151617@FunctionalInterface public interface Function&lt;T, R&gt;&#123; R apply(T t); &#125; public static &lt;T, R&gt; List&lt;R&gt; map(List&lt;T&gt; list, Function&lt;T, R&gt; f) &#123; List&lt;R&gt; result = new ArrayList&lt;&gt;(); for(T s: list) &#123; result.add(f.apply(s)); &#125; return result; &#125; // [7, 2, 6] List&lt;Integer&gt; l = map( Arrays.asList(\"lambdas\",\"in\",\"action\"), (String s) -&gt; s.length() ); 原始类型特化Java类型要么是引用类型（比如Byte、Integer、Object、List），要么是原始类型（比如int、double、byte、char）。但是泛型（比如Consumer中的T）只能绑定到引用类型。这是由泛型内部的实现方式造成的。因此，在Java里有一个将原始类型转换为对应的引用类型的机制。这个机制叫作装箱（boxing）。相反的操作，也就是将引用类型转换为对应的原始类型，叫作拆箱（unboxing）。Java还有一个自动装箱机制来帮助程序员执行这一任务：装箱和拆箱操作是自动完成的。比如一个int被装箱成为 Integer。但这在性能方面是要付出代价的。装箱后的值本质上就是把原始类型包裹起来，并保存在堆里。因此，装箱后的值需要更多的内存，并需要额外的内存搜索来获取被包裹的原始值。 Java 8为我们前面所说的函数式接口带来了一个专门的版本，以便在输入和输出都是原始类型时避免自动装箱的操作。比如，使用 IntPredicate 就避免了对值 1000 进行装箱操作，但要是用 Predicate 就会把参数 1000 装箱到一个 Integer 对象中。一般来说，针对专门的输入参数类型的函数式接口的名称都要加上对应的原始类型前缀，比 如 DoublePredicate、IntConsumer、LongBinaryOperator、IntFunction等。Function 接口还有针对输出参数类型的变种：ToIntFunction、IntToDoubleFunction等。 常用的函数式接口下表中列出 Java 8 中常用的函数式接口： 函数式接口 函数描述符 原始类型特化 Predicate&lt;T&gt; T -&gt; boolean IntPredicate,LongPredicate, DoublePredicate Consumer&lt;T&gt; T -&gt; void IntConsumer,LongConsumer, DoubleConsumer Function&lt;T,R&gt; T -&gt; R IntFunction&lt;R&gt;, IntToDoubleFunction, IntToLongFunction, LongFunction&lt;R&gt;, LongToDoubleFunction, LongToIntFunction, DoubleFunction&lt;R&gt;, ToIntFunction&lt;T&gt;, ToDoubleFunction&lt;T&gt;, ToLongFunction&lt;T&gt; Supplier&lt;T&gt; () -&gt; T BooleanSupplier,IntSupplier, LongSupplier, DoubleSupplier UnaryOperator&lt;T&gt; T -&gt; T IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator BinaryOperator&lt;T&gt; (T,T) -&gt; T IntBinaryOperator, LongBinaryOperator, DoubleBinaryOperator BiPredicate&lt;L,R&gt; (L,R) -&gt; boolean BiConsumer&lt;T,U&gt; (T,U) -&gt; R ObjIntConsumer&lt;T&gt;, ObjLongConsumer&lt;T&gt;, ObjDoubleConsumer&lt;T&gt; BiFunction&lt;T,U,R&gt; (T,U) -&gt; R ToIntBiFunction&lt;T,U&gt;, ToLongBiFunction&lt;T,U&gt;, ToDoubleBiFunction&lt;T,U&gt; 类型检查、推断以及限制类型检查Lambda 的类型是从使用 Lambda 的上下文推断出来的。上下文（比如接受它传递的方法的参数，或接受它的值的局部变量）中 Lambda 表达式需要的类型称为目标类型。下图表示了代码的类型检查过程： 类型检查过程可以分解为如下所示： 首先，找出 filter 方法的声明； 第二，找出目标类型 Predicate&lt;Apple&gt;。 第三，Predicate&lt;Apple&gt;是一个函数式接口，定义了一个叫作 test 的抽象方法。 第四，test 方法描述了一个函数描述符，它可以接受一个 Apple，并返回一个 boolean。 最后，filter 的任何实际参数都必须匹配这个要求。 同样的 Lambda，不同的函数式接口用一个 Lambda 表达式就可以与不同的函数式接口联系起来，只要它们的抽象方法签名能够兼容。比如，前面提到的 Callable 和 PrivilegeAction，这两个接口都代表着什么也不接受且返回一个泛型 T 的函数。如下代码所示两个赋值时有效的： 12Callable&lt;Integer&gt; c = () -&gt; 42;PrivilegeAction&lt;Integer&gt; p = () -&gt; 42; 特殊的void兼容规则如果一个Lambda的主体是一个语句表达式， 它就和一个返回void的函数描述符兼容（当然需要参数列表也兼容）。例如，以下两行都是合法的，尽管 List 的 add 方法返回了一个 boolean，而不是 Consumer 上下文（T -&gt; void）所要求的void： 1234//Predicate 返回一个 booleanPredicate&lt;String&gt; p = s -&gt; list.add(s);//Consumer 返回一个 voidConsumer&lt;String&gt; b = s -&gt; list.add(s); 类型推断Java编译器会从上下文（目标类型）推断出用什么函数式接口来配合 Lambda 表达式，这意味着它也可以推断出适合Lambda 的签名，因为函数描述符可以通过目标类型来得到。这样做的好处在于，编译器可以了解Lambda表达式的参数类型，这样就可以在Lambda语法中省去标注参数类型。 123List&lt;Apple&gt; greenApples = filter(inventory, a -&gt; \"green\".equals(a.getColor())); //参数a没有显示类型Comparator&lt;Apple&gt; c = (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()); //无类型推断Comparator&lt;Apple&gt; c = (a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight()); //类型推断 使用局部变量Lambda表达式也允许使用自由变量（不是参数，而是在外层作用域中定义的变量），就像匿名类一样。 它们被称作捕获Lambda。例如，下面的Lambda捕获了portNumber变量： 12int num = 1337;Runnable r = () -&gt; System.out.println(num); Lambda可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为final， 或事实上是final。换句话说，Lambda表达式只能捕获指派给它们的局部变量一次。（注：捕获 实例变量可以被看作捕获最终局部变量this。） 例如，下面的代码无法编译，因为portNumber 变量被赋值两次： 123int portNumber = 1337; Runnable r = () -&gt; System.out.println(portNumber); portNumber = 31337; //错误：Lambda表达式引用的局 部变量必须是最终的（final） 或事实上最终的 为什么局部变量有这些限制？**第一，实例变量和局部变量背后的实现有一 个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变量。因此，Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了这个限制。第二**，这一限制不鼓励你使用改变外部变量的典型命令式编程模式（这种模式会阻碍很容易做到的并行处理）。 方法引用方法引用让你可以重复使用现有的方法定义，并像Lambda一样传递它们。在一些情况下，比起使用 Lambda 表达式，它们似乎更易读，感觉也更自然。下面就是我们借助更新的Java 8 API，用方法引用写的一个排序的例子： 1lists.sort(comparing(Apple::getWeight); 如何使用方法引用可以被看作仅仅调用特定方法的Lambda的一种快捷写法。它的基本思想是，如果一个Lambda代表的只是“直接调用这个方法”，那最好还是用名称来调用它，而不是去描述如何调用它。事实上，方法引用就是让你根据已有的方法实现来创建 Lambda表达式。但是，显式地指明方法的名称，你的代码的可读性会更好。它是如何工作的呢？ 当你需要使用方法引用时， 目标引用放在分隔符 :: 前， 方法的名称放在后面。 例如， Apple::getWeight就是引用了Apple类中定义的方法getWeight。请记住，不需要括号，因为 你没有实际调用这个方法。方法引用就是Lambda表达式(Apple a) -&gt; a.getWeight()的快捷写法，下表给出了Java 8中方法引用的其他一些例子。 Lambda 等效的引用方法 (Apple a) -&gt; a.getWeight() Apple::getWeight () -&gt; Thread.currentThread().dumpStack() Thread.currentThread()::dumpStack (str,i) -&gt; str.substring(i) String::substring (String i) -&gt; System.out.println(s) System.out::println 分类方法引用主要分为三类： 指向静态方法的引用（例如 Integer 的 parseInt 方法，写作 Integer::parseInt） 指向任意类型实例方法的方法引用（例如 String 的 length 方法，写作 String::length） 指向现有对象的实例方法的引用(假设有一个局部变量 expensiveTransaction 用于存放 Transaction 类型的对象，它支持实例方法 getValue，那么就可以写 expensiveTransaction::getValue) 注意，编译器会进行一种与Lambda表达式类似的类型检查过程，来确定对于给定的函数 式接口，这个方法引用是否有效：方法引用的签名必须和上下文类型匹配。 构造函数引用对于一个现有构造函数，可以利用它的名称和关键字 new 来创建它的一个引用：ClassName::new。它的功能与指向静态方法的引用类似。 例如，假设有一个构造函数没有参数。 它适合 Supplier 的签名() -&gt; Apple。可以这样做： 1234567Supplier&lt;Apple&gt; c1 = Apple::new; //构造函数引用指向默认的 Apple() 构造函数Apple a1 = c1.get(); //产生一个新的对象//等价于：Supplier&lt;Apple&gt; c1 = () -&gt; new Apple(); //利用默认构造函数创建 Apple 的 Lambda 表达式Apple a1 = c1.get(); 如果你的构造函数的签名是Apple(Integer weight)，那么它就适合 Function 接口的签名，于是可以这样写： 1234567Function&lt;Integer, Apple&gt; c2 = Apple::new; //构造函数引用指向 Apple(Integer weight) 构造函数Apple a2 = c2.apple(100);//等价于：Function&lt;Integer, Apple&gt; c2 = (Integer weight) -&gt; new Apple(weight);Apple a2 = c2.apple(100); 如果你有一个具有两个参数的构造函数Apple(String color, Integer weight)，那么它就适合BiFunction接口的签名，于是可以这样写： 1234567BiFunction&lt;Integer, Integer, Apple&gt; c3 = Apple::new; Apple a3 = c23.apple(\"green\", 100);//等价于：BiFunction&lt;Integer, Apple&gt; c3 = (String color, Integer weight) -&gt; new Apple(color, weight);Apple a3 = c3.apple(\"green\", 100); Lambda 和方法引用实战第1步：传递代码Java 8的API已经为你提供了一个 List 可用的 sort 方法，那么如何把排序策略传递给 sort 方法呢？sort方法的签名是这样的： 1void sort(Comparator&lt;? super E&gt; c) 它需要一个 Comparator 对象来比较两个Apple！这就是在Java中传递策略的方式：它们必须包裹在一个对象里。我们说 sort 的行为被参数化了：传递给它的排序策略不同，其行为也会 不同。第一个解决方案可以是这样的： 123456789public class AppleComparator implements Comparator&lt;Apple&gt; &#123; @Override public int compare(Apple o1, Apple o2) &#123; return o1.getWeight().compareTo(o2.getWeight()); &#125;&#125;apples.sort(new AppleComparator()) 第2步：使用匿名类可以使用匿名类来改进方案，而不是实现一个 Comparator 却只实例化一次： 123456apples.sort(new Comparator&lt;Apple&gt;() &#123; @Override public int compare(Apple o1, Apple o2) &#123; return o1.getWeight().compareTo(o2.getWeight()); &#125;&#125;); 第3步：使用 Lambda 表达式接下来使用 Lambda 表达式来改进方案： 1apples.sort((Apple a1,Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight())); Comparator 具有一个叫作 comparing 的静态辅助方法，它可以接受一个 Function 来提取 Comparable 键值，并生成一个 Comparator 对象，它可以像下面这样用（注意你现在传递的Lambda只有一 个参数：Lambda说明了如何从苹果中提取需要比较的键值）： 1apples.sort(Comparator.comparing(((Apple apple) -&gt; apple.getWeight()))); 第4步：使用方法引用方法引用就是替代那些转发参数的 Lambda 表达式的语法糖。可以用方法引 用改进方案如下： 1apples.sort(Comparator.comparing(Apple::getWeight)); 复合 Lambda 表达式比较器复合 逆序：Comparator 接口有一个默认方法 reversed 可以使给定的比较器逆序。 1apples.sort(Comparator.comparing(Apple::getWeight).reversed()); //按重量递减排序 比较器链：Comparator 接口的 thenComparing 方法接受一个函数作为参数（就像 comparing方法一样），如果两个对象用第一个Comparator比较之后是相等的，就提供第二个 Comparator。 1apples.sort(Comparator.comparing(Apple::getWeight).reversed().thenComparing(Apple::getColor)); //按重量递减排序，一样重时，按颜色排序 谓词复合谓词接口包括三个方法：negate、and和or。 12345678 //苹果不是红的Predicate&lt;Apple&gt; notRedApple = redApple.negate();//苹果是红色并且重量大于150Predicate&lt;Apple&gt; redAndHeavyApple = redApple.and(a -&gt; a.getWeight() &gt; 150); //要么是150g以上的红苹果，要么是绿苹果Predicate&lt;Apple&gt; redAndHeavyAppleOrGreen = redApple.and(a -&gt; a.getWeight() &gt; 150) .or(a -&gt; \"green\".equals(a.getColor())); 函数复合Function 接口的 andThen 方法Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after)会返回一个函数，它先计算 andThen 的调用函数，将输入函数的结果应用于 andThen 方法的 after 函数。 1234Function&lt;Integer, Integer&gt; f = x -&gt; x + 1; Function&lt;Integer, Integer&gt; g = x -&gt; x * 2; Function&lt;Integer, Integer&gt; h = f.andThen(g); //g(f(x))int result = h.apply(1); //result = 4 Function 接口的 Compose 方法Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before)先计算 compose 的参数里面给的那个函数，然后再把结果用于 compose 的调用函数。 1234Function&lt;Integer, Integer&gt; f = x -&gt; x + 1; Function&lt;Integer, Integer&gt; g = x -&gt; x * 2; Function&lt;Integer, Integer&gt; h = f.compose(g); //f(g(x))int result = h.apply(1); //result = 3 小结 Lambda表达式可以理解为一种匿名函数：它没有名称，但有参数列表、函数主体、返回 类型，可能还有一个可以抛出的异常的列表。 Lambda表达式让你可以简洁地传递代码。 函数式接口就是仅仅声明了一个抽象方法的接口。 只有在接受函数式接口的地方才可以使用Lambda表达式。 Lambda表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式作为函数式接口的一个实例。 Java 8自带一些常用的函数式接口，放在java.util.function包里，包括Predicate&lt;T&gt;、Function&lt;T,R&gt;、Supplier&lt;T&gt;、Consumer&lt;T&gt;和BinaryOperator&lt;T&gt;。 为了避免装箱操作，对Predicate&lt;T&gt;和Function&lt;T, R&gt;等通用函数式接口的原始类型特化：IntPredicate、IntToLongFunction等。 环绕执行模式（即在方法所必需的代码中间，你需要执行点儿什么操作，比如资源分配 和清理）可以配合 Lambda 提高灵活性和可重用性。 Lambda 表达式所需要代表的类型称为目标类型。 方法引用让你重复使用现有的方法实现并直接传递它们。 Comparator、Predicate 和Function 等函数式接口都有几个可以用来结合 Lambda 表达式的默认方法。","tags":[{"name":"Java8","slug":"Java8","permalink":"http://liuguoquan727.github.io/tags/Java8/"}]},{"title":"数据结构与算法学习合集","date":"2017-03-29T07:06:16.000Z","path":"2017/03/29/数据结构与算法学习合集/","text":"数据结构数据结构之①算法 数据结构之②顺序线性表 数据结构之③单链表 数据结构之④静态链表 数据结构之⑤循环链表 数据结构之⑥双向链表 数据结构之⑦栈的顺序存储 数据结构之⑧栈的链式存储 数据结构之⑨栈与递归 数据结构之⑩顺序队列 数据结构之⑪循环顺序队列 数据结构之⑫链式队列 数据结构之⑬链式队列的优化 数据结构之⑭栈与队列 数据结构之⑮树的定义 数据结构之⑯树的存储结构 数据结构之⑰二叉树 数据结构之⑱二叉树存储 数据结构之⑲遍历二叉树 数据结构⑳线索化二叉树 数据结构㉑哈夫曼树 数据结构㉒图 数据结构㉓图的邻接矩阵结构及遍历 数据结构㉔图的邻接链表结构及遍历 数据结构㉕最小生成树 数据结构㉖最短路径 查找查找①线性表查找 查找②有序表查找 查找③线性索引查找 查找④二叉排序树 查找⑤哈希表 排序排序①基本概念 排序②冒泡排序 排序③选择排序 排序④插入排序 排序⑤希尔排序 排序⑥快速排序 排序⑦归并排序 排序⑧小结","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://liuguoquan727.github.io/tags/数据结构/"}]},{"title":"JNI之⑤C/C++处理Java对象引用","date":"2017-01-04T07:42:25.000Z","path":"2017/01/04/JNI之⑤C:C++处理Java对象引用/","text":"数组引用的处理在Java中,使用new关键字创建对象,创建之后我们就可以随意使用这个对象,我们无需关心这个对象是什么时候被回收的 ,对象的回收已经托管到了JVM的GC,由GC来帮我们回收无引用的对象。将对象引用传递给C/C++时，C/C++层就会持有Java对象，如果不进行妥善处理，对象多了就会出现内存泄漏问题，所以在C/C++层使用Java对象后，需要释放这个引用 。 12345678910111213141516package com.michael.ndk.write;/** * * Created by liuguoquan on 2017/1/3. */public class WriteJava &#123; // 对数组进行排序 public native void c2JavaArraySort(int[] array) ; static &#123; System.loadLibrary(\"native-lib\"); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;android/log.h&gt;//logcat日志#define LOG_TAG \"NDK\"#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)#ifdef __cplusplusextern \"C\" &#123;#endif//比较int compare(const void *a, const void *b);// 对数组进行排序JNIEXPORT void JNICALLJava_com_michael_ndk_write_WriteJava_c2JavaArraySort(JNIEnv *env, jobject instance, jintArray array_) &#123; jint *array = env-&gt;GetIntArrayElements(array_, NULL); // 数组长度 jsize array_size = env-&gt;GetArrayLength(array_); // 快速排序函数 qsort(array, (size_t) array_size, sizeof(jint), compare); // 释放引用,因为数组和对象在java中都是引用,都会在堆内存中开辟一块空间,但我们使用完对象之后 // 需要将引用释放掉,不然会很耗内存,在一定程度上可能会造成内存溢出 。 // JNI_ABORT, Java数组不进行更新，但是释放C/C++数组 // JNI_COMMIT，Java数组进行更新，不释放C/C++数组（函数执行完，数组还是会释放） //// 0，Java数组进行更新，释放C/C++数组 env-&gt;ReleaseIntArrayElements(array_, array, 0);&#125;int compare(const void *a, const void *b) &#123; LOGI(\"a = %d,b = %d\",*((int*)a),*((int*)b)); return *((int*)a) - *((int*)b);&#125;#ifdef __cplusplus&#125;#endif 引用释放只要是Java对象,在C中都需要释放,如String类型引用： 123// String类型引用释放void (JNICALL *ReleaseStringUTFChars) (JNIEnv *env, jstring str, const char* chars); 在C中创建的对象引用也需要进行引用释放. 创建一个数组对象,并将引用传递给了Java层,将引用交给了Java之后,C就需要释放这个引用,不然会一直持有,GC也不会回收这个对象 12345678910111213141516171819202122232425262728293031/*返回int类型的数组*/JNIEXPORT jintArray JNICALL Java_com_zeno_jni_HelloJNI_getIntArray(JNIEnv *env, jobject jobj,jint len) &#123; // 创建一个jint类型的数组 jintArray jArray = (*env)-&gt;NewIntArray(env, len); // 得到数组首个元素指针 jint* arrayElements = (*env)-&gt;GetIntArrayElements(env, jArray, NULL); // 指针运算 int i = 0; for (; i &lt; len; i++) &#123; arrayElements[i] = i; &#125; // 同步 (*env)-&gt;ReleaseIntArrayElements(env, jArray, arrayElements, JNI_COMMIT); return jArray;&#125;java code// 在C中生存数组 ， 返回到Java中private native int[] getIntArray(int len) ;int[] intArray = jni.getIntArray(20); for (int i = 0; i &lt; intArray.length; i++) &#123; System.out.println(\"int array === \"+intArray[i]);&#125; JNI引用分类局部引用局部引用在本地方法调用的时间内有效，本地方法调用结束后会自动释放，每个局部引用都消耗一定的JVM资源，所以我们必须确保本地方法中不能过多的分配局部引用，尽管局部引用能够在方法调用后自动释放，但是过多的局部引用仍然可能导致虚拟机内存溢出。 1234567891011121314151617181920212223JNIEXPORT void JNICALL Java_com_zeno_jni_HelloJNI_localRef(JNIEnv *env, jobject jobj) &#123; // 找到类 jclass dateClass = (*env)-&gt;FindClass(env, \"java/util/Date\"); // 得到构造方法ID jmethodID dateConstructorId = (*env)-&gt;GetMethodID(env, dateClass, \"&lt;init&gt;\", \"()V\"); // 创建Date对象 jobject dateObject = (*env)-&gt;NewObject(env, dateClass, dateConstructorId); // 创建一个局部引用 jobject dateLocalRef = (*env)-&gt;NewLocalRef(env, dateObject); // 省略N行代码 // 不再使用对象,则通知GC回收对象，手动释放对象 (*env)-&gt;DeleteLocalRef(env, dateLocalRef); // 因为dateObject也是局部对象，可以直接回收dateObject对象 //(*env)-&gt;DeleteLocalRef(env, dateObject);&#125; 全局引用12345678910111213141516171819202122232425262728jstring globalStr;/*创建全局引用*/JNIEXPORT void JNICALL Java_com_zeno_jni_HelloJNI_createGlobalRef(JNIEnv *env, jobject jobj) &#123; jstring jStr = (*env)-&gt;NewStringUTF(env, \"I want your love !\"); // 创建一个全局引用 globalStr = (*env)-&gt;NewGlobalRef(env, jStr);&#125;/*使用全局引用*/JNIEXPORT jstring JNICALL Java_com_zeno_jni_HelloJNI_useGlobalRef(JNIEnv *env, jobject jobj) &#123; return globalStr;&#125;/*释放全局引用*/JNIEXPORT void JNICALL Java_com_zeno_jni_HelloJNI_deleteGlobalRef(JNIEnv *env, jobject jobj) &#123; // 释放全局引用 (*env)-&gt;DeleteGlobalRef(env, globalStr);&#125; 弱全局引用节省内存，在内存不足时可以释放所引用的对象可以引用一个不常用的对象，如果为NULL，临时创建 1234//创建jweak NewWeakGlobalRef(JNIEnv *env, jobject obj);//销毁void DeleteWeakGlobalRef(JNIEnv *env, jweak obj); JNI开发系列⑤对象引用的处理","tags":[{"name":"NDK","slug":"NDK","permalink":"http://liuguoquan727.github.io/tags/NDK/"}]},{"title":"JNI之④C/C++创建Java对象","date":"2017-01-04T07:41:57.000Z","path":"2017/01/04/JNI之④C:C++创建Java对象/","text":"步骤 获取Java对象的jclass 获取构造函数的id，方法名使用 NewObject创建Java对象jobject 获取并调用jobject中的方法 示例1234567891011121314151617package com.michael.ndk.write;/** * C访问Java字段和方法 * Created by liuguoquan on 2017/1/3. */public class WriteJava &#123; /** * C/C++ 调用Java对象 */ public native long c2JavaClass(); static &#123; System.loadLibrary(\"native-lib\"); &#125;&#125; 1234567891011121314151617181920extern \"C\"/** * C/C++ 创建Java对象 */JNIEXPORT jlong JNICALLJava_com_michael_ndk_write_WriteJava_c2JavaClass(JNIEnv *env, jobject instance) &#123; //获取Date jclass jclass clz = env-&gt;FindClass(\"java/util/Date\"); //获取构造方法id jmethodID methodId = env-&gt;GetMethodID(clz,\"&lt;init&gt;\",\"()V\"); //创建Date对象 jobject obj = env-&gt;NewObject(clz,methodId); //获取getTime的方法ID jmethodID getTimeId = env-&gt;GetMethodID(clz,\"getTime\",\"()J\"); //调用getTime方法 jlong time = env-&gt;CallLongMethod(obj,getTimeId); LOGI(\"time = %ld\\n\",time); return time;&#125; JNI开发系列④C语言调用构造方法","tags":[{"name":"NDK","slug":"NDK","permalink":"http://liuguoquan727.github.io/tags/NDK/"}]},{"title":"JNI之③C/C++调用Java字段与方法","date":"2017-01-04T07:41:41.000Z","path":"2017/01/04/JNI之③C:C++调用Java字段与方法/","text":"native函数定义1234567891011121314151617181920212223242526272829303132333435363738394041package com.michael.ndk.write;/** * C访问Java字段和方法 * Created by liuguoquan on 2017/1/3. */public class WriteJava &#123; //Java成员变量 public String name = \"liu\"; private int age = 20; public static String sex = \"男\"; public void setName(String name) &#123; this.name = name; &#125; public static String getName() &#123; return \"刘涤生\"; &#125; /** * C/C++修改java String 类型字段本地方法 */ public native void c2JavaStringField(); public native void c2JavaIntField(); public native void c2JavaStringStaticField(); /** * C/C++ 访问Java方法 */ public native void c2JavaMethod(); public native void c2JavaStaticMethod(); /** * 静态native方法访问字段 */ public static native void native2JavaStringField(); static &#123; System.loadLibrary(\"native-lib\"); &#125;&#125; C/C++访问Java字段 获取jclass对象 获取字段ID 设置字段的值 12345678910111213141516171819202122232425262728293031323334353637/*C语言访问java String类型字段*/JNIEXPORT void JNICALLJava_com_michael_ndk_write_WriteJava_c2JavaStringField(JNIEnv *env, jobject instance) &#123; // 1.获取jclass jclass clz = env-&gt;GetObjectClass(instance); // 2.获取字段ID jfieldID fieldId = env-&gt;GetFieldID(clz,\"name\",\"Ljava/lang/String;\"); //3.获取字段的值 jstring str = (jstring)env-&gt;GetObjectField(instance,fieldId); //4.将jstring类型转换成字符指针 const char *cstr = env-&gt;GetStringUTFChars(str,JNI_FALSE); LOGI(\"%s\",cstr); //释放内存 env-&gt;ReleaseStringUTFChars(str,cstr); //拼接字符 const char *newstr = \"lee\"; //5.创建新jstring jstring new_str = env-&gt;NewStringUTF(newstr); //6.将jstring类型的变量值 设置到java字段中 env-&gt;SetObjectField(instance,fieldId,new_str);&#125;/** * C/C++访问修改java int字段 */JNIEXPORT void JNICALLJava_com_michael_ndk_write_WriteJava_c2JavaIntField(JNIEnv *env, jobject instance) &#123; // jclass jclass clz = env-&gt;GetObjectClass(instance); // 字段id jfieldID fieldId = env-&gt;GetFieldID(clz,\"age\",\"I\"); //得到字段值 jint age = env-&gt;GetIntField(instance,fieldId); LOGI(\"age = %d\",age); env-&gt;SetIntField(instance,fieldId,age + 1);&#125; C/C++访问Java方法 获取jclass对象 获取方法ID 调用方法 123456789101112131415/** * C/C++ 访问java方法 */JNIEXPORT void JNICALLJava_com_michael_ndk_write_WriteJava_c2JavaMethod(JNIEnv *env, jobject instance) &#123; // 获取jclass jclass clz = env-&gt;GetObjectClass(instance); // 获取methodId //函数签名 括号内表示参数 括号外表示返回值 jmethodID methodId = env-&gt;GetMethodID(clz,\"setName\",\"(Ljava/lang/String;)V\"); // 调用方法 jstring str = env-&gt;NewStringUTF(\"zhang\"); env-&gt;CallVoidMethod(instance,methodId,str);&#125; C/C++访问Java静态字段 获取jclass对象 获取静态字段ID 设置静态字段的值 1234567891011121314151617/** * c/c++ 访问java静态字段 */JNIEXPORT void JNICALLJava_com_michael_ndk_write_WriteJava_c2JavaStringStaticField(JNIEnv *env, jobject instance) &#123; // 获取jclass对象 jclass clz = env-&gt;GetObjectClass(instance); jfieldID fieldId = env-&gt;GetStaticFieldID(clz,\"sex\",\"Ljava/lang/String;\"); //获取字段的值 jstring jstr = (jstring)env-&gt;GetStaticObjectField(clz,fieldId); const char *sex = env-&gt;GetStringUTFChars(jstr,JNI_FALSE); LOGI(\"sex = %s\\n\",sex); jstring newStr = env-&gt;NewStringUTF(\"女\"); //修改字段 env-&gt;SetStaticObjectField(clz,fieldId,newStr);&#125; C/C++访问Java静态方法 获取jclass对象 获取静态方法ID 调用静态方法 12345678910111213/** * c/c++访问静态方法 */JNIEXPORT void JNICALLJava_com_michael_ndk_write_WriteJava_c2JavaStaticMethod(JNIEnv *env, jobject instance) &#123; jclass clz = env-&gt;GetObjectClass(instance); //获取静态方法id jmethodID methodId = env-&gt;GetStaticMethodID(clz,\"getName\",\"()Ljava/lang/String;\"); jstring obj = (jstring)env-&gt;CallStaticObjectMethod(clz,methodId); const char* value = env-&gt;GetStringUTFChars(obj,JNI_FALSE); LOGI(\"name = %s\\n\",value);&#125; 静态native方法访问Java静态字段 获取静态字段id 设置静态字段值 12345678910111213/** * 静态native方法 第二个参数是jclass而不是jobject类型 */JNIEXPORT void JNICALLJava_com_michael_ndk_write_WriteJava_native2JavaStringField(JNIEnv *env, jclass clz) &#123; jfieldID fieldID = env-&gt;GetStaticFieldID(clz,\"sex\",\"Ljava/lang/String;\"); jstring jstr = (jstring) env-&gt;GetStaticObjectField(clz, fieldID); LOGI(\"sex = %s\\n\",env-&gt;GetStringUTFChars(jstr,JNI_FALSE)); jstring newStr = env-&gt;NewStringUTF(\"女\"); //修改静态常量字段 env-&gt;SetStaticObjectField(clz,fieldID,newStr);&#125; 示例代码Java代码1234567891011121314151617181920212223242526272829303132333435363738394041package com.michael.ndk.write;/** * C访问Java字段和方法 * Created by liuguoquan on 2017/1/3. */public class WriteJava &#123; //Java成员变量 public String name = \"liu\"; private int age = 20; public static String sex = \"男\"; public void setName(String name) &#123; this.name = name; &#125; public static String getName() &#123; return \"刘涤生\"; &#125; /** * C/C++修改java String 类型字段本地方法 */ public native void c2JavaStringField(); public native void c2JavaIntField(); public native void c2JavaStringStaticField(); /** * C/C++ 访问Java方法 */ public native void c2JavaMethod(); public native void c2JavaStaticMethod(); /** * 静态native方法访问字段 */ public static native void native2JavaStringField(); static &#123; System.loadLibrary(\"native-lib\"); &#125;&#125; C/C++代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;android/log.h&gt;//logcat日志#define LOG_TAG \"NDK\"#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)/* Header for class com_example_demo_JniUtil */extern \"C\"/*C语言访问java String类型字段*/JNIEXPORT void JNICALLJava_com_michael_ndk_write_WriteJava_c2JavaStringField(JNIEnv *env, jobject instance) &#123; // 1.获取jclass jclass clz = env-&gt;GetObjectClass(instance); // 2.获取字段ID jfieldID fieldId = env-&gt;GetFieldID(clz,\"name\",\"Ljava/lang/String;\"); //3.获取字段的值 jstring str = (jstring)env-&gt;GetObjectField(instance,fieldId); //4.将jstring类型转换成字符指针 const char *cstr = env-&gt;GetStringUTFChars(str,JNI_FALSE); LOGI(\"%s\",cstr); //拼接字符 const char *newstr = \"lee\"; //5.创建新jstring jstring new_str = env-&gt;NewStringUTF(newstr); //6.将jstring类型的变量值 设置到java字段中 env-&gt;SetObjectField(instance,fieldId,new_str);&#125;extern \"C\"/** * C/C++访问修改java int字段 */JNIEXPORT void JNICALLJava_com_michael_ndk_write_WriteJava_c2JavaIntField(JNIEnv *env, jobject instance) &#123; // jclass jclass clz = env-&gt;GetObjectClass(instance); // 字段id jfieldID fieldId = env-&gt;GetFieldID(clz,\"age\",\"I\"); //得到字段值 jint age = env-&gt;GetIntField(instance,fieldId); LOGI(\"age = %d\",age); env-&gt;SetIntField(instance,fieldId,age + 1);&#125;extern \"C\"/** * C/C++ 访问java方法 */JNIEXPORT void JNICALLJava_com_michael_ndk_write_WriteJava_c2JavaMethod(JNIEnv *env, jobject instance) &#123; // 获取jclass jclass clz = env-&gt;GetObjectClass(instance); // 获取methodId //函数签名 括号内表示参数 括号外表示返回值 jmethodID methodId = env-&gt;GetMethodID(clz,\"setName\",\"(Ljava/lang/String;)V\"); // 调用方法 jstring str = env-&gt;NewStringUTF(\"zhang\"); env-&gt;CallVoidMethod(instance,methodId,str);&#125;extern \"C\"/** * c/c++ 访问java静态字段 */JNIEXPORT void JNICALLJava_com_michael_ndk_write_WriteJava_c2JavaStringStaticField(JNIEnv *env, jobject instance) &#123; // 获取jclass对象 jclass clz = env-&gt;GetObjectClass(instance); jfieldID fieldId = env-&gt;GetStaticFieldID(clz,\"sex\",\"Ljava/lang/String;\"); //获取字段的值 jstring jstr = (jstring)env-&gt;GetStaticObjectField(clz,fieldId); const char *sex = env-&gt;GetStringUTFChars(jstr,JNI_FALSE); LOGI(\"sex = %s\\n\",sex); jstring newStr = env-&gt;NewStringUTF(\"女\"); //修改字段 env-&gt;SetStaticObjectField(clz,fieldId,newStr);&#125;extern \"C\"/** * c/c++访问静态方法 */JNIEXPORT void JNICALLJava_com_michael_ndk_write_WriteJava_c2JavaStaticMethod(JNIEnv *env, jobject instance) &#123; jclass clz = env-&gt;GetObjectClass(instance); //获取静态方法id jmethodID methodId = env-&gt;GetStaticMethodID(clz,\"getName\",\"()Ljava/lang/String;\"); jstring obj = (jstring)env-&gt;CallStaticObjectMethod(clz,methodId); const char* value = env-&gt;GetStringUTFChars(obj,JNI_FALSE); LOGI(\"name = %s\\n\",value);&#125;extern \"C\"/** * 静态native方法 第二个参数书jclass而不是jobject类型 */JNIEXPORT void JNICALLJava_com_michael_ndk_write_WriteJava_native2JavaStringField(JNIEnv *env, jclass clz) &#123; jfieldID fieldID = env-&gt;GetStaticFieldID(clz,\"sex\",\"Ljava/lang/String;\"); jstring jstr = (jstring) env-&gt;GetStaticObjectField(clz, fieldID); LOGI(\"sex = %s\\n\",env-&gt;GetStringUTFChars(jstr,JNI_FALSE)); jstring newStr = env-&gt;NewStringUTF(\"女\"); //修改静态常量字段 env-&gt;SetStaticObjectField(clz,fieldID,newStr);&#125; Q&amp;A为什么要得到jclass呢 ？因为 ，我们要获取字段ID，在JNI中，获取java字段与方法都需要签名。而签名是在类加载的时候完成，所以在获取字段ID的时候需要传入jclass。 为什么传入了字段名称，还需要签名呢 ？因为java支持重载 ， 一个方法名称可以有多个不同实现 ， 根据传入的参数不同 ，所以C语言调用函数为了区分不同的方法， 而对每个方法做了签名 ， 而字段则可用来标识类型。 在.class的文件目录下 ，使用javap -s -p className 就可以列举出 ， 所有的字段与方法签名 JNI开发系列③C语言调用Java字段与方法JNI开发系列②.h头文件分析JNI开发系列①JNI概念及开发流程","tags":[{"name":"NDK","slug":"NDK","permalink":"http://liuguoquan727.github.io/tags/NDK/"}]},{"title":"JNI之②头文件分析","date":"2017-01-02T07:34:23.000Z","path":"2017/01/02/JNI之②头文件分析/","text":"编写Java文件12345678910111213141516171819202122232425262728public class HeaderFile &#123; private native void doVoid(); native int doShort(); native void doArray(Object[] o ); native int doInt(int i); //byte ,short ,int,long,float,double ,boolean,char native int doInt(double d); //byte ,short ,int,long,float,double ,boolean,char native int doInt(Object o); native int doInt(double d1,double d2); static native int doInt(double d1 ,double d2,double d3); static native int doInt(double d1 ,float f,boolean b ,char[] c ); native int doInt(int[] i); native int doInt(int[] i1,double[] i2 ); static native int doInt(int[] i1,double[] i2 ,Object[] o ); public native String doString(String s); public native Object doObject(Object o ); public native Enumeration doInterface(Iterator it); public native Student doStudent(Student s); // native int[] doInt(int[] i); //byte ,short ,int,long,float,double ,boolean,char public native String[] doString(String[] s); public native Object[] doObjects(Object[] o ); public native Enumeration[] doInterface(Iterator[] it); public native Student[] doStudent(Student[] s); public native static Object doAll(int[] i , String[] s , Student[] student ); &#125; 生成头文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181/* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class com_nedu_jni_helloword_HeaderFile */ #ifndef _Included_com_nedu_jni_helloword_HeaderFile #define _Included_com_nedu_jni_helloword_HeaderFile #ifdef __cplusplus extern \"C\" &#123; #endif /* * Class: com_nedu_jni_helloword_HeaderFile * Method: doVoid * Signature: ()V */ JNIEXPORT void JNICALL Java_com_nedu_jni_helloword_HeaderFile_doVoid (JNIEnv *, jobject); /* * Class: com_nedu_jni_helloword_HeaderFile * Method: doShort * Signature: ()I */ JNIEXPORT jint JNICALL Java_com_nedu_jni_helloword_HeaderFile_doShort (JNIEnv *, jobject); /* * Class: com_nedu_jni_helloword_HeaderFile * Method: doArray * Signature: ([Ljava/lang/Object;)V */ JNIEXPORT void JNICALL Java_com_nedu_jni_helloword_HeaderFile_doArray (JNIEnv *, jobject, jobjectArray); /* * Class: com_nedu_jni_helloword_HeaderFile * Method: doInt * Signature: (I)I */ JNIEXPORT jint JNICALL Java_com_nedu_jni_helloword_HeaderFile_doInt__I (JNIEnv *, jobject, jint); /* * Class: com_nedu_jni_helloword_HeaderFile * Method: doInt * Signature: (D)I */ JNIEXPORT jint JNICALL Java_com_nedu_jni_helloword_HeaderFile_doInt__D (JNIEnv *, jobject, jdouble); /* * Class: com_nedu_jni_helloword_HeaderFile * Method: doInt * Signature: (Ljava/lang/Object;)I */ JNIEXPORT jint JNICALL Java_com_nedu_jni_helloword_HeaderFile_doInt__Ljava_lang_Object_2 (JNIEnv *, jobject, jobject); /* * Class: com_nedu_jni_helloword_HeaderFile * Method: doInt * Signature: (DD)I */ JNIEXPORT jint JNICALL Java_com_nedu_jni_helloword_HeaderFile_doInt__DD (JNIEnv *, jobject, jdouble, jdouble); /* * Class: com_nedu_jni_helloword_HeaderFile * Method: doInt * Signature: (DDD)I */ JNIEXPORT jint JNICALL Java_com_nedu_jni_helloword_HeaderFile_doInt__DDD (JNIEnv *, jclass, jdouble, jdouble, jdouble); /* * Class: com_nedu_jni_helloword_HeaderFile * Method: doInt * Signature: (DFZ[C)I */ JNIEXPORT jint JNICALL Java_com_nedu_jni_helloword_HeaderFile_doInt__DFZ_3C (JNIEnv *, jclass, jdouble, jfloat, jboolean, jcharArray); /* * Class: com_nedu_jni_helloword_HeaderFile * Method: doInt * Signature: ([I)I */ JNIEXPORT jint JNICALL Java_com_nedu_jni_helloword_HeaderFile_doInt___3I (JNIEnv *, jobject, jintArray); /* * Class: com_nedu_jni_helloword_HeaderFile * Method: doInt * Signature: ([I[D)I */ JNIEXPORT jint JNICALL Java_com_nedu_jni_helloword_HeaderFile_doInt___3I_3D (JNIEnv *, jobject, jintArray, jdoubleArray); /* * Class: com_nedu_jni_helloword_HeaderFile * Method: doInt * Signature: ([I[D[Ljava/lang/Object;)I */ JNIEXPORT jint JNICALL Java_com_nedu_jni_helloword_HeaderFile_doInt___3I_3D_3Ljava_lang_Object_2 (JNIEnv *, jclass, jintArray, jdoubleArray, jobjectArray); /* * Class: com_nedu_jni_helloword_HeaderFile * Method: doString * Signature: (Ljava/lang/String;)Ljava/lang/String; */ JNIEXPORT jstring JNICALL Java_com_nedu_jni_helloword_HeaderFile_doString__Ljava_lang_String_2 (JNIEnv *, jobject, jstring); /* * Class: com_nedu_jni_helloword_HeaderFile * Method: doObject * Signature: (Ljava/lang/Object;)Ljava/lang/Object; */ JNIEXPORT jobject JNICALL Java_com_nedu_jni_helloword_HeaderFile_doObject (JNIEnv *, jobject, jobject); /* * Class: com_nedu_jni_helloword_HeaderFile * Method: doInterface * Signature: (Ljava/util/Iterator;)Ljava/util/Enumeration; */ JNIEXPORT jobject JNICALL Java_com_nedu_jni_helloword_HeaderFile_doInterface__Ljava_util_Iterator_2 (JNIEnv *, jobject, jobject); /* * Class: com_nedu_jni_helloword_HeaderFile * Method: doStudent * Signature: (Lcom/nedu/jni/helloword/Student;)Lcom/nedu/jni/helloword/Student; */ JNIEXPORT jobject JNICALL Java_com_nedu_jni_helloword_HeaderFile_doStudent__Lcom_nedu_jni_helloword_Student_2 (JNIEnv *, jobject, jobject); /* * Class: com_nedu_jni_helloword_HeaderFile * Method: doString * Signature: ([Ljava/lang/String;)[Ljava/lang/String; */ JNIEXPORT jobjectArray JNICALL Java_com_nedu_jni_helloword_HeaderFile_doString___3Ljava_lang_String_2 (JNIEnv *, jobject, jobjectArray); /* * Class: com_nedu_jni_helloword_HeaderFile * Method: doObjects * Signature: ([Ljava/lang/Object;)[Ljava/lang/Object; */ JNIEXPORT jobjectArray JNICALL Java_com_nedu_jni_helloword_HeaderFile_doObjects (JNIEnv *, jobject, jobjectArray); /* * Class: com_nedu_jni_helloword_HeaderFile * Method: doInterface * Signature: ([Ljava/util/Iterator;)[Ljava/util/Enumeration; */ JNIEXPORT jobjectArray JNICALL Java_com_nedu_jni_helloword_HeaderFile_doInterface___3Ljava_util_Iterator_2 (JNIEnv *, jobject, jobjectArray); /* * Class: com_nedu_jni_helloword_HeaderFile * Method: doStudent * Signature: ([Lcom/nedu/jni/helloword/Student;)[Lcom/nedu/jni/helloword/Student; */ JNIEXPORT jobjectArray JNICALL Java_com_nedu_jni_helloword_HeaderFile_doStudent___3Lcom_nedu_jni_helloword_Student_2 (JNIEnv *, jobject, jobjectArray); /* * Class: com_nedu_jni_helloword_HeaderFile * Method: doAll * Signature: ([I[Ljava/lang/String;[Lcom/nedu/jni/helloword/Student;)Ljava/lang/Object; */ JNIEXPORT jobject JNICALL Java_com_nedu_jni_helloword_HeaderFile_doAll (JNIEnv *, jclass, jintArray, jobjectArray, jobjectArray); #ifdef __cplusplus &#125; #endif #endif 头文件分析方法注释/* * Class: com_nedu_jni_helloword_HeaderFile * Method: doVoid * Signature: ()V */ Class：表示Native方法的类名称Method：表示方法名称Signature：是方法的标识，主要提供我们再JNI操作java对象中使用 Signature一般 是两部分构成，一个方法的参数。另一个是返回类型。方法参数在括号里面，返回类型在后面，例如： ()V 返回值为void，没有参数。 (DFZ[C)I 返回值为int，参数为double、float、char[] (Ljava/lang/String;)Ljava/lang/String; 返回值String，参数为String 基本类型的对应关系如下 方法参数或者返回值为java中的对象时，必须以“L”加上其路径，次路径必须以”/“分开，自定义的对象也使用本规则，不在包中时直接”L”，比如说java.lang.String为“java/lang/String”,com.nedu.jni.helloword.Student为”com/nedu/jni/helloword/Student” 方法)方法参数或者返回值为数组时类型前加上[,例如[I表示int[],[[[D表示 double[][][]，即几维数组就加几个[。例子如下： 方法的声明1JNIEXPORT void JNICALL Java_com_nedu_jni_helloword_HeaderFile_doArray(JNIEnv *,jobject,jobjectArray); 从声明可以看出方法基本由7部分组成： JNIEXPORT是JNI的关键字，表示此函数时要被JNI调用的 void表示方法的返回值类型 JNICALL是JNI的关键字，表示此函数时要被JNI调用的 Java_为JNI中表示此方法来源于java的标志头 com_nedu_jni_helloword_HeaderFile表示方法所在的包名+类名 doArray表示方法名 参数：JNIEnv*是一个接口指针，用于定位函数表中的函数，后面的jobject是 一个指向该类的指针，类似与C语言中的this。这个第二个参数是变化的，当该方法为类的实例方法时该参数为jobject；当该方法为类方法（即静态方法）时该参数为jclass，指向该类的class。 根据不同方法前缀生成的头文件比较如下： static与非static的比较 123456789101112131415/* 非static方法 * Class: com_nedu_jni_helloword_HeaderFile * Method: doInt * Signature: (DD)I */ JNIEXPORT jint JNICALL Java_com_nedu_jni_helloword_HeaderFile_doInt__DD (JNIEnv *, jobject, jdouble, jdouble); /* static方法 * Class: com_nedu_jni_helloword_HeaderFile * Method: doInt * Signature: (DDD)I */ JNIEXPORT jint JNICALL Java_com_nedu_jni_helloword_HeaderFile_doInt__DDD (JNIEnv *, jclass, jdouble, jdouble, jdouble); private、friendly、protected以及public这些方法限制符不会在JNI的头文件中出现。这些访问修饰符只有在其它类使用这些方法时有效！JNI中不关心此修饰符！","tags":[{"name":"NDK","slug":"NDK","permalink":"http://liuguoquan727.github.io/tags/NDK/"}]},{"title":"JNI之①参数类型与Java参数类型对比","date":"2017-01-02T07:32:11.000Z","path":"2017/01/02/JNI之①参数类型与Java参数类型对比/","text":"区别 Java中的返回值void和JNI中的void完全对应（仅仅一个） Java中的基本数据类型（byte ,short ,int,long,float,double ,boolean,char－8种）在JNI中对应的数据类型只要在前面加上j就可以了（jbyte ,jshort ,jint,jlong,jfloat,jdouble ,jboolean,jchar） Java中的对象，包括类库中定义的类、接口以及自定义类接口，都对应于JNI中的jobject Java中的基本数据类型对应的数组对应于JNI中的jArray类型（type就是8中基本数据类型） Java中对象的数组对应于JNI中的jobjectArray类型 基本数据类型映射图 引用数据类型的映射图","tags":[{"name":"NDK","slug":"NDK","permalink":"http://liuguoquan727.github.io/tags/NDK/"}]},{"title":"NDK开发①开发流程","date":"2017-01-01T07:31:57.000Z","path":"2017/01/01/NDK开发①开发流程/","text":"Java编写native方法新建JniUtil类如下: 12345678910111213141516171819202122232425262728293031323334353637383940public class JniUtil &#123; /** * 回调接口 * @author jimi098 * */ public interface IRecFrameListener &#123; public void onRecFrameListener(String result); &#125; private IRecFrameListener mListener; static &#123; System.loadLibrary(\"test\"); &#125; public void setOnRecFrameListener(IRecFrameListener listener) &#123; mListener = listener; &#125; /** * 供jni调用的java方法 * @param result */ public void onRecFrame(int result) &#123; mListener.onRecFrameListener(String.valueOf(result)); &#125; //java本地方法 public native int init(); public native int add(int a,int b); public native String getString(String input);&#125; 生成.h头文件编译JniUtil类，生成JniUtil.class文件，然后在cmd中切换目录至android工程的src文件夹路径，运行javah -jni com.example.demo.JniUtil命令即可生成.h头文件 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;jni.h&gt;#include &lt;android/log.h&gt;//logcat日志#define LOG_TAG \"Test\"#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,LOG_TAG,__VA_ARGS__)#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)/* Header for class com_example_demo_JniUtil */#ifndef _Included_com_example_demo_JniUtil#define _Included_com_example_demo_JniUtil#ifdef __cplusplusextern \"C\" &#123;#endif/* * Class: com_example_demo_JniUtil * Method: init * Signature: ()I */JNIEXPORT jint JNICALL Java_com_example_demo_JniUtil_init (JNIEnv *, jobject);/* * Class: com_example_demo_JniUtil * Method: add * Signature: (II)I */JNIEXPORT jint JNICALL Java_com_example_demo_JniUtil_add (JNIEnv *, jobject, jint, jint);/* * Class: com_example_demo_JniUtil * Method: getString * Signature: (Ljava/lang/String;)Ljava/lang/String; */JNIEXPORT jstring JNICALL Java_com_example_demo_JniUtil_getString (JNIEnv *, jobject, jstring);#ifdef __cplusplus&#125;#endif#endif 实现jni新建jni文件夹，实现本地java方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;jniutil.h&gt;jobject mObject;JNIEXPORT jint JNICALL Java_com_example_demo_JniUtil_init(JNIEnv *env, jobject obj) &#123; //获取全局对象 mObject = (*env)-&gt;NewGlobalRef(env, obj); jmethodID methodID; jclass mClass; //查找指定名称类 mClass = (*env)-&gt;GetObjectClass(env, mObject);; //获取方法ID methodID = (*env)-&gt;GetMethodID(env,mClass,\"onRecFrame\",\"(I)V\"); //调用上层java方法 (*env)-&gt;CallVoidMethod(env,obj,methodID,89); return 5;&#125;/* * Class: com_example_demo_JniUtil * Method: add * Signature: (II)I */JNIEXPORT jint JNICALL Java_com_example_demo_JniUtil_add(JNIEnv *env, jobject obj, jint x, jint y) &#123; return x + y;&#125;/* * Class: com_example_demo_JniUtil * Method: getString * Signature: (Ljava/lang/String;)Ljava/lang/String; */JNIEXPORT jstring JNICALL Java_com_example_demo_JniUtil_getString(JNIEnv *env, jobject obj, jstring result) &#123; return result;&#125; 编写mk文件Android.mk指定编译规则 123456789LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := testLOCAL_SRC_FILES := test.cLOCAL_LDLIBS := -lloginclude $(BUILD_SHARED_LIBRARY) Application.mk指定编译平台 1234APP_ABI := armeabi armeabi-v7aAPP_PLATFORM := android-22APP_STL:=gnustl_staticAPP_CPPFLAGS:=-frtti -fexceptions 配置NDK执行编译右击工程–》Properties–》Builders–》New–》选择Program–》Main–》Location：选择ndk-build.cmd命令路径–》Working Directory：选择工程路径–》Refresh–》Build Options，配置完成后即可自动编译，不需要安装cygwin linux模拟环境 应用jni12345678910111213141516171819202122232425262728293031323334353637public class MainActivity extends Activity implements OnClickListener, IRecFrameListener &#123; private Button mButton; private JniUtil mJniUtil; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mButton = (Button) findViewById(R.id.btn_click); mButton.setOnClickListener(this); mJniUtil = new JniUtil(); mJniUtil.setOnRecFrameListener(this); &#125; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub System.out.println(\"init: \" + mJniUtil.init()); System.out.println(\"sum: \"+ mJniUtil.add(1, 2)); System.out.println(\"getString: \" + mJniUtil.getString(\"wert\")); &#125; /** * 回调，由jni方法返回数据 */ @Override public void onRecFrameListener(String result) &#123; // TODO Auto-generated method stub System.out.println(result); &#125;&#125; Android Studio 2.2 开发NDKNDK开发基础①使用Android Studio编写NDK Gradle配置NDK1234567891011121314151617181920212223242526272829303132333435android &#123; compileSdkVersion 25 buildToolsVersion \"25.0.1\" defaultConfig &#123; applicationId \"com.michael.lplayer\" minSdkVersion 15 targetSdkVersion 22 versionCode 1 versionName \"1.0\" testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\" externalNativeBuild &#123; cmake &#123; cppFlags \"\" arguments '-DANDROID_TOOLCHAIN=clang' abiFilters \"armeabi-v7a\" &#125; &#125; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; externalNativeBuild &#123; cmake &#123; path \"CMakeLists.txt\" &#125; &#125; //加载外部so库 sourceSets.main &#123; jniLibs.srcDirs = ['libs'] jni.srcDirs = [] &#125;&#125; CMakeLists.txt 配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# Sets the minimum version of CMake required to build the native# library. You should either keep the default value or only pass a# value of 3.4.0 or lower.cmake_minimum_required(VERSION 3.4.1)find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )set(distribution_DIR $&#123;CMAKE_SOURCE_DIR&#125;/../../../../libs)include_directories(libs/include)add_library( avutil-55 SHARED IMPORTED )set_target_properties( avutil-55 PROPERTIES IMPORTED_LOCATION ../../../../libs/armeabi-v7a/libavutil-55.so )add_library( swresample-2 SHARED IMPORTED )set_target_properties( swresample-2 PROPERTIES IMPORTED_LOCATION ../../../../libs/armeabi-v7a/libswresample-2.so )add_library( avcodec-57 SHARED IMPORTED )set_target_properties( avcodec-57 PROPERTIES IMPORTED_LOCATION ../../../../libs/armeabi-v7a/libavcodec-57.so )add_library( avfilter-6 SHARED IMPORTED)set_target_properties( avfilter-6 PROPERTIES IMPORTED_LOCATION ../../../../libs/armeabi-v7a/libavfilter-6.so )add_library( swscale-4 SHARED IMPORTED)set_target_properties( swscale-4 PROPERTIES IMPORTED_LOCATION ../../../../libs/armeabi-v7a/libswscale-4.so )add_library( avformat-57 SHARED IMPORTED)set_target_properties( avformat-57 PROPERTIES IMPORTED_LOCATION ../../../../libs/armeabi-v7a/libavformat-57.so )#set(CMAKE_CXX_FLAGS \"$&#123;CMAKE_CXX_FLAGS&#125; -std=gnu++11\")add_library( ffmpeg SHARED src/main/cpp/ffmpeg_decode.c )#target_include_directories(ffmpeg PRIVATE libs/include)target_link_libraries( ffmpeg avutil-55 swresample-2 avcodec-57 avfilter-6 swscale-4 avformat-57 $&#123;log-lib&#125; )","tags":[{"name":"NDK","slug":"NDK","permalink":"http://liuguoquan727.github.io/tags/NDK/"}]},{"title":"iOS开发之08PopoverView","date":"2016-11-25T10:46:33.000Z","path":"2016/11/25/iOS开发之08PopoverView/","text":"PopoverView是一种临时的视图，以漂浮的形式出现在视图表面，称为浮动层。 APIPopoverPresentationController barButtonItem：指定一个UIBarButtonItem类型按钮作为锚点 sourceView：指定一个普视图作为锚点 sourceRect:指定一个矩形区域作为锚点 permittedArrowDirection：指定锚点箭头的方向（up,down.lwft,right,any,unkown) UIPopoverPresentationControllerDelegate popoverPresentationControllerShouldDismissPopover:返回true可以消失，false不可消失 popoverPresentationControllerDidDismissPopover：销毁时调用 func prepareForPopoverPresentation(_ popoverPresentationController: UIPopoverPresentationController)：显示时调用 步骤 创建iOS工程 拖入一个Button到界面中心，并设置点击事件，点击按钮室弹出popover view 代码实现 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//// ViewController.swift// PopoverViewSample//// Created by Michael on 2016/11/17.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UIViewController,UIPopoverPresentationControllerDelegate &#123; @IBOutlet weak var mBtn: UIButton! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; @IBAction func show(_ sender: Any) &#123; //作为popover View let controller = SelectViewController(); //设置为popover视图 controller.modalPresentationStyle = .popover //视图动画 controller.modalTransitionStyle = .crossDissolve controller.preferredContentSize = CGSize(width: 300, height: 100) let popController = controller.popoverPresentationController popController?.sourceView = mBtn popController?.sourceRect = mBtn.bounds popController?.delegate = self self.present(controller, animated: true, completion: nil) &#125; func adaptivePresentationStyle(for controller: UIPresentationController) -&gt; UIModalPresentationStyle &#123; //popover样式 return .none &#125; func prepareForPopoverPresentation(_ popoverPresentationController: UIPopoverPresentationController) &#123; NSLog(\"show\") &#125; func popoverPresentationControllerDidDismissPopover(_ popoverPresentationController: UIPopoverPresentationController) &#123; NSLog(\"hide\") &#125; func popoverPresentationControllerShouldDismissPopover(_ popoverPresentationController: UIPopoverPresentationController) -&gt; Bool &#123; return true &#125;&#125; 12345678910111213141516171819202122232425262728293031323334//// SelectViewController.swift// PopoverViewSample//// Created by Michael on 2016/11/17.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass SelectViewController: UIViewController &#123; var label1:UILabel! var label2:UILabel! override func viewDidLoad() &#123; super.viewDidLoad() self.view.frame = CGRect(x: 0, y: 0, width: 200, height: 500)// label1 = UILabel(frame: CGRect(x: 0, y: 0, width: self.view.frame.width, height: 200))// label2 = UILabel(frame: CGRect(x: 0, y: 300, width: self.view.frame.width, height: 200))// self.view.addSubview(label1)// self.view.addSubview(label2) self.view.backgroundColor = UIColor.blue &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125;&#125; 效果","tags":[{"name":"ios","slug":"ios","permalink":"http://liuguoquan727.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"http://liuguoquan727.github.io/tags/swift/"},{"name":"xcode","slug":"xcode","permalink":"http://liuguoquan727.github.io/tags/xcode/"}]},{"title":"iOS开发之07视图控制器与导航模式","date":"2016-11-25T10:46:06.000Z","path":"2016/11/25/iOS开发之07视图控制器与导航模式/","text":"模态视图在导航过程中，有时候需要放弃主要任务而做其他次要任务，然后在返回到次要任务，这个次要任务就是在模态视图中完成的，如注册中主要任务是登录后进入主界面，如果用户没有注册，就要先去注册，注册是次要任务，当用户注册完成后，它会关闭注册视图，回到登录界面继续进行主要任务。 默认情况下，模态视图是从屏幕下方滑出来的。 负责控制器模态视图的控制器称为模态视图控制器，它并不是一个专门的类，它可以是前面提到的控制器的子类。负责主要任务视图的控制器称为主视图控制器。在UICOntrollerView中，主要有如下两个方法： -present():呈现视图 -dismiss()：关闭视图 在呈现模态视图时有两种方式：一是通过使用UIViewController的present方法实现；二是通过故事板的“过渡”（Segue）实现。 下面我们通过登录案例来介绍模态视图 步骤 创建一个iOS工程，将当前控制器嵌入到一个导航控制器中，具体步骤是：在故事板中选择View Controller，然后点击Xcode菜单栏Editor-Embed In-Navigation Controller菜单就会自动创建一个导航视图 点击导航栏，将导航栏的标题设为登录，然后从对象库中拖入Lable、TextField、Button等控件 接下来设计第二个界面，先从对象库中拖入一个View Controller到设计界面中，然后参考步骤1将该视图控制器嵌入到导航控制器中，修改该导航栏标题为注册，然后从对象库中拖入两个Bar Button Item到导航栏两边，分别设置identifier属性为Cancel和Save 接下来需要在登录场景和注册场景创建一个过渡，按住control键，从登录界面的注册按钮拖鼠标到注册导航控制器，然后松开鼠标，在弹出的视图框中选择Present Modally菜单；它是模态类型的过渡 最后，添加注册控制器类，创建一个类RegisterViewController集成UIViewController，然后回到故事板中将注册视图的Class选择为RegisterViewController 代码实现ViewController.swift 123456789101112131415161718192021222324252627282930313233//// ViewController.swift// ModalViewSample//// Created by Michael on 2016/11/9.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; @IBOutlet weak var mUserName: UITextField! override func viewDidLoad() &#123; super.viewDidLoad() // 注册消息 NotificationCenter.default.addObserver(self, selector: #selector(self.register(_ :)), name: NSNotification.Name(rawValue: \"RegisterCompletion\"), object: nil) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. NotificationCenter.default.removeObserver(self, name: NSNotification.Name.init(rawValue: \"RegisterCompletion\"), object: nil) &#125; func register(_ notification : Notification) &#123; let text = notification.userInfo?[\"username\"] as? String mUserName.text = text! NSLog(\"%@\",text!) &#125;&#125; RegisterViewController.swift 123456789101112131415161718192021222324252627282930313233343536373839//// RegisterViewController.swift// ModalViewSample//// Created by Michael on 2016/11/9.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass RegisterViewController: UIViewController &#123; @IBOutlet weak var mName: UITextField! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; @IBAction func save(_ sender: Any) &#123; let userInfo = [\"username\":self.mName.text!] //发送消息 NotificationCenter.default.post(name: NSNotification.Name.init(rawValue: \"RegisterCompletion\"), object: nil, userInfo: userInfo) self.dismiss(animated: true, completion: &#123; &#125;) &#125; @IBOutlet weak var save: UIBarButtonItem! @IBAction func cancel(_ sender: Any) &#123; self.dismiss(animated: true, completion: &#123; &#125;) &#125;&#125; 效果图 分屏导航基于分屏导航是平铺导航的主要实现方式，涉及的主要控件有分屏控件UIPageControll和屏幕滚动视图UIScrollView,一般不超过10屏 步骤 创建iOS工程，从对象库中拖入UIPageControll和UIScrollView到故事板中，并将其放到合适的位置，UIPageControll放在靠底部，UIScrollView全屏显示，将视图的背景设为黑色 选中UIScrollView的属性检查器，设置不显示Scroll View的Indicator，同时选择滚动Scrolling Enable和分屏Paging Enable。分屏属性是Scroll View每次滑动时翻一屏 选择Page Controll的属性检查器，设置Pages中的of pages总屏数为3，Current当前位置为0，并修改其宽度为300，它的高度是不能修改的。 最后为这两个控件定义输出口并连接注册到ViewController类中，为Page Controll控件定义响应屏幕变化事件的方法。-changPage 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//// ViewController.swift// PageControlNavigation//// Created by Michael on 2016/11/10.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UIViewController,UIScrollViewDelegate &#123; @IBOutlet weak var mScrollView: UIScrollView! @IBOutlet weak var mPageControl: UIPageControl! var mImage1: UIImageView! var mImage2: UIImageView! var mImage3: UIImageView! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. self.mScrollView.delegate = self self.mScrollView.contentSize = CGSize(width: self.view.frame.size.width * 3, height: self.mScrollView.frame.size.height) self.mScrollView.frame = self.view.frame self.mImage1 = UIImageView(frame: CGRect(x: 0, y: 0, width: self.view.frame.size.width, height: 480)) self.mImage1.image = UIImage(named: \"达芬奇-蒙娜丽莎\") self.mScrollView.addSubview(mImage1) self.mImage2 = UIImageView(frame: CGRect(x: self.view.frame.size.width, y: 0, width: self.view.frame.size.width, height: 480)) self.mImage2.image = UIImage(named: \"罗丹-思想者\") self.mScrollView.addSubview(mImage2) self.mImage3 = UIImageView(frame: CGRect(x: self.view.frame.size.width * 2, y: 0, width: self.view.frame.size.width, height: 480)) self.mImage3.image = UIImage(named: \"保罗克利-肖像\") self.mScrollView.addSubview(mImage3) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; //UIPageControll事件处理 @IBAction func changePage(_ sender: Any) &#123; UIView.animate(withDuration: 0.3, animations: &#123; let whichPage = self.mPageControl.currentPage //设置内容视图坐标原点与屏幕滚动视图坐原点的偏移量 self.mScrollView.contentOffset = CGPoint(x: 320 * whichPage, y: 0) &#125;) &#125; //屏幕滚动视图事件处理方法å func scrollViewDidScroll(_ scrollView: UIScrollView) &#123; let offset = scrollView.contentOffset self.mPageControl.currentPage = Int(offset.x) / 320 &#125; &#125; 效果图 分页控制器在iOS5以后，我们可以使用分页控制器UIPageViewController构建类似于电子书效果的应用。 分页控制器需要放置在一个父视图控制器中，在分页控制器下面还要有子视图控制器，每个子视图控制器对应一个页面。 UIPageViewController没有对应的视图，我们需要使用代码来实现；需要在UIPageViewController所在的控制器实现UIPageViewControllerDelegate和UIPageViewControllerDataSource协议，UIPageViewControllerDataSource数据源协议必须要实现的方法有以下两个： func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) UIPageViewControllerDelegate委托协议中一般实现的方法是： func pageViewController(_ pageViewController: UIPageViewController, spineLocationFor orientation: UIInterfaceOrientation) func pageViewController(_ pageViewController: UIPageViewController, didFinishAnimating finished: Bool, previousViewControllers: [UIViewController], transitionCompleted completed: Bool) 步骤 创建一个iOS工程 代码实现UIPageViewController 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120//// ViewController.swift// PageNavigation//// Created by Michael on 2016/11/10.// Copyright © 2016年 Michael. All rights reserved.//import UIKitenum DirectionFroward : Int &#123; case Before = 1 //向前 case After = 2 //向后 &#125;class ViewController: UIViewController,UIPageViewControllerDelegate,UIPageViewControllerDataSource &#123; //当前Page的索引 var mPageIndex = 0 var direct = DirectionFroward.After var mPageViewController : UIPageViewController! var mViewControllers : [UIViewController]! override func viewDidLoad() &#123; super.viewDidLoad() let pageViewController1 = UIViewController() let pageViewController2 = UIViewController() let pageViewController3 = UIViewController() self.mViewControllers = [pageViewController1,pageViewController2,pageViewController3] let mImage1 = UIImageView(frame: self.view.frame) mImage1.image = UIImage(named: \"达芬奇-蒙娜丽莎\") pageViewController1.view.addSubview(mImage1) let mImage2 = UIImageView(frame: self.view.frame) mImage2.image = UIImage(named: \"罗丹-思想者\") pageViewController2.view.addSubview(mImage2) let mImage3 = UIImageView(frame: self.view.frame) mImage3.image = UIImage(named: \"保罗克利-肖像\") pageViewController3.view.addSubview(mImage3) //transitionStyle: pageCurl表示翻书效果样式 scroll 滑屏效果样式 //navigationOrientation 水平和垂直方向 self.mPageViewController = UIPageViewController(transitionStyle: .pageCurl, navigationOrientation: .horizontal, options: nil) self.mPageViewController.delegate = self self.mPageViewController.dataSource = self //设置首页 //direction forward向前 reverse向后 self.mPageViewController.setViewControllers([pageViewController1], direction: .forward, animated: true, completion: nil) self.view.addSubview(self.mPageViewController.view) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; //DataSource协议 func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) -&gt; UIViewController? &#123; NSLog(\"向前翻\") mPageIndex -= 1 if mPageIndex &lt; 0 &#123; mPageIndex = 0; return nil &#125; direct = .Before return self.mViewControllers[mPageIndex] &#125; func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) -&gt; UIViewController? &#123; NSLog(\"向后翻\") mPageIndex += 1 if mPageIndex &gt; 2 &#123; mPageIndex = 2 return nil &#125; direct = .After return self.mViewControllers[mPageIndex] &#125; //Delegate协议 func pageViewController(_ pageViewController: UIPageViewController, spineLocationFor orientation: UIInterfaceOrientation) -&gt; UIPageViewControllerSpineLocation &#123; self.mPageViewController.isDoubleSided = false //min和max 首页显示一个视图 mid首页显示两个视图 return .min &#125; func pageViewController(_ pageViewController: UIPageViewController, didFinishAnimating finished: Bool, previousViewControllers: [UIViewController], transitionCompleted completed: Bool) &#123; //翻页未成功 if completed == false &#123; if direct == .After &#123; mPageIndex -= 1 &#125; if direct == .Before &#123; mPageIndex += 1 &#125; &#125; &#125;&#125; 效果图 标签导航使用标签栏时有一定的指导原则：标签栏位于屏幕下方，占有49个像素屏幕空间，有时可以隐藏起来；标签栏中的标签不能超过5个，如果超过5个则最后一个显示为更多，点击更多标签会出现更多的列表。 步骤在开发具体应用的时候，标签导航的各个标签分别代表一个功能模块，各功能模块之间相对独立。 创建一个iOS工程模板Tabbed Application应用，默认创建两个标签 从对象库中拖入一个ViewController到故事板中 添加ViewController和Tab Controller Scene的连线，具体操作是：按住control键从Tab Controller Scene拖曳鼠标到ViewController，释放鼠标，从弹出窗口中选择view controllers项即可 设置三个场景的标题 分别为三个场景创建三个视图类 代码实现1234567891011121314151617181920212223242526272829303132333435//// HeiViewController.swift// TabNavigation//// Created by Michael on 2016/11/15.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass HeiViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; /* // MARK: - Navigation // In a storyboard-based application, you will often want to do a little preparation before navigation override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; // Get the new view controller using segue.destinationViewController. // Pass the selected object to the new view controller. &#125; */&#125; 1234567891011121314151617181920212223242526272829303132333435//// JiViewController.swift// TabNavigation//// Created by Michael on 2016/11/15.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass JiViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; /* // MARK: - Navigation // In a storyboard-based application, you will often want to do a little preparation before navigation override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; // Get the new view controller using segue.destinationViewController. // Pass the selected object to the new view controller. &#125; */&#125; 1234567891011121314151617181920212223242526272829303132333435//// LiaoViewController.swift// TabNavigation//// Created by Michael on 2016/11/15.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass LiaoViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view. &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; /* // MARK: - Navigation // In a storyboard-based application, you will often want to do a little preparation before navigation override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; // Get the new view controller using segue.destinationViewController. // Pass the selected object to the new view controller. &#125; */&#125; 效果图 树形导航树形导航模式是将导航控制器UINavigationController与表视图结使用，主要用于构建从属关系的导航。下面我们创建一个三级视图的树形导航示例。 步骤 创建iOS工程，使用UINavigationController创建以及表视图 创建二级表视图CitiesViewController 从对象库中拖入一个Table View Controller到对象库中作为二级视图控制器 按住control键，从上一个Root View Controller的单元格中拖动鼠标到当前添加的Table View Controller中，释放鼠标，在弹出窗口中选择Show选项 选择连接线中的过渡Segue，打开其属性检查器，然后在Indentifier属性中输入ShowCities 创建三级视图DetailViewController 从对象库中拖入一个View Controller到对象库中作为三级视图控制器 按住control键，从上一个Table View Controller的单元格中拖动鼠标到当前添加的View Controller中，释放鼠标，在弹出窗口中选择Show选项 选择连接线中的过渡Segue，打开其属性检查器，然后在Indentifier属性中输入ShowDetail 设置各级视图的Table View Cell的属性 代码实现一级视图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//// ViewController.swift// TreeNavigation//// Created by Michael on 2016/11/15.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UITableViewController &#123; var dictData:NSDictionary! var listData:NSArray! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. self.tableView.delegate = self self.tableView.dataSource = self let path = Bundle.main.path(forResource: \"provinces_cities\", ofType: \"plist\") self.dictData = NSDictionary(contentsOfFile: path!) self.listData = self.dictData.allKeys as NSArray self.title = \"省份信息\" &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return self.listData.count &#125; override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell:UITableViewCell! = tableView.dequeueReusableCell(withIdentifier: \"Custom\", for: indexPath) let row = indexPath.row cell.textLabel?.text = self.listData[row] as? String return cell &#125; //场景过渡之前的处理 点击表视图的单元格触发 override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; if segue.identifier == \"ShowCities\" &#123; let indexPath = self.tableView.indexPathForSelectedRow! as IndexPath let selectedIndex = indexPath.row //获取要跳转到的视图控制器对象 let controller = segue.destination as! CitiesTableViewController let selectName = self.listData[selectedIndex] as! String controller.listData = self.dictData[selectName] as! NSArray controller.title = selectName &#125; &#125;&#125; 二级视图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//// CitiesTableViewController.swift// TreeNavigation//// Created by Michael on 2016/11/15.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass CitiesTableViewController: UITableViewController &#123; var listData:NSArray! override func viewDidLoad() &#123; super.viewDidLoad() &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; // #warning Incomplete implementation, return the number of rows return self.listData.count &#125; override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell:UITableViewCell! = tableView.dequeueReusableCell(withIdentifier: \"CityCell\", for: indexPath) let row = indexPath.row let dict = self.listData[row] as! NSDictionary cell.textLabel?.text = dict[\"name\"] as? String return cell &#125; //场景过渡之前的与处理 override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; if segue.identifier == \"ShowDetail\" &#123; let indexPath = self.tableView.indexPathForSelectedRow! as IndexPath let selectIndex = indexPath.row let dict = self.listData[selectIndex] as! NSDictionary //获取要跳转到的视图控制器对象 let controller = segue.destination as! DetailViewController controller.url = dict[\"url\"] as! String controller.title = dict[\"name\"] as? String &#125; &#125;&#125; 三级视图 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//// DetailViewController.swift// TreeNavigation//// Created by Michael on 2016/11/15.// Copyright © 2016年 Michael. All rights reserved.//import UIKitimport WebKitclass DetailViewController: UIViewController,WKNavigationDelegate &#123; var url:String! var webView: WKWebView! override func viewDidLoad() &#123; super.viewDidLoad() NSLog(url) self.webView = WKWebView(frame: self.view.frame) view.addSubview(webView) webView.navigationDelegate = self //let nUrl = URL(string: \"https://baike.baidu.com/view/2172.htm\") let mUrl = URL(string: url) let request = URLRequest(url: mUrl!) webView.load(request) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) &#123; NSLog(\"开始加载\") &#125; func webView(_ webView: WKWebView, didCommit navigation: WKNavigation!) &#123; NSLog(\"内容开始返回时回调\") &#125; func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) &#123; NSLog(\"加载完成\") &#125; func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation!, withError error: Error) &#123; NSLog(\"加载失败\") &#125;&#125; 效果图","tags":[{"name":"ios","slug":"ios","permalink":"http://liuguoquan727.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"http://liuguoquan727.github.io/tags/swift/"},{"name":"xcode","slug":"xcode","permalink":"http://liuguoquan727.github.io/tags/xcode/"}]},{"title":"iOS开发之06StackView","date":"2016-11-25T10:45:56.000Z","path":"2016/11/25/iOS开发之06StackView/","text":"在iOS开发中可以利用StackView嵌套实现比较复杂的界面，比如我们实现三个按钮呈现三角形摆放，可以这样实现，整个界面是一个垂直StackView，它的子视图是Button1和水平StackView，水平StackView的子 视图是Button2和Button3。 步骤 创建一个iOS工程，从对象库中拖入一个Vertical Stack View到设计界面中，然后再从对象库中拖入一个Horizontal Stack View到前一个垂直StackView中。 属性检查器： Axis：设置StackView是垂直还是水平的 Spacing：设置子视图之间的距离 Alignment：设置子视图之间的对齐方式 Distribution：设置子视图的尺寸与位置 拖入Button1到Vertical Stack View中，注意要放在Horizontal Stack View的上方，当出现一条横线时松开鼠标；类似的方法拖入Button2和Button3到Horizontal Stack View中 效果","tags":[{"name":"ios","slug":"ios","permalink":"http://liuguoquan727.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"http://liuguoquan727.github.io/tags/swift/"},{"name":"xcode","slug":"xcode","permalink":"http://liuguoquan727.github.io/tags/xcode/"}]},{"title":"iOS开发之05常见表视图","date":"2016-11-25T10:45:39.000Z","path":"2016/11/25/iOS开发之05常见表视图/","text":"分节表视图步骤 创建一个iOS工程 删除storyboard中View Controller Scene 中的View Controller，再从对象库拖入一个Table View Controller到设计界面 打开Table View Controller属性检查器，勾选Is Initial View Controller选项，否则应用启动后是黑屏 将ViewController类的父类由UIViewController改为UITableViewController 打开View Controller的属性选择器在Class列表中选择ViewController UITableViewController默认以注册UITableViewDataSource和UITableViewDelegate协议，不需要再注册 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//// ViewController.swift// IndexTable//// Created by Michael on 2016/10/31.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UITableViewController &#123; var datas: NSDictionary! var groupNames:NSArray! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. let path = Bundle.main.path(forResource: \"team_dictionary\", ofType: \"plist\") self.datas = NSDictionary(contentsOfFile: path!) let tempList = self.datas.allKeys as NSArray //排序 let sortedArray = tempList.sortedArray(comparator: &#123; (obj1, obj2) -&gt; ComparisonResult in let str1 = obj1 as! String let str2 = obj2 as! String let ret = str1.compare(str2) return ret &#125;) self.groupNames = sortedArray as NSArray! &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; //组中条目的数量 override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; let groupName = self.groupNames[section] as! String let teams = self.datas[groupName] as! NSArray return teams.count &#125; override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell:UITableViewCell! = tableView.dequeueReusableCell(withIdentifier: \"liu\",for: indexPath) let section = indexPath.section let row = indexPath.row let groupName = self.groupNames[section] as! String let teams = self.datas[groupName] as! NSArray cell.textLabel?.text = teams[row] as? String return cell &#125; //组的数量 override func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return self.groupNames.count &#125; //组的标题 override func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? &#123; let name = self.groupNames[section] as! String return name &#125; //索引的标题 override func sectionIndexTitles(for tableView: UITableView) -&gt; [String]? &#123; var titles = [String]() for item in self.groupNames &#123; let title = item as! String titles.append(title.substring(to: title.index(title.startIndex, offsetBy: 1))) &#125; return titles &#125; //点击事件 override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; let section = indexPath.section let row = indexPath.row let groupName = self.groupNames[section] as! String let teams = self.datas[groupName] as! NSArray print(groupName) print(teams[row]) &#125;&#125; 示例 静态表视图步骤 创建一个iOS工程，使用Table View Controller作为表视图控制器 选择Table View，打开属性检查器，从Content下拉列表中选择Static Cells，将Section的值为设为3.，从Style下拉列表中选择Grouped 选择第一个Table View Section，将Rows值设为2，即该节中包含两个单元格，分别拖入一个TextField到两个单元格中 选择第二个Table View Section，将Rows值设为1，拖入一个Button到单元格中 选择第二个Table View Section，将Rows值设为1，拖入一个Lable到单元格中 代码实现12345678910111213141516171819202122232425262728293031323334353637//// ViewController.swift// StaticTable//// Created by Michael on 2016/11/2.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UITableViewController &#123; @IBOutlet weak var mUserName: UITextField! @IBOutlet weak var mPwd: UITextField! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; @IBAction func login(_ sender: UIButton) &#123; if self.mUserName.text == \"liu\" &amp;&amp; self.mPwd.text == \"123\" &#123; NSLog(\"login sucess\"); mUserName.resignFirstResponder(); mPwd.resignFirstResponder(); &#125; &#125; override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; NSLog(\"Section: %d,Row: %d\",indexPath.section,indexPath.row); &#125;&#125; 示例 插入和删除单元格步骤 创建一个iOS工程 删除storyboard中View Controller Scene 中的View Controller，再从对象库拖入一个Navigation Controller到设计界面，同时也会添加一个Table View Controller到设计界面 打开Table View Controller属性检查器，勾选Is Initial View Controller选项，否则应用启动后是黑屏 将ViewController类的父类由UIViewController改为UITableViewController 打开View Controller的属性选择器在Class列表中选择ViewController UITableViewController默认以注册UITableViewDataSource和UITableViewDelegate协议，不需要再注册 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//// ViewController.swift// DeleteAddCell//// Created by Michael on 2016/11/2.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UITableViewController &#123; var txtField:UITextField! var listTeams: NSMutableArray! override func viewDidLoad() &#123; super.viewDidLoad() //设置导航栏 self.navigationItem.rightBarButtonItem = self.editButtonItem self.navigationItem.title = \"单元格插入和删除\" self.txtField = UITextField() self.listTeams = NSMutableArray(array: [\"黑龙江\",\"吉林\",\"辽宁\",\"北京\"]) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; //响应视图编辑状态 override func setEditing(_ editing: Bool, animated: Bool) &#123; super.setEditing(editing, animated: animated) self.tableView.setEditing(editing, animated: true) if editing &#123; self.txtField.isHidden = false &#125; else&#123; self.txtField.isHidden = true &#125; &#125; override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return self.listTeams.count + 1 &#125; override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let isAddCell = (indexPath.row == self.listTeams.count) let cell:UITableViewCell! = tableView.dequeueReusableCell(withIdentifier: \"CustomCell\", for: indexPath) if !isAddCell &#123; cell.accessoryType = .disclosureIndicator cell.textLabel?.text = self.listTeams[indexPath.row] as? String &#125; else &#123; self.txtField.frame = CGRect(x: 40, y: 0, width: 300, height: cell.frame.size.height) self.txtField.borderStyle = .none self.txtField.placeholder = \"Add...\" self.txtField.text = \"\" cell.addSubview(self.txtField) &#125; return cell &#125; //返回编辑样式 override func tableView(_ tableView: UITableView, editingStyleForRowAt indexPath: IndexPath) -&gt; UITableViewCellEditingStyle &#123; if indexPath.row == self.listTeams.count &#123; return .insert &#125; else &#123; return .delete &#125; &#125; //添加删除时调用 override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) &#123; if editingStyle == .delete &#123; self.listTeams.removeObject(at: indexPath.row) self.tableView.deleteRows(at: [indexPath], with: .fade) &#125; else if editingStyle == .insert &#123; self.listTeams.insert(self.txtField.text!, at: self.listTeams.count) self.tableView.insertRows(at: [indexPath], with: .fade) &#125; self.tableView.reloadData(); &#125; &#125; 示例 移动单元格步骤1234561. 创建一个iOS工程2. 删除storyboard中View Controller Scene 中的View Controller，再从对象库拖入一个Navigation Controller到设计界面，同时也会添加一个Table View Controller到设计界面3. 打开Table View Controller属性检查器，勾选Is Initial View Controller选项，否则应用启动后是黑屏4. 将ViewController类的父类由UIViewController改为UITableViewController5. 打开View Controller的属性选择器在Class列表中选择ViewController6. UITableViewController默认以注册UITableViewDataSource和UITableViewDelegate协议，不需要再注册 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//// ViewController.swift// MoveCell//// Created by Michael on 2016/11/2.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UITableViewController &#123; var listTeams: NSMutableArray! override func viewDidLoad() &#123; super.viewDidLoad() //设置导航栏 self.navigationItem.rightBarButtonItem = self.editButtonItem self.navigationItem.title = \"单元格移动\" self.listTeams = NSMutableArray(array: [\"黑龙江\",\"吉林\",\"辽宁\",\"北京\"]) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; //响应视图编辑状态 override func setEditing(_ editing: Bool, animated: Bool) &#123; super.setEditing(editing, animated: animated) self.tableView.setEditing(editing, animated: true) &#125; override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return self.listTeams.count &#125; override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell:UITableViewCell! = tableView.dequeueReusableCell(withIdentifier: \"MoveCell\", for: indexPath) cell.accessoryType = .disclosureIndicator cell.textLabel?.text = self.listTeams[indexPath.row] as? String return cell &#125; //返回true表示可以移动 override func tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -&gt; Bool &#123; return true &#125; //移动单元格时触发此方法 override func tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) &#123; let mode = self.listTeams[sourceIndexPath.row] as! String self.listTeams.removeObject(at: sourceIndexPath.row) self.listTeams.insert(mode, at: destinationIndexPath.row) &#125; //编辑的样式 override func tableView(_ tableView: UITableView, editingStyleForRowAt indexPath: IndexPath) -&gt; UITableViewCellEditingStyle &#123; return .delete &#125; override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) &#123; if editingStyle == .delete &#123; self.listTeams.removeObject(at: indexPath.row) self.tableView.deleteRows(at: [indexPath], with: .fade) &#125; else if editingStyle == .insert &#123; self.tableView.insertRows(at: [indexPath], with: .fade) &#125; self.tableView.reloadData(); &#125; &#125; 示例 下拉刷新步骤 创建一个iOS工程 删除storyboard中View Controller Scene 中的View Controller，再从对象库拖入一个Table View Controller到设计界面 打开Table View Controller属性检查器，勾选Is Initial View Controller选项，否则应用启动后是黑屏 将ViewController类的父类由UIViewController改为UITableViewController 打开View Controller的属性选择器在Class列表中选择ViewController UITableViewController默认以注册UITableViewDataSource和UITableViewDelegate协议，不需要再注册 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//// ViewController.swift// RefreshCell//// Created by Michael on 2016/11/7.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UITableViewController &#123; var listTeams: NSMutableArray! override func viewDidLoad() &#123; super.viewDidLoad() //设置导航栏 self.navigationItem.rightBarButtonItem = self.editButtonItem self.navigationItem.title = \"单元格移动\" let rc = UIRefreshControl() rc.attributedTitle = NSAttributedString(string: \"下拉刷新\") rc.addTarget(self, action: #selector(ViewController.refresh), for: .valueChanged) self.refreshControl = rc self.listTeams = NSMutableArray(array: [\"黑龙江\",\"吉林\",\"辽宁\",\"北京\"]) &#125; func refresh() &#123; NSLog(\"refresh\") if (self.refreshControl?.isRefreshing)! &#123; self.refreshControl?.attributedTitle = NSAttributedString(string: \"加载中\") listTeams.add(\"上海\") listTeams.add(\"天津\") self.refreshControl?.endRefreshing() self.refreshControl?.attributedTitle = NSAttributedString(string: \"下拉刷新\") &#125; self.tableView.reloadData() &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; //响应视图编辑状态 override func setEditing(_ editing: Bool, animated: Bool) &#123; super.setEditing(editing, animated: animated) self.tableView.setEditing(editing, animated: true) &#125; override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return self.listTeams.count &#125; override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell:UITableViewCell! = tableView.dequeueReusableCell(withIdentifier: \"RefreshCell\", for: indexPath) cell.accessoryType = .disclosureIndicator cell.textLabel?.text = self.listTeams[indexPath.row] as? String return cell &#125; //返回true表示可以移动 override func tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -&gt; Bool &#123; return true &#125; //移动单元格时触发此方法 override func tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) &#123; let mode = self.listTeams[sourceIndexPath.row] as! String self.listTeams.removeObject(at: sourceIndexPath.row) self.listTeams.insert(mode, at: destinationIndexPath.row) &#125; //编辑的样式 override func tableView(_ tableView: UITableView, editingStyleForRowAt indexPath: IndexPath) -&gt; UITableViewCellEditingStyle &#123; return .delete &#125; override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) &#123; if editingStyle == .delete &#123; self.listTeams.removeObject(at: indexPath.row) self.tableView.deleteRows(at: [indexPath], with: .fade) &#125; else if editingStyle == .insert &#123; self.tableView.insertRows(at: [indexPath], with: .fade) &#125; self.tableView.reloadData(); &#125; &#125; 示例","tags":[{"name":"ios","slug":"ios","permalink":"http://liuguoquan727.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"http://liuguoquan727.github.io/tags/swift/"},{"name":"xcode","slug":"xcode","permalink":"http://liuguoquan727.github.io/tags/xcode/"}]},{"title":"iOS开发之04表视图","date":"2016-11-25T10:45:30.000Z","path":"2016/11/25/iOS开发之04表视图/","text":"概述表视图组成表视图是iOS开发中最重要的视图，它以列表的形式展示数据。表视图又一下部分组成： 表头视图：表视图最上边的视图 表脚视图：表视图最下边的视图 单元格（cell）：表视图中每一行的视图 节(section)：由多个单元格组成，应用于分组列表 节头 节脚 表视图的相关类UITableView继承自UIScrollView，且有两个协议：UITableViewDelegate和UITableViewDataSource。此外UITableViewCell类时单元格类，UITableViewController类时UITableView的控制器，UITableViewHeaderFooterView用于为节头和节脚提供视图。 表视图分类 普通表视图：主要用于动态表，而动态表一般在单元格数目未知的情况下使用 分组表视图：一般用于静态表，用来进行界面布局 单元格的组成和样式单元格由图标、主标题、副标题、扩展视图组成，可以根据需要进行选择，其中内置的扩展视图在枚举类型UITableViewCellAccessoryType中定义： Swift枚举成员 Objective-C枚举成员 说明 none ITableViewCellAccessoryNone 没有扩展图标 disclosureIndicator UITableViewCellAccessoryDisclosureIndicator 扩展指示器，为箭头+问号 detailDisclosureButton UITableViewCellAccessoryDetailDisclosureButton 细节展示图，为问号 checkmark UITableViewCellAccessoryCheckmark 选中标志，图标为勾 detailButton UITableViewCellAccessoryDetailButton 细节详情展示，图标为问号 内置的单元格样式在枚举类型UITableViewCellStyle中定义： Swift枚举成员 Objective-C枚举成员 说明 default UITableViewCellStyleDefault 默认样式 subtitle UITableViewCellStyleSubtitle 有图标、主标题、副标题、副标题在主标题的下面 value1 UITableViewCellStyleValue1 有主标题、副标题，主标题左对齐、副标题右对齐，可以有图标 2alue3 UITableViewCellStyleValue2 有主标题、副标题，主标题和副标题居中对齐，无图标 数据源协议与委托协议UITableViewDataSource数据源协议主要为表视图提供数据，主要方法如下 方法 返回类型 说明 func tableView(UITableView, cellForRowAt: IndexPath) UITableViewCell 为表视图单元格提供数据，必须实现 tableView(UITableView, numberOfRowsInSection: Int) Int 返回某个节中的行数，必须实现 tableView(UITableView, titleForHeaderInSection: Int) String 返回节头的标题 tableView(UITableView, titleForFooterInSection: Int) String 返回节脚的标题 numberOfSections(in: UITableView) Int 返回节的个数 sectionIndexTitles(for: UITableView) [String]? 返回表示图节索引标题 UITableViewDelegate委托协议主要主要用来设定表视图中节头和节脚的标题，以及一些动作事件，主要方法如下 方法 返回类型 说明 tableView(UITableView, didSelectRowAt: IndexPath) 单元格响应事件 tableView(UITableView, accessoryButtonTappedForRowWith: IndexPath) 扩展视图响应事件 简单表视图UIViewController根视图控制器实现表视图步骤 创建一个iOS工程 从对象库中拖入一个TableView到storyboard文件中，并将TableView覆盖整个View 打开Table View的属性检查器，将PrototypeCells的值设为1，注意不要添加多个，否则会发生错误；此时Table View会添加一个Table View Cell。 打开Table View Cell的属性检查器，设置Identifier属性。 注册UITableViewDataSource和UITableViewDelegate协议 编写代码实现功能 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//// ViewController.swift// TableViewDemo//// Created by Michael on 2016/10/26.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UIViewController,UITableViewDataSource,UITableViewDelegate &#123; //全部数据 var listItems: NSArray! override func viewDidLoad() &#123; super.viewDidLoad() //读取资源文件数据 let listPath = Bundle.main.path(forResource: \"team\", ofType: \"plist\") self.listItems = NSArray(contentsOfFile: listPath!) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; //返回列表每行的视图 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; //根据Identifier找到Cell let cell = tableView.dequeueReusableCell(withIdentifier: \"CustomId\", for: indexPath) let row = indexPath.row let rowDict = self.listItems[row] as! NSDictionary cell.textLabel?.text = rowDict[\"name\"] as? String cell.detailTextLabel?.text = \"123\" let imagePath = String(format: \"%@.png\", rowDict[\"image\"] as! String) cell.imageView?.image = UIImage(named: imagePath) cell.accessoryType = UITableViewCellAccessoryType.disclosureIndicator return cell &#125; //返回条目数目 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return self.listItems.count &#125; //响应条目点击事件 func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; print(\"点击事件\") &#125; &#125; 示例图 none模式 disclosureIndicator UITableViewController根视图控制器实现表视图步骤 创建一个iOS工程 删除storyboard中View Controller Scene 中的View Controller，再从对象库拖入一个Table View Controller到设计界面 打开Table View Controller属性检查器，勾选Is Initial View Controller选项，否则应用启动后是黑屏 将ViewController类的父类由UIViewController改为UITableViewController 打开View Controller的属性选择器在Class列表中选择ViewController UITableViewController默认以注册UITableViewDataSource和UITableViewDelegate协议，不需要再注册 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546import UIKitclass ViewController: UITableViewController &#123; //全部数据 var listItems: NSArray! override func viewDidLoad() &#123; super.viewDidLoad() //读取资源文件数据 let listPath = Bundle.main.path(forResource: \"team\", ofType: \"plist\") self.listItems = NSArray(contentsOfFile: listPath!) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; //返回列表每行的视图 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: \"CustomId\", for: indexPath) let row = indexPath.row let rowDict = self.listItems[row] as! NSDictionary cell.textLabel?.text = rowDict[\"name\"] as? String cell.detailTextLabel?.text = \"123\" let imagePath = String(format: \"%@.png\", rowDict[\"image\"] as! String) cell.imageView?.image = UIImage(named: imagePath) cell.accessoryType = UITableViewCellAccessoryType.disclosureIndicator return cell &#125; //返回条目数目 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return self.listItems.count &#125; //响应条目点击事件 func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; print(\"点击事件\") &#125; &#125; 示例图 detailButton模式 checkmark模式 自定义单元格步骤 创建一个表视图工程 修改根视图控制器为表视图控制器UITableViewController，参照上节的步骤 从对象库中拖入控件到单元格内部，比如Lable和ImageView 创建自定义单元格类CustomCell文件，并继承UITableViewCell类 在设计界面中选择View Controller Scene中的Table View Cell，并打开属性检查器，将Class设为CustomCell类，并设置单元格的Identifier 为单元格中的控件Label和ImageView控件连接输出接口，将控件绑定到CustomCell类中 打开ViewController类，编写代码实现 实现 CustomCell类 1234567891011121314151617181920212223242526//// CustomCell.swift// CustomCell//// Created by Michael on 2016/10/25.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass CustomCell: UITableViewCell &#123; @IBOutlet weak var mImage: UIImageView! @IBOutlet weak var mLabel: UILabel! override func awakeFromNib() &#123; super.awakeFromNib() // Initialization code &#125; override func setSelected(_ selected: Bool, animated: Bool) &#123; super.setSelected(selected, animated: animated) // Configure the view for the selected state &#125;&#125; ViewController类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//// ViewController.swift// SimpleTableView//// Created by Michael on 2016/10/24.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UITableViewController &#123; var listItems: NSArray! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. let listPath = Bundle.main.path(forResource: \"team\", ofType: \"plist\") self.listItems = NSArray(contentsOfFile: listPath!) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return self.listItems.count &#125; override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; //找到自定义单元格 let cell:CustomCell! = tableView.dequeueReusableCell(withIdentifier: \"CustomCellId\", for: indexPath) as? CustomCell //let cell = UITableViewCell(style: .value1, reuseIdentifier: \"CellIdentifier\") let row = indexPath.row let rowDict = self.listItems[row] as! NSDictionary //设置控件属性 cell.mLabel.text = rowDict[\"name\"] as? String let imagePath = String(format: \"%@.png\", rowDict[\"image\"] as! String) cell.mImage.image = UIImage(named: imagePath) cell.accessoryType = .disclosureIndicator return cell &#125;&#125; 示例图","tags":[{"name":"ios","slug":"ios","permalink":"http://liuguoquan727.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"http://liuguoquan727.github.io/tags/swift/"},{"name":"xcode","slug":"xcode","permalink":"http://liuguoquan727.github.io/tags/xcode/"}]},{"title":"iOS开发之03UIView","date":"2016-11-25T10:45:19.000Z","path":"2016/11/25/iOS开发之03UIView/","text":"UILabelLable的作用是显示不可编辑的文字。 属性检查器 Text：Label显示的文字 Color：文字的颜色 Font：字体和字号 Alignment：文本的对齐方式 Lines：设置Label中文本的行数，默认为1 Line Breaks：设置文字的截断，当文本太长以至于Label不能显示全部的字体时，超长的部分会显示“…”，通常在以下三个选项中做选择。 Truncate Tail：截断尾部 Truncate Head：截断头部 Truncate Middle：保留头尾，截断中间 Highlighted：设置高亮是文本的颜色 Shadow：设置文本的阴影颜色 Shadow Offset：设置标签文本的阴影偏移量 代码创建Lable123456//代码创建Labellet lable = UILabel(frame: CGRect(x: 100, y: 100, width: 200, height: 200))lable.text = \"代码创建的Lable\"lable.font = UIFont.systemFont(ofSize: CGFloat(28))lable.textColor = UIColor.redview.addSubview(lable) 实现123456789101112131415161718192021222324252627282930313233343536373839404142//// ViewController.swift// LableDemo//// Created by Michael on 2016/10/12.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; //storyboard @IBOutlet weak var mLabel: UILabel! override func viewDidLoad() &#123; super.viewDidLoad() // 设置文本 mLabel.text = \"Hello ShenZhen\" //设置字体对齐方式 mLabel.textAlignment = .left mLabel.textColor = UIColor.red mLabel.backgroundColor = UIColor.green //设置字体大小 mLabel.font = UIFont.boldSystemFont(ofSize: 25) //文本的行数 mLabel.numberOfLines = 2 //代码创建Label let lable = UILabel(frame: CGRect(x: 100, y: 100, width: 200, height: 200)) lable.text = \"代码创建的Lable\" lable.font = UIFont.systemFont(ofSize: CGFloat(28)) lable.textColor = UIColor.red view.addSubview(lable) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125;&#125; 示例图 UIButtonUIButton是ios中最基本的按钮控件 属性检查器在StoryBoard中拖曳生成一个控件时，可以使用属性检查器来设置场景中控件的属性。如果使用的是代码生成的控件，则在代码中给控件的属性赋值来改变属性的属性。 属性检查器的内容如下： Type：按钮的样式，默认是System，也就是透明背景蓝色字体的按钮样式。 State Config：默认为default，此外还有HighLight（触摸高亮）、Selected（选中状态）和Disable（禁用状态） Title：设置按钮显示的文字 Font：设置后按钮字体和字号 TextColor：设置字体颜色 Shadow Color：设置文字的阴影颜色 Image：设置按钮的图片格式，在这里设置图片会让按钮的文字消失 Backgroud：设置按钮的背景图片，保留文字 代码创建按钮1234567891011//用代码添加一个Button到View中let btn1 = UIButton(frame: CGRectMake(100,50,200,200))btn1.setTitle(\"word\", forState: .Normal)btn1.backgroundColor = UIColor.blueColor()//添加点击事件btn1.addTarget(self, action: #selector(ViewController.show(_:)), forControlEvents: .TouchUpInside)view.addSubview(btn1)func show(button : UIButton) &#123; print(button.currentTitle!)&#125; 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//// ViewController.swift// ButtonDemo//// Created by Michael on 16/9/12.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; //实例 @IBOutlet weak var myButton: UIButton! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. //用代码添加一个Button到View中 let btn1 = UIButton(frame: CGRectMake(100,50,200,200)) btn1.setTitle(\"word\", forState: .Normal) btn1.backgroundColor = UIColor.blueColor() //添加点击事件 btn1.addTarget(self, action: #selector(ViewController.show(_:)), forControlEvents: .TouchUpInside) view.addSubview(btn1) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; func show(button : UIButton) &#123; print(button.currentTitle!) &#125; //StoryBoard点击事件 @IBAction func click(sender: UIButton) &#123; print(sender.currentTitle!) //设置文字 sender.setTitle(\"hello\", forState: .Normal) //设置文字颜色 sender.setTitleColor(UIColor.darkTextColor(), forState: .Normal) //设置背景颜色 sender.backgroundColor = UIColor.redColor() //设置圆角 sender.layer.cornerRadius = 15 //是否可见 sender.hidden = false &#125;&#125; 示例 UISwitch、UISilder、UISegmentedControlUISWitchSwitch控件状态分为开启和关闭状态。 UISwitch的属性检查器的主要内容有： State：有On和Off两种状态 On Tint：开关打开时的背景颜色 Thumb Tint：滑块的颜色 UISliderSlider控件通常用来指示进度，并且可以通过拖曳改变进度。 UISlider控件的属性检查器的主要内容有： Value：设置Value的最大值、最小值，以及通过设置Current的值来限定Slider初始化时滑块的位置 Min Image和Max Image：Slider最大值和最小值处的图片 Min Track Tint：滑块左侧轨道的颜色 Max Track Tint：滑块右侧轨道的颜色 Thumb Tint：滑块的颜色 Events：有一个可选项Continuous Updates，勾选后再拖动滑块的过程中会不断触发事件 UISegmentedControl（分段控件）UISegmentedControl的属性检查器的主要内容有： Style：样式 State： Segments：设置分段的数量，默认的是2个，而且不能低于2个。 Segment：设置当前编辑的分段 Title：设置该分段所显示的文字，默认是First、Second等英文序数词 Image：设置该分段的图片 Behavior：Enabled表示该分段是否可用，Selected表示在初次加载时该分段是否被选中 Content OffSet：设置分段中的Title的位置，如果对默认的位置不满意，则可以设置X和Y方向的偏移量来调整，可正可负 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//// ViewController.swift// OtherButtonDemo//// Created by Michael on 2016/10/13.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; @IBOutlet weak var mSwitchButton: UISwitch! @IBOutlet weak var mBottomSwitch: UISwitch! @IBOutlet weak var mSegmentButton: UISegmentedControl! @IBOutlet weak var mLabel: UILabel! @IBOutlet weak var mSlideButton: UISlider! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. mSlideButton.minimumValue = 0 mSlideButton.maximumValue = 100 mSlideButton.setValue(60, animated: true) mLabel.text = String(format: \"SlideValue: %0.0f\", mSlideButton.value) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; /** * UISwitch点击事件 * */ @IBAction func switchValueChange(_ sender: AnyObject) &#123; //AnyObject转为UISwitch类型 let witchSwitch = sender as! UISwitch print(witchSwitch.isOn) print(mSwitchButton.isOn) mBottomSwitch.setOn(mSwitchButton.isOn, animated: true) &#125; // //UISegmentedControl点击事件 // @IBAction func switchSegment(_ sender: AnyObject) &#123; //选择的段 NSLog(\"%ld\", mSegmentButton.selectedSegmentIndex) if mSwitchButton.isHidden &#123; self.mSwitchButton.isHidden = false; &#125; else &#123; self.mSwitchButton.isHidden = true; &#125; &#125; //USlider滑动事件 @IBAction func slideValueChange(_ sender: AnyObject) &#123; let slider = sender as! UISlider NSLog(\"\\(slider.value)\") mLabel.text = String(format: \"SlideValue: %0.3f\", slider.value) &#125;&#125; 示例图 UITextField和UITextViewUITextFieldUITextField文本框与UILabel的不同是文本框是可以编辑的。iOS用到的文本框的地方很多，比如搜索框、用户登录框等。 UITextField的属性检查器的主要内容有： Placeholder：默认显示在这里的文字，通常用来提示该文本框中需要输入的内容 Border Style：选择文本框的样式 Clear Button：设置清除输入的按钮 Min Font Size：文本框被挤压时，文本框中字体的最小尺寸 Capitalization：设置文本框是否自动转换大小写 Spell Checking：检查是否有拼写错误 KeyBoard Style：键盘的样式 Return key：选择返回键的样式 UITextViewUITextView也是可以编辑文本内容的，适用于大段文本的编辑 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//// ViewController.swift// TextDemo//// Created by Michael on 2016/10/12.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UIViewController,UITextFieldDelegate,UITextViewDelegate &#123; @IBOutlet weak var mTextField: UITextField! @IBOutlet weak var mTextView: UITextView! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. mTextField.delegate = self mTextView.delegate = self &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; @IBAction func onClick(_ sender: UIButton) &#123; NSLog(\"TextFiled: %@\", mTextField.text!) NSLog(\"TextView: %@\", mTextView.text!) &#125; func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool &#123; //关闭键盘 mTextField.resignFirstResponder() NSLog(\"TextFiled 获得焦点\") return true &#125; func textFieldDidEndEditing(_ textField: UITextField) &#123; NSLog(\"%@\", textField.text!) &#125; func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -&gt; Bool &#123; if text == \"\\n\" &#123; NSLog(\"TextView 获得焦点\") //关闭键盘 mTextView.resignFirstResponder() return false &#125; return true &#125;&#125; 示例图 UIProgressViewProgressView(进度条)可以用来显示式地表示某个操作处理的进度。 属性检查器 Progress:当前进度条的进度值 Progress Tint:已完成进度部分的颜色 Track Tint：未完成部分的颜色 Progress Image：使用图片填充以完成的部分 Track Image“使用图片填充未完成的部分 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344//// ViewController.swift// ProgressViewDemo//// Created by Michael on 2016/10/18.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; @IBOutlet weak var mProgressView: UIProgressView! var timer:Timer! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. self.mProgressView.progress = 0; &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; @IBAction func download(_ sender: AnyObject) &#123; //执行定时任务 self.timer = Timer.scheduledTimer(timeInterval: 1.0, target: self, selector: #selector(ViewController.download as (ViewController) -&gt; () -&gt; ()), userInfo: nil, repeats: true) &#125; func download() &#123; //更新进度值 self.mProgressView.progress += 0.05 if self.mProgressView.progress == 1.0 &#123; //结束定时器 self.timer.invalidate() &#125; &#125;&#125; 示例图 UIActivityIndicatorView与UIProgressView相比，UIActivityIndicatorView不会显示具体的进度，只是用做提示的作用 属性检查器 Style：样式有三种：Gray、White、Large White Color：ActivityIndicatorView的颜色 Behavior：有两个选项：Animating表示ActivityIndicatorView的齿轮是否在转动；Hides When Stopped 表示当齿轮停止转动时是否将ActivityIndicatorView隐藏。 实现12345678910111213141516171819202122232425262728293031323334353637//// ViewController.swift// IndicatorViewDemo//// Created by Michael on 2016/10/18.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; @IBOutlet weak var mIndicatorView: UIActivityIndicatorView! override func viewDidLoad() &#123; super.viewDidLoad() //活动指示器出于非活动状态时则会隐藏 mIndicatorView.hidesWhenStopped = true &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() @IBAction func download(_ sender: AnyObject) &#123; &#125; // Dispose of any resources that can be recreated. &#125; @IBAction func upLoad(_ sender: AnyObject) &#123; if mIndicatorView.isAnimating &#123; //停止旋转 mIndicatorView.stopAnimating() &#125; else &#123; //开始旋转 mIndicatorView.startAnimating() &#125; &#125;&#125; 示例图 UIStepperUIStepper(步进器)的作用是按照约定的步长进行增减操作。Stepper上的+和-按钮对应Stepper所控制的数值的增减操作 属性检查器 Value:Stepper所控制的值。Mininum表示最小值，Maximun表示最大值，Current表示初始化时的值，Step表示步长。 Behavior：有三个复选框 Autorepeat：表示按住+和-的时候会不断地触发Stepper。 Continuous：勾选后系统实时触发ValueChanged事件，未勾选时系统只有当用户停止与Stepper交互时才触发ValueChanged事件。 Wrap：选择后当前当前Value值达到最大最小值时会继续增加或减少，value值会被复位成一个循环，比如最大值为100，最小值为0，当达到100后继续增加时Value的值就会变为0；如未选中，则达到最大或最小值时，Value会保持最大或最小值。 实现1234567891011121314151617181920212223242526272829303132333435//// ViewController.swift// StepperDemo//// Created by Michael on 2016/10/19.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; @IBOutlet weak var mStepper: UIStepper! @IBOutlet weak var mCount: UILabel! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. mStepper.stepValue = 1.0 //步长 mStepper.minimumValue = 0.0 mStepper.maximumValue = 10.0 mStepper.value = 0.0 //当前值 &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; @IBAction func step(_ sender: AnyObject) &#123; let text = String(format: \"数量%d\", Int(mStepper.value)) mCount.text = text &#125;&#125; 示例图 UIImageViewUIImageView是用于展示图片的控件。 属性检查器 Image:从工程的图片资源文件夹中选择一张图片作为UIImageVIew的填充，在Storyboard中使用图片名称来索引图片 Highlighted：高亮状态下显示的图片 State：可以设置UIImageView的初始状态，默认是非高亮状态 实现1234567891011121314151617181920212223242526//// ViewController.swift// ImageView//// Created by Michael on 2016/10/19.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; @IBOutlet weak var mImage: UIImageView! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. mImage.image = UIImage(named: \"ic_welcome\")! //代码添加图片 &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125;&#125; 示例图 UIPickerViewUIPickerView是可以用来更灵活地显示滑轮要显示的内容，如选择省市区等。 属性检查器Behavior：默认勾选，勾选后会高亮显示选中的选项 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//// ViewController.swift// PickerViewDemo//// Created by Michael on 2016/10/20.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UIViewController,UIPickerViewDelegate,UIPickerViewDataSource &#123; @IBOutlet weak var mPickerView: UIPickerView! @IBOutlet weak var mLable: UILabel! var pickerData: NSDictionary! var pickerProvinceData: NSArray! var pickerCityData: NSArray! override func viewDidLoad() &#123; super.viewDidLoad() //从资源文件夹获取plist文件内容 let listPath = Bundle.main.path(forResource: \"provinces_cities\", ofType: \"plist\") let dict = NSDictionary(contentsOfFile: listPath!) self.pickerData = dict self.pickerProvinceData = self.pickerData.allKeys as! NSArray let provice = self.pickerProvinceData[0] as! String self.pickerCityData = self.pickerData[provice] as! NSArray //设置代理处理回调事件 mPickerView.dataSource = self mPickerView.delegate = self &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; //确定选择器的拨轮的数目 func numberOfComponents(in pickerView: UIPickerView) -&gt; Int &#123; return 2 &#125; //确定每个拨轮的条目数 func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -&gt; Int &#123; if component == 0 &#123; return self.pickerProvinceData.count &#125; else &#123; return self.pickerCityData.count &#125; &#125; //为选择器某个拨轮的条目提供显示数据 func pickerView(_ pickerView: UIPickerView, titleForRow row: Int, forComponent component: Int) -&gt; String? &#123; if component == 0 &#123; return self.pickerProvinceData[row] as? String &#125; else &#123; return self.pickerCityData[row] as? String &#125; &#125; //选择选择器的某个拨轮的条目时调用 func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) &#123; if component == 0 &#123; let provice = self.pickerProvinceData[row] as! String self.pickerCityData = self.pickerData[provice] as! NSArray self.mPickerView.reloadComponent(1) &#125; &#125; @IBAction func onClick(_ sender: UIButton) &#123; let row1 = self.mPickerView.selectedRow(inComponent: 0) let row2 = self.mPickerView.selectedRow(inComponent: 1) let province = self.pickerProvinceData[row1] as! String let city = self.pickerCityData[row2] as! String let title = String(format: \"%@,%@市\", province,city) mLable.text = title &#125;&#125; 示例图 UIDatePickerView属性检查器 Model:设置UIDatePicker的样式，有以下四种模式： Date and Time：显示的是时间和日期 Date：只显示日期 Time：只显示时间 Count Down Timer：显示24小时制的倒计时模式 Local：设置语言类型，默认是英文 Interval：设置时间间隔，以分钟为单位 Date：显示的日期，默认是当前的日期 Constraints：设置UIDatePickerView的最大值和最小值 Timer：设置Count Down Time模式下倒计时的秒数 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//// ViewController.swift// DatePickerViewDemo//// Created by Michael on 2016/10/19.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; @IBOutlet weak var mDatePickerView: UIDatePicker! @IBOutlet weak var mDesc: UILabel! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. mDesc.text = mDatePickerView.date.description(with: Locale.current) &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; @IBAction func datePick(_ sender: AnyObject) &#123; let date = mDatePickerView.date let format = DateFormatter() format.dateFormat = \"YYYY-MM-dd HH:mm:ss\" let time = format.string(from: date) mDesc.text = time &#125; @IBAction func timeMode(_ sender: AnyObject) &#123; //设置为Time模式 mDatePickerView.datePickerMode = UIDatePickerMode.time &#125; @IBAction func dateMode(_ sender: AnyObject) &#123; mDatePickerView.datePickerMode = UIDatePickerMode.date &#125; @IBAction func dateAndTimeMode(_ sender: AnyObject) &#123; mDatePickerView.datePickerMode = UIDatePickerMode.dateAndTime &#125; @IBAction func mCountDownTime(_ sender: AnyObject) &#123; mDatePickerView.datePickerMode = UIDatePickerMode.countDownTimer &#125; &#125; 示例图 Date and Time模式 Time模式 Date模式 Count Down Timer模式 UIAlertView&amp;UIActionSheetUIAlertView是用来显示的提示框的控件，只能在代码中创建.UIActionSheet是用来显示操作表的控件，也只能在代码中创建。 使用步骤： 创建一个UIAlertController的实例 创建UIAlertAction的实例，可以有多个 将UIAlertAction实例添加到UIAlertController中 使用UIViewController的present显示UIAlertController 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//// ViewController.swift// AlertViewDemo//// Created by Michael on 2016/10/18.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; @IBOutlet weak var mAlertBtn: UIButton! @IBOutlet weak var mActionBtn: UIButton! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; //弹出警告栏 @IBAction func showAletView(_ sender: AnyObject) &#123; let alertController = UIAlertController(title: \"警告\", message: \"是否继续?\", preferredStyle: UIAlertControllerStyle.alert) //取消 let noAction = UIAlertAction(title: \"否\", style: UIAlertActionStyle.cancel) &#123; (UIAlertAction) in NSLog(\"No\") &#125; //确认 let yesAction = UIAlertAction(title: \"是\", style: UIAlertActionStyle.default) &#123; (UIAlertAction) in NSLog(\"Yes\") &#125; let confirmAction = UIAlertAction(title: \"是\", style: UIAlertActionStyle.destructive) &#123; (UIAlertAction) in NSLog(\"Yes\") &#125; //添加文本框 alertController.addTextField &#123; (UITextField) in UITextField.placeholder = \"请输入密码\" &#125; alertController.addAction(noAction) alertController.addAction(yesAction) alertController.addAction(confirmAction) self.present(alertController, animated: true, completion: nil) &#125; //弹出操作表 @IBAction func showActionSheet(_ sender: AnyObject) &#123; //默认是ActionSheet let actionSheet = UIAlertController() let cancelAction = UIAlertAction(title: \"取消\", style: UIAlertActionStyle.cancel) &#123; (UIAlertAction) in NSLog(\"cancel\") &#125; let sina = UIAlertAction(title: \"新浪微博\", style: UIAlertActionStyle.destructive) &#123; (UIAlertAction) in NSLog(\"weibo\") &#125; let wechat = UIAlertAction(title: \"微信\", style: UIAlertActionStyle.default) &#123; (UIAlertAction) in NSLog(\"wechat\") &#125; let tecent = UIAlertAction(title: \"QQ空间\", style: UIAlertActionStyle.default) &#123; (UIAlertAction) in NSLog(\"tecent\") &#125; actionSheet.addAction(cancelAction) actionSheet.addAction(sina) actionSheet.addAction(wechat) actionSheet.addAction(tecent) self.present(actionSheet, animated: true, completion: nil) &#125;&#125; 示例图 UIAlertView UIActionSheet UIToolbar属性检查器 Style:工具栏的样式，浅色和深色 Translucent：是否半透明 Bar Tint：工具栏的颜色 实现1234567891011121314151617181920212223242526272829303132333435//// ViewController.swift// ToolBarDemoo2//// Created by Michael on 2016/10/18.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UIViewController &#123; @IBOutlet weak var mDesc: UILabel! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; @IBAction func save(_ sender: AnyObject) &#123; mDesc.text = \"存储\" &#125; @IBAction func done(_ sender: AnyObject) &#123; mDesc.text = \"完成\" &#125; @IBAction func edit(_ sender: AnyObject) &#123; mDesc.text = \"编辑\" &#125;&#125; 示例图 UISearchBarUISearchBar是用于显示搜索框的控件 属性检查器 Text：SearchBar中输入的文字 PlaceHolder：占位符，通常用来提示用户输入的内容 Prompt：SearchBar的标题，显示在输入框的上方 Search Style：SearchBar的样式，可以选择边框加深还是搜索框加深 Bar Style:整体的颜色，可选择深色和浅色 Bar Tint:边框的颜色 Background:设置背景图片 Scope Bar:设置Scope Bar的背景图片 Search Text：设置关键字的位置。默认是在左边 Options：SearchBar的右侧可以配备一个功能按钮，比如查找搜索记录、清除已输入的内容。 实现123456789101112131415161718192021222324252627282930313233343536373839//// ViewController.swift// SearchBar//// Created by Michael on 2016/10/21.// Copyright © 2016年 Michael. All rights reserved.//import UIKitclass ViewController: UIViewController,UISearchBarDelegate &#123; @IBOutlet weak var mSearch: UISearchBar! @IBOutlet weak var mInfo: UILabel! override func viewDidLoad() &#123; super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. mSearch.delegate = self &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) &#123; mInfo.text = searchText &#125; func searchBarCancelButtonClicked(_ searchBar: UISearchBar) &#123; NSLog(\"searchBarCancelButtonClicked\"); &#125; //按搜索键时调用 func searchBarSearchButtonClicked(_ searchBar: UISearchBar) &#123; NSLog(\"searchBarSearchButtonClicked\"); &#125; &#125; 示例图 WebViewWKWebViewWKWebView不是UKit内容，它属于WebKit中的类，是在iOS8中引入的部分。WKWebView将浏览器的内存渲染进程从App转移到系统中进行，提高了性能；其次它拥有和Safari相同的JavaScript引擎；最后它拥有60fps的滚动刷新频率。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//// ViewController.swift// WebViewDemo//// Created by Michael on 2016/10/17.// Copyright © 2016年 Michael. All rights reserved.//import UIKitimport WebKit //引入库class ViewController: UIViewController,WKNavigationDelegate &#123; @IBOutlet weak var mButton: UIButton! var mWebView: WKWebView! @IBOutlet weak var mSafari: UIButton! override func viewDidLoad() &#123; super.viewDidLoad() mButton.layer.borderColor = UIColor.black.cgColor mButton.layer.borderWidth = 1 //设置Button的边框颜色 mSafari.layer.borderColor = UIColor.black.cgColor mSafari.layer.borderWidth = 1 &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; @IBAction func openWeb(_ sender: AnyObject) &#123; //打开网页 mWebView = WKWebView(frame: view.frame) let mUrl = URL(string: \"http://www.baidu.com\") let request = URLRequest(url: mUrl!) mWebView.load(request) //注册网页加载过程代理 mWebView.navigationDelegate = self view.addSubview(mWebView) &#125; func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) &#123; NSLog(\"开始加载\") &#125; func webView(_ webView: WKWebView, didCommit navigation: WKNavigation!) &#123; NSLog(\"内容开始返回时回调\") &#125; func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) &#123; NSLog(\"加载完成\") &#125; func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation!, withError error: Error) &#123; NSLog(\"加载失败\") &#125; &#125; 示例图 SFSafariViewControllerSFSafariViewController是iOS9中加入的控制器，这样就可以直接使用Safari来打开网页，获得Safari的完整功能而不需要离开App。 实现1234567891011121314151617181920212223242526272829303132333435363738//// ViewController.swift// WebViewDemo//// Created by Michael on 2016/10/17.// Copyright © 2016年 Michael. All rights reserved.//import UIKitimport SafariServices //引入库class ViewController: UIViewController,WKNavigationDelegate &#123; @IBOutlet weak var mSafari: UIButton! override func viewDidLoad() &#123; super.viewDidLoad() //设置Button的边框颜色 mSafari.layer.borderColor = UIColor.black.cgColor mSafari.layer.borderWidth = 1 &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. &#125; @IBAction func openSafari(_ sender: AnyObject) &#123; //通过Safari打开网页 let mUrl = URL(string: \"http://www.baidu.com\") let safari = SFSafariViewController(url: mUrl!) //展示视图 present(safari, animated: true,completion: nil) &#125; &#125; 示例图","tags":[{"name":"ios","slug":"ios","permalink":"http://liuguoquan727.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"http://liuguoquan727.github.io/tags/swift/"},{"name":"xcode","slug":"xcode","permalink":"http://liuguoquan727.github.io/tags/xcode/"}]},{"title":"iOS开发之02应用界面","date":"2016-11-25T10:45:08.000Z","path":"2016/11/25/iOS开发之02应用界面/","text":"iOS界面应用界面主要是使用Cocoa Touch框架开发，它有一套自己的MVC模式，其中视图和控制器是UIKit中的UIVIew及其子类和UIVIewController及其子类。 视图控制器Cocoa Touch中UIVIewController是所有控制器的基类，视图控制器有很多种，下面先介绍一个iOS中的控制器种类和生命周期。 视图控制器种类与导航相关的视图控制器如下所示： UIViewController： 用于自定义视图控制器的导航。例如对于两个界面的跳转，可以用一个UIViewController来控制另两个UIViewController。 UINavigationController：导航控制器，它与UITableViewController结合使用，能够构建树形结构导航模式 UITabBarController： 标签栏控制器，用于构建树形标签导航模式 UIPageViewController：呈现电子书导航风格控制器 UISplitViewController：可以把屏幕分割成几块的视图控制器，主要为iPad屏幕设计 UIPopoverController：呈现气泡风格视图的控制器，主要为iPad屏幕设计。 视图的生命周期在应用运行过程中视图会显示不同的状态，这就是应用的生命周期。视图生命周期的不同阶段会回调视图控制器的不同的方法，视图控制器的生命周期如下图所示： 视图的生命周期主要有四种状态： 视图创建 视图创建不加载到内存中，会调用viewDidLoad方法，但是视图此时并不可见。该方法中通常会对所控制的视图进行初始化处理。viewDidLoad方法在应用运行的时候只调用一次。 视图可见 视图可见前后会调用viewWillAppear和viewDidAppear两个方法。 视图不可见 视图不可见前后会调用viewWillDisappear和viewDidDisappear两个方法。 系统低内存 在低内存情况下，iOS系统会调用didReceiveMemoryWarning方法，该方法的功能是释放内存，包括视图控制器中的一些成员变量和视图的释放。 视图Cocoa Touch中UIViewC是所有视图的基类。 UIView继承层次结构 视图分类苹果将UIKit框架中的视图分为以下几个类别： 控件 继承自UIController类，能够响应用户高级事件。 窗口 它是UIWindow对象，一个iOS应用只有一个UIWindow对象，它是所有子视图的父容器。 容器视图 它是UIScrollView、UIToolbar及它们的子类。UIScrollView的子类有UITextView、UITabView和UICollectionView，在内容超出屏幕时，它们可以提供水平或垂直滚动条。UIToolbar是非常特殊的容器，它能够包含其他控件，一般置于屏幕底部，特殊情况下也可以置于屏幕顶部。 显示视图 用于显示信息，包括UIImageView，UILabel、UIProgressView和UIActivityIndicatorView等 文本和Web视图 提供了能够显示多行文本的视图，包含UITextView和UIWebView，其中UITextView也属于容器视图，UIWebView是能够加载和显示HTML代码的视图。 导航视图 为用户提供从一个屏幕到另一个屏幕的导航视图，它包括UITabBar和UINavigationBar。 警告框和操作表 用于给用户提供一种反馈或者与用户进行交互。警告框是可以以动画方式弹出来的视图，而操作表是给用户可选择操作的视图，在iphone中它会从屏幕底部弹出，在iPad中则会出现在屏幕中央。 应用界面构建层次一般情况下，iOS用于中只包含一个UIWindow。从UI构建层次来讲，UIWindow包含了一个根视图UIView。根视图一般也只有一个，置于UIWindow中。根视图类型决定了应用程序的类型。应用界面的构建层次是一种树形结构，如下图所示： 简要介绍图中三个属性的含义： superview：获得父视图对象 subviews：获得子视图对象集合 window：获得视图所在的界面Window对象","tags":[{"name":"ios","slug":"ios","permalink":"http://liuguoquan727.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"http://liuguoquan727.github.io/tags/swift/"},{"name":"xcode","slug":"xcode","permalink":"http://liuguoquan727.github.io/tags/xcode/"}]},{"title":"iOS开发之01基础","date":"2016-11-25T10:44:53.000Z","path":"2016/11/25/iOS开发之01基础/","text":"Xcode中的iOS工程模板iOS工程模板分为两类-Application和Framework &amp; Library。 Application类型Application包含5个模板，具体如下所示： Master-Detail Application：可以构建树形结构导航模式应用，生成的代码中包含了导航控制器和表视图控制器等。 Page-Based Application：可以构建类似电子书效果的应用 Single View Application：可以构建简单的单个视图应用 Tabbed Application：可以构建标签导航模式的应用，生成的代码中包含了标签控制器和标签栏等。 Game： 可以构建基于iOS的游戏应用 Framework &amp; Library Cocoa Touch Framework 可以让开发者自定义应用于UIKit的框架 Cocoa Touch Static Library 可以让开发者创建基于Foundation框架的静态库。 Xcode中的iOS工程目录 AppDelegate.swift类文件:应用程序委托对象 ViewController.swift类文件：是视图控制器类，在工程中扮演着根视图和用户事件控制类的角色 Main.storyboard文件:故事板文件 LaunchScreen.storyboard：应用启动界面故事板文件 Assets.xcassets文件夹: 资源目录,可以用来管理图片 Info.plist:工程属性文件 Products组:工程将要生成的产品包 在访问资源文件时，文件夹和组是有区别的。访问文件夹中的资源时需要将文件夹作为路径。如果icon.png文件放在images文件夹下，则访问它的路径时images/icon.png，如果images是组，则访问它的路径是icon.png. iOS应用生命周期AppDelegate类在应用生命周期的不同阶段会回调不同的方法。首先介绍iOS应用的5中状态。 Not Running（非运行状态）：应用没有运行或被系统终止 Inactive（前台非活动状态）：应用正在进入前台状态，但是还不能接受事件处理 Active（前台活动状态）：应用进入前台状态，能接受事件处理 Backgroud（后台状态）：应用进入后台状态，依然能够执行代码。如果有可执行的代码，就会执行代码；如果没有可执行的代码或者将可执行的代码执行完毕，应用会马上进入挂起状态 Suspend（挂起状态）：被挂起的应用不能执行代码。如果系统内存不够，应用会被终止。 在应用状态切换的过程中，iOS系统会回调AppDelegate中的一些方法，并且发送一些通知。下面介绍几个主要的方法和通知。 方法 本地通知 说明 application:didFinishLaunchingWithOptions UIApllicationDidFinishedLaunchingNotification 应用启动并进行初始化时会调用该方法并发出通知。这个阶段会实例化根视图控制器 applicationDidBecomeActive UIApplicationDidBecomeActiveNotification 应用进入前台并处于活动状态时调用该方法并发出通知。这个阶段可以恢复UI的状态 applicationWillResignActive UIApplicationWillResignActiveNotification 应用从活动状态进入到非活动状态时调用该方法并发出通知。这个阶段可以保存UI状态 applicationDidEnterBackgroud UIApplicationDidEnterBackgroudNotification 应用进入后台时调用该方法并发出通知。这个阶段可以保存用户数据，释放一些资源 applicationWillEnterForegroud UIApplicationWillEnterForegroudNotification 应用进入到前台，但是还没有处于活动状态时调用该方法并发出通知。这个阶段可以恢复用户数据 applicationWillTerminate UIApplicationWillTerminateNotification 应用被终止时调用该方法并发出通知，但内存清除时除外，这个阶段释放一些资源，也可以保存用户数据 非运行状态-应用启动场景场景描述：用户点击应用图标时，可能是第一次启动这个应用，也可能是应用终止后再次启动。该场景的状态跃迁过程共经历两个阶段单个状态：Not running -&gt; Inactive -&gt; Active。 Not running -&gt; Inactive阶段：调用application:didFinishLaunchingWithOptions方法，发出UIApllicationDidFinishedLaunchingNotification通知。 Inactive -&gt; Active阶段：调用applicationDidBecomeActive方法，发出UIApplicationDidBecomeActiveNotification通知。 点击Home键-应用退出场景场景描述：应用出于运行状态（即Active状态）时点击Home键应用会退出。该场景的状态变迁过程分为两种情况：可以在后台运行或者挂起和不可以在后台运行或挂起，可以根据工程属性文件Info.plist中的属性Application does not run in background来控制这两种状态。 应用可以在后台运行或者挂起该场景的状态变迁共经历3个阶段4个状态：Activie -&gt; Inactive -&gt; Backgroud -&gt; Suspend。 Activie -&gt; Inactive阶段：调用applicationWillResignActive方法，发出UIApplicationWillResignActiveNotification通知。 Inactive -&gt; Backgroud阶段：应用从非活动状态进入到后台（不涉及重点的方法和通知）。 Backgroud -&gt; Suspend阶段：调用applicationDidEnterBackground方法，发出UIApplicationDidEnterBackgroudNotification通知。 应用不可以在后台运行或挂起该场景下的状态变迁共经历4个阶段5种状态：Activie -&gt; Inactive -&gt; Backgroud -&gt; Suspend -&gt; Not Running。 Activie -&gt; Inactive阶段：调用applicationWillResignActive方法，发出UIApplicationWillResignActiveNotification通知。 Inactive -&gt; Backgroud阶段：应用从非活动状态进入到后台（不涉及重点的方法和通知） Backgroud -&gt; Suspend阶段：调用applicationDidEnterBackground方法，发出UIApplicationDidEnterBackgroudNotification通知 Suspend -&gt; Not Running阶段：调用applicationWillTerminate方法，发出UIApplicationWillTerminateNotification通知。 挂起重新运行场景场景描述：挂起状态的应用重新运行。该场景的状态变迁过程共经历三个阶段4种状态：Suspend -&gt; Backgroud -&gt; Inactive -&gt; Active。 Suspend -&gt; Backgroud阶段：应用从挂起状态进入到后台（不涉及重点的方法和通知） Backgroud -&gt; Inactive：调用applicationWillEnterForeground方法，发出UIApplicationWillEnterForegroudNotification通知。 Inactive -&gt; Active：调用applicationDidBecomeActive方法，发出UIApplicationDidBecomeActiveNotification通知。 内存清楚-应用终止场景场景描述：应用在后台处理完成时进入挂起状态（这是一种休眠状态），如果这时发出低内存警告，为了满足其他应用对内存的需要，该应用就会被清除内存从而终止运行。该场景的变迁过程为：Backgroud -&gt; Suspend -&gt; Not running。 内存清除的时候应用终止运行。内存清除有两种情况，可能是系统强制清楚内存，也可能是由使用者从任务栏中手动清除。内存清除后如果应用再次运行，上一次的运行状态不会被保存，相对于应用第一次运行。 在内存清除的场景下，应用不会调用任何方法，也不会发出任何通知。 iOS API 简介iOS的整体架构图参见图2-28，分为4层-Cocoa Touch层，Media层，Core Service层和Core OS层。 Cocoa Touch层Cocoa Touch层提供了构建iOS应用的一些基本系统服务（如多任务、触摸输入和推送通知等）和关键框架。 框架 前缀 说明 ConatactsUI CN 访问通讯录相关UI类 EventKitUI EK 访问日历事件数据 GameKit GK 提供能够进行点对点通信的网络通信API iAd AD 广告API MapKit MK 地图API MessageUI MF 电子邮件消息相关API PhotosUi PF 照片API Twitter TW 提供发送Twitter API UIKit UK 提供UI类 WatchKit Wk Apple Watch相关类 Media层Media层提供了图形、音频、视频和AirPlay技术等。 框架 前缀 说明 Assets Library Al 访问图片和视频的API AudioToolBox Audio 录制或播放视频、音频流以及格式转换 AudioUnit Audio、AU 使用内置音频单元服务以及音频处理模块 AV Foundation AV 播放与录制音频和视频的OC API Core Audio Audio 录制、制作、播放音频的C语言接口 Core Graphics CG 提供Quartz 2D接口 Core Image CI 操作视频和静态图像的接口 Core MIDI MIDI 处理MIDI数据的底层API Core Text CT 渲染文本和处理字体的简单、高效的C语言接口 Core Video CV 处理音频和视频的API Image I/O CG 读写图像数据类 GLKit GLK 构建复杂OpenGL ES应用的OC应用类 Media Player MP 播放接口 OpenAl AL 包含了OpenAL（跨平台）的C接口 OpenGL ES GL 包含OpenGL ES（跨平台的2D/3D图形库）的C语言接口 Quartz Core CA 提供动画接口类 Sprite Kit SK 苹果提供的基于2D游戏的开发引擎 Scene Kit SCK 一种高级别的3D图像框架，能创建3D动画场景和特效 Core Services层Core Services层提供了CloudKit、HealthKit、HomeKit、SQLite和XML支持等技术 框架 前缀 说明 Accounts AC 用于访问用户的Twitter账户 Contacts CN 访问通讯录信息 AdSupport AS 获得iAd广告标识 CFNetwork CF 提供了访问Wi-Fi网络和蜂窝移动网络的API Core Data NS 提供管理应用数据的ORM接口 CoreFoundation CF 最基本的框架包括数据集 Core Location CL 定位服务的API CoreMedia CM 提供AV Foundation框架使用的底层媒体类型，可以精确控制音频或视频的创建及展示 CoreMotion CM 接收和处理重力加速度以及其他的运动操作 CoreTelephony CT 提供访问电话基本信息的API Event Kit EK 访问日历事件数据 Foundation NS 是OC最基本的框架 JavaScriptCore.framework JS 实现OC与JS的相互调用 MobileCoreServices UT 定义统一标识符类型（UIT）使用的底层类型 Newsstand Kit NK 提供在后台下载杂志和新闻的API接口 Pass Kit PK 提供访问优惠券的API QuickLock QL 提供预览无法直接查看的文件内容 Social SL 提供社交网络访问API，中国区提供新浪微博的API Store Kit SK 提供处理应用内置收费的资金交易 SystemConfiguration SC 用于确定设备的网络配置，也可以用于判断某个主机服务是否可以使用 Cloud Kit CK 开发iCloud应用的API Health Kit HK 开发健康和健身等服务的API Home Kit HM 能够与用户家中连接的设备通信并进行控制 Core OS层Core OS层提供了一些低级功能，一般不直接使用它。 框架 前缀 说明 Accelerate AC 访问重力加速计API Core Bluetooth CB 访问低功耗蓝牙设备API External Accessory EA 访问外围配件API接口 Generic Security Services GSS 提供一组安全相关的服务 Security CSSM 管理证书、公钥、私钥和安全信任策略的API LocalAuthentication LA 提供用户指定的安全策略进行安全认证","tags":[{"name":"ios","slug":"ios","permalink":"http://liuguoquan727.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"http://liuguoquan727.github.io/tags/swift/"},{"name":"xcode","slug":"xcode","permalink":"http://liuguoquan727.github.io/tags/xcode/"}]},{"title":"DiffUtil在RecyclerView中的使用","date":"2016-11-25T10:31:12.000Z","path":"2016/11/25/Android DiffUtil在RecyclerView中的使用/","text":"概述DiffUtil是recyclerview support library v7 24.2.0版本中新增的类，根据Google官方文档的介绍，DiffUtil的作用是比较两个数据列表并能计算出一系列将旧数据表转换成新数据表的操作。这个概念比较抽象，换一种方式理解，DiffUtil是一个工具类，当你的RecyclerView需要更新数据时，将新旧数据集传给它，它就能快速告知adapter有哪些数据需要更新。 那么相比直接调用adapter.notifyDataSetChange()方法，使用DiffUtil有什么优势呢？它能在收到数据集后，提高UI更新的效率，而且你也不需要自己对新老数据集进行比较了。 顾名思义，凡是数据集的比较DiffUtil都能做，所以用处并不止于更新RecyclerView。DiffUtil也提供了回调让你可以进行其他操作。本文只介绍使用DiffUtil更新RecyclerView。 DiffUtil简介在使用DiffUtil前我们先简单看看DiffUtil的特性。DiffUtil使用Eugene W. Myers的Difference算法来计算出将一个数据集转换为另一个的最小更新量，也就是用最简单的方式将一个数据集转换为另一个。除此之外，DiffUtil还可以识别一项数据在数据集中的移动。Eugene的算法对控件进行了优化，在查找两个数据集间最少加减操作时的空间复杂度为O(N)，时间复杂度为O(N+D^2)。而如果添加了对数据条目移动的识别，复杂度就会提高到O(N^2)。所以如果数据集中数据不存在移位情况，你可以关闭移动识别功能来提高性能。当数据集较大时，你应该在后台线程计算数据集的更新。 如何使用DiffUtil类 DiffUtil.Callback：这是最核心的类,你可以将它理解成比较新老数据集时的规则。 DiffUtil：通过静态方法DiffUtil.calculateDiff(DiffUtil.Callback)来计算数据集的更新。 DiffResult：是DiffUtil的计算结果对象，通过DiffResult.dispatchUpdatesTo(RecyclerView.Adapter)来进行更新。 代码模式为 123DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new DiffCallBack(mDatas, newDatas), true);mAdapter.setDatas(newDatas);diffResult.dispatchUpdatesTo(mAdapter); dispatchUpdatesTo()方法它会自动计算新老数据集的差异，并根据差异情况，自动调用以下四个方法 1234adapter.notifyItemRangeInserted(position, count);adapter.notifyItemRangeRemoved(position, count);adapter.notifyItemMoved(fromPosition, toPosition);adapter.notifyItemRangeChanged(position, count, payload); DiffUtil.Callback抽象类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public abstract static class Callback &#123; /** * 返回旧数据集的大小 * * @return The size of the old list. */ public abstract int getOldListSize(); /** * 返回新数据集的大小 * * @return The size of the new list. */ public abstract int getNewListSize(); /** * 比较两个Item对象是否是同一个对象 * * @param oldItemPosition The position of the item in the old list * @param newItemPosition The position of the item in the new list * @return True if the two items represent the same object or false if they are different. */ public abstract boolean areItemsTheSame(int oldItemPosition, int newItemPosition); /** * 比较两个Item对象的内容是否相同 * Called by the DiffUtil when it wants to check whether two items have the same data. * DiffUtil uses this information to detect if the contents of an item has changed. * &lt;p&gt; * DiffUtil uses this method to check equality instead of &#123;@link Object#equals(Object)&#125; * so that you can change its behavior depending on your UI. * For example, if you are using DiffUtil with a * &#123;@link android.support.v7.widget.RecyclerView.Adapter RecyclerView.Adapter&#125;, you should * return whether the items' visual representations are the same. * &lt;p&gt; * This method is called only if &#123;@link #areItemsTheSame(int, int)&#125; returns * &#123;@code true&#125; for these items. * * @param oldItemPosition The position of the item in the old list * @param newItemPosition The position of the item in the new list which replaces the * oldItem * @return True if the contents of the items are the same or false if they are different. */ public abstract boolean areContentsTheSame(int oldItemPosition, int newItemPosition); /** * areItemsTheSame()返回true而areContentsTheSame()返回false时调用，也就是说两个对象代表的数据是一条，但是内容更新了。 * When &#123;@link #areItemsTheSame(int, int)&#125; returns &#123;@code true&#125; for two items and * &#123;@link #areContentsTheSame(int, int)&#125; returns false for them, DiffUtil * calls this method to get a payload about the change. * &lt;p&gt; * For example, if you are using DiffUtil with &#123;@link RecyclerView&#125;, you can return the * particular field that changed in the item and your * &#123;@link android.support.v7.widget.RecyclerView.ItemAnimator ItemAnimator&#125; can use that * information to run the correct animation. * &lt;p&gt; * Default implementation returns &#123;@code null&#125;. * * @param oldItemPosition The position of the item in the old list * @param newItemPosition The position of the item in the new list * * @return A payload object that represents the change between the two items. */ @Nullable public Object getChangePayload(int oldItemPosition, int newItemPosition) &#123; return null; &#125;&#125; DiffUtil步骤 自定义类继承DiffUtil.Callback，通过重写特定方法给出数据比较逻辑。 调用DiffUtil.calculateDiff(DiffUtil.Callback callback,boolean detectMove)来计算更新，得到DiffResult对象。第二个参数可省，意为是否探测数据的移动，是否关闭需要根据数据集情况来权衡。当数据集很大时，此操作可能耗时较长，需要异步计算。 在UI线程中调用DiffResult.dispatchUpdatesTo(RecyclerView.Adapter)，而后Adapter的onBindViewHolder(RecyclerView.ViewHolder holder, int position, Listpayloads)。注意这个方法比必须覆盖的onBindViewHolder(RecyclerView.ViewHolder holder, int position)方法多一个参数payloads，而里面存储了数据的更新。 示例初始化RecyclerView 新建一个Bean为Item： 1234567891011121314151617181920212223242526272829303132package com.michael.materialdesign.bean;/** * Created by liuguoquan on 2016/10/18. */public class Item &#123; public int id = 0; public String name; public Item(int id, String name) &#123; this.id = id; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 新建Adapter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class DiffUtilAdapter extends RecyclerView.Adapter&lt;DiffUtilAdapter.DiffItemHolder&gt; &#123; private Context mContext; private List&lt;Item&gt; mDatas; public DiffUtilAdapter(Context context, List&lt;Item&gt; datas) &#123; this.mContext = context; this.mDatas = datas; &#125; public void setDatas(List&lt;Item&gt; mDatas) &#123; this.mDatas = mDatas; &#125; @Override public DiffItemHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item_diff_util, parent, false); return new DiffItemHolder(view); &#125; @Override public void onBindViewHolder(DiffItemHolder holder, int position) &#123; Item info = mDatas.get(position); holder.mInfo.setText(info.getName()); Log.d(\"lgq\",\"onBindViewHolder\"); &#125; //payloads就是DiffUtil.Callback中的getChangePayload方法返回的数据集 @Override public void onBindViewHolder(DiffItemHolder holder, int position, List&lt;Object&gt; payloads) &#123; if (payloads.isEmpty()) &#123; onBindViewHolder(holder,position); &#125; else &#123; //更新item Bundle bundle = (Bundle) payloads.get(0); for(String key : bundle.keySet()) &#123; switch (key) &#123; case \"name\": holder.mInfo.setText((CharSequence) bundle.get(key)); break; &#125; &#125; &#125; &#125; @Override public int getItemCount() &#123; return mDatas != null ? mDatas.size() : 0; &#125; static class DiffItemHolder extends RecyclerView.ViewHolder &#123; @BindView(R.id.info) TextView mInfo; public DiffItemHolder(View itemView) &#123; super(itemView); ButterKnife.bind(this, itemView); &#125; &#125;&#125; 初始化ReyclerView 12345678910111213private void initView() &#123; for(int i = 0; i &lt; 20;i++) &#123; Item item = new Item(i,\"liu\"+i); mDatas.add(item); &#125; mAdapter = new DiffUtilAdapter(this,mDatas); mList.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false)); mList.setItemAnimator(new DefaultItemAnimator()); mList.setAdapter(mAdapter);&#125; 初始化RecyclerView后效果为： 实现DiffUtil.Callback新建类继承DiffUtil.Callback 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private class DiffCallback extends DiffUtil.Callback &#123; private List&lt;Item&gt; mOldDatas; private List&lt;Item&gt; mNewDatas; //传入旧数据和新数据的集合 public DiffCallback(List&lt;Item&gt; oldDatas,List&lt;Item&gt; newDatas) &#123; this.mOldDatas = oldDatas; this.mNewDatas = newDatas; &#125; @Override public int getOldListSize() &#123; return mOldDatas != null ? mOldDatas.size() : 0; &#125; @Override public int getNewListSize() &#123; return mNewDatas != null ? mNewDatas.size() : 0; &#125; /** * 被DiffUtil调用，用来判断 两个对象是否是相同的Item。 * 例如，如果你的Item有唯一的id字段，这个方法就 判断id是否相等。 * 本例判断id字段是否一致 */ @Override public boolean areItemsTheSame(int oldItemPosition, int newItemPosition) &#123; boolean is = mOldDatas.get(oldItemPosition).id == mNewDatas.get(newItemPosition).id; Log.d(\"lgq\",\"areItemsTheSame \" +oldItemPosition + \" \" + newItemPosition + \" \" + is); return is; &#125; /* * 被DiffUtil调用，用来检查 两个item是否含有相同的数据 * 这个方法仅仅在areItemsTheSame()返回true时，才调用。 * @param oldItemPosition The position of the item in the old list * @param newItemPosition The position of the item in the new list which replaces the * oldItem * @return True if the contents of the items are the same or false if they are different. */ @Override public boolean areContentsTheSame(int oldItemPosition, int newItemPosition) &#123; String oldName = mOldDatas.get(oldItemPosition).getName(); String newName = mNewDatas.get(newItemPosition).getName(); Log.d(\"lgq\",\"areContentsTheSame\" + \" \" +oldName + \" \" + newName); if (!oldName.equals(newName)) &#123; Log.d(\"lgq\",\"false\"); return false; &#125; return true; &#125; /** * areItemsTheSame()返回true而areContentsTheSame()返回false，也就是说两个对象代表的数据是一条，但是内容更新了。 * @param oldItemPosition * @param newItemPosition * @return */ @Nullable @Override public Object getChangePayload(int oldItemPosition, int newItemPosition) &#123; String oldItem = mOldDatas.get(oldItemPosition).getName(); String newItem = mNewDatas.get(newItemPosition).getName(); Bundle bundle = new Bundle(); if (!oldItem.equals(newItem)) &#123; bundle.putString(\"name\",newItem); &#125; if (bundle.size() == 0) &#123; return null; &#125; Log.d(\"lgq\",\"getChangePayload\"); return bundle; &#125;&#125; 使用DiffUtil下面通过两种不同的改变RecyclerView条目来介绍DiffUtil的使用。 增加或删除条目 这种情况下，数据集的大小改变，反映在RecyclerView的效果就是增加或者删除条目 123456789101112private void add() &#123; mNewDatas.clear(); mNewDatas.addAll(mDatas); mNewDatas.add(new Item(89,\"xiao\")); mNewDatas.add(new Item(90,\"xia\")); DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new DiffCallback(mDatas,mNewDatas),true); mAdapter.setDatas(mNewDatas); diffResult.dispatchUpdatesTo(mAdapter); mDatas.clear(); mDatas.addAll(mNewDatas);&#125; 增加条目后的RecyclerView的效果为： 更新具体的条目 这种情况下数据集大小不改变，改变数据集中条目的内容，反映在RecyclerView的效果就是更新具体的条目，这回调用Callback中的getChangePayload方法，而Adapter必须要实现public void onBindViewHolder(DiffItemHolder holder, int position, List&lt;Object&gt; payloads)方法。 1234567891011121314private void refresh() &#123; mNewDatas.clear(); mNewDatas.addAll(mDatas); //改变第三个位置的对象 Item item = new Item(3,\"zhang\"); mNewDatas.remove(3); mNewDatas.add(3,item); DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(new DiffCallback(mDatas,mNewDatas),true); //将新数据给Adapter mAdapter.setDatas(mNewDatas); diffResult.dispatchUpdatesTo(mAdapter); mDatas.clear(); mDatas.addAll(mNewDatas);&#125; 更新条目后的RecyclerView效果为： 由图可知，第四个位置的条目显示变为zhang。 结语DiffUtil可用于高效进行RecyclerView的数据更新，但DiffUtil本身的作用是计算数据集的最小更新。DiffUtil有强大的算法支撑，可以利用DiffUtil完成许多其他功能。 示例代码在RecyclerView目录下 参考文章: 使用DiffUtil高效更新RecyclerView详解7.0带来的新工具类：DiffUtil","tags":[{"name":"实战","slug":"实战","permalink":"http://liuguoquan727.github.io/tags/实战/"}]},{"title":"Android LoaderManager使用详解","date":"2016-09-12T12:23:25.000Z","path":"2016/09/12/Android_LoaderManager使用详解/","text":"LoaderManager是什么？LoaderManager用来负责管理与Activity或者Fragment联系起来的一个或多个Loaders对象。每个Activity或者Fragment都有唯一的一个LoaderManager实例，用来启动、停止、保持、重启、关闭它的Loaders。这些事件有时直接在客户端通过调用initLoader()/restartLoader()/destroyLoader()函数来实现。通常这些事件通过主要的Activity/Fragment声明周期事件来触发，而不是手动（当然也可以手动调用）。比如，当一个Activity关闭时（destroyed），改活动将指示它的LoaderManager来销毁并且关闭它的Loaders（当然也会销毁并关闭与这些Loaders关联的资源，比如Cursor）。 LoaderManager并不知道数据如何装载以及何时需要装载。相反地，LoaderManager只需要控制它的Loaders们开始、停止、重置他们的Load行为，在配置变换（比如横竖屏切换）时保持loaders们的状态，并提供一个简单的接口来获取load结果到客户端中。 实现LoaderManager.LoaderCallbacks接口LoaderManager.LoaderCallbacks接口LoaderManager用来向客户返回数据的方式。每个Loader都有自己的回调对象供与LoaderManager进行交互。该回调对象在实现LoaderManager中地位很高，告诉LoaderManager如何实例化Loader(onCreateLoader)，以及当载入行为结束或者重启（onLoadFinished或者onLoadReset）之后执行什么操作。大多数情况，你需要把该接口实现为组件的一部分，比如说让你的Activity或者Fragment实现LoadManager.LoaderCallbacks接口。 12345678910public class SampleActivity extends Activity implements LoaderManager.LoaderCallbacks&lt;D&gt; &#123; public Loader&lt;D&gt; onCreateLoader(int id, Bundle args) &#123; ... &#125; public void onLoadFinished(Loader&lt;D&gt; loader, D data) &#123; ... &#125; public void onLoaderReset(Loader&lt;D&gt; loader) &#123; ... &#125; /* ... */ &#125; 一旦实现该接口，客户端将回调对象（本例中为“this”）作为LoaderManager的initLoader函数的第三个参数传输。总的来说，实现回调接口非常直接明了。每个回调方法都有各自明确的与LoaderManager进行交互的目的： onCreateLoader是一个工厂方法，用来返回一个新的Loader。LoaderManager将会在它第一次创建Loader的时候调用该方法。 onLoadFinished方法将在Loader创建完毕的时候自动调用。典型用法是，当载入数据完毕，客户端（译者注：调用它的Activity之类的）需要更新应用UI。客户端假设每次有新数据的时候，新数据都会返回到这个方法中。记住，检测数据源是Loader的工作，Loader也会执行实际的同步载入操作。一旦Loader载入数据完成，LoaderManager将会接受到这些载入数据，并且将将结果传给回调对象的onLoadFinished方法，这样客户端（比如Activity或者Fragment）就能使用该数据了。 最后，当Loader们的数据被重置的时候将会调用onLoadReset。该方法让你可以从就的数据中移除不再有用的数据。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.michael.loadermanagerdemo;import android.database.Cursor;import android.os.Looper;import android.provider.MediaStore;import android.support.v4.app.LoaderManager;import android.support.v4.content.CursorLoader;import android.support.v4.content.FileProvider;import android.support.v4.content.Loader;import android.support.v4.content.PermissionChecker;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;import com.orhanobut.logger.Logger;public class MainActivity extends AppCompatActivity implements LoaderManager.LoaderCallbacks&lt;Cursor&gt;&#123; private static final String[] PROJECTION = new String[] &#123; MediaStore.Images.Media._ID, MediaStore.Images.Media.DATA &#125;; final String[] DOC_PROJECTION = &#123; MediaStore.Files.FileColumns.DATA, MediaStore.Files.FileColumns.MIME_TYPE, MediaStore.Files.FileColumns.TITLE &#125;; private static final int LOADER_ID = 1; private static final int LOADER_FILE_ID = 2; LoaderManager mLoaderManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Logger.init(\"loader\"); //1.获取LoadManager实例 mLoaderManager = getSupportLoaderManager(); //2.设置LoadManager传输的参数 Bundle bundle = new Bundle(); bundle.putString(\"liu\",\"liuguoquan\"); //3.初始化LoadManager mLoaderManager.initLoader(LOADER_FILE_ID,bundle,this); &#125; @Override public Loader&lt;Cursor&gt; onCreateLoader(int id, Bundle bundle) &#123; Logger.d(\"bundle: \" + bundle.getString(\"liu\")); if (id == LOADER_ID) &#123; //获取图片信息 return new CursorLoader(MainActivity.this, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, PROJECTION, null, null, null); &#125; else if (id == LOADER_FILE_ID) &#123; //获取文件名 return new CursorLoader(MainActivity.this,MediaStore.Files.getContentUri(\"external\"),DOC_PROJECTION,null,null,null); &#125; return null; &#125; @Override public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor cursor) &#123; //创建完毕后调用 switch (loader.getId()) &#123; case LOADER_ID: while (cursor.moveToNext()) &#123; Long id = cursor.getLong(0); String data = cursor.getString(1); Log.d(\"loader\",\"id:\" + id + \"; data: \" + data); &#125; break; case LOADER_FILE_ID: while (cursor.moveToNext()) &#123; String title = cursor.getString(2); Log.d(\"loader\",\"title: \" + title); &#125; cursor.close(); &#125; &#125; @Override public void onLoaderReset(Loader&lt;Cursor&gt; loader) &#123; //数据重置时调用 &#125;&#125; LoaderManager使用详解（三）—实现Loaders","tags":[{"name":"实战","slug":"实战","permalink":"http://liuguoquan727.github.io/tags/实战/"}]},{"title":"Android设计模式(十一)观察者模式","date":"2016-06-09T13:20:01.000Z","path":"2016/06/09/Android设计模式(十一)观察者模式/","text":"介绍观察者模式是一个使用率非常高的模式，它最常用的地方是GUI系统、订阅-发布系统，因为这个模式的一个重要作用就是解耦，将被观察者和观察者解耦，使得它们之间的依赖性更小，甚至做到毫无依赖。 定义定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 使用场景 关联行为场景，需要注意的是，关联行为是可拆分的，而不是组合关系； 事件多级触发场景； 跨系统的消息交换场景，如消息队列、事件总线的处理机制； UML类图UML类图如下： 角色介绍： Subject：抽象主题，也就是被观察者(Observable)角色，抽象主题角色把所有观察者对象的引用保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。 ConcreteSubject：具体主题，该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发出通知，具体主题角色又叫做具体被观察者(ConcreteObservable)角色。 Observer：抽象观察者，该角色是观察者的抽象类，它定义了一个更新接口，使得在得到主题的更改通知时更新自己。 ConcreteObserver：具体的观察者，该角色实现抽象观察者角色所定义的更新接口，以便在主题的主题发生改变时更新自身的状态。 实现发布-订阅模式也称为观察者模式。下面通过实例来了解观察者模式： 12345678910111213141516171819202122232425262728/** * 程序员是观察者 */import java.util.Observable;import java.util.Observer;public class Coder implements Observer &#123; private String mName; public Coder(String name) &#123; // TODO Auto-generated constructor stub this.mName = name; &#125; @Override public void update(Observable o, Object arg) &#123; // TODO Auto-generated method stub System.out.println(\"Hi,\" + mName + \"更新啦，内容是: \" + arg); &#125; @Override public String toString() &#123; return \"Coder [mName=\" + mName + \"]\"; &#125;&#125; 12345678910111213141516/** * 被观察者，发布者 */import java.util.Observable;public class DevTechFrontier extends Observable &#123; public void postNewPublication(String content) &#123; //标识状态或内容改变 setChanged(); //通知所有观察者 notifyObservers(content); &#125;&#125; 1234567891011121314151617181920212223242526public class Test &#123; public static void main(String[] args) &#123; DevTechFrontier devTechFrontier = new DevTechFrontier(); Coder coder = new Coder(\"liu\"); Coder coder2 = new Coder(\"lee\"); Coder coder3 = new Coder(\"zhang\"); //注册观察者到观察者列表中 devTechFrontier.addObserver(coder); devTechFrontier.addObserver(coder2); devTechFrontier.addObserver(coder3); //发布消息 devTechFrontier.postNewPublication(\"新一期周报发布啦!\"); &#125;&#125;结果打印：Hi,zhang更新啦，内容是: 新一期周报发布啦!Hi,lee更新啦，内容是: 新一期周报发布啦!Hi,liu更新啦，内容是: 新一期周报发布啦! Observer和Observable是JDK中的内置类型，可见观察者模式是非常重要的，这里Observer是抽象的观察者角色，Coder是具体观察者角色；Observable是抽象的主题角色，DevTechFrontier是具体的主题角色。 总结观察者模式主要的作用就是对象解耦，经观察者与被观察者完全隔离，只依赖于Observer和Observable抽象。 优点 观察者和被观察者之间是抽象耦合，应对业务变化。 增强系统灵活性、可扩展性。 缺点在Java中消息的通知默认是顺序执行的，一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般考虑采用异步的方式。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://liuguoquan727.github.io/tags/设计模式/"}]},{"title":"Android设计模式(五)抽象工厂模式","date":"2016-06-07T13:35:01.000Z","path":"2016/06/07/Android设计模式(五)抽象工厂模式/","text":"介绍抽象工厂模式也是创建型设计模式之一。抽象工厂模式起源于以前对不同操作系统的图形化解决方案，如果不同操作系统中的按钮和文本控件其实现不同、展示效果也不一样，对于每一种操作系统其本身就构成一个产品类，而按钮与文本控件也构成一个产品类，两种产品类两种变化，各自有各自的特性。 定义为创建一组相关或是相互依赖的对象提供一个接口，而不需要指定它们的具体类。 使用场景一个对象族有相同约束时可以使用抽象工厂模式？比如Android、iOS、Window Phone下都有短信软件和拨号软件，两者都属于SoftWare软件范畴，但是它们所在的平台不一样，即便是同一家公司出品的软件，其代码实现逻辑也是不同的，这时就可以考虑使用抽象工厂方法模式来产生Android、iOS、Window Phone下的短信和拨号软件。 UML类图UML类图如下： 主要有四类角色： AbstractFactory：抽象工厂类，它声明了一组用于创建一种产品的方法，每一种方法对应一中产品，类图中分别创建产品A和产品B。 ConcreteFactory：具体工厂类，它实现类在抽象工厂中定义的创建产品的方法，生成一组具体产品，这些产品构成一个产品种类。如类图中的ConcreteFactory1和ConcreteFactory2. AbstractProduct：抽象产品类，它为每种产品声明接口，如类图中的AbstractProductA和AbstractProductB。 ConcreteProduct：具体产品类，它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的方法，如类图中的ConcreteProductA1、ConcreteProductB1、ConcreteProductA2、ConcreteProductB2。 实现在工厂模式中，以小明的车厂为例讲述了工厂方法模式，但是小明后来发现一个问题，虽然Q3、Q5都是一个车系，但是三者之间的零部件差别却是很大，使用了不同的发动机、轮胎、制动系统等零部件。Q3、Q7对应的是一系列车，而发动机、轮胎、制动系统则对应的是一系列零部件，两者是不同的产品类型，这是就可以将抽象工厂模式应用其中，首先，汽车工厂需要生产轮胎、发动机、制动系统这3种部件，然后再根据车型组装这些零部件。 抽象车厂类 12345678910111213141516171819public abstract class CarFactory &#123; /* *生产轮胎 */ public abstract ITire createTire(); /** * 生产发动机 * @return */ public abstract IEngine createEngine(); /** * 生产制动系统 * @return */ public abstract IBrake createBrake();&#125; 下面是零部件产品类： 轮胎相关类 123456789101112131415161718192021222324public interface ITire &#123; public void tire();&#125;public class NormalTire implements ITire &#123; @Override public void tire() &#123; // TODO Auto-generated method stub System.out.println(\"普通轮胎\"); &#125;&#125;public class SUVTire implements ITire&#123; @Override public void tire() &#123; // TODO Auto-generated method stub System.out.println(\"SUV 轮胎\"); &#125;&#125; 发动机相关类 1234567891011121314151617181920212223242526public interface IEngine &#123; public void engine();&#125;public class DomesticEngine implements IEngine &#123; @Override public void engine() &#123; // TODO Auto-generated method stub System.out.println(\"国产发动机\"); &#125;&#125;public class ForeignEngine implements IEngine &#123; @Override public void engine() &#123; // TODO Auto-generated method stub System.out.println(\"进口发动机\"); &#125;&#125; 制动系统相关类 1234567891011121314151617181920212223242526public interface IBrake &#123; public void brake();&#125;public class NormalBrake implements IBrake &#123; @Override public void brake() &#123; // TODO Auto-generated method stub System.out.println(\"普通刹车\"); &#125;&#125;public class SeniorBrake implements IBrake &#123; @Override public void brake() &#123; // TODO Auto-generated method stub System.out.println(\"高级刹车\"); &#125;&#125; 下面是具体车型的生产工厂类: 生产工厂类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Q3工厂类public class Q3Factory extends CarFactory &#123; @Override public ITire createTire() &#123; // TODO Auto-generated method stub return new NormalTire(); &#125; @Override public IEngine createEngine() &#123; // TODO Auto-generated method stub return new DomesticEngine(); &#125; @Override public IBrake createBrake() &#123; // TODO Auto-generated method stub return new NormalBrake(); &#125;&#125;//Q7工厂类public class Q7Factory extends CarFactory &#123; @Override public ITire createTire() &#123; // TODO Auto-generated method stub return new SUVTire(); &#125; @Override public IEngine createEngine() &#123; // TODO Auto-generated method stub return new ForeignEngine(); &#125; @Override public IBrake createBrake() &#123; // TODO Auto-generated method stub return new SeniorBrake(); &#125;&#125; 客户类 12345678910111213141516171819202122232425262728public class Client &#123; public static void main(String[] args) &#123; //构造Q3的工厂 CarFactory factoryQ3 = new Q3Factory(); factoryQ3.createTire().tire();; factoryQ3.createEngine().engine();; factoryQ3.createBrake().brake(); System.out.println(\"--------------------\"); //构造Q7的工厂 CarFactory factoryQ7 = new Q7Factory(); factoryQ7.createTire().tire();; factoryQ7.createEngine().engine();; factoryQ7.createBrake().brake();; &#125;&#125;结果打印：普通轮胎国产发动机普通刹车--------------------SUV 轮胎进口发动机高级刹车 上面只是模拟了Q3和Q7的工厂，如果需要增加Q5的工厂，那么对于的轮胎、制动系统、发动机类又要增加，这里看出抽象工厂类的一个弊端就是类大量增加，如果工厂类过多，势必导致类文件非常多。因此开发中一定要权衡利弊。 总结优点一个显著的优点是分离接口与实现，客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已，使其从具体的产品实现中解耦，同时基于接口与实现的分离，使抽象该工厂方法模式在切换产品类时更加灵活简单。 缺点一是类文件的爆炸性增加，二是不太容易扩展新的产品类，因为每当我们增加一个产品类就需要修改抽象工厂，那么所有的具体工厂类均会修改。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://liuguoquan727.github.io/tags/设计模式/"}]},{"title":"Android设计模式(四)工厂方法模式","date":"2016-06-07T12:34:01.000Z","path":"2016/06/07/Android设计模式(四)工厂方法模式/","text":"介绍工厂方法模式是创建型设计模式之一。工厂方法模式是一种结构简单的模式。 定义定义一个用于创建对象的接口，让子类决定实例化哪个类。 使用场景在任何需要生成复杂对象的地方，都可以使用工厂方法模式。复杂对象适合使用工厂模式，用new就可以完成创建的对象无需使用工厂对象。 UML类图UML类图如下： 这里的角色主要分为四个模块： 抽象工厂Factory，其为工厂方法的核心； 具体工厂ConcreteFactory，实现了具体的业务逻辑； 抽象产品Product，是工厂方法模式所创建的产品的父类； 具体产品ConcreteFactory，实现抽象产品的某个具体产品的对象； 实现小明是一家汽车厂的厂长，对他来说，组装汽车就是讲一些进口的核心部件，比如发动机和一些零部件组装起来，小明的汽车厂主要组装某款SUV车型，比如Q3、Q5，对于这类车型来说内部结构差异并不是很大，因此小明只需要一条生产线就足以应付这2种车型，对于该类生产线小明提供一个抽象类定义： 123456789101112131415/** * 抽象生产线类 * @author Administrator * */public abstract class AudiFactory &#123; /** * 某车型的工厂方法 * @param clz 具体的车型类 * @return 具体型号的车对象 */ public abstract &lt;T extends AudiCar&gt; T createAudiCar(Class&lt;T&gt; clz);&#125; 生产线的具体实现类： 123456789101112131415161718192021222324/** * 生产线具体类 * @author Administrator * */public class AudiCarFactory extends AudiFactory&#123; @Override public &lt;T extends AudiCar&gt; T createAudiCar(Class&lt;T&gt; clz) &#123; // TODO Auto-generated method stub AudiCar car = null; try &#123; car = (AudiCar) Class.forName(clz.getName()).newInstance(); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; return (T) car; &#125;&#125; 对于这两种车型，除了一些车的基本共性之外，还提供了自动导航功能，这些都使用一个抽象的基本类来声明： 1234567891011121314151617/** * 汽车的抽象产品类 * @author Administrator * */public abstract class AudiCar &#123; /** * 行为方法，车可以驾驶 */ public abstract void drive(); /** * 行为方法，车可以自动导航 */ public abstract void selfNavigation();&#125; 接下来就是具体的车型了： 12345678910111213141516171819202122232425262728293031323334public class AudiQ3 extends AudiCar &#123; @Override public void drive() &#123; // TODO Auto-generated method stub System.out.println(\"Q3 run\"); &#125; @Override public void selfNavigation() &#123; // TODO Auto-generated method stub System.out.println(\"Q3 navi\"); &#125;&#125;public class AudiQ5 extends AudiCar &#123; @Override public void drive() &#123; // TODO Auto-generated method stub System.out.println(\"Q5 run\"); &#125; @Override public void selfNavigation() &#123; // TODO Auto-generated method stub System.out.println(\"Q5 navi\"); &#125;&#125; 最后我们将各个类组装起来形成一条完整的流水线： 123456789101112131415161718192021222324public class Client &#123; public static void main(String[] args) &#123; AudiFactory factory = new AudiCarFactory(); AudiQ3 audiQ3 = factory.createAudiCar(AudiQ3.class); audiQ3.drive(); audiQ3.selfNavigation(); AudiQ5 audiQ5 = factory.createAudiCar(AudiQ5.class); audiQ5.drive(); audiQ5.selfNavigation(); &#125;&#125;结果打印：Q3 runQ3 naviQ5 runQ5 navi 总结总的来说，工厂方法模式是一个很好的设计模式，但是也存在缺点，就是每次我们为工厂方法模式添加新的产品时就要编写一个新的产品类，同时还要引入抽象层，这必然导致类结构的复杂化，所以工作中需要权衡。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://liuguoquan727.github.io/tags/设计模式/"}]},{"title":"Android设计模式之(三)原型模式","date":"2016-06-04T14:34:01.000Z","path":"2016/06/04/Android设计模式之(三)原型模式/","text":"介绍原型模式是一种创建型的模式。原型表示该模式有一个样板实例，用户从这个样板对象中复制出一个内部属性一致的对象，被复制的实例就称为原型。原型模式多用于创复杂的或者构造耗时的实例，因为这种情况下，复制一个已经存在的实例可以使程序运行更高效。 定义用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。 使用场景 类初始化需要消耗非常多的资源，包括数据、硬件资源等，通过原型拷贝避免这些消耗。 通过new产生一个对象需要非常繁琐的数据准备或访问权限，这时可以使用原型模式。 一个对象需要提供给其他对象访问，而且各个调用者可能需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用，即保护性拷贝。 需要注意的是，通过实现Cloneable接口的原型模式在调用clone函数构造实例时并不一定比通过new操作速度快，只有当通过new构造对象较为耗时或者资源消耗比较大时，通过clone方法才能获得效率上的提升。因此，使用Cloneable时需要考虑构建对象的成本以及做一些效率上的测试。当然，实现原型模式也并不一定非要实现Cloneable接口，也有其他的实现方式。 UML类图原型模式的UML类图如下： 角色介绍： Client：客户端用户 Prototype：抽象类或者接口，声明具clone的能力 ConcretePrototype：具体的原型类 实现下面以简单的文档拷贝为例来演示一下简单的原型模式，例子中首先创建一个文档对象，即WordDocument，这个文档包括文字和图片。用户经过产时间的内容编辑后，打开该文档做进一步的编辑，但是这个文档编辑后是否被采用还不确定，因此为了安全起见，用户需要将当前文档拷贝一份，然后再在这个文档副本上进行修改。如下所示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.lgq.pattern.prototype;import java.util.ArrayList;/** * 文档类型，扮演的是ConcretePrototype角色，而Cloneable是代表Prototype角色 * @author liuguoquan * */public class WordDocument implements Cloneable&#123; //文本 private String text; //图片名列表 private ArrayList&lt;String&gt; images = new ArrayList&lt;&gt;(); public WordDocument() &#123; // TODO Auto-generated constructor stub System.out.println(\"---WordDocument构造函数---\"); &#125; public String getText() &#123; return text; &#125; public void setText(String text) &#123; this.text = text; &#125; public ArrayList&lt;String&gt; getImages() &#123; return images; &#125; public void addImage(String image) &#123; images.add(image); &#125; @Override protected WordDocument clone() &#123; // TODO Auto-generated method stub try &#123; WordDocument document = (WordDocument) super.clone(); document.text = this.text; //浅拷贝 document.images = this.images; //深拷贝// document.images = (ArrayList&lt;String&gt;) this.images.clone(); return document; &#125; catch (Exception e) &#123; // TODO: handle exception &#125; return null; &#125; @Override public String toString() &#123; return \"WordDocument [text=\" + text + \", images=\" + images + \"]\"; &#125;&#125;package com.lgq.pattern.prototype;public class Client &#123; public static void main(String[] args) &#123; WordDocument document = new WordDocument(); document.setText(\"这是一篇文档\"); document.addImage(\"image1\"); document.addImage(\"image2\"); System.out.println(document.toString()); //拷贝一份副本 WordDocument document2 = document.clone(); System.out.println(document2.toString()); //修改文档副本，不会影响原始文档 document2.setText(\"这是修改过的document2文档\"); System.out.println(document2.toString()); System.out.println(document.toString()); &#125;&#125;打印结果：---WordDocument构造函数---WordDocument [text=这是一篇文档, images=[image1, image2]]WordDocument [text=这是一篇文档, images=[image1, image2]]WordDocument [text=这是修改过的document2文档, images=[image1, image2]]WordDocument [text=这是一篇文档, images=[image1, image2]] 需要注意的是，上述的例子中WordDocument的构造函数只运行了一次，通过clone拷贝对象时并不会执行构造函数！ 总结原型模式本质上是对象拷贝，容易出现的问题是深拷贝、浅拷贝。使用原型模式可以解决构建复杂对象的资源消耗问题，能够在某些场景下提升创建对象的效率。还有一个重要用途就是保护性拷贝，也就是某个对象对外可能是只读的，为了防止外部对这个只读对象修改，通过可以通过返回一个对象拷贝的形式实现只读的限制。 优点原型模式是在内存中二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。 缺点直接在内存中拷贝时，构造函数是不会执行的，在实际开发中应该注意这个潜在的问题。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://liuguoquan727.github.io/tags/设计模式/"}]},{"title":"Android设计模式之(二)Builder模式","date":"2016-06-03T13:34:01.000Z","path":"2016/06/03/Android设计模式之(二)Builder模式/","text":"介绍Builder模式是一步一步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，更精细地控制对象的构造流程。该模式是为了将构建复杂对象的过程和它的部件解耦，使得构建过程和部件的表示隔离开来。 定义将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 使用场景 相同的方法，不同的执行顺序，产生不同的事件结果时； 多个部件或零件都可以装配到一个对象中，但是产生的运行结果又不相同时； 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用，这个时候使用建造者模式非常适合； 当初始化一个对象特别复杂，如参数多，且很多参数都具有默认值的情况下； UML类图UML类图角色介绍： Product产品类-产品的抽象类； Builder-抽象Builder类，规范产品的组建，一般由子类实现具体的组件过程； ConcreteBuilder-具体的Builder类,组装对象； 简单实现123456789101112131415161718192021222324252627282930313233343536package com.lgq.pattern.builder;/** * Computer抽象类 即 Product角色 * @author liuguoquan * */public abstract class Computer &#123; protected String mBoard; protected String mDisplay; protected String mOS; public Computer() &#123; &#125; //设置主板 public void setBoard(String mBoard) &#123; this.mBoard = mBoard; &#125; //设置显示器 public void setDisplay(String mDisplay) &#123; this.mDisplay = mDisplay; &#125; //设置操作系统 public abstract void setOs(); @Override public String toString() &#123; return \"Computer [mBoard=\" + mBoard + \", mDisplay=\" + mDisplay + \", mOS=\" + mOS + \"]\"; &#125;&#125; 12345678910111213141516171819package com.lgq.pattern.builder;/** * 具体的Computer类 * @author liuguoquan * */public class MacBookPro extends Computer&#123; public MacBookPro() &#123; // TODO Auto-generated constructor stub &#125; @Override public void setOs() &#123; // TODO Auto-generated method stub mOS = \"Mac OS X 10.11\"; &#125;&#125; 123456789101112131415package com.lgq.pattern.builder;/** * 抽象Builder * @author liuguoquan * */public abstract class Builder &#123; public abstract Builder setBoard(String board); public abstract Builder setDisplay(String display); public abstract Builder setOs(); public abstract Computer create();&#125; 123456789101112131415161718192021222324252627282930313233343536373839package com.lgq.pattern.builder;/** * Builder具体实现类 * @author liuguoquan * */public class MacBookBuilder extends Builder &#123; private Computer mComputer = new MacBookPro(); @Override public Builder setBoard(String board) &#123; // TODO Auto-generated method stub mComputer.setBoard(board); return this; &#125; @Override public Builder setDisplay(String display) &#123; // TODO Auto-generated method stub mComputer.setDisplay(display); return this; &#125; @Override public Builder setOs() &#123; // TODO Auto-generated method stub mComputer.setOs(); return this; &#125; @Override public Computer create() &#123; // TODO Auto-generated method stub return mComputer; &#125;&#125; 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Computer computer = new MacBookBuilder().setBoard(\"APPLE\").setDisplay(\"Retina\").setOs().create(); System.out.println(computer.toString()); &#125;&#125;结果打印：Computer [mBoard=APPLE, mDisplay=Retina, mOS=Mac OS X 10.11] 上述示例中，通过具体的MacBookBuilder来构建MacBookPro对象，Builder将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的对象。 Android中应用 AlertDialog 总结优点 良好的封装性，使用建造者模式可以使得客户端不必知道产品内部组成的细节。 建造者独立，容易扩展 缺点会产生多余的Builder对象，消耗内存。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://liuguoquan727.github.io/tags/设计模式/"}]},{"title":"Android设计模式之(一)单例模式","date":"2016-06-03T12:34:01.000Z","path":"2016/06/03/Android设计模式之(一)单例模式/","text":"概述单例模式是应用最广的模式之一，在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个全局对象，这样有利于我们协调系统整体的行为。如在一个应用中，应该只有一个ImageLoader实例，这个ImageLoader中又含有线程池、缓存系统、网络请求等，很消耗资源。因此不应该让它构造多个实例。这样不能自由构造对象的情况，就是单例模式的使用场景。 定义确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 使用场景确保某个类有且只要一个对象的场景，避免产生多个对象消耗过多的资源，或者某种类型的对象只应该有且只有一个。例如，创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源，这时就要考虑使用单例模式。 UML类图单例模式的UML类图如下： 角色介绍： Client：高层客户端 Singleton：单例类 实现单例模式主要有以下几个关键点： 构造函数不对外开放，一般为private； 通过一个静态方法或者枚举返回单例类对象； 确保单例类的对象有且只有一个，尤其是在多线程环境下； 确保单例类对象在反序列化时不会重新构建对象； 单例模式中实现比较困难的是在多线程环境下构造单例类的对象有且只有一个。 简单示例单例模式在设计模式中是结构比较简单的，只有一个单例类，没有其他层次结构和抽象。该模式需要确保该类只能生成一个对象，通常是该类需要消耗较多的资源或者没有对个实例的情况。例如一个公司只有一个CEO、一个应用只有一个Application对象等。 下面以公司里的CEO为例来简单演示一下，一个公司可以有多个VP、无数个员工，但只有一个CEO，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * * 普通员工 * */public class Staff &#123; public void work() &#123; //干活 &#125;&#125;//副总裁public class VP extends Staff &#123; @Override public void work() &#123; // 管理下面的经理 &#125;&#125;//CEO，饿汉式单例public class CEO extends Staff &#123; private static final CEO mCEO = new CEO(); private CEO() &#123; &#125; //公有的静态函数，对外暴露获取单例对象的接口 public static CEO getCeo() &#123; return mCEO; &#125; @Override public void work() &#123; // 管理VP &#125;&#125;//公司类public class Company &#123; private List&lt;Staff&gt; mStaffs = new ArrayList&lt;Staff&gt;(); public void addStaff(Staff staff) &#123; mStaffs.add(staff); &#125; public void showStaffs() &#123; for(Staff staff : mStaffs) &#123; System.out.println(\"Obj: \" + staff.toString()); &#125; &#125;&#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub Company company = new Company(); //CEO对象只能通过getCeo获取 Staff ceo1 = CEO.getCeo(); Staff ceo2 = CEO.getCeo(); company.addStaff(ceo1); company.addStaff(ceo2); Staff vp1 = new VP(); Staff vp2 = new VP(); company.addStaff(vp1); company.addStaff(vp2); Staff staff1 = new Staff(); Staff staff2 = new Staff(); company.addStaff(staff1); company.addStaff(staff2); company.showStaffs(); &#125; 运行输出结果如下： 123456Obj: com.liuguoquan.design.single.CEO@15db9742Obj: com.liuguoquan.design.single.CEO@15db9742Obj: com.liuguoquan.design.single.VP@6d06d69cObj: com.liuguoquan.design.single.VP@7852e922Obj: com.liuguoquan.design.single.Staff@4e25154fObj: com.liuguoquan.design.single.Staff@70dea4e 从上面代码可以看出，CEO类不能通过new的形式构造函数，只能通过CEO.getCeo()方法来获取，而这个CEO对象是静态对象，并且在声明的时候就已经初始化，这就保证类CEO对象的唯一性。 从输出结果中可以看出，CEO两次输出的CEO对象的地址都一样，说明是同一个CEO对象；而VP、Staff等类型的对象都是不同的。 实现方式饿汉式饿汉式模式是在声明静态对象时就已经初始化，这种方式简单粗暴，如果单例对象初始化非常快，而且占用内存小的时候这种方式是比较适合的，可以直接在应用启动时加载初始化。实现如下： 123456789101112public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton() &#123; &#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 懒汉式懒汉模式是声明一个静态对象，并且在用户第一次调用getInstance时进行初始化。 1234567891011121314151617public class Singleton &#123; private static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; synchronized(Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; getInstance方法中添加了Synchronized关键字，也就是同步类synchronized关键字包含的代码块，这就是上面所说的在多线程中保证单例对象唯一性的手段。但是仍存在一个问题，即使instance已经初始化，每次调用getInstance方法都会进行同步，这样会消耗不必要的资源，这也是懒汉式存在的最大问题。 懒汉单例模式的优点是只有在使用时才会被实例化，在一定程度上节约了资源，缺点是第一次加载时需要及时进行实例化，反应稍慢，最大问题是每次调用geInstance都进行同步，造成不必要的同步开销，这样模式一般不建议使用。 Double CheckLock(双重校验锁)DCL方式的优点是既能够在需要时才初始化单例，又能够保证线程的安全，且单例对象初始化后调用getInstance不获取同步锁。 1234567891011121314151617181920public class Singleton &#123; //private static volatile Singleton instance = null; private static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; //如果已经初始化，不需要每次获取同步锁 if(instance == null) &#123; synchronized(Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 可以看到getInstance方法对instance进行了两次判空：第一层判断主要是为了避免不必要的同步，第二层判断主要则是为了在null的情况下创建实例。下面，我们来分析一下： 假设线程A执行到instance=new Singleton()语句，这里看起来是一句代码，但实际上它并不是一个原子操作，这局代码最终会被编译成多条汇编指令，它大致做了3件事情： 给Singleton的实例分配内存 调用Singleton()的 构造函数，初始化字段成员 将instance对象执行分配的内存空间（此时instance就不是null了） 但是，由于Java编译器运行处理器乱序执行，以及jdk1.5之前Java内存模型中Cache、寄存器到主内存会写顺序的规定，上面的第二和第三的顺序是无法保证的。也就是说，执行顺序可能是1-2-3也可能是1-3-2.如果是后者，并且在3执行完毕、2未执行之前，被切换到线程B上，这时候instance因为已经在线程A内执行3了，instance已经是非null，所有线程B直接取走instance，再使用时就会出错，这就是DCL失效问题，而且这种难以跟踪难以重现的问题很可能会隐藏很久。 在jdk1.5之后，官方已经注意到这种问题，调整了JMM、具体化了volatile关键字，因此，如果是1.5或之后的版本，只需要将instance的定义改成private static volatile Singleton instance = null;就可以保证instance对象每次都是从主内存中读取，就可以使用DCL的写法来完成单例模式。当然，volatile多少会影响到性能，但考虑到程序的正确性，牺牲这点性能还是值得的。 DCL的优点：资源利用率高，第一次执行getInstance时单例对象才会被实例化，效率高。 缺点：第一次加载稍慢，也由于Java内存模型的原因偶尔会失败。在高并发的环境下也有一定的缺陷，虽然概率发生很小。 DCL模式是使用最多的单例实现模式，它能够在需要时才实例化单例对象，并且能够在绝大多数场景下保证单例对象的唯一性，除非你的代码在并发场景比较复杂或者低于jdk1.6版本下使用，否则这种方式一般能够满足需求。 静态内部类单例模式在《Java并发编程实战》中谈到不赞成使用DCL的优化方式，而建议使用如下代码替代： 12345678910111213public class Singleton &#123; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; return SingletonHolder.instance; &#125; //静态内部类 private static class SingletonHolder &#123; private static final Singleton instance = new Singleton(); &#125;&#125; 当第一次加载Singleton类时并不会初始化instance，只有第一次调用Singleton的getInstance方法时才会导致instance被初始化。因此，第一次调用getInstance方法会导致虚拟机加载SingletonHolder类，这种方式不仅能够确保线程安全，也能够保证单例对象的唯一性，同时也延迟了单例的实例化，所以这是推荐使用的单例模式实现方式。 枚举单例123456789101112131415public enum Singleton &#123; //定义一个枚举的元素，它就是Singleton的一个实例 INSTANCE; public void doSomething() &#123; &#125;&#125;//使用public static void main(String[] args)&#123; Singleton singleton = Singleton.instance; singleton.doSomething();&#125; 写法简单是枚举单例最大的优点，枚举在Java中与普通的类是一样的，不仅能够有字段，还能够有自己的方法。最重要的是默认枚举实例的创建时线程安全的，并且在任何情况下它都是一个单例。 为什么这么说呢？在上述的几种单例模式实现中，在一个情况下它们会出现重新创建对象的情况，那就是反序列化。 通过序列化可以将一个单例的实例对象写到磁盘，然后再读回来，从而有效地获得一个实例。即使构造函数时私有的，反序列化时依然可以通过特殊的途径去创建类的一个新的实例，相当于调用该类的构造函数。反序列化操作提供一个很特别的钩子函数，类中具有一个私有的、被实例化的方法readResolve()，这个方法可以让开发人员控制对象的反序列化。例如，上述几个实例中如果要杜绝单例对象在被反序列化时重新生成对象，那么必须加入如下方法： 123private Object readResolve() throws ObjectStreamException &#123; return instance;&#125; 也就是在readResolve方法中将instance对象返回，而不是默认的重新生成一个新的对象。而对于枚举并不存在这样的问题，因为即使反序列化它也不会重新生成新的实例。 容器管理单例1234567891011121314public class SingletonManager &#123; private static Map&lt;String,Object&gt; objMap = new HashMap&lt;String,Object&gt;(); public static void registerService(String key,Object instance) &#123; if (!objMap.containsKey(key)) &#123; objMap.put(key); &#125; &#125; public static getInstance(String key) &#123; return objMap.get(key); &#125;&#125; 在程序的初始，将多种单例类注入到一个统一的管理类中，在使用根据key获取对应类型的对象，这种方式使得我们可以管理很多类型的单例，并且在使用它们的时候可以通过统一的接口进行获取操作操作，降低用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。 总结单例模式是运用频率很高的模式，但是，由于在客户端通常没有高并发的情况，因此，选择哪种实现方式并不会有太大的影响。即便如此，出于效率考虑，推荐使用双重校验锁和静态内部类单例模式。 优点 由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁创建、销毁时，而且创建或者销毁时性能又无法优化，单例模式的优势就非常明显。 由于单例模式只生成一个实例，所以，减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永驻内存的方式解决。 单例模式可以避免对资源的多重占用，例如一个写文件操作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。 单例模式可以在系统设置全局访问点，优化和共享资源访问，例如，可以设计一个单例类，负责所有数据表的映射处理。 缺点： 单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本没有第二种途径可以实现。 在Android中，单例对象如果持有Context，那么很容易引发内存泄露，此时需要注意传给单例对象的Context最好是Application Context。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://liuguoquan727.github.io/tags/设计模式/"}]},{"title":"Android Context详解","date":"2016-06-02T13:20:28.000Z","path":"2016/06/02/Android Context详解/","text":"前言Activity可以new吗？Android的应用程序开发采用Java语言，Activity本质上也是一个对象，那Activity activity = new Activity()这种写法有什么问题吗？Android应用模型是基于组件的设计模式，组件的运行需要有一个完整的Android工程环境，在这个环境下，Activity、Service等系统组件才能够正常工作，而这些组件并不能采用普通的Java对象创建方式，new一下就能创建实例，而是要有它们各自的上下文环境，也就是我们要介绍的Context。可以这样讲，Context是维持Android程序中各组件能够正常工作的一个核心功能类。 源码中的Context12345678910111213141516171819202122232425262728/** * Interface to global information about an application environment. This is * an abstract class whose implementation is provided by * the Android system. It * allows access to application-specific resources and classes, as well as * up-calls for application-level operations such as launching activities, * broadcasting and receiving intents, etc. */public abstract class Context &#123; /** * File creation mode: the default mode, where the created file can only * be accessed by the calling application (or all applications sharing the * same user ID). * @see #MODE_WORLD_READABLE * @see #MODE_WORLD_WRITEABLE */ public static final int MODE_PRIVATE = 0x0000; public static final int MODE_WORLD_WRITEABLE = 0x0002; public static final int MODE_APPEND = 0x8000; public static final int MODE_MULTI_PROCESS = 0x0004; . . . &#125; 源码中的注释是这么来解释Context的：Context提供了关于应用环境全局信息的接口。它是一个抽象类，它的执行被Android系统所提供，它允许获取以应用为特征的资源和类型，是一个统领一些资源的上下文。就是说，它描述一个应用程序环境的信息（即上下文），是一个抽象类，Android提供了该抽象类的具体实现类；通过它我们可以获取应用程序的资源和类（包括应用级别操作，如启动Activity，发广播，接受Intent等）。既然上面Context是一个抽象类，那么肯定有他的实现类，Context抽象类的继承关系如下图所示： Context类本身是一个纯abstract类，它有两个具体的实现子类：ContextImpl和ContextWrapper。其中ContextWrapper类，如其名所言，这只是一个包装而已，ContextWrapper构造函数中必须包含一个真正的Context引用，同时ContextWrapper中提供了attachBaseContext（）用于给ContextWrapper对象中指定真正的Context对象，调用ContextWrapper的方法都会被转向其所包含的真正的Context对象。ContextThemeWrapper类，如其名所言，其内部包含了与主题（Theme）相关的接口，这里所说的主题就是指在AndroidManifest.xml中通过android：theme为Application元素或者Activity元素指定的主题。当然，只有Activity才需要主题，Service是不需要主题的，因为Service是没有界面的后台场景，所以Service直接继承于ContextWrapper，Application同理。而ContextImpl类则真正实现了Context中的所以函数，应用程序中所调用的各种Context类的方法，其实现均来自于该类。一句话总结：Context的两个子类分工明确，其中ContextImpl是Context的具体实现类，ContextWrapper是Context的包装类。Activity，Application，Service虽都继承自ContextWrapper（Activity继承自ContextWrapper的子类ContextThemeWrapper），但它们初始化的过程中都会创建ContextImpl对象，由ContextImpl实现Context中的方法。 一个应用程序有几个Context从上面的关系图可知，在应用程序中Context的具体实现子类就是：Activity、Service、Application。那么context数量 = Activity数量 + Service数量 + 1；而四大组件中BroadcastReceiver和ContentProvider并不是Context的子类，他们所持有的Context都是其他地方传过去的，所以并不计入Context总数。 Context作用弹出Toast、启动Activity、启动Service、发送广播、操作数据库等都需要用到Context。 12345678910111213141516//实例化控件TextView tv = new TextView(getContext());ListAdapter adapter = new SimpleCursorAdapter(getApplicationContext(), ...);AudioManager am = (AudioManager) getContext().getSystemService(Context.AUDIO_SERVICE);getApplicationContext().getSharedPreferences(name, mode);getApplicationContext().getContentResolver().query(uri, ...);getContext().getResources().getDisplayMetrics().widthPixels * 5 / 8;getContext().startActivity(intent);getContext().startService(intent);getContext().sendBroadcast(intent); Context作用域由于Context的具体实例是由ContextImpl类去实现的，因此自绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity、还有弹出Dialog，出于安全的考虑，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，形成返回栈，而Dialog则必须在一个Activity上面弹出（除非是System Alert类型的Dialog），因此在这种场景下，我们只能用Activity类型的Context，否则将会出错。 这里说一下上图中Application和Service所不推荐的两种使用情况。 如果我们用ApplicationContext去启动一个LaunchMode为standard的Activity的时候会报错android.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?这是因为非Activity类型的Context并没有所谓的任务栈，所以待启动的Activity就找不到栈了。解决这个问题的方法就是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就为它创建一个新的任务栈，而此时Activity是以singleTask模式启动的。所有这种用Application启动Activity的方式不推荐使用，Service同Application。 在Application和Service中去layout inflate也是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。所以这种方式也不推荐使用。 一句话总结：凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。 获取Context通常我们想要获取Context对象，主要有一下四种方法。 View.getContext，返回当前View对象的Context对象，通常是正在显示的Activity对象。 Activity.getApplicationContext，获取当前Activity所在的应用进程的Context对象，通常我们使用Context对象时要优先考虑这个全局的进程Context。3.ContextWrapper.getBaseContext()，用来获取一个ContextWrapper进行装饰之前的Context，可以使用这个方法，一般不建议使用 Activity.this，返回当前的Activity实例，如果是UI控件需要使用Activity作为Context对象，但是默认的Toast实际上使用ApplicationContext也可以。 getApplication()和getApplicationContext()获取当前Application对象用getApplicationContext，不知道你有没有联想到getApplication()，这两个方法有什么区别？ 程序是不会骗人的，我们通过上面的代码，打印得出两者的内存地址都是相同的，看来它们是同一个对象。其实这个结果也很好理解，因为前面已经说过了，Application本身就是一个Context，所以这里获取getApplicationContext()得到的结果就是Application本身的实例。那么问题来了，既然这两个方法得到的结果都是相同的，那么Android为什么要提供两个功能重复的方法呢？实际上这两个方法在作用域上有比较大的区别。getApplication()方法的语义性非常强，一看就知道是用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法了。 123456789public class MyReceiver extends BroadcastReceiver &#123; @Override publicvoidonReceive(Contextcontext,Intentintent)&#123; ApplicationmyApp=(Application)context.getApplicationContext();&#125;&#125; Context引起的内存泄露Context并不能随便乱用，用的不好有可能会引起内存泄露的问题，下面就示例两种错误的引用方式。 错误的单例模式 123456789101112131415public class Singleton &#123; private static Singleton instance; private Context mContext; private Singleton(Context context) &#123; this.mContext = context; &#125; public static Singleton getInstance(Context context) &#123; if (instance == null) &#123; instance = new Singleton(context); &#125; return instance; &#125;&#125; 这是一个非线程安全的单例模式，instance作为静态对象，其生命周期要长于普通的对象，其中也包含Activity，假如Activity A去getInstance获得instance对象，传入this，常驻内存的Singleton保存了你传入的Activity A对象，并一直持有，即使Activity被销毁掉，但因为它的引用还存在于一个Singleton中，就不可能被GC掉，这样就导致了内存泄漏。 View持有Activity的引用 123456789101112public class MainActivity extends Activity &#123; private static Drawable mDrawable; @Override protected void onCreate(Bundle saveInstanceState) &#123; super.onCreate(saveInstanceState); setContentView(R.layout.activity_main); ImageView iv = new ImageView(this); mDrawable = getResources().getDrawable(R.drawable.ic_launcher); iv.setImageDrawable(mDrawable); &#125;&#125; 有一个静态的Drawable对象当ImageView设置这个Drawable时，ImageView保存了mDrawable的引用，而ImageView传入的this是MainActivity的mContext，因为被static修饰的mDrawable是常驻内存的，MainActivity是它的间接引用，MainActivity被销毁时，也不能被GC掉，所以造成内存泄漏。 正确使用Context一般Context造成的内存泄漏，几乎都是当Context销毁的时候，却因为被引用导致销毁失败，而Application的Context对象可以理解为随着进程存在的，所以我们总结出使用Context的正确姿势： 当Application的Context能搞定的情况下，并且生命周期长的对象，优先使用Application的Context。 不要让生命周期长于Activity的对象持有到Activity的引用。 尽量不要在Activity中使用非静态内部类，因为非静态内部类会隐式持有外部类实例的引用，如果使用静态内部类，将外部实例引用作为弱引用持有。 获取全局Application123456789101112131415public class MyApplication extends Application &#123; private static MyApplication app; public static MyApplication getInstance() &#123; return app; &#125; @Override public void onCreate() &#123; super.onCreate(); app = this; &#125; &#125; Application全局只有一个，它本身就已经是单例了，无需再用单例模式去为它做多重实例保护了,getInstance()方法里面不要做任何逻辑判断，直接返回app对象就可以了，而app对象又是什么呢？在onCreate()方法中我们将app对象赋值成this，this就是当前Application的实例，那么app也就是当前Application的实例了。 参考文章： Context都没弄明白，还怎么做Android开发？","tags":[{"name":"Android系统","slug":"Android系统","permalink":"http://liuguoquan727.github.io/tags/Android系统/"}]},{"title":"View的事件分发机制","date":"2016-04-26T13:22:52.000Z","path":"2016/04/26/Android-View的事件分发机制/","text":"点击事件的传递规则首先明确我们这里要分析的对象就是MotionEvent，及点击事件。所谓点击事件的事件分发，其实就是对MotionEvent事件的分发过程，即当一个MotionEvent事件产生了以后，系统需要把这个事件传递给一个具体的View，而这个传递的过程就是分发过程。点击事件的分发过程由三个很重要的方法来共同完成：dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent。 public boolean dispatchTouchEvent(MotionEvent event) 用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级的dispatchTouchEvent方法的影响，表示是否消耗此事件 public boolean onInterceptTouchEvent(MotionEvent event) //view无此方法，存在于ViewGroup中 用来判断是否拦截某个事件，如果当前View拦截某个事件，那么在同一个事件序列中，次方法将不会被再次调用，返回结果表示是否拦截某个事件。 public boolean onTouchEvent(MotionEvent event) 在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件 上述三个方法到底有什么区别呢？它们是什么关系呢？下面通过一段伪代码来表示： 1234567891011121314151617public boolean dispatchTouchEvent(MotionEvent event) &#123; public consume = false; if(onInterceptTouchEvent(ev)) &#123; consume = onTouchEvent(ev); &#125; else &#123; consume = chiled.dispatchTouchEvent(ev); &#125; return consume;&#125; 通过上面的伪代码，我们可以大致了解点击事件的传递规则：对已一个跟ViewGroup来说，点击事件产生以后，首先会传递给它，这是它的dispatchTouchEvent就会被调用，如果这个ViewGroup的onInterceptTouchEvent方法返回true就表示它要拦截当前事件，接着事件就会交给这个ViewGroup的onTouchEvent方法就会被调用；如果这个ViewGroup的onInterceptTouchEvent方法返回false就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispatchTouchEvent方法就会被调用，如此反复直到事件被最终处理。 当一个View需要处理事件时，如果它设置了OnTouchListener，那么OnTouchListener中的OnTouch方法就会被回调，事件如何处理还要看onTouch的返回值，如果返回值为false，则当前View的OnTouchEvent方法会被调用；如果返回为true，则当前View的OnTouchEvent方法不会被调用。由此可见，给View设置的OnTouchListener，其优先级比onTouchEvent要高。在OnTouchEvent方法中，如果当前设置的有OnClickListener，那么它的onClick方法会被调用。可以看出，平时使用的OnClickListener其优先级最低，即处于事件的尾端。 当一个点击事件产生后，它的传递过程遵循如下顺序：Activity &gt; Window &gt; View，即事件总是先传递到Activity。Activity再传递给Window，最后Window再传递给顶级View，顶级View接收到事件后，就会按照事件分发机制去分发事件。 考虑一种情况，如果一个View的OnTouchEvent都返回false，那么它的父容器的OnTouchEvent将会被调用，依次类推，如果所有的子元素都不处理这个事件，那么这个事件将会最终传递给Activity处理，即Activity的OnTouchEvent将会被调用。我们可以用实际生活的例子来描述：假如点击事件是一个难题，这个难题最终被上级领导分给了一个程序员去处理（这是事件分发过程），结果这个程序员搞不定（OnTouchEvent返回false），现在该怎么办呢？程序员只能交给水平更高的程序员去解决（上级的OnTouchEvent被调用），如果上级再搞不定，那只能交给上级的上级去解决，这样就将难题一层层的向上抛，这是公司内部一种很常见的处理问题的过程。 关于事件传递的机制，这里给出一些结论，根据这些揭露可以更好地理解整个传递机制： （1）同一个事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束。在这个过程中产生了一系列事件，这个时间序列以down事件开始，中间含有数量不定的move事件，最终以up事件结束。 （2）正常情况下，一个事件序列只能被一个View拦截并且消耗。这一条的原因可以参考（3），因为一旦一个元素拦截了某此事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一个事件序列中的事件不能分别由两个View同时处理，但是通过特殊手段可以做到，比如一个View将本该自己处理的事件通过OnTouchEvent强行传递给其他View处理。 （3）某个View一旦决定拦截，那么这个事件的序列的搜只能由它来处理（如果事件序列能够传递给它的话），并且它的onInterceptTouchEvent方法不会再被调用。就是说当一个View决定拦截一个事件后，那么系统会把同一个事件序列的其他方法都直接交给它来处理，因此就不用再调用这个View的OnInterceptTouchEvent其询问它是否要拦截了。 （4）某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件（onTouchEvent返回了false），那么同一个事件序列中的其他事件都不会再交给它来处理。并且事件将重新交由它的父元素去处理，即父元素的OnTouchEvent会被调用。意思就是事件一旦交给一个View处理，那么它就必须消耗掉，否则同一事件序列中剩下的事件就不再交给它来处理了。 （5）如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件将会消失，此时父元素的OnTouchEvent并不会被调用，并且当前View可以持续受到后续的事件，最终这些消失的点击事件会传递给Activity处理。 （6）ViewGroup默认不拦截任何事件。Android源码中ViewGroup的OnInterceptTouchEvent方法默认返回false （7）View没有OnInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的OnTouchEvent方法就会被调用 （8）View的OnTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable默认为true，而TextView的clickable属性默认为false。 （9）View的enable属性不影响OnTouchEvent的默认返回值，哪怕一个View是disable状态的，只要它的clickable和longClickable有一个为true，那么它的OnTouchEvent就返回true。 （10）onClick会发生的前提是当前View是可点击的，并且收到了down和up事件 （11）事件传递过程是由外向内的，即事件总是先传递给父元素，然后再有父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。 事件分发的源码解析Activity对点击事件的分发过程点击事件用MotionEvent来表示，当一个点击操作发生时，事件最先传递给当前Activity，由Activity的dispatchTouchEvent来进行事件分发，具体的工作是由Activity内部的Window来完成的。Window会将事件传递给decor view，decor view一般就是当前界面的底层容器（即setContentView所设置的View的父容器），通过Activity.getWindow。getDecorView()可以获得。先从Activity的dispatchTouchEvent开始分析。 源码：Activity#dispatchTouchEvent 123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; 分析上面的代码。首先事件交给Activity所附属的Window进行分发，如果返回true，整个事件就循环结束了，返回false以为着事件没人处理，所有View的onTouchEvent都返回了false，那么Activity的onTouchEvent就会被调用 接下里看Window是如何将事件传递给ViewGroup的。Window是是个抽象类，而Window的superDispatchTouchEvent方法也是个抽象方法，因此我们必须找到Window的实现类才行 源码：Window#superDispatchTouchEvent 1public abstract boolean superDispatchTouchEvent(MotionEvent event); 到底Window的实现类是什么呢？其实是PhoneWindow，Window的唯一实现是android.policy.Window，接下来看一下PhoneWindow是如何处理点击事件的， 源码：PhoneWindow#superDispatchTouchEvent 12345private DecorView mDecor;public boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);&#125; PhoneWindow将事件直接传递给了DecorView，这个DecorView是什么呢？ 123456789private final class DecorView extends FrameLayout implements RootViewSurfaceTaker@Overridepublic final View getDecorView() &#123; if (mDecor == null) &#123; installDecor(); &#125; return mDecor;&#125; 可以看出，这个mDecor就是通过getWindow().getDecor()返回的View，而我们通过setContentView设置的View是它的一个子View。目前事件传递到了DecorView这里，由于DecorView继承自FrameLayout且是父View，所有最终事件会传递到View。换句话说，事件肯定会传递到View，不然应用如何响应点击事件呢？重点是事件到了View以后该如何传递。从这里开始，事件已经传递到顶级View了，即在Activity中通过setContentView所设置的View，另外顶级View也叫根View，顶级View一般来说都是ViewGroup。 顶级View对点击事件的分发过程点击事件达到顶级View以后，会调用ViewGroup的dispatchTouchEvent方法，然后逻辑是这样的：如果顶级ViewGroup拦截事件即OnInterceptTouchEvent返回true，则事件由ViewGroup处理，这时如果ViewGroup的OnTouchListener被设置，则onTouch被调用，否则onTouchEvent被调用，也就是说两者都设置的话，onTouch会屏蔽掉OnTouchEvent。在OnTouchEvent中如果设置了OnClickListener，则OnClick会被调用。如果顶级ViewGroup不拦截事件，则事件会传递给它所在的点击事件链上的子View，这时子View的dispatchTouchEvent会被调用。到此，事件已经从顶级View传递给下一层View，接下来的传递过程和顶级View是一致的，如此循环完成整个事件的分发。 首先看ViewGroup对点击事件的分发过程，其主要实现在ViewGroup的dispatchTouchEvent方法中，这个方法较长。先看下面一段，它描述的是View是否拦截点击事件这个逻辑 1234567891011121314151617// Check for interception.final boolean intercepted;if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125;&#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true;&#125;` 从上面的代码可以看出，ViewGroup在如下两种情况下会判断是否要拦截当前事件：事件类为ACTION_DOWN或者mFirstTouchTarget ！= null，mFirstTouchTarget ！= null是什么意思了？当ViewGroup不拦截事件并将事件交由子元素处理时mFirstTouchTarget ！= null 。反过来，一旦事件由当前ViewGroup拦截时，mFirstTouchTarget ！= null就不成立，那么当ACTION_DWON和ACTION_UP事件到来时，由于(actionMasked == MotionEvent.ACTION_DOWN|| mFirstTouchTarget != null)为false，将导致ViewGroup的OnInterceptTouchEvent不会再调用，并且同一序列中的其他事件都会默认交由给它处理。 这里有一种特使情况，那就是FLAG_DISALLOW_INTERCEPT标记位，这个标记位是通过requestDisallowInterceptTouchEvent设置的，一般用于子View中。FLAG_DISALLOW_INTERCEPT一旦设置后，ViewGroup将无法拦截除了ACTION_DOWN以外的其他事件。为什么说是除了ACTION_DOWN意外的其他事件了？这是因为ViewGroup在分发事件时，如果是ACTION_DOWN就会重置FLAG_DISALLOW_INTERCEPT这个标记位，将导致子View中设置的这个标记位无效。因此，当面对ACTION_DOWN事件时，ViewGroup总是会调用自己的OnInterceptTouchEvent方法来询问自己是否要拦截事件。在下面的代码中，ViewGroup会在ACTION_DOWN事件到来时做重置状态的操作，而在resetTouchState方法中会对FLAG_DISALLOW_INTERCEPT进行重置，因此子View调用requestDisallowInterceptTouchEvent方法并不能影响ViewGroup对ACTION_DOWN的处理 1234567if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState();&#125; 从上面的源码分析，我们可以得出结论：当ViewGroup决定拦截事件后，那么后续的点击事件将会默认交给它处理，并且不再调用它的OnInterceptTouchEvent方法。FLAG_DISALLOW_INTERCEPT这个标志的作用是ViewGroup不再拦截事件，当前前提是ViewGroup不拦截ACTION_DOWN事件。那么这段分析有什么价值呢？总结起来有两点：第一，OnInterceptTouchEvent不是每次事件都会被调用的，如果我们想提前处理所有的点击事件，要选择dispatchTouchEvent方法，只有这个方法能确保每次都会调用，当然前提是事件能够传递到当前的ViewGroup；第二点：FLAG_DISALLOW_INTERCEPT标记位的作用给我们提供了一个思路，当面对滑动冲突时，我们可以是不是考虑用这种方法去解决问题？ 接着再看当ViewGroup不拦截事件的时候，事件会向下分发交由它的子View进行处理，这段源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465final int childrenCount = mChildrenCount;if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) &#123; // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123; // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; &#125;&#125; 首先遍历ViewGroup的所有子元素，然后判断子元素是否能够接收到点击事件。是否能够接收到点击事件主要由两点来衡量：子元素是否在播动画和点击事件的坐标是否落在子元素的区域内。如果某个子元素满足这两个条件，那么事件就会传递给它来处理。可以看到dispatchTransformedTouchEvent实际上调用的就是子元素的dispatchTouchEvent方法，在它的内部有一段内容：而在上面的代码中child传递的不是null，因此它会直接调用子元素的dispatchTouchEvent，这样事件就交由子元素处理，从而完成了一轮事件分发。 12345if (child == null) &#123; handled = super.dispatchTouchEvent(event);&#125; else &#123; handled = child.dispatchTouchEvent(event);&#125; 如果子元素的dispatchTouchEvent返回true，那么，FirstTouchTarget就会被赋值同时跳出for循环，如下所示： 123newTouchTarget = addTouchTarget(child, idBitsToAssign);alreadyDispatchedToNewTouchTarget = true;break; 这几行代码就完成了mFirstTouchTarget的赋值并终止对子元素的遍历。如果子元素的dispatchTouchEvent返回false，ViewGroup就会把事件分发给下一个子元素。 其实mFirstTouchTarget真正的赋值过程是在addTouchTarget内部完成的，从下面的addTouchTarget方法的内部结构可以看出，mFirstTouchTarget其实是一种单链表结构。mFirstTouchTarget是否被赋值，将直接影响到ViewGroup对事件的拦截策略，如果mFirstTouchTarget为null，那么ViewGroup就默认拦截接下来同一序列中所有的点击事件 123456private TouchTarget addTouchTarget(View child, int pointerIdBits) &#123; TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target;&#125; 如果遍历所有的子元素后事件都没有合适地处理，这包含两种情况：第一种是ViewGroup没有子元素；第二种是子元素处理了点击事件，但是再dispatchTouchEvent中返回了false，这一般式因为子元素在OnTouchEvent中返回了false。在这两种情况下ViewGroup会自己处理点击事件。 123456// Dispatch to touch targets.if (mFirstTouchTarget == null) &#123; // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);&#125; 第三个参数child为null，它会调用super.dispatchTouchEvent(event)，很显然，这里就转到了View（不包括ViewGroup）的dispatchTouchEvent方法，即点击事件开始交由View来处理。 View对点击事件的处理过程View点击事件的处理过程简单一些，这里的View不包含ViewGroup。先看它的dispatchTouchEvent方法： 12345678910111213141516171819202122public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. ... if (onFilterTouchEventForSecurity(event)) &#123; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; ... return result;&#125; View对点击事件的处理就比较简单了因为View是一个单独的元素，它没有子元素因此无法向下传递事件，所以它只能自己处理事件。从上面的源码可以看出View对点击事件的处理过程，首先会判断有没有设置OnTouchListener，如果OnTouchListener中的OnTouch方法返回true，那么OnTouchEvent就不会被调用，可见OnTouchListener的优先级高于OnTouchEvent。 接着再分析OnTouchEvent的实现。先看当View出于不可用状态下的点击事件的处理过程，如下所示，不可用状态下的View照样会消耗点击事件，尽管它看起来不可用。 123456789if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (event.getAction() == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE));&#125; 接着，如果View设置有代理，那么还会执行TouchDelegate的onTouchEvent方法，这个OnTouchEvent的工作机制看起来和OnTouchListener类似 12345if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125;&#125; 下面再看一下OnTouchEvent中堆点击事件的具体处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) &#123; break; &#125; // Walk up the hierarchy to determine if we're inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; // Not inside a scrolling container, so show the feedback right away setPressed(true, x, y); checkForLongClick(0); &#125; break; case MotionEvent.ACTION_CANCEL: setPressed(false); removeTapCallback(); removeLongPressCallback(); break; case MotionEvent.ACTION_MOVE: drawableHotspotChanged(x, y); // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); setPressed(false); &#125; &#125; break; &#125; return true; &#125; 只要View的Clickable和longClickable有一个为true，那么就会消耗这个事件，即OnTouchEvent返回true，不管它是不是disable状态。然后就是当ACTION_UP事件发生时会触发performClick方法，如果View设置了OnClickListener，那么performClick方法内部会调用它的onClick方法，如下所示 1234567891011121314public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result;&#125; View的LONG_CLICKABLE属性默认为false，而CLICKABLE属性是否为false和具体的View有关，确切来说是可点击的View其CLICKABLE为true，不可点击的View其CLICKABLE为false。通过setClickable和setLongClickable可以改变View的LONG_CLICKABLE、CLICKABLE属性。另外，setOnClickListener和setOnLongClickListener会自动将View的LONG_CLICKABLE、CLICKABLE属性设置为true。 12345678910111213public void setOnClickListener(OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; getListenerInfo().mOnClickListener = l;&#125;public void setOnLongClickListener(OnLongClickListener l) &#123; if (!isLongClickable()) &#123; setLongClickable(true); &#125; getListenerInfo().mOnLongClickListener = l;&#125;","tags":[{"name":"Android系统","slug":"Android系统","permalink":"http://liuguoquan727.github.io/tags/Android系统/"}]},{"title":"View的工作流程","date":"2016-04-26T13:22:34.000Z","path":"2016/04/26/Android-View的工作流程/","text":"View的工作流程主要指measure、layout、draw这三大流程，即测量、布局和绘制，其中measure确定View的测量宽/高，layout确定View的最终宽/高和四个顶点的位置（即View在父容器中的放置位置），draw则将View绘制到屏幕上。 measure过程measure过程要分情况来看，如果只是一个原始的View，那么通过measure方法就完成了其测量的过程，如果是一个ViewGroup，除了完成自己的测量过程外，还会遍历去调用所有子元素的measure方法，各个子元素再递归去执行这个流程。 View的测量过程View的measure过程是由其measure方法来完成，measure方法是一个final类型的方法，这意味着子类不能重写此方法，在View的measure方法中会去调用View的onMeasure方法，因此只需要看onMeasure的实现即可，代码如下所示： 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; 如上所示，setMeasuredDimension方法会设置View宽/高的测量值，因此我们只需要看getDefaultSize这个方法即可： 测量的三种模式 EXACTLY：精确值模式当我们将控件的layout_width或layout_height属性指定为具体的数值时，或指定为match_parent属性时，系统使用的是EXACTLY模式。 AT_MOST：最大值模式当我们将控件的layout_width或layout_height属性指定为wrap_content时,系统使用的是AT_MOST模式 UNSPECIFIED：此模式不指定其大小测量模式，View想多大就多大，通常情况系统绘制自定义View时才会使用 Note:: View类默认的onMeasure()方法只支持EXACTLY模式，而如果要让自定义View支持wrap_content属性时，那么必须重写onMeasure()方法来指定wrap_content的大小 12345678910111213141516public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); //测量模式 int specSize = MeasureSpec.getSize(measureSpec); //绘制的大小 switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: //重写指定AT_MOST模式的值 case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; 可以看出，其实getDefaultSize返回的大小就是measureSpec中的specSize，而这个specSize就是View测量后的大小，这里多次提到测量后的大小是因为View的最终大小是在layout阶段确定的，所以必须加以区分，但是几乎所有情况下View的测量大小和最终大小是相等的。 在上述情况下，View的大小为getDefaultSize的第一个参数size，及宽高分别为getSuggestedMinimumWidth和getSuggestedMinimumHeight的返回值，源码如下： 12345678protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());&#125;protected int getSuggestedMinimumHeight() &#123; return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());&#125; layout过程Layout的作用是ViewGroup用来确定子元素的位置，当ViewGroup的位置被确定后，它在onLayout中会遍历所有子元素并调用其layout方法，View的layout方法中onLayout方法又会被调用。layout方法确定View本身的位置，而onLayout方法则会确定所有子元素的位置，View的layout方法如下： 1234567891011121314151617181920212223242526272829303132public void layout(int l, int t, int r, int b) &#123; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123; onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) &#123; ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); &#125; &#125; &#125; mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;&#125; layout方法大致流程如下：首先通过setFrame方法设定View的四个顶点的位置，即初始化mLeft、mTop、mBottom、mRight这四个值，View的四个顶点一旦确定，那么View在父容器的位置也就确定了；接着会调用onLayout方法，用途是父容器确定子元素的位置，和onMeasure方法类似，onLayout的具体实现同样和具体的布局有关，所以View和ViewGroup均没有真正的实现。我们可以看一下TextView的onLayout方法，如下所示： 12345678protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); if (mDeferScroll &gt;= 0) &#123; int curs = mDeferScroll; mDeferScroll = -1; bringPointIntoView(Math.min(curs, mText.length())); &#125;&#125; draw过程Draw过程较简单，作用是将View绘制到屏幕上面。 当测量好一个View之后，我们就可以重写onDraw方法，并在Canvas对象上绘制所需要的图形，最终显示在屏幕上。","tags":[{"name":"Android系统","slug":"Android系统","permalink":"http://liuguoquan727.github.io/tags/Android系统/"}]},{"title":"Android的消息机制","date":"2016-04-26T13:20:28.000Z","path":"2016/04/26/Android的消息机制/","text":"Android的消息机制概述Android的消息机制主要是指Handler的运行机制，Handler的运行机制需要底层的MessageQueue和Looper的支撑。 MessageQueue的中文为消息队列，顾名思义，它的内部存储了一组消息，以队列的形式对外提供插入和删除的方法。虽然称为消息队列，但是它的内部存储结构并不是真正的队列，而是采用单链表的数据结构来存储消息列表。 Looper的中文翻译是循环，这里可以理解为消息循环。由于MessageQueue只是一个消息的存储单元，它不能去处理消息，而Looper会以无限循环的形式其查询是否有新的消息，如果有的话就处理消息，否则就一直等待。 Looper中还有一个特殊的概念，那就是ThreadLocal，ThreadLocal并不是线程，它的作用是可以在每个线程中存储数据。我们知道，Handler创建的时候会采用当前线程的Looper来构造消息循环系统，那么Handler内部如何获取到当前线程的Looper呢？这就要使用ThreadLocal了，ThreadLocal可以在不同的线程中互不干扰地存储并提供数据，通过ThreadLocal就可以轻松地获取每个线程的Looper。 需要注意的是，线程是默认没有Looper的，如果需要使用Handler就必须为线程创建Looper。而主线程，即UI线程，它就是ActivityThread，ActivityThread被创建时就会初始化Looper，这也是在主线程中默认可以使用Handler的原因。 Android消息机制分析Android消息机制主要是指Handler的运行机制以及Handler所附带的MessageQueue和Looper的工作过程，这三者实际上是一个整体。Handler的作用主要是将一个任务切换到某个指定的线程中去执行，那么Android为什么要提供这个功能呢？这是因为Android规定UI只能在主线程中进行，如果在子线程中访问UI，那么程序就会抛出运行时异常。ViewRootImp对UI操作做了验证，这个验证工作是由ViewRootImpl的checkThread方法来完成的，如下所示。 123456void checkThread() &#123; if(mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException(\"Only the original thread that created a view hiearachy can touch its view\"); &#125;&#125; Android建议我们不要在主线程中进行耗时的操作，否则会导致程序无法响应ANR。考虑一种情况，假如我们需要从服务器拉取一些信息并将其显示在UI上，这个时候必须在子线程中进行拉取工作，拉取完毕之后又不能在子线程中直接访问UI，如果没有Handler，那么我们确实没有办法将访问UI的工作切换到主线程中执行，因此，系统提供Handler的主要原因及时为了解决在子线程中无法访问UI的矛盾。 系统为什么不允许在子线程中访问UI呢？这是 因为Android的UI控件不是线程安全的，如果在多线程中并发访问可能会导致UI控件处于不可预期的状态，而为什么系统不对UI控件的访问加上锁机制呢？缺点有两个：首先加上锁机制会让UI访问的逻辑变得复杂，其次锁机制会降低UI访问的效率，因为锁机制会阻塞某些线程的执行。因此最简单最高效的方法就是采用单线程模型来处理UI操作，对于开发者来说也不是很麻烦，只是需要通过Handler切换到UI访问的执行线程即可。 Handler的工作过程：Handler创建时会采用当前线程的Looper来构建内部的消息循环系统，如果当前线程没有Looper，那么就会报错；Handler创建完毕后，这个时候其内部的MessageQueue和Looper就可以协同工作了，然后通过Handler的post方法将一个Runnable传递到Handler内部的Looper中去处理，也可以通过Handler的send方法来发送一个消息，这个消息同样会在Looper中去处理。其实post方法最终也是在send方法中完成的。当Handler的send方法被调用时，它会调用MessageQueue的enqueueMessage方法将这个消息放入消息队列中，然后Looper发现有新消息到来时，就会处理这个消息，最终消息中的Runnable或者Handler的handleMessage方法就会被调用。 注意：Looper是运行在创建Handler所在的线程中的，这样一来Handler中的业务逻辑就被切换到创建Handler所在的线程中去执行了。 ThreadLocal的工作原理ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。 下面通过实际的例子来演示ThreadLocal的作用。首先定义一个ThreadLocal对象，这里选择Boolean类型的，如下所示：1private ThreadLocal&lt;Boolean&gt; mThreadLocal = new ThreadLocal&lt;Boolean&gt;(); 然后在主线程、子线程1和子线程2中设置和访问它的值，代码如下所示： 123456789101112131415161718192021222324 mThreadLocal.set(true); System.out.println(\"main thread: \" + mThreadLocal.get()); //true new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub mThreadLocal.set(false); System.out.println(\"thread 1: \" + mThreadLocal.get()); //false &#125;&#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(\"thread 2: \" + mThreadLocal.get()); //null，没有设置值 &#125;&#125;).start(); 上述代码中，根据对ThreadLocal的描述，主线中mThreadLocal.get()为true，子线程1中mThreadLocal.get()为false，子线程2中mThreadLocal.get()为null。代码运行打印如下： 12315:54:55.478: I/System.out(11711): main thread: true01-09 15:54:55.479: I/System.out(11711): thread 1: false01-09 15:54:55.480: I/System.out(11711): thread 2: null 从上面的打印可以看出，虽然不同的线程访问的是同一个ThreadLocal对象，但是它们通过ThreadLocal获取的值却是不一样的，这就是ThreadLocal的特点。ThreadLocal之所以有如此特点，是因为不同线程访问同一个ThreadLocal的get方法，ThreadLocal内部会从各自的线程中取出一个数组，然后再从数组中根据当前的ThreadLocal索引去查找对应的value值。很显然，不同线程中的数组是不同的，这就是为什么通过ThreadLocal可以在不同的线程中维护一套数据的副本并且互不干扰。 上面描述的ThreadLocal的使用方法和工作过程，下面分析ThreadLocal的内部实现，ThreadLocal是一个泛型类，它的定义为public class ThreadLocal&lt;T&gt;，只要弄清楚ThreadLocal的get和set方法就可以明白它的工作原理。 首先看get和set方法，如下所示 12345678910111213141516171819public void set(T value) &#123; Thread currentThread = Thread.currentThread(); Values values = values(currentThread); if (values == null) &#123; values = initializeValues(currentThread); &#125; values.put(this, value);&#125;Values initializeValues(Thread current) &#123; return current.localValues = new Values();&#125;/** * Gets Values instance for this thread and variable type. */Values values(Thread current) &#123; return current.localValues;&#125; 在上面的set方法中，首先会通过values方法来获取当前线程中的ThreadLocal数据，如何获取呢？在Thread内部有一个成员变量专门用于存储线程的ThreadLocal数据：ThreadLocal.Values localValues;因此获取当前线程的ThreadLocal数据就变得异常简单。如果localValues的值为null，那么久需要对其进行初始化化，初始化后再将ThreadLocal的值进行存储。 下面看一下ThreadLocal的值到底是如何在localValues中进行存储的。在localValues内部有一个数组：private Object[] table;ThreadLocal的值就存储在这个table数组中。下面看一下localValues是如何使用put方法将ThreadLocal的值存储到table数组中的，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Sets entry for given ThreadLocal to given value, creating an * entry if necessary. */void put(ThreadLocal&lt;?&gt; key, Object value) &#123; cleanUp(); // Keep track of first tombstone. That's where we want to go back // and add an entry if necessary. int firstTombstone = -1; for (int index = key.hash &amp; mask;; index = next(index)) &#123; Object k = table[index]; if (k == key.reference) &#123; // Replace existing entry. table[index + 1] = value; return; &#125; if (k == null) &#123; if (firstTombstone == -1) &#123; // Fill in null slot. table[index] = key.reference; table[index + 1] = value; size++; return; &#125; // Go back and replace first tombstone. table[firstTombstone] = key.reference; table[firstTombstone + 1] = value; tombstones--; size++; return; &#125; // Remember first tombstone. if (firstTombstone == -1 &amp;&amp; k == TOMBSTONE) &#123; firstTombstone = index; &#125; &#125;&#125; 上面的代码实现了数据的存储过程，我们可以由上可以得出一个存储规则，那就是ThreadLocal的值在table数组中的存储位置总是为ThreadLocal的reference字段所标识的对象的下一个位置，比如ThreadLocal的reference对在table数组中的索引为index，那么ThreadLocal的值在table数组中的索引就是index+1.最终ThreadLocal的值会被存储在table数组中：table[index + 1] = value; 接下来，分析get方法，如下所示 12345678910111213141516public T get() &#123; // Optimized for the fast path. Thread currentThread = Thread.currentThread(); Values values = values(currentThread); if (values != null) &#123; Object[] table = values.table; int index = hash &amp; values.mask; if (this.reference == table[index]) &#123; return (T) table[index + 1]; &#125; &#125; else &#123; values = initializeValues(currentThread); &#125; return (T) values.getAfterMiss(this);&#125; 可以发现，ThreadLocal的get方法同样是取出当前线程的localValues对象，如果这个对象不为null，那就取出它的table数组并找出ThreadLocal的reference对象在table数组中的位置，然后table数组中下一个位置所存储的数据就是ThreadLocal的值。如果这个对象为null，则返回初始值，初始值由ThreadLocal的initialValue方法来描述，默认情况下为null，当然也可以重写这个方法，它的默认实现如下 1234567891011121314151617181920212223242526Object getAfterMiss(ThreadLocal&lt;?&gt; key) &#123; Object[] table = this.table; int index = key.hash &amp; mask; // If the first slot is empty, the search is over. if (table[index] == null) &#123; Object value = key.initialValue(); // If the table is still the same and the slot is still empty... if (this.table == table &amp;&amp; table[index] == null) &#123; table[index] = key.reference; table[index + 1] = value; size++; cleanUp(); return value; &#125; // The table changed during initialValue(). put(key, value); return value; &#125;protected T initialValue() &#123; return null;&#125; 从ThreadLocal的set和get方法可以看出，它们所操作的对象都是当前线程的Values对象的table数组，因此在不同的线程中访问同一个ThreadLocal的set和get方法，它们对ThreadLocal所在的读/写权限仅限各自线程的内部，这就是ThreadLocal可以在不同线程中互不干扰的储存和修改数据的原因，理解ThreadLocal的工作方式有助于理解Looper的工作原理。 MessageQueue的工作原理消息队列在Android中指的是MessageQueue，MessageQueue主要包括两个操作：插入和读取，读取操作会伴随着删除操作，插入和读取的方法分别是enqueueMessage和next，其中enqueueMessage的作用往往是往消息队列中插入一条消息，而next的作用是往消息队列中取出一条消息并将其从消息队列中移除。尽管MessageQueue叫消息队列，但是它的内部实现不是用的队列，而是通过一个单链表的数据结构来维护消息列表，单链表在插入和删除上效率较高。enqueueMessage的源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(\"MessageQueue\", e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don not have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 从enqueueMessage的实现来看，它的主要操作就是单链表的插入和删除，下面看一下next方法的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105 Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0;//死循环 for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (false) Log.v(\"MessageQueue\", \"Returning message: \" + msg); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(\"MessageQueue\", \"IdleHandler threw exception\", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125; &#125; 可以发现next方法是一个无限循环的过程，如果消息队列中没有消息，那么next方法会一直阻塞在这里。当有新的消息到来时，next方法会返回这条消息并将其从单链表中移除。 Looper的工作原理Looper在Android消息机制里面扮演着消息循环的角色，具体来说它会不停地从MessageQueue中查看是否有新消息，如有有新消息就会立刻处理，否则就会一直阻塞在那里。首先看一下Looper的构造函数，在构造方法中它会创建一个MessageQueue即消息队列，然后将当前线程的对象存储起来，如下所示： 1234567891011private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125;private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; Handler的工作需要Looper，没有Looper的线程就会报错，那么如何为一个线程创建Looper呢？通过Looper.prepare()即可为当前线程创建一个Looper，接着通过Looper.loop()来开启消息循环，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041 new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub Looper.prepare(); //创建Looper mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; // TODO Auto-generated method stub super.handleMessage(msg); if (msg.what == 0) &#123; System.out.println(\"msg: \" + \"123456\"); &#125; &#125; &#125;; Looper.loop(); //开启Looper循环 &#125;&#125;).start(); /** * 发送消息 * @param view */ public void click(View view) &#123; mHandler.sendEmptyMessage(0); &#125; /** * 退出Looper循环 * @param view */ public void quit(View view) &#123; mHandler.getLooper().quit(); mHandler.getLooper().quitSafely(); //API18 &#125; Looper除了prepare方法外，还提供了prepareMainLooper()方法，这个方法主要是给主线程也就是ActivityThread创建Looper使用的，其本质也是通过prepare方法创建的。由于主线程的Looper比较特殊，所以Looper提供了一个getMainLooper方法，通过它可以在任何位置获取主线程Looper。 Looper也是可以退出的，Looper提供了quit和quitSafely来退出一个Looper，二者的区别在于：quit会直接退出Looper，而quitSafely只是设定一个退出标志，然后把消息队列中的已有消息处理完毕后才安全地退出。Looper退出后，提供Handler发送的消息会失败，这时Handler的send方法返回false。在子线程中，如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来终止消息循环，否则这个子线程会一直处于等待状态，而如果推出Looper以后，这个线程就会立刻终止，因此建议不需要的时候终止Looper。 Looper最重要的一个方法是loop方法，只有调用了loop后，消息循环系统才会真正的运行，实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might bloc 退出时返回null if (msg == null) &#123; // No message indicates that the message queue is quitting. return; //位移跳出循环的方式 &#125; // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; msg.target.dispatchMessage(msg); //分发消息 msg.target = Handler if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; msg.recycleUnchecked(); &#125; &#125; Looper的loop方法工作过程，loop方法是一个死循环，位移跳出循环的方式是MessageQueue的next方法返回null。当Looper的quit方法被调用时，Looper就会调用MessageQueue的quit或者quitSafely方法来通知消息队列退出，当消息队列表计为退出状态时，它的next方法就返回null。 Looper必须退出，否则loop方法会无线循环下去。loop方法会调用MessageQueue的next方法来获取新的消息，而next是一个阻塞操作，当没有消息时，next方法会一直阻塞在那里，这也导致loop方法一直阻塞在那里。如果MessageQueue的next方法返回了新的消息，Looper就会处理这条消息：msg.target.dispatchMessage(msg);这里的msg.target是发送这条消息的Handler对象，这样Handler的发送的消息最终在它的dispatchMessage中处理了。 Handler的工作原理Handler的主要工作包含消息的发送和接收过程。消息的发送可以通过post的一系列方法以及send的一系列方法实现，post的一系列方法最终是通过send的一系列方法来实现的。发送一条消息典型过程如下所示： 1234567891011121314151617181920212223242526272829303132public final boolean sendMessage(Message msg) &#123; return sendMessageDelayed(msg, 0); &#125;public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125;public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;//送入消息队列private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 可以发现，Handler发送消息的过程仅仅是向消息队列插入了一条消息，MessageQueue的next方法就会返回这条消息给Looper，Looper收到消息后就开始处理了，最终消息由Looper交由Handler处理，即Handler的dispatchMessage方法会被调用，这是Handler就进入了消息处理阶段。dispatchMessage实现如下： 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; Handler处理消息的过程如下： 首先，检查Message的Callback是否为null，不为null则通过handleCallback来处理消息，Message的callback是一个Runnable对象，实际上就是Handler的post方法所传递的Runnable参数。 123private static void handleCallback(Message message) &#123; message.callback.run(); //messge.callback = Runnable对象&#125; 其次，若Message的Callback是为null，则检查mCallback是否为null，不为null就调用mCallback的handleMessage方法来处理消息，Callback是个接口，定义如下： 123public interface Callback &#123; public boolean handleMessage(Message msg);&#125; 通过Callback框图用如下方式创建Handler对象：Handler mHandler = new Handler(mCallback)。那么Callback的意义是什么了？可以用来创建一个Handler的实例但并不需要派生Handler的子类。 最后，若都为null，则直接调用Handler中的handlerMessage方法来处理消息。 Handler还有一种特使的构造函数，那就是通过一个特定的Looper来构造Handler，通过这个构造方法可以实现一些特殊的功能如IntentService，它的实现如下所示 123public Handler(Looper looper) &#123; this(looper, null, false);&#125; Handler的一个默认构造方法public Handler()，这个构造方法会调用下面的的构造方法。很明显，如果当前线程没有Looper的话，就会抛出异常，这也解释了在没有Looper的子线程创建Handler会引发程序异常的原因。 1234567891011121314151617public Handler() &#123; this(null, false);&#125;public Handler(Callback callback, boolean async) &#123; ... mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 主线程的消息循环Android的主线程就是ActivityThread，主线程的入口方法为main，在main方法中系统会通过Looper.prepareMainLooper()来创建主线程的Looper以及MessageQueue，并通过Looper.loop()开启主线程的消息循环，如下所示： 12345678910111213141516171819202122232425262728293031323334353637public static void main(String[] args) &#123; SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); Security.addProvider(new AndroidKeyStoreProvider()); Process.setArgV0(\"&lt;pre-initialized&gt;\"); Looper.prepareMainLooper(); // ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; AsyncTask.init(); if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; Looper.loop(); //无限循环 throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; 主线程的消息循环开始以后，ActivityThread需要一个Handler来和消息队列进行交互，这个Handler就是ActivityThread.H，它内部定义了一组消息类型，主要包含了四大组件的启动和停止等过程，如下所示 ActivityThread通过ApplicationThread和AMS进行进程间通信，AMS以进程间通信的方式完成ActivityThread的请求后回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程中执行，这个过程就是主线程的消息循环模型。","tags":[{"name":"Android系统","slug":"Android系统","permalink":"http://liuguoquan727.github.io/tags/Android系统/"}]},{"title":"Android的线程和线程池","date":"2016-04-25T13:06:06.000Z","path":"2016/04/25/Android的线程和线程池/","text":"前言线程在Android中是一个很重要的概念，从用途上来说，线程分为主线程和子线程，主线程主要处理和界面相关的事情，而子线程则往往用于执行耗时操作。由于Android的特性，如果在主线程中执行耗时操作那么就会导致程序无法及时地响应，因此耗时操作必须放在子线程中去执行。 在操作系统中，线程是操作系统调度的最小单元，同时线程又是一种受限的系统资源，即线程不可能无限制的产生，并且线程的创建和销毁都会有相应的开销。档系统中存在大量的线程时，系统会通过时间片轮转的方式调度每个线程，因此线程不可能做到绝对的并行，除非线程数量小于等于CPU核心数，一般来说这是不可能的。正确的做法是采用线程池，一个线程池会缓存一定数量的线程，通过线程池就可以避免因为频繁创建和销毁线程所带来的系统开销。 主线程和子线程Android沿用了Java的线程模型，其中的线程也分为主线程和子线程，其中主线程也叫UI线程。主线程的作用是运行四大组件以及处理它们和用户的交互，而子线程的作用则是执行耗时任务，比如网络请求、I/O操作等。从Android3.0开始系统要求网络访问必须在子线程中进行，否则网络访问将会失败并抛出NetworkOnMainThreadException这个异常，这样做事为了避免主线程由于耗时操作所阻塞而出现ANR异常。 Android中的线程形态除了传统的Thread线程外，Android还提供了AsyncTask、HandlerTask以及IntentService，这三者的底层实现也是线程，但它们具有特殊的表现形式，同时在使用上也各有优缺点。 AsyncTaskAsyncTask是一种轻量级的异步任务类，它可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程并在主线程上更新UI。是实现上来说，AsyncTask封装了Thread和Handler，通过AsyncTask可以更加方便地执行后台任务以及在主线程中访问UI，但是AsyncTask并不适合进行特别耗时的任务，对应特别耗时的任务来说，建议使用线程池。 AsyncTask使用AsyncTask是一个抽象的泛型类，它提供了Params、Progress和Result这三个泛型参数，其中Params表示输入参数的类型，Progress表示后台任务的执行进度的类型，而Result则表示后台任务返回结果的类型，如果AsyncTask确实不需要传递具体的参数，那么这三个泛型可以用Void来代替。声明如下： 1public abstract class AsyncTask&lt;Params,Progress,Result&gt; AsyncTask提供了4个核心方法，它们的含义如下图所示 onPreExecute()，在主线程中执行，在异步任务执行之前会调用此方法，一般可以用于做一些准备工作。 doInBackground(Params…params)，在线程池中执行，用于执行异步任务，params表示异步任务的输入参数。在该方法中可以通过调用publishProgress方法来更新任务的进度，因为publishProgress会调用onProgressUpdate方法。 onProgressUpdate(Progress…values)，在主线程中执行，当后台任务的执行进度发生改变时此方法会被调用。 onPostExecute(Result result)，在主线程中执行，在异步任务执行之后，次方法会被调用，其中result参数是后台任务的返回值，即doInBackground的返回值。 上述方法中，onPreExecute先执行，然后是doInBackground，最后才是onPostExecute。此外AsyncTask还提供了onCancelled()方法，它同样在主线程中执行，当异步任务被取消时，onCancelled()方法会被调用，这个时候onPostExecute则不会被调用。 下面代码为AsyncTask的一个应用实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869private class LoadRecordTask extends AsyncTask&lt;Object, VideoInfo, List&lt;VideoInfo&gt;&gt; &#123; @Override protected void onPreExecute() &#123; // TODO Auto-generated method stub super.onPreExecute(); mDescLoad.setVisibility(View.VISIBLE); mDescLoad.setText(R.string.refreshing); mVideoRecords.setEnabled(false); &#125; @Override protected List&lt;VideoInfo&gt; doInBackground(Object... params) &#123; // TODO Auto-generated method stub videoInfos = (ArrayList&lt;VideoInfo&gt;) MediaContentResolverUtils .getVideoInfoList(RecordVideoActivity.this); mVideoThumbnailMap = (HashMap&lt;String, String&gt;) mVideoThumbnailDao .findAllToMap(); if (videoInfos == null || videoInfos.size() == 0) &#123; return videoInfos; &#125; // 没有缩略图 获取缩略图 for (VideoInfo info : videoInfos) &#123; String md5Name = Md5Utils.encode(info.getFileTitle()); if (!mVideoThumbnailMap.containsKey(md5Name)) &#123; //数据处理 &#125; publishProgress(info); if (isCancelled()) &#123; //异步任务取消时会调用 break; &#125; &#125; return videoInfos; &#125; @Override protected void onProgressUpdate(VideoInfo... values) &#123; // TODO Auto-generated method stub super.onProgressUpdate(values); for (VideoInfo info : values) &#123; //UI更新进度 &#125; &#125; @Override protected void onPostExecute(List&lt;VideoInfo&gt; result) &#123; //取得后台任务的结果，更新UI &#125; /** * 运行在UI线程，调用cancel()方法后触发，在doInBackground()方法结束后执行 */ @Override protected void onCancelled(List&lt;VideoInfo&gt; result) &#123; // TODO Auto-generated method stub super.onCancelled(result); &#125;&#125; 运行和取消该任务的代码如下: 123mLoadRecordTask = new LoadRecordTask();mLoadRecordTask.execute();mLoadRecordTask.cancel(true); //结束任务 AsyncTask条件限制 AsyncTask的类必须在主线程中加载 AsyncTask的对象必须在主线程中创建 execute方法必须在UI线程调用 不要在程序中直接调用onPreExecute()、onPostExecute()、doInBackgroud()和onProgressUpdate() 一个AsyncTask对象只能执行一次，即只能调用一次execute方法，否则会报运行时异常 在Android1.6之前，AsyncTask是串行执行任务的，Android1.6的时候AsyncTask开始采用线程池里处理并行任务，但从Android3.0开始，为了避免AsyncTask所带来的并发错误，AsyncTask又采用一个线程来串行执行任务。尽管如此，在Android3.0及以后版本中，我们仍然可以通过AsyncTask的executeOnExecutor方法（不能向下兼容）来并行的执行任务 AsyncTask工作原理我们从AsyncTask的execute方法开始分析，execute方法又会调用ecuteOnExecutor方法，它们的实现如下: 123456789101112131415161718192021222324252627public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(\"Cannot execute task:\" //异步任务执行一次 + \" the task is already running.\"); case FINISHED: throw new IllegalStateException(\"Cannot execute task:\" //异步任务执行一次 + \" the task has already been executed \" + \"(a task can be executed only once)\"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); //最先执行 mWorker.mParams = params; exec.execute(mFuture); //线程池开始执行 return this;&#125; 上述代码中，sDefaultExecutor实际上是一个串行的线程池，一个进程中所有的AsyncTask全部在这个串行的线程池中排队执行。在executeOnExecutor方法中，AsyncTask的onPreExecute()最先执行，然后线程池开始执行。下面分析线程池的执行过程，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked return postResult(doInBackground(mParams)); &#125; &#125;; //将AsyncTask的Params参数封装到FutureTask对象中，FutureTask的run方法会调用mWorker的call方法 mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(\"An error occured while executing doInBackground()\", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;; &#125; private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors(); //CPU核心数 private static final int CORE_POOL_SIZE = CPU_COUNT + 1; //核心工作线程 private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1; //最多工作线程 private static final int KEEP_ALIVE = 1; //空闲线程的超时时间为1秒 public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;//实现一个线程池 private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; //线程同步 public synchronized void execute(final Runnable r) &#123; //将任务r插入mTasks任务队列中 mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); //执行任务 &#125; finally &#123; scheduleNext(); //继续执行下一个任务 &#125; &#125; &#125;); //没有真正活动的AsyncTask时调用 if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); //真正执行任务 &#125; &#125; &#125; 从SerialExecutor的实现可以分析AsyncTask的排队执行情况。首先系统会将AsyncTask的Params参数封装到FutureTask对象中，FutureTask是一个并发类，在这里它充当了Runnable的作用(FutureTask实现了Runnable方法)。接着这个FutureTask即mFuture会交给SerialExecutor的execute方法去处理。SerialExecutor的execute方法首先会把FutureTask对象添加到任务队列mTasks中，如果当前没有正在活动的AsyncTask任务，那么就会调用SerialExecutor的scheduleNext方法来执行下一个AsyncTask任务，否则等待当前AsyncTask任务完成再继续执行新的AsyncTask任务，直到所有的AsyncTask任务执行完毕。从这可以看出，AsyncTask是串行执行任务的 AsyncTask中有两个线程池（SerialExecutor和THREAD_POOL_EXECUTOR）和一个Handler（InternalHandler），其中线程池SerialExecutor用于执行任务的排队，线程池THREAD_POOL_EXECUTOR用于真正地执行AsyncTask任务，InternalHandler用于将执行环境从线程池切换到主线程。在AsyncTask的构造方法中有如下这么一段代码，由于FutureTask的run方法调用mWorker的call方法，因此mWorker的call方法最终会在线程池中执行。 12345678910111213141516171819202122232425262728public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); //表示当前任务以及调用过了 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked return postResult(doInBackground(mParams)); //执行doInBackground方法 &#125; &#125;; //将AsyncTask的Params参数封装到FutureTask对象中，FutureTask的run方法会调用mWorker的call方法 mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(\"An error occured while executing doInBackground()\", e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; 在mWorker的call方法中，首先将mTaskInvoked设为true，表示当前任务以及被调用了，然后执行AsyncTask的doInBackground方法，接着将其返回值传递给postResult方法，它的实现如下： 1234567private Result postResult(Result result) &#123; @SuppressWarnings(\"unchecked\") Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 在上面的代码中，postResult方法会通过sHandler发送一个MESSAGE_POST_RESULT的消息，这个sHandler的定义如下所示： 12345678910111213141516171819202122232425262728293031private static InternalHandler sHandler; private static Handler getHandler() &#123; synchronized (AsyncTask.class) &#123; if (sHandler == null) &#123; sHandler = new InternalHandler(); &#125; return sHandler; &#125; &#125;private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;\"unchecked\", \"RawUseOfParameterizedType\"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 可以发现，sHandler是一个静态的Handler类对象，为了能够将执行环境切换到主线程，这就sHandler这个对象必须在主线程中创建。由于静态成员会在加载类的时候进行初始化，因此这就变相要求AsyncTask的类必须在主线程中加载，否则同一进程中的AsyncTask都将无法正常工作。sHandler收到sHandlerMESSAGE_POST_PROGRESS会调用onProgressUpdate方法更新进度，收到MESSAGE_POST_RESULT这个消息后会调用AsyncTask的finish方法，如下 12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; AsyncTask的finish方法会判断AsyncTask是否取消执行了，是则调用onCancelled方法，否则调用onPostExecute(result)，此时doInBackground的返回结果会传递给onPostExecute方法，最后将任务状态mStatus置为完成。至此AsyncTask的整个过程就分析完成了。 通过分析AsyncTask的源码，可以进一步确定，从Android3.0开始，默认情况下AsyncTask的确是串行执行。我们仍然可以通过AsyncTask的executeOnExecutor方法（不能向下兼容）来并行的执行任务。 HandlerThreadHandlerThread继承了Thread，它是一种可以使用Handler的Thread，它的实现也很简单，就是在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许HandlerThread中创建Handler。HandlerThread的run方法如下所示： 123456789101112public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1;&#125; 从HandlerThread的实现来看，它和普通的Thread有显著的不同之处。普通Thread主要同于run方法中执行一个耗时任务，而HandlerThread在内部创建了消息队列，外界需要通过Handler的消息方式来通知HandlerThread执行一个具体任务。HandlerThread是个很有用的类，它在Android中的一个具体的使用场景是IntentService。由于HandlerThread的run方法是一个无限循环，因此当明确不需要再使用HandlerThread时，可以通过它的quit或者quitSafely方法来终止线程的执行，这是一个好的编程习惯。示例代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class HandlerThreadDemo extends Activity &#123; private Looper mLooper; private MyHandlerThread mHandlerThread; private TextView mInfoTxt; private Handler mHandler; @Override protected void onCreate(Bundle savedInstanceState) &#123; // TODO Auto-generated method stub super.onCreate(savedInstanceState); setContentView(R.layout.activity_thread); mInfoTxt = (TextView) findViewById(R.id.tv_info); mHandlerThread = new MyHandlerThread(\"mHandlerThread\"); mHandlerThread.start(); //先start mLooper = mHandlerThread.getLooper(); //注册到Handler，通过Handler发送消息 mHandler = new Handler(mLooper,mHandlerThread); &#125; public void click(View view) &#123; mHandler.sendEmptyMessage(1); &#125; private class MyHandlerThread extends HandlerThread implements Callback &#123; public MyHandlerThread(String name) &#123; super(name); // TODO Auto-generated constructor stub &#125; @Override public boolean handleMessage(Message msg) &#123; // TODO Auto-generated method stub if (msg.what == 1) &#123; System.out.println(\"mHandlerThread\"); mInfoTxt.setText(\"mHandlerThread\"); &#125; return true; &#125; &#125;&#125; IntentServiceIntentService是一种特殊的Service，它继承了Service并且它是一个抽象类，因此必须创建它的子类才能使用IntentService。IntentService可用于执行后台耗时的后台，当任务执行后它会自动停止，同时由于IntentService是服务的原因，这导致它的优先级比单纯的线程要高很多，所以IntentService比较适合执行一些高优先级的后台任务，因为它的优先级高不容易被系统杀死。在实现上，IntentService封装了HandlerThread和Handler，这一点可以在它的onCreate方法中看出来，如下所示。 123456789101112public void onCreate() &#123; // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread(\"IntentService[\" + mName + \"]\"); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper);&#125; 当IntentService被第一次启动时，它的onCreate方法会被调用，onCreate方法会创建一个HandlerThread，然后使用它的Looper来构造一个Handler对象mServiceHandler，这样通过mServiceHandler发送的消息最终都会在HandlerThread中执行，从这个角度来看，IntentService也可以用于执行后台任务。每次启动IntentService，它的onStartCommand方法就会调用一次，IntentService在onStartCommand中处理每个后台任务的Intent。下面看一下onStartCommand方法是如何处理外界Intent的，onStartCommand调用了onStart，onStart方法的实现如下所示： 123456public void onStart(Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg);&#125; 可以看出，IntentService仅仅是通过mServiceHandler发送了一个消息，这个消息会在HandlerThread中去处理。mServiceHandler收到消息后，会将Intent对象对象传递给onHandleIntent方法去处理。注意这个Intent对象的内容和外界的startService(intent)中的intent的内容是完全一致的，通过这个Intent对象即可解析出外界启动IntentService时所传递的参数，通过这些参数就可以区分具体的后台任务，这样在onHandleIntent方法中就可以对不同的后台任务做处理了。当onHandleIntent方法执行结束后，IntentService会通过stopSelf（int startId）来尝试停止服务。这里之所以采用stopSelf（int startId）而不是stopSelf（）来停止服务，是因为stopSelf（）会立刻停止服务，而这个时候还可能有其他消息未处理，stopSelf（int startId）则会等待所有的消息都处理完毕后才终止服务。一般来说，stopSelf（int startId）在尝试停止服务之前会判断最近启动服务的次数是否和startId相等，如果相等就立刻停止服务，不相等则不停止服务，这个策略可以从AMS的stopServiceToken方法的实现中找到依据。ServiceHandler的实现如下所示： 1234567891011private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); &#125;&#125; IntentService的onHandleIntent方法是一个抽象方法，它需要我们在子类中实现，它的作用是从Intent参数中区分具体的任务并执行这些任务。如果目前只存在一个后台任务，那么onHandleIntent(Intent)方法执行完这个任务后，stopSelf（int startId）就会直接停止服务；如果目前存在多个后台任务，那么当onHandleIntent方法执行完最后一个任务时，stopSelf（int startId）才会直接停止服务。另外，由于没执行一个后台任务就必须启动一次IntentService，而IntentService内部则通过消息的方式向HandlerThread请求执行任务，Handler中的Looper是顺序处理消息的，这就意味着IntentService也是顺序执行后台任务，当有多个后台任务同时存在时，这些后台任务会按照外界发起的顺序排队执行。 下面通过一个示例来说明IntentService的工作方式，首先派生一个IntentService的子类，它的实现如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041public class LocalIntentService extends IntentService &#123; public LocalIntentService() &#123; super(\"LocalIntentService\"); // TODO Auto-generated constructor stub &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; // TODO Auto-generated method stub System.out.println(\"onStartCommand\"); return super.onStartCommand(intent, flags, startId); &#125; @Override protected void onHandleIntent(Intent intent) &#123; // TODO Auto-generated method stub String action = intent.getStringExtra(\"task\"); System.out.println(\"action: \" + action); SystemClock.sleep(3000); //休眠模拟耗时的后台任务 if (action.equals(\"task1\")) &#123; System.out.println(\"handle action: \" + action); &#125; if (action.equals(\"task2\")) &#123; System.out.println(\"handle action: \" + action); &#125; if (action.equals(\"task3\")) &#123; System.out.println(\"handle action: \" + action); &#125; &#125; @Override public void onDestroy() &#123; // TODO Auto-generated method stub System.out.println(\"onDestroy\"); super.onDestroy(); &#125;&#125; LocalIntentService实现完成以后，就可以在外界请求执行后台任务了，下面在Activity中发起3个后台任务的请求，如下所示: 1234567Intent service = new Intent(this, LocalIntentService.class);service.putExtra(\"task\", \"task1\");startService(service);service.putExtra(\"task\", \"task2\");startService(service);service.putExtra(\"task\", \"task3\");startService(service); 运行程序，观察日记如下 1234567891022:14:19.407: I/System.out(16384): onStartCommand01-08 22:14:19.407: I/System.out(16384): action: task101-08 22:14:19.407: I/System.out(16384): onStartCommand01-08 22:14:19.408: I/System.out(16384): onStartCommand01-08 22:14:22.407: I/System.out(16384): handle action: task101-08 22:14:22.409: I/System.out(16384): action: task201-08 22:14:25.410: I/System.out(16384): handle action: task201-08 22:14:25.418: I/System.out(16384): action: task301-08 22:14:28.418: I/System.out(16384): handle action: task301-08 22:14:28.429: I/System.out(16384): onDestroy 从日志可以看出，三个后台任务是排队执行的，它们的执行顺序就是它们发起请求对的顺序。当task3执行完毕后，LocalIntentService才真正地停止，执行了onDestroy方法。 Android中的线程池线程池的有点主要有三点： 重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销 能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致的阻塞现象。 能够对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。 Android中的线程池概念来源于Java中的Executor，Executor是一个接口，真正的线程池的实现为ThreadPoolExecutor。ThreadPoolExecutor提供了一系列参数来配置线程池，通过不同的参数可以创建不同的线程池。由于Android中的线程池都是直接或者间接通过配置ThreadPoolExecutor来实现的，因此需要先介绍ThreadPoolExecutor。 ThreadPoolExecutorThreadPoolExecutor是线程池的真正实现，它的构造方法提供了一系列参数来配置线程池，下面介绍ThreadPoolExecutor的构造方法中各个参数的含义，这些参数将会直接影响到线程池的功能特性，下面是ThreadPoolExecutor的一个比较常用的构造方法。 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123;&#125; corePoolSize 线程池的核心线程数，默认情况下，核心线程会在线程池中一直存活，即使他们处于闲置状态。如果将ThreadPoolExecutor的allowCoreThreadTimeout属性设置为true，那么闲置的核心线程在等待新任务到来会有超时策略，这个时间间隔由keepAliveTime所指定，当等待时间超时keepAliveTime所指定的时长后，核心线程会被终止。 maximumPoolSize 线程池所能容纳的最大线程数，当活动线程达到这个数值后，后续的新任务将会被阻塞。 keepAliveTime 非核心线程闲置时的超时时长，超过这个时间，非核心线程就会被收回。当ThreadPoolExecutor的allowCoreThreadTimeout属性设置为true时，keepAliveTime同样会作用于核心线程。 unit 用于指定keepAliveTime参数的时间单位，这是一个枚举，常用的有TimeUnit.MILLISECONDS;TimeUnit.SECONDS;TimeUnit.MINUTES等 workQueue 线程池的任务队列，通过线程池的execute方法提交的Runnable对象会存储在这个参数中。 ThreadFactory 线程工厂，为线程池提供创建新线程的功能。ThreadFactory是一个接口，它只有一个方法：Thread newThread(Runnable r); 除上面的这些主要的参数外，ThreadPoolExecutor还有一个不常用的参数RejectedExecutionHandler。当线程池无法执行新的任务时，这可能是由于任务队列已满或者是无法成功执行任务，这个时候ThreadPoolExecutor回调用RejectedExecutionHandler的rejectedExecution(Runnable r, ThreadPoolExecutor executor)方法来通知调用者，默认情况下rejectedExecution会直接抛出一个RejectedExecutionException的运行时异常。ThreadPoolExecutor为RejectedExectutionHandler提供了几个可选值：CallerRunsPolicy、AbortPolicy、DiscardPolicy、DiscardOldestPolicy，其中AbortPolicy是默认值，但是RejectedExecutionHandler这个参数不常用。 ThreadPoolExecutor执行任务时大致遵循如下规则： 如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务 如果线程池中的线程数量已经达到或超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行。 如果在步骤2中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务。 如果步骤3中线程数量已经达到线程池中规定的最大值，那么就拒绝执行此任务，ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution方法来通知调用者。 ThreadPoolExecutor的参数配置在AsyncTask中有明显的体现，下面是AsyncTask中的线程池配置情况 12345678910111213141516171819202122private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();private static final int CORE_POOL_SIZE = CPU_COUNT + 1;private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;private static final int KEEP_ALIVE = 1;private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, \"AsyncTask #\" + mCount.getAndIncrement()); &#125;&#125;;private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);/** * An &#123;@link Executor&#125; that can be used to execute tasks in parallel. */public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); AsyncTask线程池配置后的规格如下： 核心线程数等于CPU核心数+1 线程池的最大线程数为CPU的核心数的2倍 + 1 核心线程无超时机制，非核心线程在闲置时的超时时间为1秒 任务队列的容量为128 线程池的分类 FixedThreadPool 通过Executors的newFixedThreadPool方法来创建。它是一种线程数量固定的线程池，当线程处于空闲状态时，它们并不会被收回，除非线程池关闭了。当所有的线程都处于活动状态时，新任务都会处于等待状态，直到有线程空闲出来。由于FixedThreadPool只有核心线程并且这些核心线程都不会被回收，这意味着它能够更加快速的响应外界的请求。实现如下，可以发现FixedThreadPool中只有核心线程并且这些核心线程没有超时机制，另外任务队列也是没有大小限制的 12345678910/* * @param nThreads the number of threads in the pool * @return the newly created thread pool * */ public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; CachedThreadPool 通过Executors的newCachedThreadPool方法来创建。它是一种线程数量不定的线程池，它只有非核心线程，并且最大线程数为Integer.MAX_VALUE。由于Integer.MAX_VALUE是一个很大的数，实际上就相当于最大线程数可以任意大。当线程池中的线程都处于活动状态时，线程池会创建新的线程来处理新任务，否则就会利用空闲的线程来处理新的任务。线程池中的空闲线程都有超时机制，这个超时时长为60秒，超过60秒闲置线程就会被回收。和FixedThreadPool不同的是，CachedThreadPool的任务队列其实相当于一个空集合，这将导致任何任务都会立即被执行，因为这种情况下SynchronousQueue是无法插入任务的。SynchronousQueue是一个非常特殊的队列，很多情况下可以理解为一个无法存储元素的队列（实际中很少使用）。从CachedThreadPool的特性来看这类线程池比较适合执行大量的耗时较少的任务。当整个线程池都处于闲置状态时，线程池中的线程都会超时而被停止，这个时候CachedThreadPool之中是没有任何线程的，它几乎不占用任何系统资源的。 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; ScheduledThreadPoll 通过Executors的newScheduledThreadPool方法来创建。它的核心线程数量是固定的，而非核心线程数量是没有限制的，并且当核心线程闲置时会被立即收回。ScheduledThreadPoll这类线程主要用于执行定时任务和具有固定周期的重复任务 123456789public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public ScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue(), threadFactory);&#125; SingleThreadExecutor 通过Executors的newSingleThreadExecutor方法来创建。这类线程池内部只有一个核心线程，它确保所有的任务都在同一个线程中顺序执行。SingleThreadExecutor的意义在于统一所有的外界任务到一个线程中，这使得在这些任务之间不需要处理线程同步的问题。 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;","tags":[{"name":"Android系统","slug":"Android系统","permalink":"http://liuguoquan727.github.io/tags/Android系统/"}]},{"title":"Android的IPC方式","date":"2016-04-19T14:49:47.000Z","path":"2016/04/19/Android的IPC方式/","text":"Bundle四大组件中的三大组件（Activity、Service、BroadcastReceiver）都是支持在Intent中传递Bundle数据的，由于Bundle实现了Parcelable接口，所以它可以方便地在不同的进程间传输，基于这一点，当我们在一个进程中启动了另一个进程的Activity、Service和BroadcastReceiver，我们就可以在Bundle中附加我们需要传输给远程进程的信息并通过Intent发送出去。当然，我们传输的数据必须能够被序列化，比如基本类型、实现了Parcelable接口的对象、实现了Serializable接口的对象以及一些Android所支持的特殊对象（如Bundle、Size、SizeF、IBinder）。 文件共享共享文件也是一种不错的进程间通信方式，两个进程提供读/写同一个文件来交换数据，比如A进程把数据写入文件，B进程提供读取这个文件来获取数据。通过文件交换数据很好使用，除了可以交换一些文本信息外，我们还可以序列化一个对象到文件中，从另一进程中恢复这个对象。 通过文件共享方式来共享数据对文件格式是没有具体要求的，比如可以是文本文件，也可以是XML文件，只要读写双方约定数据格式即可。通过文件共享的方式是有局限性的，比如并发读/写的问题，因此我们要尽量避免并发写这种情况的发生或者考虑使用线程同步来限制多个线程的写操作。通过上面的分析可以知道，文件共享方式适合在对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读/写的问题。 SharedPreference是个特例，SharedPreference是Android中提供的轻量级存储方案，它通过键值对的方式来存储数据，在底层实现上采用XML文件来存储键值对，每个应用的SharedPreference文件都可以在当前包所在的data目录下查到，一般来说，它的目录位于/data/data/package name/shared_prefs目录下。从本质上来说，SharedPreference属于文件的一种，但是由于系统对它的读/写有一定的缓存策略2，即在内存中会有一份SharedPreference文件的缓存。因此在多进程模式下，系统对它的读/写变得不可靠，当面对搞并发的读/写访问时，SharedPreference有很大几率会丢失数据，因此不建议在进程间通信中使用SharedPreference。 MessengerMessenger可以翻译为信使，通过它可以在不同进程中传递Message对象，在Message中放入我们需要传递的数据，就可以轻松实现数据的进程间传递,也可以在同一个进程中使用。Messenger是一种轻量级的IPC方案，它的底层实现是AIDL。Messenger类的构造方法如下 1234567public Messenger(Handler target) &#123; mTarget = target.getIMessenger();&#125;public Messenger(IBinder target) &#123; mTarget = IMessenger.Stub.asInterface(target);&#125; Messenger使用简单，它对AIDL做了封装。同时，由于它一次处理一个请求，因此在服务端我们不用考虑线程同步的问题，这是因为服务端不存在并发执行的情形。实现一个Messenger由如下几个步骤，分为服务端和客户端。 1. 服务端进程 首先，我们需要在服务端创建一个Service来处理客户端的连接请求，同时创建一个Handler，并通过它来创建一个Messenger对象，然后在Service的onBind中返回这个Messenger对象底层的Binder即可。 2. 客户端进程 客户端进程中，首先要绑定服务端的Servcie，绑定成功后用服务端返回的IBinder对象创建一个Messenger，通过这个Messenger就可以向服务器发送消息了，发送消息类型为Message对象。如果需要服务端回应客户端蛮久和服务端一样，我们还需要创建一个Handler并创建一个新的Messenger，并把这个Messenger对象通过Messge的replyTo参数传递给服务端，服务端通过这个replyTo参数就可以回应客户端。 首先是服务端的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MessengerService extends Service &#123; //1.创建Handler对象处理Message private static class MessengerHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; // TODO Auto-generated method stub switch (msg.what) &#123; case Constants.MSG_FROM_CLIENT: System.out.println(\"receiver msg from client: \" + msg.getData().get(\"msg\")); //返回信息到服务端 //获取客户端接收消息的Messenger Messenger client = msg.replyTo; Message replyMessage = Message.obtain(); replyMessage.what = Constants.MSG_FROM_SERVER; Bundle data = new Bundle(); data.putString(\"reply\", \"嗯，你的消息我已经收到!\"); replyMessage.setData(data); try &#123; client.send(replyMessage); &#125; catch (RemoteException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; break; &#125; super.handleMessage(msg); &#125; &#125; //2.创建一个Messenger,将客户端发送的消息传递给MessengerHandler处理 private final Messenger mMessenger = new Messenger(new MessengerHandler()); //3.返回Messenger对象底层Binder @Override public IBinder onBind(Intent intent) &#123; // TODO Auto-generated method stub return mMessenger.getBinder(); &#125;&#125; 然后，注册Service 1234&lt;service android:name=\"com.ryg.chapter_2.messenger.MessengerService\" android:process=\":remote\" &gt;&lt;/service&gt; 最后是客户端代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class MainActivity extends Activity &#123; private Messenger mService; //将服务端返回的消息传递MessengerHandler处理 private Messenger mGetReplyMessenger = new Messenger(new MessengerHandler()); private static class MessengerHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; // TODO Auto-generated method stub switch (msg.what) &#123; case Constants.MSG_FROM_SERVER: System.out.println(\"receiv msg from server: \" + msg.getData().getString(\"reply\")); break; &#125; super.handleMessage(msg); &#125; &#125; private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; // TODO Auto-generated method stub &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; // TODO Auto-generated method stub //2.创建一个Messenger mService = new Messenger(service); //3.通过Messenger发送Message消息到服务端 if (mService != null) &#123; Message msg = Message.obtain(); msg.what = Constants.MSG_FROM_CLIENT; Bundle data = new Bundle(); data.putString(\"msg\", \"hello,this is client\"); msg.setData(data); //将接收服务端回复的Messenger传递给服务端，必须要传递过去，否则收不到回复 msg.replyTo = mGetReplyMessenger; try &#123; mService.send(msg); &#125; catch (RemoteException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //1.绑定服务 Intent intent = new Intent(this, MessengerService.class); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); &#125; @Override protected void onDestroy() &#123; // TODO Auto-generated method stub if (mConnection != null) &#123; unbindService(mConnection); &#125; super.onDestroy(); &#125;&#125; 运行结果: 12 13:20:43.218: I/System.out(3280): receiver msg from client: hello,this is client01-11 13:20:43.234: I/System.out(3222): receiv msg from server: 嗯，你的消息我已经收到! 通过上面的例子可以看出，在Messenger中进行数据传递必须将数据放入Message中，而Messenger和Message都实现了Parcelable接口，因此可以跨进程传输。简单来说，Message中所支持的数据类型就是Messenger中所支持的传输类型。实际上，通过Messenger来传输Message，Message中能使用的载体只有what、arg1、arg2、Bundle以及reply。Message中的另一个字段object在同一进程中的很实用的，但是再进程间通信的时候，在Android2.2以前object字段不支持跨进程传输，即便是android2.2以后，也仅仅是系统提供的实现了Parcelable接口的对象才能通过它来传输，这就意味着我们自定义的Parcelable对象无法通过object字段来传输。因此使用Bundle可以支持大量的数据类型。 AIDLMessenger是以串行的方式处理客户端发来的消息，如果大量的消息同时发送到服务器，服务端仍然只能一个一个处理,（1）如果有大量的并发请求，那么用Messenger就不太合适了。同时，Messenger的作用仅仅是为了传递消息，（2）很多时候我们可能需要跨进程调用服务端的方法，这种情形用Messenger就无法做到了，但是我们可以使用AIDL来实现跨进程的方法调用。 下面介绍使用AIDL来进行进程间通信的流畅，分为服务端和客户端两个方面 服务端服务端要首先创建一个Service用来监听客户端的连接，然后创建一个AIDL文件，将暴露给客户端的接口再这个AIDL文件中声明，最后在Service中实现这个AIDL接口。 （1）AIDL接口的创建创建一个后缀为aidl的文件，在里面声明了一个接口和两个接口方法 123456789101112//IBookManager.aidlpackage com.ryg.chapter_2.aidl;import com.ryg.chapter_2.aidl.Book;interface IBookManager &#123; List&lt;Book&gt; getBookList(); void addBook(in Book book); &#125; 在AIDL文件中，并不是所有的数据类型都是可以使用的，AIDL到底支持哪些数据类型呢？如下所示 基本数据类型 String和CharSequence List：只支持ArrayList，并且里面的每个元素必须能够被AIDL支持 Map： 只支持HashMap，并且里面的每个元素都必须能够被AIDL文件支持，包括key和value Parcelable：所有实现了Parcelable接口的对象 AIDL：所有的AIDL接口本身也可以在AIDL文件中使用 以上6中就是AIDL支持的数据类型，其中自定义的Parcelable对象和AIDL对象必须要显示的import进来，不管它们是否和当前的AIDL文件位于同一个文件夹内。 IBookManager.aidl文件中引用了Book这个类，Book类是一个自定义的Parcelable对象，所以必须新建一个与它同名的AIDL文件，并在其中声明它为Parcelable，如下所示： 12345//Book.aidlpackage com.ryg.chapter_2.aidl;parcelable Book; 注意： 除此之外，AIDL中除了基本数据类型，其他类型的参数必须标上方向：in、out或者inout，in表示输入型参数，out表示输出型参数，inout表示输入输出型参数。 AIDL的包结构在客户端工程和服务端工程中要保持一致，否则会运行出错，这是因为客户端需要反序列化服务端中和AIDL接口相关的所有类，如果类的完整路径不一致，就无法成功反序列化，程序也就无法正常运行。 （2）远程服务端service的实现 1234567891011121314151617181920212223242526272829303132333435363738public class BookManagerService extends Service &#123; private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;Book&gt;(); private Binder mBinder = new IBookManager.Stub() &#123; @Override public List&lt;Book&gt; getBookList() throws RemoteException &#123; // TODO Auto-generated method stub return mBookList; &#125; @Override public void addBook(Book book) throws RemoteException &#123; // TODO Auto-generated method stub if (!mBookList.contains(book)) &#123; mBookList.add(book); &#125; &#125; &#125;; @Override public void onCreate() &#123; // TODO Auto-generated method stub super.onCreate(); mBookList.add(new Book(1, \"Android\")); mBookList.add(new Book(2, \"IOS\")); &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO Auto-generated method stub return mBinder; &#125;&#125; 上面是一个服务端Service的典型实现，首先在onCreate中初始化添加两本书的信息，然后创建一个Binder对象并在Binder中返回次对象，这个对象继承自IBookManager.Stub并实现了内部的AIDL方法。这里采用了CopyOnWriteArrayList，这个CopyOnWriteArrayList支持并发读/写。AIDL方法是在服务端的Binder线程池中执行的，因此当多个客户端同时连接的时候，会存在多个线程同时访问的情形，所以我们要在AISL方法中处理线程的同步，这里使用CopyOnWriteArrayList来进行自动的线程同步。 AIDL中能够使用的List只有ArrayList，但是我们这里使用的CopyOnWriteArrayList不是继承自ArrayList，为什么能够正常工作呢？这是因为AIDL所支持的是抽象的List，而List只是一个接口，因此虽然服务端返回的是CopyOnWriteArrayList，但在Binder中会按照List的规范去访问数据并最终形成一个ArrayList传递给客户端。所以，在服务端采用CopyOnWriteArrayList是完全可行的，与此类似的类还有ConCureentHashMap。 注册Service 1234&lt;service android:name=\"com.ryg.chapter_2.aidl.BookManagerService\" android:process=\":remote1\" &gt;&lt;/service&gt; 客户端客户端首先要绑定远程服务，绑定成功后将服务端返回的Binder对象转换成AIDL接口，然后就可以通过这个接口去调用服务端的远程方法了，如下 1234567891011121314151617181920212223242526272829303132333435363738private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; // TODO Auto-generated method stub &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; // TODO Auto-generated method stub IBookManager bookManager = IBookManager.Stub.asInterface(service); try &#123; List&lt;Book&gt; list = bookManager.getBookList(); System.out.println(\"query book list type: \" + list.getClass().getCanonicalName()); System.out.println(\"query book list: \" + list.toString()); bookManager.addBook(new Book(3, \"Windows Phone\")); list = bookManager.getBookList(); System.out.println(\"query book list: \" + list.toString()); &#125; catch (RemoteException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; // TODO Auto-generated method stub super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(this, BookManagerService.class); bindService(intent, mConnection, Context.BIND_AUTO_CREATE);&#125; 运行结果: 123 14:51:36.937: I/System.out(24841): query book list type: java.util.ArrayList //CopyOnWriteArrayList转为Arraylist01-11 14:51:36.937: I/System.out(24841): query book list: [Book [bookId=1, bookName=Android], Book [bookId=2, bookName=IOS]]01-11 14:51:36.939: I/System.out(24841): query book list: [Book [bookId=1, bookName=Android], Book [bookId=2, bookName=IOS], Book [bookId=3, bookName=Windows Phone]] Binder意外死亡的处理办法（1）给Binder设置DeathRecipinent监听，当Binder死亡时，会收到binderDied的回调，在此回调中重新连接远程服务，次方法在客户端的Binder线程池中调用，不能直接访问UI 1234567891011121314151617181920212223242526272829303132333435363738394041private IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient() &#123; //Binder死亡时的回调方法 @Override public void binderDied() &#123; // TODO Auto-generated method stub if (bookManager == null) &#123; return; &#125; bookManager.asBinder().unlinkToDeath(mDeathRecipient, 0); bookManager = null; //重新绑定远程服务 Intent intent = new Intent(BookManagerActivity.this, BookManagerService.class); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); &#125;&#125;;private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; // TODO Auto-generated method stub &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; // TODO Auto-generated method stub bookManager = IBookManager.Stub.asInterface(service); //给binder设置死亡代理 try &#123; service.linkToDeath(mDeathRecipient, 0); &#125; catch (RemoteException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; &#125; （2）在onServiceDisconnected中重连远程服务，此方法在客户端的UI线程中调用 1234567891011121314151617181920212223private ServiceConnection mConnection = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; // TODO Auto-generated method stub //重新绑定远程服务 Intent intent = new Intent(BookManagerActivity.this, BookManagerService.class); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; // TODO Auto-generated method stub bookManager = IBookManager.Stub.asInterface(service); //给binder设置死亡代理 try &#123; service.linkToDeath(mDeathRecipient, 0); &#125; catch (RemoteException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125;&#125; AIDL中使用权限验证功能默认情况下，我们的远程服务任何人都可以连接，所以我们必须给服务加入权限验证功能，权限验证失败则无法调用服务的方法，这里介绍两种常用的方法。 onBind中验证 早onBind中进行验证，验证不通过就直接返回null，这样验证失败的客户端无法绑定服务，比如使用permission验证。首先，在Manifest.xml中声明所需要的权限，比如： 123&lt;permission android:name=\"com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE\" android:protectionLevel=\"normal\"&gt; 然后在BookManagerService的onBind做权限验证，如下所示。 1234567891011@Overridepublic IBinder onBind(Intent intent) &#123; // TODO Auto-generated method stub int check = checkCallingOrSelfPermission(\"com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE\"); if (check == PackageManager.PERMISSION_DENIED) &#123; return null; //客户端就无法绑定到此服务 &#125; return mBinder;&#125; 这种方法同样适用于Messenger中。如果我们自己内部的应用想绑定到我们的服务中，只需要在它的AndroidManifest文件中使用permission即可 服务端的onTransact方法中验证 在服务端的onTransact方法中进行权限验证，验证失败就返回false，这样服务端就不会终止执行AIDL中的方法从而达到保护服务端的效果。至于验证的方式有很多，如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445private Binder mBinder = new IBookManager.Stub() &#123; @Override public List&lt;Book&gt; getBookList() throws RemoteException &#123; // TODO Auto-generated method stub return mBookList; &#125; @Override public void addBook(Book book) throws RemoteException &#123; // TODO Auto-generated method stub if (!mBookList.contains(book)) &#123; mBookList.add(book); &#125; &#125; @Override public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; // TODO Auto-generated method stub //1.通过permission验证 int check = checkCallingOrSelfPermission(\"com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE\"); if (check == PackageManager.PERMISSION_DENIED) &#123; return false; &#125; //2.验证包名 String packageName = null; String[] packages = getPackageManager().getPackagesForUid(getCallingUid()); if (packages != null &amp;&amp; packages.length &gt; 0) &#123; packageName = packages[0]; &#125; if (!packageName.startsWith(\"com.ryg\")) &#123; return false; &#125; return super.onTransact(code, data, reply, flags); &#125; &#125;; 上面介绍了常用的两种权限验证方式，但是还有其他方式做权限验证，比如为Service指定android:permission属性等。 ContentProviderContentProvider是Android中专门用于不同应用间进行数据共享的方式，从这一点来看，它天生适合进程间通信。和Messenger一样，ContentProvider的底层实现同样是Binder。 系统预置了许多ContentProvider，比如通讯录信息日程表信息等，要跨进程访问这些信息，只需要通过ContentResolver的query、update、insert和delete方法。下面我们演示实现一个自定义的ContentProvider，并演示如何在其他应用中获取ContentProvider中的数据从而实现进行间通信的目的。首先，创建一个ContentProvider的类，叫BookProvider，并实现6个抽象方法即可onCreate、query、delete、update、insert和getType。onCreate代表ContentProvider的创建，需要做一些初始化的工作；getType用来返回一个Uri请求所对应的MIME类型，比如视频、图片、等，如果应用不关心这个选项，可以直接在方法中返回null或者“*/*”剩下的四个方法对应于CRUD操作，对数据表的增删改查功能。 根据Binder的工作原理，这留个方法均运行在ContentProvider的进程中，除了onCreate有系统回调运行在主线程里，其他无非方法由外界回调并运行在Binder线程池中。 示例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//BookProvider.javapublic class BookProvider extends ContentProvider &#123; @Override public boolean onCreate() &#123; // TODO Auto-generated method stub System.out.println(\"onCreate current thread:\" + Thread.currentThread().getName()); return false; &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; // TODO Auto-generated method stub System.out.println(\"query current thread:\" + Thread.currentThread().getName()); return null; &#125; @Override public String getType(Uri uri) &#123; // TODO Auto-generated method stub return null; &#125; @Override public Uri insert(Uri uri, ContentValues values) &#123; // TODO Auto-generated method stub return null; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; // TODO Auto-generated method stub return 0; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; // TODO Auto-generated method stub return 0; &#125;&#125; 接下来我们需要注册这个BookProvider，如下所示。其中android:anthorities是ContentProvider的唯一标识，通过这个属性外部应用就可以访问我们的BookProvide。 12345678&lt;provider android:name=\"com.ryg.chapter_2.provider.BookProvider\" android:authorities=\"com.ryg.chapter_2.provider.book.provider\" //标识 android:permission=\"com.ryg.PROVIDER\" //权限 android:process=\":provider\" //ndroid:readPermission=\"com.ryg.PROVIDER.READ\" //读权限 //android:writePermission=\"com.ryg.PROVIDER.WRITE\" &gt; //写权限&lt;/provider&gt; 然后声明权限和加入权限 12345&lt;uses-permission android:name=\"com.ryg.PROVIDER\" /&gt; &lt;permission android:name=\"com.ryg.PROVIDER\" android:protectionLevel=\"normal\" /&gt; 创建BookActivity.java访问这个ContentProvider，代码如下： 123456789101112131415public class BookActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; // TODO Auto-generated method stub super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Uri uri = Uri.parse(\"content://com.ryg.chapter_2.provider.book.provider\"); getContentResolver().query(uri, null, null, null, null); getContentResolver().query(uri, null, null, null, null); getContentResolver().query(uri, null, null, null, null); getContentResolver().query(uri, null, null, null, null); &#125;&#125; 上面的代码中，我们提供ContentResolver对象的query方法查询BookProvider中的数据，其中”content://com.ryg.chapter_2.provider.book.provider”位移标识了BookProvider，这个标识正式为BookProvider的android:authorities属性所指定的值。 运行结果如下 12345 16:50:31.678: I/System.out(22482): onCreate current thread:main //主线程01-11 16:50:31.680: I/System.out(22482): query current thread:Binder_2 //Binder线程池中01-11 16:50:31.681: I/System.out(22482): query current thread:Binder_101-11 16:50:31.682: I/System.out(22482): query current thread:Binder_201-11 16:50:31.682: I/System.out(22482): query current thread:Binder_1 从结果可以看出，onCreate运行于主线程中，所以不能在onCreate中做耗时操作，query方法的四次调用不在同一个线程中，但是在同一个Binder线程池中。 接下来，我们继续完善BookProvider，从而使其对外界的应用提供数据。为了完成上述功能，我们需要一个数据库来管理图示和用户信息，如下所示。 12345678910111213141516171819202122232425262728293031323334public class BookOpenHelper extends SQLiteOpenHelper &#123; private static final String DB_NAME = \"book_provider.db\"; public static final String BOOK_TABLE_NAME = \"book\"; public static final String USER_TABLE_NAME = \"user\"; private static final int DB_VERSION = 1; //图书列表 private String CREATE_BOOK_TABLE = \"CREATE TABLE IF NOT EXISTS \" + BOOK_TABLE_NAME +\"(_id INTEGER PRIMARY KEY, name TEXT)\"; //用户列表 private String CREATE_USER_TABLE = \"CREATE TABLE IF NOT EXISTS \" + USER_TABLE_NAME +\"(_id INTEGER PRIMARY KEY, name TEXT, sex INT)\"; public BookOpenHelper(Context context) &#123; super(context, DB_NAME, null, DB_VERSION); // TODO Auto-generated constructor stub &#125; @Override public void onCreate(SQLiteDatabase db) &#123; // TODO Auto-generated method stub db.execSQL(CREATE_BOOK_TABLE); db.execSQL(CREATE_USER_TABLE); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; // TODO Auto-generated method stub &#125;&#125; 接下来，分别为book表和user表指定Uri，并关联对应的uri——code 123456789101112131415161718192021public class BookOpenHelper extends SQLiteOpenHelper &#123; private static final String DB_NAME = \"book_provider.db\"; public static final String BOOK_TABLE_NAME = \"book\"; public static final String USER_TABLE_NAME = \"user\"; private static final int DB_VERSION = 1; //图书列表 private String CREATE_BOOK_TABLE = \"CREATE TABLE IF NOT EXISTS \" + BOOK_TABLE_NAME +\"(_id INTEGER PRIMARY KEY, name TEXT)\"; //用户列表 private String CREATE_USER_TABLE = \"CREATE TABLE IF NOT EXISTS \" + USER_TABLE_NAME +\"(_id INTEGER PRIMARY KEY, name TEXT, sex INT)\"; public BookOpenHelper(Context context) &#123; super(context, DB_NAME, null, DB_VERSION); // TODO Auto-generated constructor stub &#125; .......&#125; 接下来我们就可以通过如下方式获取外界要访问点饿数据源，根据Uri取出Uri_code，根据Uri_code得到数据表的名称 1234567891011121314151617181920212223private String getTableName(Uri uri) &#123; String tableName = null; switch (sUriMatcher.match(uri)) &#123; case BOOK_URI_CODE: tableName = BookOpenHelper.BOOK_TABLE_NAME; break; case USER_URI_CODE: tableName = BookOpenHelper.USER_TABLE_NAME; break; default: break; &#125; return tableName;&#125; 接下来，我们就实现query、update、insert、delete方法了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144public class BookProvider extends ContentProvider &#123; public static final String AUTHORITY = \"com.ryg.chapter_2.provider.book.provider\"; public static final Uri BOOK_CONTENT_URI = Uri.parse(\"content://\" + AUTHORITY + \"/book\"); public static final int BOOK_URI_CODE = 0; public static final Uri USER_CONTENT_URI = Uri.parse(\"content://\" + AUTHORITY + \"/user\"); public static final int USER_URI_CODE = 1; private static final UriMatcher sUriMatcher = new UriMatcher( UriMatcher.NO_MATCH); static &#123; // 将Uri和Uri_Code关联起来 sUriMatcher.addURI(AUTHORITY, \"book\", 0); sUriMatcher.addURI(AUTHORITY, \"book\", 1); &#125; private Context mContext; private SQLiteDatabase db; @Override public boolean onCreate() &#123; // TODO Auto-generated method stub mContext = getContext(); initData(); return true; &#125; private void initData() &#123; // TODO Auto-generated method stub db = new BookOpenHelper(mContext).getWritableDatabase(); db.execSQL(\"delete from \" + BookOpenHelper.BOOK_TABLE_NAME); db.execSQL(\"delete from \" + BookOpenHelper.USER_TABLE_NAME); db.execSQL(\"insert into book values(2,'Android');\"); db.execSQL(\"insert into book values(3,'IOS');\"); db.execSQL(\"insert into book values(4,'Window Phone');\"); db.execSQL(\"insert into user values(6,'lee',1);\"); db.execSQL(\"insert into book values(7,'lau',0);\"); &#125; @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException(\"Unsupported URI: \" + uri); &#125; return db.query(table, projection, selection, selectionArgs, null, null, sortOrder, null); &#125; @Override public String getType(Uri uri) &#123; // TODO Auto-generated method stub return null; &#125; @Override public Uri insert(Uri uri, ContentValues values) &#123; // TODO Auto-generated method stub String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException(\"Unsupported URI: \" + uri); &#125; db.insert(table, null, values); mContext.getContentResolver().notifyChange(uri, null); //通过数据源变化 return uri; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; // TODO Auto-generated method stub String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException(\"Unsupported URI: \" + uri); &#125; int count = db.delete(table, selection, selectionArgs); if (count &gt;0) &#123; mContext.getContentResolver().notifyChange(uri, null); &#125; return count; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; // TODO Auto-generated method stub String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException(\"Unsupported URI: \" + uri); &#125; int row = db.update(table, values, selection, selectionArgs); if (row &gt; 0) &#123; mContext.getContentResolver().notifyChange(uri, null); &#125; return row; &#125; private String getTableName(Uri uri) &#123; String tableName = null; switch (sUriMatcher.match(uri)) &#123; case BOOK_URI_CODE: tableName = BookOpenHelper.BOOK_TABLE_NAME; break; case USER_URI_CODE: tableName = BookOpenHelper.USER_TABLE_NAME; break; default: break; &#125; return tableName; &#125;&#125; 访问BookProvider 1234567891011121314151617181920212223242526272829public class BookActivity extends Activity &#123; private ContentObserver mObserver = new ContentObserver(new Handler()) &#123; @Override public void onChange(boolean selfChange, Uri uri) &#123; // TODO Auto-generated method stub System.out.println(uri); super.onChange(selfChange, uri); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; // TODO Auto-generated method stub super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Uri uri = Uri.parse(\"content://com.ryg.chapter_2.provider.book.provider/book\"); getContentResolver().registerContentObserver(uri, false, mObserver); ContentValues values = new ContentValues(); values.put(\"_id\", 7); values.put(\"name\", \"Html\"); getContentResolver().insert(uri, values); &#125;&#125; 需要注意的是，query、update、insert、delete四大方法是存在多线程并发访问的，因此方法内部要做好线程同步本例中，由于采用的是SQLite并且只有一个SQLiteDataBase的连接，所以可以正确应对多线程的情况。具体原因是SQLiteDatabase内部对数据库的操作是有同步处理的，但是如果通过多个SQLiteDatabase对象来操作数据库就无法保证线程同步，因为SQLiteDatabase对象之间无法进行线程同步。如果ContentProvider的底层数据是一块内存的话，比如List，在这种情况下同List的遍历、插入、删除操作就需要进行线程同步，否则就会引起并发错误。 SocketSocket又称为套接字，是网络通信的概念，它分为流式套接字和用户数据报套接字，分别对应于网络传输层的TCP和UDP协议。TCP是面向连接的协议，提供稳定的双向通信功能，TCP连接的建立需要经过“三次握手”才能完成，为了提供稳定的数据传输功能，其本身提供了超时重传机制，因此具有很高的稳定性；而UDP是面向无连接的协议，提供不稳定的单向通信功能，当然UDP也可以实现双向通信功能。在性能上，UDP具有更高的效率，其缺点是不能保证数据一定能够正确传输，尤其是在网络拥塞的情况下。 下面示例一个聊天室程序，首先是服务端的设计，当Service启动时，会在线程中建立TCP服务，这里监听的是8688端口，然后就可以等待客户端的连接请求。当有客户端连接时，就会生成一个新的Socket，通过每次新创建的Socket就可以分别和不同的客户端通信了。当客户端断开连接时，服务端这边也会关闭对应Socket并结束通话线程。这点是如何做到的呢？这里是通过判断服务端输入流的返回值来确定的，当客户端断开连接后，服务端这边的输入流会返回null，这个时候我们就知道客户端退出了。服务端代码如下： 选用合适的IPC方式 名称 优点 缺点 适用场景 Bundle 简单易用 只能传输Bundle支持的数据类型 四大组件间的进程间通信 文件共享 简单易用 不适合高并发场景，并且无法做到进程间的即时通信 无并发访问情形，交换简单的数据实时性不高的场景 AIDL 功能强大，支持一对多并发通信，支持实时通信 使用稍复杂，需要处理好现场同步 一对多通信且有RPC需求 Messenger 功能一般，支持一对多串行通信，支持实时通信 不能很好地处理搞并发情形，不支持RPC，数据通过Messenger进行传输，因此只能传输Bundle支持的数据类型 低并发的一对多即时通信，无RPC需求，或者无需要返回结果的RPC需求 ContentProvider 在数据源访问方面功能强大，支持一对多并发数据共享，可通过Call方法扩展其他操作 可以理解为受约束的AIDL，主要提供数据源的CRUD操作 一对多的进程间的数据共享 Socket 功能强大，可通过网络传输字节流，支持一对多并发实时通信 实现细节稍微有些烦琐，不支持直接的RPC 网络数据交换","tags":[{"name":"Android系统","slug":"Android系统","permalink":"http://liuguoquan727.github.io/tags/Android系统/"}]},{"title":"Android的IPC机制","date":"2016-04-19T14:39:32.000Z","path":"2016/04/19/Android的IPC机制/","text":"Android IPC简介IPC是Inter-Process Communication的缩写，含义为进程间通信，是指两个进程之间进行数据交换的过程。 Android中IPC的使用情况分为两种： 第一种情况是一个应用因为某些原因自身需要采用多进程模式来实现，至于原因，可能有很多，比如有些模块由于特殊的原因需要运行在单独的进程中，又或者为了加大一个应用可使用的内存所以需要通过多进行来获取多分内存空间。 第二种情况是当前应用需要向其他应用获取数据，由于是两个应用，所以必须采用跨进程的方式来获取所需要的数据，甚至我们系统提供的ContentProvider去查询数据的时候，其实也是一种进程间通信，只不过通信细节被系统内部屏蔽了。 Android中的多进程模式开启多进行模式正常情况下，在Android中多进程是指一个应用中存在多个进程的情况，因此这里不讨论两个应用之间的多进程情况。首先，在Android中使用多进程只有一种方法，就是给四大组件在AndroidManifest中指定android:process属性，除此之外没有其他办法。其实还有另一种非常规的多进程方法，那就是通过JNI在native层其fork一个新的进程，这种方法属于特殊情况，也不是常用的创建多进程的方式。下面示例，描述如何在Android中创建多进程 1234567&lt;activity android:name=\"com.example.demo.AActivity\" android:process=\":remote\" /&gt;&lt;activity android:name=\"com.example.demo.BActivity\" android:process=\"com.example.demo.BaseActivity.remote\" /&gt; 上面示例分为为AActivity和BActivity指定了process属性，并且他们的属性值不同，意味着当前应用又增加了两个进程。当AActivity启动时，系统会为它创建一个单独的进程，进程名为”com.example.demo.BaseActivity:remote”；当BActivity启动时，系统也会为它创建一个单独的进程，进程名为”com.example.demo.BaseActivity.remote”。 “:remote”和”com.example.demo.BaseActivity.remote”这两种命名方式的区别？ 首先“:”的含义是指要在当前的进程名前面附加当前的包名，而”com.example.demo.BaseActivity.remote”是完整的命名方式不会附加包名信息 其次，进程名以“:”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中，而进程名不易“：”开头的进程属于全局进程，其他应用通过ShareUID方式可以和它跑在同一个进程中。 多进程模式的运行机制Android为你每个应用分配了一个独立的虚拟机，或者说为每个进程都分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就会导致在不同的虚拟机中访问同一个类对象会产生多份副本。 所有运行在不同进程中的四大组件，只要它们之间需要通过内存来共享数据，都会共享失败，这也是多线程所带来的主要影响。 一般来说，使用多线程会造成如下四个方面的问题： （1）静态成员和单例模式完全失效 Android为你每个应用分配了一个独立的虚拟机，或者说为每个进程都分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就会导致在不同的虚拟机中访问同一个类对象会产生多份副本。 （2）线程同步机制完全失效 本质上和第一个问题是类似的，既然都不是一块内存了，那么不管锁对象还是锁全局类都无法保证线程同步，因为不同进程锁的不是同一个对象。 （3）SharedPreference的可靠性下降 是因为SharedPreference不支持两个进程同步去执行写操作，否则会导致一定几率的丢失，这是因为SharedPreference底层是通过读/写XML文件实现的，并发写文件显然是可能出问题的，甚至并发读/写都有可能出问题。 （4）Application会多次创建 当一个组件跑在一个新的进程中的时候，由于系统要在创建新的进程同时分配独立的虚拟机，所以这个过程其实就是启动一个新应用的过程。因此，相当于系统又把这个应用重新启动了一遍，既然重新启动了，那么自然会创建新的Application。 在多进程模式中，不同进程的组件的确会拥有独立的虚拟机、Application和内存空间。 为了解决这个问题，Android系统提供了很多跨进程通信方法实现数据交互。如Intent来传递数据，共享文件和SharedPreference，基于Binder的Messenger和AIDL，Socket等。 IPC基础概念介绍Serializable接口Serializable是Java所提供的一个序列化接口，它是一个空接口，为对象提供标准的序列化和反序列化操作。使用Serializable来实现序列化相当简单只需要在类的声明中指定一个类似下面的标志即可自动实现默认的序列化过程。 12345678910111213141516171819202122private static final long serialVersionUID = 5123020951483359287L; //系统生成的hash值private static final long serialVersionUID = 1L; //指定为1Lpublic class User implements Serializable &#123; /** * */ private static final long serialVersionUID = 5123020951483359287L; //系统生成的hash值 public int userId; public String userName; public boolean isMale; @Override public String toString() &#123; return \"User [userId=\" + userId + \", userName=\" + userName + \", isMale=\" + isMale + \"]\"; &#125;&#125; 通过Serializable接口来实现对象的序列化过程非常简单，几乎所有的工作都被系统自动完成了。 1234567891011//序列化存储User user = new User(2, \"liuguoquan\", true); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(Environment.getExternalStorageDirectory()+\"/cache.txt\")); out.writeObject(user); out.close();//反序列化 ObjectInputStream in = new ObjectInputStream(new FileInputStream(Environment.getExternalStorageDirectory()+\"/cache.txt\")); User newUser = (User) in.readObject(); in.close(); 上述代码描述了采用Serializable方式序列化对象的典型过程，很简单，只需要把实现了Serializable接口的User对象写到文件中就可以快速恢复了，恢复后的对象newUser和user的内容完全一样，但是两者并不是同一个对象。 其实，不指定serialVersionUID也可以实现序列化，那到底要不要指定呢？系统既然提供了这个serialVersionUID，那么它必须是有用的，原则上序列化的数据中的serialVersionUID只有和当前类的serialVersionUID相同时才能够正常地被反序列化。 serialVersionUID的详细工作机制是这样的：序列化的时候系统会把当前类的serialVersionUID写入序列化的文件中，当反序列化的时候系统会去检查文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，如果一致说明序列化的类版本与当前类的版本是相同的则可以成功反序列化；否则就说明当前类和序列化的类相比发生了某些变化，比如成员变量的数量、类型可能发生了改变，这个时候是无法正常反序列化的。 给serialVersionUID指定为1L或者采用系统当前类结构去生成的hash值，这两者并没有什么区别，效果完全一样。以下两点需要注意： 静态成员变量属于类不属于对象，所以不会参与序列化过程 用transient关键字标记的成员变量不参与序列化过程 Parcalable接口Parcelable也是一个也是一个接口，只要实现这个接口，一个类的对象就要就可以实现序列化并可以通过Intent和Binder传递。下面的示例是一个典型的用法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Person implements Parcelable &#123; private int id; private String name; private int sex; private User user; @Override public int describeContents() &#123; // TODO Auto-generated method stub return 0; &#125; //序列化 @Override public void writeToParcel(Parcel dest, int flags) &#123; // TODO Auto-generated method stub dest.writeInt(id); dest.writeString(name); dest.writeInt(sex); dest.writeSerializable(user); &#125; //反序列化 public static final Parcelable.Creator&lt;Person&gt; CREATOR = new Parcelable.Creator&lt;Person&gt;() &#123; @Override public Person createFromParcel(Parcel source) &#123; // TODO Auto-generated method stub Person person = new Person(); //必须要按照成员变量的初始化顺序 person.id = source.readInt(); person.name = source.readString(); person.sex = source.readInt(); person.user = (User) source.readSerializable(); return person; &#125; @Override public Person[] newArray(int size) &#123; // TODO Auto-generated method stub return new Person[size]; &#125; &#125;;&#125; 系统已经为我们提供了许多实现了Parcelable接口的类，它们逗死可以直接序列化的，比如Intent、Bundle、Bitmap等，同时List和Map也可以序列化，前提是他们里面的每个元素都可以序列化。 既然Parcelable和Serializable都能实现序列化并且都可用于Intent间的数据传递，那么二者该如何选取呢？Serializable是Java中的序列化接口，其使用起来非常简单但是开销很大，序列化和反序列化过程需要大量的I/O操作。而Parcelable是Android中的序列化方式，因此更适合在Android平台上，它的缺点就是使用起来稍微麻烦点，但是它的效率很高，这是Android推荐的序列化方式。因此首选Parcelable。Parcelable主要用在内存序列化上，通过Parcelable将对象序列化到存储设备中或者将对象序列化后通过网络传输也都是可以的，但这个过程显得复杂，因此这两种情况下建议使用Serializable。 Binder是Android中的一个类，它实现了IBinder接口。从IPC角度来说，Binder是Android中的一种跨进程通信方式，Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在Linux中没有；从Android Framework角度来说，Binder是ServiceManager连接各种Manager（ActivityManager、WindowManager，等待）和相应的ManagerService的桥梁；从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindservice时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或数据，这里的服务包括普通的服务和基于AIDL的服务。 Android开发中，Binder主要用在service中，包括AIDL和Messenger，其中普通Service中的Binder不涉及进程间通信，而Messenger的底层其实是AIDL，所以这里选用AIDL来分析Binder的工作机制。 下面新建一个AIDL示例，新建三个文件Book.java、Book.aidl、IBookManager.aidl，代码如下所示： Book.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 package com.ryg.chapter_2.aidl; import android.os.Parcel; import android.os.Parcelable; public class Book implements Parcelable &#123; public int bookId; public String bookName; public Book(int bookId, String bookName) &#123; this.bookId = bookId; this.bookName = bookName; &#125; @Override public int describeContents() &#123; // TODO Auto-generated method stub return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; // TODO Auto-generated method stub dest.writeInt(bookId); dest.writeString(bookName); &#125; public static final Parcelable.Creator&lt;Book&gt; CREATOR = new Parcelable.Creator&lt;Book&gt;() &#123; @Override public Book createFromParcel(Parcel source) &#123; // TODO Auto-generated method stub return new Book(source); &#125; @Override public Book[] newArray(int size) &#123; // TODO Auto-generated method stub return new Book[size]; &#125; &#125;; private Book(Parcel in) &#123; bookId = in.readInt(); bookName = in.readString(); &#125; &#125;Book.aidl package com.ryg.chapter_2.aidl; parcelable Book;IBookManager.aidl package com.ryg.chapter_2.aidl; import com.ryg.chapter_2.aidl.Book; interface IBookManager &#123; List&lt;Book&gt; getBookList(); void addBook(in Book book); &#125; Book.java是一个图书信息的类，它实现了Parcelable接口。Book.aidl是Book类在AIDL的声明。IBookManager.aidl是我们定义的一个接口，里面有两个方法，其中getBookList用于从远程服务端获取图书列表，而addBook用于向图书列表中添加一本书。尽管Book类已经和IBookManager位于相同的包中，但是IBookManager中仍然要导入Book类，接下来系统会在gen目录自动生成一个IBookManager的类。如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/* * This file is auto-generated. DO NOT MODIFY. * Original file: D:\\\\liuguoquan\\\\workspace\\\\chapter_2\\\\src\\\\com\\\\ryg\\\\chapter_2\\\\aidl\\\\IBookManager.aidl */package com.ryg.chapter_2.aidl;//在Binder传输的接口都要实现IInterfacepublic interface IBookManager extends android.os.IInterface &#123; /** Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.ryg.chapter_2.aidl.IBookManager &#123; private static final java.lang.String DESCRIPTOR = \"com.ryg.chapter_2.aidl.IBookManager\"; //内部类，这个Stub就是一个Binder类 /** Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an com.ryg.chapter_2.aidl.IBookManager * interface, generating a proxy if needed. */ public static com.ryg.chapter_2.aidl.IBookManager asInterface( android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.ryg.chapter_2.aidl.IBookManager))) &#123; return ((com.ryg.chapter_2.aidl.IBookManager) iin); &#125; return new com.ryg.chapter_2.aidl.IBookManager.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_getBookList: &#123; //用于标识方法 data.enforceInterface(DESCRIPTOR); java.util.List&lt;com.ryg.chapter_2.aidl.Book&gt; _result = this .getBookList(); reply.writeNoException(); reply.writeTypedList(_result); return true; &#125; case TRANSACTION_addBook: &#123; data.enforceInterface(DESCRIPTOR); com.ryg.chapter_2.aidl.Book _arg0; if ((0 != data.readInt())) &#123; _arg0 = com.ryg.chapter_2.aidl.Book.CREATOR .createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; this.addBook(_arg0); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements com.ryg.chapter_2.aidl.IBookManager &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; @Override public java.util.List&lt;com.ryg.chapter_2.aidl.Book&gt; getBookList() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List&lt;com.ryg.chapter_2.aidl.Book&gt; _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0); _reply.readException(); _result = _reply .createTypedArrayList(com.ryg.chapter_2.aidl.Book.CREATOR); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; @Override public void addBook(com.ryg.chapter_2.aidl.Book book) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); if ((book != null)) &#123; _data.writeInt(1); book.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125; &#125; static final int TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); //标识方法的id static final int TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); &#125; public java.util.List&lt;com.ryg.chapter_2.aidl.Book&gt; getBookList() throws android.os.RemoteException; public void addBook(com.ryg.chapter_2.aidl.Book book) throws android.os.RemoteException;&#125; 上述代码实现的功能：（1）IBookManager类继承IInterface接口，同时它自己也是个接口，所有可以在Binder中传输的接口都需要继承IInterface接口（2）首先，它声明了两个方法getBookList和addBook，就是我们自IBookManager.aidl中定义的方法，同时还声明了两个整形id分别用于标识这两个方法，这两个id用于标识在transact中客户端所请求的到底是哪个方法（3）接着，它声明了一个内部类Stub，这个Stub就是一个Binder类，当客户端和服务端都位于一个进程时，方法调用不会走跨进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由Stub的内部代理类Proxy来完成。这个接口的核心实现就是内部了Stub和Stub的内部代理类Proxy 说明：首先，当客户端发起远程请求时，由于当前线程会被挂起直至服务器进程返回数据，所以如果一个远程方法是很耗时的，那么不能在UI线程中发起次远程请求；其次，由于服务器的Binder方法运行在Binder线程池中，所以Binder方法不管是否耗时都应该采用同步的方式去实现，因为它已经运行在一个线程中了。","tags":[{"name":"Android系统","slug":"Android系统","permalink":"http://liuguoquan727.github.io/tags/Android系统/"}]},{"title":"Android EventBus3.0源码解析","date":"2016-04-18T15:05:06.000Z","path":"2016/04/18/Android EventBus3.0源码解析/","text":"前面已经介绍了EventBus3.0开源库的详细使用，下面我们开始进入其源代码的学习，先看看EventBus3.0与2.x版本之间的区别。 项目地址https://github.com/greenrobot/EventBusEventBus版本是3.0 EventBus 3.0与2.x的区别注册订阅者12345678//3.0版本的注册EventBus.getDefault().register(this);//2.x版本的注册EventBus.getDefault().register(this);EventBus.getDefault().register(this, 100);EventBus.getDefault().registerSticky(this, 100);EventBus.getDefault().registerSticky(this); 2.x版本中有四种注册方法，区分了普通注册和粘性事件注册，并且在注册时可以选择接受事件的优先级； 3.0版本中将粘性事件以及订阅事件的优先级用注解的方式实现，所以3.0版本中的注册就变得只有一个register()方法注册。 事件订阅方法12345678910111213141516//3.0版本@Subscribe(threadMode = ThreadMode.BACKGROUND, sticky = true, priority = 100)public void test(String str) &#123;&#125;//2.x版本public void onEvent(String str) &#123;&#125;public void onEventMainThread(String str) &#123;&#125;public void onEventBackgroundThread(String str) &#123;&#125; 2.x版本中只有通过onEvent开头的方法会被注册，而且响应事件方法触发的线程通过onEventMainThread或onEventBackgroundThread这些方法名区分； 3.0版本中，通过@Subscribe注解来确定运行的线程threadMode，是否接收粘性事件sticky以及事件优先级priority，而且方法名不再需要使用onEvent开头，所以3.0提高了简单性和灵活性。 发送事件发送事件和发送粘性事件在2.x和3.0版本中是相同的。 12EventBus.getDefault().post(\"str\");EventBus.getDefault().postSticky(\"str\"); 解除注册2.x和3.0版本的解除注册的方法也是相同的。 1EventBus.getDefault().unregister(this); 类关系图类图引用自CodeKK的EventBus源代码分析 从类图可以看出，上部分主要是订阅相关信息，中间是EventBus，下面部分是发布者发布事件后的调用。下面开始进入源码分析: 源码分析通过EventBus的使用流程来分析它的调用流程及实现原理。 创建EventBus一般都是通过EventBus.getDefault()静态方法获取到EventBus对象，先来看看getDefault()方法的实现 12345678910public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance;&#125; 这里使用单例模式获取EventBus对象，目的是保证getDefault方法得到的是同一个EventBus对象。第一次创建实例，会调用EventBus的构造方法 12345678910111213141516171819202122232425262728293031323334353637public EventBus() &#123; this(DEFAULT_BUILDER);&#125;//key:订阅的事件 value：订阅这个事件的所有订阅者集合private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;//key:订阅者对象， value：这个订阅者订阅的事件集合private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;//粘性事件 key：粘性事件的class对象， value：事件对象private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;EventBus(EventBusBuilder builder) &#123; subscriptionsByEventType = new HashMap&lt;&gt;(); typesBySubscriber = new HashMap&lt;&gt;(); stickyEvents = new ConcurrentHashMap&lt;&gt;(); //事件主线程处理 mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10); //事件Background处理 backgroundPoster = new BackgroundPoster(this); //事件异步线程处理 asyncPoster = new AsyncPoster(this); indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0; //订阅者想要方法信息存储和查找 subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes, builder.strictMethodVerification, builder.ignoreGeneratedIndex); logSubscriberExceptions = builder.logSubscriberExceptions; logNoSubscriberMessages = builder.logNoSubscriberMessages; sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent; sendNoSubscriberEvent = builder.sendNoSubscriberEvent; throwSubscriberException = builder.throwSubscriberException; //是否支持事件继承 eventInheritance = builder.eventInheritance; executorService = builder.executorService;&#125; 注册事件过程register()方法的实现1234567891011121314151617181920public void register(Object subscriber) &#123; //首先获取订阅者的class对象 Class&lt;`?&gt; subscriberClass = subscriber.getClass(); //1 获取订阅者订阅的事件集合 List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; //2 订阅 subscribe(subscriber, subscriberMethod); &#125; &#125;&#125;public SubscriberMethod(Method method, Class&lt;?&gt; eventType, ThreadMode threadMode, int priority, boolean sticky) &#123; this.method = method; //事件处理方法的Method对象 this.threadMode = threadMode; //线程的ThreadMode this.eventType = eventType; //订阅的事件类型 this.priority = priority; //事件优先级 this.sticky = sticky; //是否接收粘性事件&#125; 通过subscriberMethodFinder.findSubscriberMethods(subscriberClass)方法可以返回一个SubscriberMethod对象的集合，下面来看看findSubscriberMethods()方法的实现 SubscriberMethodFinder的实现SubscriberMethodFinder类就是用来查找和缓存订阅者响应方法的信息的类。那么怎么能获得订阅者响应函数的相关信息呢？在3.0版本中,EventBus提供了一个EventBusAnnotationProcessor注解处理器来在编译期通过读取@Subscribe注解并解析，然后生成java类来保存所有订阅者关于订阅的信息，这样就比在运行时使用反射来获得这些订阅者的信息速度要快。我们可以参考EventBus项目里的EventBusPerformance这个例子，编译后我们可以在build文件夹里找到这个类，MyEventBusIndex类，当然类名是可以自定义的，下面看一下生成的MyEventBusIndex类的组成： 123456789101112131415161718192021222324252627282930313233/** * This class is generated by EventBus, do not edit. */public class MyEventBusIndex implements SubscriberInfoIndex &#123; private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX; static &#123; SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;(); putIndex(new SimpleSubscriberInfo(org.greenrobot.eventbusperf.testsubject.PerfTestEventBus.SubscriberClassEventBusAsync.class, true, new SubscriberMethodInfo[]&#123; new SubscriberMethodInfo(\"onEventAsync\", TestEvent.class, ThreadMode.ASYNC), &#125;)); putIndex(new SimpleSubscriberInfo(TestRunnerActivity.class, true, new SubscriberMethodInfo[]&#123; new SubscriberMethodInfo(\"onEventMainThread\", TestFinishedEvent.class, ThreadMode.MAIN), &#125;)); &#125; private static void putIndex(SubscriberInfo info) &#123; SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info); &#125; @Override public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123; SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass); if (info != null) &#123; return info; &#125; else &#123; return null; &#125; &#125;&#125; 可以看出是使用一个静态HashMap即：SUBSCRIBER_INDEX来保存订阅类的信息，其中包括了订阅类的Class对象，是否需要检查父类，以及订阅方法的信息SubscriberMethodInfo的数组，SubscriberMethodInfo中又保存了订阅方法的方法名、订阅的事件类型、触发线程，是否接收sticky事件以及优先级priority。这其中就保存了register()的所有需要的信息，如果再配置EventBus的时候通过EventBuilder配置：eventBus=EventBus.builder().addIndex(new MyEventBusIndex()).build()；来将编译生成的MyEventBusIndex配置进去，这样能在SubscriberMethodFinder类中直接查找出订阅类的信息，就不需要再利用注解判断了，这种方法是作为EventBus的可选配置存在的。 SubscriberMethodFinder同样提供了通过注解来获得订阅类信息的方法，下面来看看findSubscriberMethods()到底是如何实现的： 12345678910111213141516171819202122232425List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; //先从Method_CACHE取看是否有缓存，key：保存订阅类的类名，value:保存类中订阅的方法名 List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) &#123; return subscriberMethods; &#125; //是否忽略注解器生成的MyEventIndex类，默认false if (ignoreGeneratedIndex) &#123; //利用反射来读取订阅类中的订阅方法 subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; //从注解器生成的MyEventBusIndex类中获得订阅类的订阅方法 subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; throw new EventBusException(\"Subscriber \" + subscriberClass + \" and its super classes have no public methods with the @Subscribe annotation\"); &#125; else &#123; //保存到缓存中 METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125;&#125; findUsingInfo()方法就是通过查找MyEventBusIndex类中的信息来转换成List从而获得订阅类的相关订阅方法的信息集合。 下面来看看findUsingReflection()的实现过程 12345678910111213private List&lt;SubscriberMethod&gt; findUsingReflection(Class&lt;?&gt; subscriberClass) &#123; //FindState用来做订阅方法的校验和保存 FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; //通过反射获得订阅方法信息 findUsingReflectionInSingleClass(findState); //查找父类的订阅方法 findState.moveToSuperclass(); &#125; //获取findState中的SubscriberMethod(也就是订阅方法List)并返回 return getMethodsAndRelease(findState);&#125; 这里通过FindState类来做订阅方法的校验和保存，并通过FIND_STATE_POOL静态数组来保存FindState对象，可以使FindState复用，避免重复创建过多的对象，最终是通过findUsingReflectionSingleClass()来具体获得相关订阅方法的信息的： 123456789101112131415161718192021222324252627282930313233343536373839404142private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; //通过反射得到方法数组 try &#123; // This is faster than getMethods, especially when subscribers are fat classes like Activities methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 methods = findState.clazz.getMethods(); findState.skipSuperClasses = true; &#125; //遍历Method for (Method method : methods) &#123; int modifiers = method.getModifiers(); if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); //保证必须只有一个事件参数 if (parameterTypes.length == 1) &#123; //得到注解 Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; Class&lt;?&gt; eventType = parameterTypes[0]; //校验是否添加该方法 if (findState.checkAdd(method, eventType)) &#123; ThreadMode threadMode = subscribeAnnotation.threadMode(); //实例化SubscriberMethod对象并添加 findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + \".\" + method.getName(); throw new EventBusException(\"@Subscribe method \" + methodName + \"must have exactly 1 parameter but has \" + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; String methodName = method.getDeclaringClass().getName() + \".\" + method.getName(); throw new EventBusException(methodName + \" is a illegal @Subscribe method: must be public, non-static, and non-abstract\"); &#125; &#125;&#125; 上面代码运行后，订阅类的所有SubscriberMethod都已经被保存了，最后在通过getMethodsAndRelease方法返回List集合。 下面接着来看subscribe()是如何实现的 subsribe()方法的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 必须在同步代码块中调用private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; //获取订阅事件的事件类型 Class&lt;?&gt; eventType = subscriberMethod.eventType; //创建SubScription对象 Subscription newSubscription = new Subscription(subscriber, subscriberMethod); //检查是否已经添加过该SubScription对象，添加过则抛出异常 CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException(\"Subscriber \" + subscriber.getClass() + \" already registered to event \" + eventType); &#125; &#125; //根据优先级来添加SubScription对象 int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; //将订阅者对象以及订阅的事件保存到typesBySubscriber中 List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; subscribedEvents.add(eventType); //如果接受sticky事件则立即分发sticky事件 if (subscriberMethod.sticky) &#123; //eventInheritance表示是否分发订阅了响应事件类及父类事件的方法 if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125;&#125; 一下结合一张图来理解整个注册过程： 事件分发过程EventBus通过post方法来发送一个事件，首先看看post方法的实现过程 1234567891011121314151617181920212223242526public void post(Object event) &#123; //得到当前线程的Posting状态 PostingThreadState postingState = currentPostingThreadState.get(); //获取当前线程的事件队列 List&lt;Object&gt; eventQueue = postingState.eventQueue; //加入事件到队列 eventQueue.add(event); if (!postingState.isPosting) &#123; postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper(); postingState.isPosting = true; if (postingState.canceled) &#123; throw new EventBusException(\"Internal error. Abort state was not reset\"); &#125; try &#123; //发送知道队列为空 while (!eventQueue.isEmpty()) &#123; //发送单个事件 postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125;&#125; 首先是通过currentPostingThreadState.get()方法来得到当前线程PostingThreadState的对象，为什么是说当前线程？我们来看看currentPostingThreadState的实现： 123456private final ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal&lt;PostingThreadState&gt;() &#123; @Override protected PostingThreadState initialValue() &#123; return new PostingThreadState(); &#125;&#125;; currentPostingThreadState的实现是一个包含了PostingThreadState的ThreadLocal对象。 ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储线程，而这段数据是不会与其他线程共享的，其内部原理是通过生成一个它包裹的泛型对象的数组，在不同的线程会有不同的数组索引值，这样就可以做到每个线程通过get()方法获取的时候，取到的只能是自己线程所对应的数据，所以这里取到的就是每个线程的PostingThreadState状态。 接下来我们来看postingSingleEvent()方法： 123456789101112131415161718192021222324252627282930private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; Class&lt;?&gt; eventClass = event.getClass(); boolean subscriptionFound = false; //是否触发订阅了该事件（eventClass）的父类，以及接口的类的响应方法 if (eventInheritance) &#123; ////查找eventClass类所有的父类以及接口 List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); //循环postSingleEventForEventType for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; //post单个事件 subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; //如果没有发现 if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; Log.d(TAG, \"No subscribers registered for event \" + eventClass); &#125; if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; //发送一个NoSubscriberEvent事件，如果我们需要处理这种状态，接收这个事件就可以了 post(new NoSubscriberEvent(this, event)); &#125; &#125;&#125; 从上面可知，实际上事件分发是在postSingleEventForEventType()方法里进行的，代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; //获取订阅了这个事件的Subscription列表. synchronized (this) &#123; subscriptions = subscriptionsByEventType.get(eventClass); &#125; if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; //是否被中断 boolean aborted = false; try &#123; //分发给订阅者 postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125; &#125; return true; &#125; return false;&#125;private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(\"Unknown thread mode: \" + subscription.subscriberMethod.threadMode); &#125;&#125; 首先从subscriptionsByEventType里获得所有订阅了这个事件的Subscription列表，然后在通过postToSubScription()方法来分发事件，在postToSubScription()通过不同的threadMode在不同的线程里invoke()订阅者的方法，ThreadMode共有四类： PostThread：默认的 ThreadMode，表示在执行 Post 操作的线程直接调用订阅者的事件响应方法，不论该线程是否为主线程（UI 线程）。当该线程为主线程时，响应方法中不能有耗时操作，否则有卡主线程的风险。适用场景：对于是否在主线程执行无要求，但若 Post 线程为主线程，不能耗时的操作； MainThread：在主线程中执行响应方法。如果发布线程就是主线程，则直接调用订阅者的事件响应方法，否则通过主线程的 Handler 发送消息在主线程中处理——调用订阅者的事件响应函数。显然，MainThread类的方法也不能有耗时操作，以避免卡主线程。适用场景：必须在主线程执行的操作； BackgroundThread：在后台线程中执行响应方法。如果发布线程不是主线程，则直接调用订阅者的事件响应函数，否则启动唯一的后台线程去处理。由于后台线程是唯一的，当事件超过一个的时候，它们会被放在队列中依次执行，因此该类响应方法虽然没有PostThread类和MainThread类方法对性能敏感，但最好不要有重度耗时的操作或太频繁的轻度耗时操作，以造成其他操作等待。适用场景：操作轻微耗时且不会过于频繁，即一般的耗时操作都可以放在这里； Async：不论发布线程是否为主线程，都使用一个空闲线程来处理。和BackgroundThread不同的是，Async类的所有线程是相互独立的，因此不会出现卡线程的问题。适用场景：长耗时操作，例如网络访问。 下面我们来看看invokeSubscriber(subscription, event)是如何实现的，关于不同线程的Poster使用可以参考这篇文章http://kymjs.com/code/2015/12/12/01 invokeSubscriber(subscription, event)代码如下 123456789void invokeSubscriber(Subscription subscription, Object event) &#123; try &#123; subscription.subscriberMethod.method.invoke(subscription.subscriber, event); &#125; catch (InvocationTargetException e) &#123; handleSubscriberException(subscription, event, e.getCause()); &#125; catch (IllegalAccessException e) &#123; throw new IllegalStateException(\"Unexpected exception\", e); &#125;&#125; 实际上就是通过反射调用了订阅者的订阅函数并把event对象作为参数传入，至此post()流程如上述所示。整体流程图如下： 解除注册过程解除注册只要调用unregister()方法即可，实现如下： 1234567891011121314151617181920212223242526272829303132public synchronized void unregister(Object subscriber) &#123; //通过typesBySubscriber来取出这个subscriber订阅者订阅的事件类型, List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber); if (subscribedTypes != null) &#123; //分别解除每个订阅了的事件类型 for (Class&lt;?&gt; eventType : subscribedTypes) &#123; unsubscribeByEventType(subscriber, eventType); &#125; //从typesBySubscriber移除subscriber typesBySubscriber.remove(subscriber); &#125; else &#123; Log.w(TAG, \"Subscriber to unregister was not registered before: \" + subscriber.getClass()); &#125;&#125;private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123; //subscriptionsByEventType里拿出这个事件类型的订阅者列表. List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions != null) &#123; int size = subscriptions.size(); //取消订阅 for (int i = 0; i &lt; size; i++) &#123; Subscription subscription = subscriptions.get(i); if (subscription.subscriber == subscriber) &#123; subscription.active = false; subscriptions.remove(i); i--; size--; &#125; &#125; &#125;&#125; 最终分别从typesBySubscriber和subscriptions里分别移除订阅者以及相关信息即可 设计模式观察者模式观察者模式是对象的行为模式，又叫发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者模式。观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。EventBus并不是标准的观察者模式的实现，但是它的整体就是一个发布/订阅框架，也拥有观察者模式的有点，比如：发布者和订阅者的解耦。 参考文章: EventBus 3.0 源码分析EventBus源码研读EventBus 源码解析","tags":[{"name":"源码分析","slug":"源码分析","permalink":"http://liuguoquan727.github.io/tags/源码分析/"}]},{"title":"Otto源码解析","date":"2016-04-18T15:04:06.000Z","path":"2016/04/18/Android Otto源码解析/","text":"前面介绍了Otto的使用情况，下面开始进入Otto的源码分析之旅。 首先来看看构造函数： 构造函数123456789101112131415161718192021222324private final String identifier;private final ThreadEnforcer enforcer;private final HandlerFinder handlerFinder;public Bus() &#123; this(DEFAULT_IDENTIFIER);&#125;public Bus(String identifier) &#123; this(ThreadEnforcer.MAIN, identifier);&#125;public Bus(ThreadEnforcer enforcer, String identifier) &#123; this(enforcer, identifier, HandlerFinder.ANNOTATED);&#125;Bus(ThreadEnforcer enforcer, String identifier, HandlerFinder handlerFinder) &#123; this.enforcer = enforcer; this.identifier = identifier; this.handlerFinder = handlerFinder;&#125; 默认参数enforcer=ThreadEnforcer.MAIN，identifier=DEFAULT_IDENTIFIER，handlerFinder=HandlerFinder.ANNOTATED。下面来看看这些参数是什么意思： ThreadEnforceThreadEnforce是一个接口，enforce()方法用于检查当前的线程是否为指定的线程类型 123456789101112131415161718192021public interface ThreadEnforcer &#123; ThreadEnforcer ANY = new ThreadEnforcer() &#123; @Override public void enforce(Bus bus) &#123; // Allow any thread. &#125; &#125;; ThreadEnforcer MAIN = new ThreadEnforcer() &#123; @Override public void enforce(Bus bus) &#123; if (Looper.myLooper() != Looper.getMainLooper()) &#123; throw new IllegalStateException(\"Event bus \" + bus + \" accessed from non-main thread \" + Looper.myLooper()); &#125; &#125; &#125;; void enforce(Bus bus);&#125; 不带参数的构造函数默认使用ThreadEnforcer.MAIN，表示enforce()方法必须在主线程上执行。 identifieridentifier为Bus对象的名字，debug用 HandlerFinderHandlerFinder用于在注册/反注册的时候查找Subscriber和Produce，后文会对其展开源码级别的解析。默认使用HandlerANNOTATED，表示使用注解来进行查找。 其他除上述以外，Bus类还有两个成员变量handlersByType和producersByType: 12345678910111213141516/**** 通过event的类型（class类型）来查找event handle。* 键为 event类型 值为 事件订阅者集合* 一个事件类型可以有多个事件订阅者*/private final ConcurrentMap&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; handlersByType = new ConcurrentHashMap&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt;();/**** 通过event的类型（class类型）来查找event producer。* 键为 event类型 值为 事件生产者* 一个事件类型，只能有一个事件生产者*/private final ConcurrentMap&lt;Class&lt;?&gt;, EventProducer&gt; producersByType = new ConcurrentHashMap&lt;Class&lt;?&gt;, EventProducer&gt;(); 注册/反注册事件如下所示要成为订阅者HandlerEvent，只需将其注册到bus，然后使用@Subscribe注解标记回调处理方法即可。回调方法要求可见性为public，有且仅有一个参数，类型为订阅的event。 12345678910class A &#123; public A() &#123; bus.register(this); &#125; @Subscribe public void answerAvailable(HandlerEvent event) &#123; // process event &#125;&#125; @Subsrible首先看一下@Subscribe注解: 1234@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Subscribe &#123;&#125; RetentionPolicy.RUNTIME表示它是运行时的注解，ElementType.METHOD表示用于注解方法。 register()register流程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public void register(Object object) &#123; //1.检查当前线程是否符合ThreadEnforcer的设置 if (object == null) &#123; throw new NullPointerException(\"Object to register must not be null.\"); &#125; enforcer.enforce(this); //2.默认情况下，通过@Producer注解找到所有的事件生产者Producers Map&lt;Class&lt;?&gt;, EventProducer&gt; foundProducers = handlerFinder.findAllProducers(object); for (Class&lt;?&gt; type : foundProducers.keySet()) &#123; //2-1 判断object上的produce注册的event是否已经被别人注册过 final EventProducer producer = foundProducers.get(type); //type存在则返回type对应的值 type不存在则将type的键值设为producer EventProducer previousProducer = producersByType.putIfAbsent(type, producer); //checking if the previous producer existed if (previousProducer != null) &#123; throw new IllegalArgumentException(\"Producer method for type \" + type + \" found on type \" + producer.target.getClass() + \", but already registered by type \" + previousProducer.target.getClass() + \".\"); &#125; //2-2 如果没有被注册过，那么找出对应event的handler，触发一次回调 Set&lt;EventHandler&gt; handlers = handlersByType.get(type); if (handlers != null &amp;&amp; !handlers.isEmpty()) &#123; for (EventHandler handler : handlers) &#123; dispatchProducerResultToHandler(handler, producer); &#125; &#125; &#125; //3. 找出object上用@Subscribe注解的方法 Map&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; foundHandlersMap = handlerFinder.findAllSubscribers(object); for (Class&lt;?&gt; type : foundHandlersMap.keySet()) &#123; Set&lt;EventHandler&gt; handlers = handlersByType.get(type); if (handlers == null) &#123; //3-1，该event是第一次注册，那么新建一个CopyOnWriteArraySet用来保存handler和event的对应关系 Set&lt;EventHandler&gt; handlersCreation = new CopyOnWriteArraySet&lt;EventHandler&gt;(); handlers = handlersByType.putIfAbsent(type, handlersCreation); if (handlers == null) &#123; handlers = handlersCreation; &#125; &#125; //3-2,保存object中新增的event-handler对应关系 final Set&lt;EventHandler&gt; foundHandlers = foundHandlersMap.get(type); if (!handlers.addAll(foundHandlers)) &#123; throw new IllegalArgumentException(\"Object already registered.\"); &#125; &#125; //4.检查object上的event是否存在对应的Producer，有则触发一次调用 for (Map.Entry&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; entry : foundHandlersMap.entrySet()) &#123; Class&lt;?&gt; type = entry.getKey(); EventProducer producer = producersByType.get(type); if (producer != null &amp;&amp; producer.isValid()) &#123; Set&lt;EventHandler&gt; foundHandlers = entry.getValue(); for (EventHandler foundHandler : foundHandlers) &#123; if (!producer.isValid()) &#123; break; &#125; if (foundHandler.isValid()) &#123; dispatchProducerResultToHandler(foundHandler, producer); &#125; &#125; &#125; &#125;&#125; register方法主要做了三件事情：触发新的Producer；注册新的event-handler关系；触发旧的Producer。另外有两点要注意： 在保证线程安全的情况下，使用CopyOnWriteArraySet作为保存event和handler的容器，可以大大提高效率。 由于register方法没有加锁，所有在3-1中，尽管已经检查了handlers是否存在，但仍需使用putIfAbsent来保存handler。 HandlerFinder注意到Bus通过HandlerFinder来查找object上的producer和subscriber，接下来看一下HanderFinder的实现： 12345678910111213141516171819interface HandlerFinder &#123; Map&lt;Class&lt;?&gt;, EventProducer&gt; findAllProducers(Object listener); Map&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; findAllSubscribers(Object listener); HandlerFinder ANNOTATED = new HandlerFinder() &#123; @Override public Map&lt;Class&lt;?&gt;, EventProducer&gt; findAllProducers(Object listener) &#123; return AnnotatedHandlerFinder.findAllProducers(listener); &#125; @Override public Map&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; findAllSubscribers(Object listener) &#123; return AnnotatedHandlerFinder.findAllSubscribers(listener); &#125; &#125;;&#125; 其中findAllProducers方法返回某event type对应的EventProducers，findAllSubscribers返回某event type对应的EventHandler集合。 EventProducerEventProducer是producer方法的包装类，源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class EventProducer &#123; final Object target; private final Method method; private final int hashCode; private boolean valid = true; EventProducer(Object target, Method method) &#123; if (target == null) &#123; throw new NullPointerException( \"EventProducer target cannot be null.\"); &#125; if (method == null) &#123; throw new NullPointerException( \"EventProducer method cannot be null.\"); &#125; this.target = target; this.method = method; method.setAccessible(true); // 提前计算hashcode，以防每次调用hash()时消耗资源 final int prime = 31; hashCode = ((prime + method.hashCode()) * prime) + target.hashCode(); &#125; public boolean isValid() &#123; return valid; &#125; // 应在object unregister时调用 public void invalidate() &#123; valid = false; &#125; public Object produceEvent() throws InvocationTargetException &#123; if (!valid) &#123; throw new IllegalStateException(toString() + \" has been invalidated and can no longer produce events.\"); &#125; try &#123; return method.invoke(target); &#125; catch (IllegalAccessException e) &#123; throw new AssertionError(e); &#125; catch (InvocationTargetException e) &#123; if (e.getCause() instanceof Error) &#123; throw (Error) e.getCause(); &#125; throw e; &#125; &#125;&#125; 其中 produceEvent方法用于获得event。可以看出Otto要求produce方法不能有参数。 EventHandlerEventHandler是一个event handler方法（事件回调）的包装类，源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class EventHandler &#123; private final Object target; private final Method method; private final int hashCode; private boolean valid = true; EventHandler(Object target, Method method) &#123; if (target == null) &#123; throw new NullPointerException( \"EventHandler target cannot be null.\"); &#125; if (method == null) &#123; throw new NullPointerException( \"EventHandler method cannot be null.\"); &#125; this.target = target; this.method = method; method.setAccessible(true); // Compute hash code eagerly since we know it will be used frequently and we cannot estimate the runtime of the // target's hashCode call. final int prime = 31; hashCode = ((prime + method.hashCode()) * prime) + target.hashCode(); &#125; public boolean isValid() &#123; return valid; &#125; public void invalidate() &#123; valid = false; &#125; public void handleEvent(Object event) throws InvocationTargetException &#123; if (!valid) &#123; throw new IllegalStateException(toString() + \" has been invalidated and can no longer handle events.\"); &#125; try &#123; method.invoke(target, event); &#125; catch (IllegalAccessException e) &#123; throw new AssertionError(e); &#125; catch (InvocationTargetException e) &#123; if (e.getCause() instanceof Error) &#123; throw (Error) e.getCause(); &#125; throw e; &#125; &#125;&#125; 其中handlEvent方法用于在object上调用handle方法（事件回调），传入event对象。Otto要求event handler方法只能有一个参数就是event handler类。 dispatchProducerResultToHandler()dispatchProducerResultToHandler方法用于将Producer产生的event分发给对应的handler，源码如下所示： 1234567891011121314151617181920private void dispatchProducerResultToHandler(EventHandler handler, EventProducer producer) &#123; Object event = null; try &#123; event = producer.produceEvent(); &#125; catch(InvocationTargetException e) &#123; throwRuntimeException(\"Producer \" + producer + \" threw an exception.\", e); &#125; if (event == null) &#123; return; &#125; dispatch(event, handler);&#125;protected void dispatch(Object event, EventHandler wrapper) &#123; try &#123; wrapper.handleEvent(event); &#125; catch(InvocationTargetException e) &#123; throwRuntimeException(\"Could not dispatch event: \" + event.getClass() + \" to handler \" + wrapper, e); &#125;&#125; 主要使用了Producer的produceEvent()获取event对象后，调用EventHandler的handleEvent（）方法处理事件。 unregister()Bus类的unregister()方法用于解除目标对象和Bus之间的关联关系，包括对象上的producer方法，subscriber方法，源码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940public void unregister(Object object) &#123; if (object == null) &#123; throw new NullPointerException(\"Object to unregister must not be null.\"); &#125; //1. 检查当前线程是否符合ThreadEnforcer的设置 enforcer.enforce(this); //2. 默认情况下，通过注解在object上找出所有Producer，将其从producersByType中删除并标记为invalidate Map&lt;Class&lt;?&gt;, EventProducer&gt; producersInListener = handlerFinder.findAllProducers(object); for (Map.Entry&lt;Class&lt;?&gt;, EventProducer&gt; entry : producersInListener.entrySet()) &#123; final Class&lt;?&gt; key = entry.getKey(); EventProducer producer = getProducerForEventType(key); EventProducer value = entry.getValue(); if (value == null || !value.equals(producer)) &#123; throw new IllegalArgumentException( \"Missing event producer for an annotated method. Is \" + object.getClass() + \" registered?\"); &#125; producersByType.remove(key).invalidate(); &#125; //3. 默认情况下，找出object上用@Subscribe注解了的handler，将其从event集合中删除并标记为invalidate Map&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; handlersInListener = handlerFinder.findAllSubscribers(object); for (Map.Entry&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; entry : handlersInListener.entrySet()) &#123; Set&lt;EventHandler&gt; currentHandlers = getHandlersForEventType(entry.getKey()); Collection&lt;EventHandler&gt; eventMethodsInListener = entry.getValue(); if (currentHandlers == null || !currentHandlers.containsAll(eventMethodsInListener)) &#123; throw new IllegalArgumentException( \"Missing event handler for an annotated method. Is \" + object.getClass() + \" registered?\"); &#125; for (EventHandler handler : currentHandlers) &#123; if (eventMethodsInListener.contains(handler)) &#123; handler.invalidate(); &#125; &#125; currentHandlers.removeAll(eventMethodsInListener); &#125;&#125; 投递事件post()简单的事件投递过程如下： 12345678910bus.post(new HandlerEvent(42));或者bus.post(getEvent);@Producerpublic HandlerEvent getEvent() &#123; return new HandlerEvent(42);&#125; 下面来看下post方法实现的源码： 1234567891011121314151617181920212223242526272829303132ublic void post(Object event) &#123; if (event == null) &#123; throw new NullPointerException(\"Event to post must not be null.\"); &#125; //1. 检查当前线程是否符合ThreadEnforcer的设置 enforcer.enforce(this); //2. 向上追溯event的所有父类 Set&lt;Class&lt;?&gt;&gt;dispatchTypes = flattenHierarchy(event.getClass()); //3. 当前event没有注册handler，则发送一个DeadEvent事件 boolean dispatched = false; for (Class&lt;?&gt;eventType: dispatchTypes) &#123; Set&lt;EventHandler&gt; wrappers = getHandlersForEventType(eventType); if (wrappers != null &amp;&amp; !wrappers.isEmpty()) &#123; dispatched = true; for (EventHandler wrapper: wrappers) &#123; //3-1 将事件和handler放到分发队列里 enqueueEvent(event, wrapper); &#125; &#125; &#125; //4. 当前event没有注册handler，则发送一个DeadEvent事件 if (!dispatched &amp;&amp; !(event instanceof DeadEvent)) &#123; post(new DeadEvent(this, event)); &#125; //5. 通知队列进行分发操作 dispatchQueuedEvents();&#125; 注意两点： 发送一个Event时，订阅了Event父类的Subscriber方法也会被调用 事件被放到调用者所在线程的队列里依次分发 flattenHierarchy()进行post操作时，首先会通过flattenHierarchy方法获得event的所有父类或接口的集合： 1234567891011121314151617181920212223242526272829303132 Set&lt;Class&lt;?&gt;&gt; flattenHierarchy(Class&lt;?&gt; concreteClass) &#123; Set&lt;Class&lt;?&gt;&gt; classes = flattenHierarchyCache.get(concreteClass); if (classes == null) &#123; Set&lt;Class&lt;?&gt;&gt; classesCreation = getClassesFor(concreteClass); classes = flattenHierarchyCache.putIfAbsent(concreteClass, classesCreation); if (classes == null) &#123; classes = classesCreation; &#125; &#125; return classes; &#125; //利用深度优先遍历导出了concreteClass的所有父类 private Set&lt;Class&lt;?&gt;&gt; getClassesFor(Class&lt;?&gt; concreteClass) &#123; List&lt;Class&lt;?&gt;&gt; parents = new LinkedList&lt;Class&lt;?&gt;&gt;(); Set&lt;Class&lt;?&gt;&gt; classes = new HashSet&lt;Class&lt;?&gt;&gt;(); parents.add(concreteClass);//深度优先遍历 while (!parents.isEmpty()) &#123; Class&lt;?&gt; clazz = parents.remove(0); classes.add(clazz); Class&lt;?&gt; parent = clazz.getSuperclass(); if (parent != null) &#123; parents.add(parent); &#125; &#125; return classes; &#125; Dispatch Queue通过post方法投递的event首先会放到当前线程所在的Dispatch Queue中，然后依次分发。Bus类有如下成员属性： 123456private final ThreadLocal&lt;ConcurrentLinkedQueue&lt;EventWithHandler&gt;&gt; eventsToDispatch = new ThreadLocal&lt;ConcurrentLinkedQueue&lt;EventWithHandler&gt;&gt;() &#123; @Override protected ConcurrentLinkedQueue&lt;EventWithHandler&gt; initialValue() &#123; return new ConcurrentLinkedQueue&lt;EventWithHandler&gt;(); &#125; &#125;; eventsToDispatch是一个ThreadLocal对象，通过initialValue()方法，eventsToDispatch每次在新的线程上调用的时候都会生成新的ConcurrentLinkedQueue实例。event是通过enqueueEvent方法放到queue中的，下面看看equeueEvent()的实现： 123protected void enqueueEvent(Object event, EventHandler handler) &#123; eventsToDispatch.get().offer(new EventWithHandler(event, handler));&#125; offer()方法会将EventWithHandler对象放到当前线程的queue的尾部。offer方法和add方法的区别在于，当无法插入（例如空间不够）情况下会返回false，而不是抛出异常。EventWithHandler类对event和handler的关系进行了简单的包装，实现如下： 123456789static class EventWithHandler &#123; final Object event; final EventHandler handler; public EventWithHandler(Object event, EventHandler handler) &#123; this.event = event; this.handler = handler; &#125;&#125; 接下来看看dispatchQueuedEvents方法的实现： 12345678910111213141516171819202122232425262728293031323334protected void dispatchQueuedEvents() &#123; // don't dispatch if we're already dispatching, that would allow reentrancy and out-of-order events. Instead, leave // the events to be dispatched after the in-progress dispatch is complete. //1. 不能重复分发，否则会导致event的分发次序混乱 if (isDispatching.get()) &#123; return; &#125; isDispatching.set(true); try &#123; while (true) &#123; //2. 依次取出EventWithHandler，并通过dispatch方法进行分发。 EventWithHandler eventWithHandler = eventsToDispatch.get().poll(); if (eventWithHandler == null) &#123; break; &#125; if (eventWithHandler.handler.isValid()) &#123; dispatch(eventWithHandler.event, eventWithHandler.handler); &#125; &#125; &#125; finally &#123; isDispatching.set(false); &#125;&#125; protected void dispatch(Object event, EventHandler wrapper) &#123; try &#123; wrapper.handleEvent(event); &#125; catch (InvocationTargetException e) &#123; throwRuntimeException( \"Could not dispatch event: \" + event.getClass() + \" to handler \" + wrapper, e); &#125; &#125; 值得注意的是，所有subscrible方法抛出的异常都会在这里捕获，捕获到异常以后event分发过程即停止，直到下一次在该线程上调用post为止。 结构图Otto的总体结构如下表示 12345678910111213141516171819202122232425262728293031 +-------------------------+ |Bus(ThreadLocal) | | +--------------+ | | |EventProducers| | | | +-------+ | register +-------+ | | |Produce| &lt;----+-------+Produce| | | +-------+ | | +-------+ | | +-------+ | | | | |Produce| | | | | +-------+ | | | +--------------+ | | | | | event | | | | post(event)| +-------v--------+ |+----------------&gt; Dispatch Queue | | | +-------+--------+ | | | | | event | | | | | +------v------+ | | |EventHandlers| | | | +---------+ | | | | |Subscribe| | register +---------+ | | +---------+ &lt;-----+-------+Subscribe| | | +---------+ | | +---------+ | | |Subscribe| | | | | +---------+ | | | +-------------+ | | | +-------------------------+","tags":[{"name":"源码分析","slug":"源码分析","permalink":"http://liuguoquan727.github.io/tags/源码分析/"}]},{"title":"Okhttp使用详解","date":"2016-04-17T14:04:06.000Z","path":"2016/04/17/Android Okhttp使用详解/","text":"Okhttp是高性能的http库，支持同步、异步，而且实现了spdy、http2、websocket协议，api很简洁易用，和volley一样实现了http协议的缓存。Okhttp已经被Android官方采用，实现了几乎和Java.net.HttpURLConnection一样的功能。 下载地址官方介绍：http://square.github.io/okhttp/Github源代码：https://github.com/square/okhttp 功能 一般的Get请求 一般的Post请求 基于Http的文件上传 文件下载 加载图片 支持请求回调，直接返回对象、对象集合 支持session的保持 使用Http Get对于网络加载库，最常用的就是http get请求，比如获取一个网页的内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445 //1.创建OkHttpClient对象 OkHttpClient mOkHttpClient = new OkHttpClient(); //2.创建一个Request final Request mRequest = new Request.Builder().url(\"https://www.baidu.com\").build(); //3.创建Call对象 Call mCall = mOkHttpClient.newCall(mRequest); //4.请求加入调度 mCall.enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; mMsgTxt.setText(\"failure\"); &#125; &#125;); &#125; @Override public void onResponse(Call call, final Response response) throws IOException &#123; //字符串 final String msg = response.body().string(); //字节数组 byte[] msgBytes = response.body().bytes(); //流 InputStream inputStream = response.body().byteStream(); runOnUiThread(new Runnable() &#123; @Override public void run() &#123; mMsgTxt.setText(msg); &#125; &#125;); &#125; &#125;);&#125; 以上就是发送一个Get请求的步骤 首先构造一个Request对象，参数最少有个url，可以通过Request.Builder设置更多的参数，比如：header、method等。 然后通过Request的对象去够着一个Call对象，类似于将你的请求封装成任务。 最后，我们希望以异步的方式去执行请求，所以我们调用的是call.equeue，将call加入调度队列，然后等待任务执行完成，在Callback中即可得到结果。注意，回调方法都是运行在子线程中，如果需要操作控件，需要使用Handler切换到主线程。 上面是异步的方式执行get请求，当然也支持阻塞的方式，直接调用call.execute()方法返回一个Response。如下所示。 123456789101112//阻塞调用new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Response response = mCall.execute(); System.out.println(response.body().string()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;).start(); Http post请求12345678910Request request = buildMultipartFormRequest( url, new File[]&#123;file&#125;, new String[]&#123;fileKey&#125;, null);FormEncodingBuilder builder = new FormEncodingBuilder(); builder.add(\"username\",\"liuguoquan\");Request request = new Request.Builder() .url(url) .post(builder.build()) .build(); mOkHttpClient.newCall(request).enqueue(new Callback()&#123;&#125;); Post请求时，参数是包含在请求体中的，所以我们通过FormEncodingBuilder，添加多个String键值对，然后去构造RequestBody，最后完成Request的构造。 基于Http的文件上传接下来构造一个RequestBody的Builder叫做MultipartBuilder。 1234567891011121314151617181920212223242526File file = new File(Environment.getExternalStorageDirectory(), \"balabala.mp4\");RequestBody fileBody = RequestBody.create(MediaType.parse(\"application/octet-stream\"), file);RequestBody requestBody = new MultipartBuilder() .type(MultipartBuilder.FORM) .addPart(Headers.of( \"Content-Disposition\", \"form-data; name=\\\"username\\\"\"), RequestBody.create(null, \"liu\")) .addPart(Headers.of( \"Content-Disposition\", \"form-data; name=\\\"mFile\\\"; filename=\\\"wjd.mp4\\\"\"), fileBody) .build();Request request = new Request.Builder() .url(\"http://192.168.1.103:8080/okHttpServer/fileUpload\") .post(requestBody) .build();Call call = mOkHttpClient.newCall(request);call.enqueue(new Callback()&#123; //...&#125;); 上述代码向服务器传递了一个键值对username：liu和一个文件。通过MultipartBuilder的addPart方法可以添加键值对或者文件。 图片下载图片下载和文件下载，这两个是通过回调的Response拿到byte[]然后解码成图片；文件下载就是拿到InputStream后做写文件操作。 参考文章： 从原理角度解析Android （Java） http 文件上传泡网：OkHttp使用教程","tags":[{"name":"实战","slug":"实战","permalink":"http://liuguoquan727.github.io/tags/实战/"}]},{"title":"Otto使用详解","date":"2016-04-17T12:04:06.000Z","path":"2016/04/17/Android_Otto使用详解/","text":"Otto是Square推出的基于Guava项目的Android支持库，otto是一个事件总线，用于应用程序的不同组件之间进行有效的通信。OTTO是基于Observer的设计模式。它有发布者，订阅者这两个主要对象。OTTO的最佳实践就是通过反射牺牲了微小的性能，同时极大的降低了程序的耦合度。 Otto官网: http://square.github.io/otto/ 目的Otto框架的主要功能是帮助我们来降低多个组件通信之间的耦合度（解耦）。 应用场景比如：由界面A跳转至界面B，然后点击B中的Button发送消息更新界面A的视图；比如：界面有一个界面A，A里面有个Fragment，点击Fragment中的一个Button，跳转至界面B，点击界面B的Button来更新界面A的Fragment视图，等等。 上面列出的两种场景，以前可以用startActivityForResult和interface的方式实现的话会比较麻烦，并且产生了很多的状态判断和逻辑判断，并且可能产生很多不必要的bug，代码量也比较大和繁琐，使用Otto就可以容易的避免这些问题。 基本用法实例添加Otto123dependencies &#123; compile 'com.squareup:otto:1.3.8'&#125; 实现一个Bus的单例12345678910111213141516/** * 单例Bus对象 * Created by Michael on 2016/4/25. */public final class BusProvider &#123; public static final Bus bus = new Bus(); public static Bus getInstance() &#123; return bus; &#125; private BusProvider() &#123; &#125;&#125; 自定义一个Event事件，封装消息123456789101112/** * 自定义一个Event事件，用来封装信息 * Created by Michael on 2016/4/25. */public class EventFirst &#123; public String msg; public EventFirst(String msg) &#123; this.msg = msg; &#125;&#125; MainActivity，订阅事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MainActivity extends AppCompatActivity &#123; private Button mBtn1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //订阅事件 BusProvider.getInstance().register(this); mBtn1 = (Button) findViewById(R.id.btn_1); mBtn1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity(new Intent(MainActivity.this,BActivity.class)); &#125; &#125;); &#125; /** * 处理事件EventFirst * @param event */ @Subscribe public void onEventFirst(EventFirst event) &#123; mBtn1.setText(event.msg); System.out.println(\"onEventFirst:\" + event.msg); &#125; @Subscribe public void onEventSecond(EventFirst event) &#123; mBtn1.setText(event.msg); System.out.println(\"onEventFirst:\" + event.msg); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //取消订阅 BusProvider.getInstance().register(this); &#125;&#125; @Subscrible这个注解在调用了register之后有效，表示订阅一个事件，并且方法用public修饰，方法名可以任意取，参数为自定义的事件类，Otto根据事件对象的类名来判断和处理对应的事件。 BActivity发送订阅事件12345678910111213141516171819202122232425262728293031323334353637public class BActivity extends AppCompatActivity &#123; private Button mBtn; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_b);// BusProvider.getInstance().register(this); mBtn = (Button) findViewById(R.id.btn_1); mBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // BusProvider.getInstance().post(new EventFirst(\"Event First\")); BusProvider.getInstance().post(produceEventFirst()); &#125; &#125;); &#125; /** * 产生事件 * @return */ @Produce public EventFirst produceEventFirst() &#123; return new EventFirst(\"Event First\"); &#125; @Override protected void onDestroy() &#123; super.onDestroy();// BusProvider.getInstance().unregister(this); &#125;&#125; @Produce注解告诉Bus该函数是一个事件产生者，产生的事件类型为该函数的返回值。 结果点击BActivity中的按钮发送消息，然后返回至MainActivity中，打印如下： 1204-25 10:52:13.179 24744-24744/com.example.michael.ottodemo I/System.out: onEventSecond:Event First04-25 10:52:13.179 24744-24744/com.example.michael.ottodemo I/System.out: onEventFirst:Event First 结果说明：@Subscrible注解的消息处理函数时根据事件对象的类名来确定事件类型，这里的两个方法的参数都是EventFirst类型，所以两个方法都处理了EventFirst事件消息。 总结通过例子我们可以发现，其实事件发布者不用@Produce注解和注册事件也可以发布消息。但是你要Subscribe订阅事件就一定要register这个类了,否则是接受不到事件的。","tags":[{"name":"实战","slug":"实战","permalink":"http://liuguoquan727.github.io/tags/实战/"}]},{"title":"EventBus使用详解","date":"2016-04-17T11:22:20.000Z","path":"2016/04/17/Android_EventBus使用详解/","text":"概述EventBus是一个Android事件发布/订阅框架，通过解耦发布者和订阅者简化Android事件传递，这里的事件可以理解为消息。事件传递既可以用于Android四大组件间通讯，也可以用于异步线程和主线程间通讯等。传统的事件传递方式包括：Handler、BroadcastReceiver、Interface回调，相比之下EventBus的有点是代码简洁，使用简单，并将事件发布和 订阅充分解耦。 概念事件Event： 又可成为消息，其实就是一个对象，可以是网络请求返回的字符串，也可以是某个开关状态等等。事件类型EventType是指事件所属的Class。 事件分为一般事件和Sticky事件，相对于一般事件，Sticky事件不同之处在于，当事件发布后，再有订阅者开始订阅该类型事件，依然能收到该类型事件的最近一个Sticky事件。 订阅者Subscriber： 订阅某种事件类型的对象，当有发布者发布这类事件后，EventBus会执行订阅者的onEvent函数，这个函数叫事件响应函数。订阅者通过register接口订阅某个事件类型，unregister接口退订。订阅者存在优先级，优先级高的订阅者可以取消事件继续向优先级低的订阅者分发，默认所有订阅者优先级都为0。 发布者Publisher： 发布某事件的对象，通过post接口发布事件。 GitHub地址EventBus源码：https://github.com/greenrobot/EventBus 基本使用自定义一个事件类123public class AnyEventType &#123; public AnyEventType()&#123;&#125; &#125; 在要接受消息的页面注册1EventBus.getDefault().register(this); 接收消息的方法12@Subscribepublic void onEvent(AnyEventType event) &#123;/* Do something */&#125;; 发送消息1EventBus.getDefault().post(event); 取消注册1EventBus.getDefault().unregister(this); 实例下面我们来实现一个具体的例子来介绍EventBus的基本使用。 需求如下：在MainActivity中注册EventBus事件，并实现事件响应方法，当点击MainActivity中的按钮时跳转到SecondActivity，当点击SecondActivity中的按钮时向MainActivity发送Event事件，当MainActivity收到事件后，将事件内容显示在TextView中。 MainActivity SecondActivity 事件处理 事件类Event123456789101112public class Event &#123; private String messgae; public Event(String messgae) &#123; this.messgae = messgae; &#125; public String getMessgae() &#123; return messgae; &#125;&#125; MainActivity在OnCreate()函数中注册EventBus，在Ondestroy()函数中反注册。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class MainActivity extends AppCompatActivity &#123; @Bind(R.id.btn_open) Button mOpenBtn; @Bind(R.id.tv_showinfo) TextView mInfoTxt; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); //注册 EventBus.getDefault().register(this); &#125; /** * 事件响应方法 * 接收消息 * @param event */ @Subscribe(threadMode = ThreadMode.MAIN) public void onEvent(Event event) &#123; String msg = event.getMessgae(); mInfoTxt.setText(msg); &#125; //绑定点击事件 @OnClick(R.id.btn_open) public void openSecondActivity(View view) &#123; Intent intent = new Intent(MainActivity.this, SecondActivity.class); startActivity(intent); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //反注册 EventBus.getDefault().unregister(this); &#125;&#125; SecondActivity123456789101112131415161718192021222324252627282930public class SecondActivity extends AppCompatActivity &#123; @Bind(R.id.btn_post) Button mPostBtn; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); ButterKnife.bind(this); mPostBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; //发送事件 EventBus.getDefault().post(new Event(\"Just do it\")); &#125; &#125;).start(); &#125; &#125;); &#125;&#125; EventBus的事件订阅函数类别在上面的例子中，我们再注解@Subscribe(threadMode = ThreadMode.MAIN)中使用了ThreadMode.MAIN这个模式，表示该函数在主线程即UI线程中执行，实际上EventBus总共有四种线程模式，分别是： ThreadMode.MAIN：表示无论事件是在哪个线程发布出来的，该事件订阅方法onEvent都会在UI线程中执行，这个在Android中是非常有用的，因为在Android中只能在UI线程中更新UI，所有在此模式下的方法是不能执行耗时操作的。 ThreadMode.POSTING：表示事件在哪个线程中发布出来的，事件订阅函数onEvent就会在这个线程中运行，也就是说发布事件和接收事件在同一个线程。使用这个方法时，在onEvent方法中不能执行耗时操作，如果执行耗时操作容易导致事件分发延迟。 ThreadMode.BACKGROUND：表示如果事件在UI线程中发布出来的，那么订阅函数onEvent就会在子线程中运行，如果事件本来就是在子线程中发布出来的，那么订阅函数直接在该子线程中执行。 ThreadMode.AYSNC：使用这个模式的订阅函数，那么无论事件在哪个线程发布，都会创建新的子线程来执行订阅函数。 实战如何调用不同的订阅函数要调用四种不同模式的订阅函数，我们首先要用清楚EventBus是如何指定调用的函数的？ 先回顾一下上一节中的例子是如何调用订阅函数onEvent的，首先新建一个事件类： 123456789101112public class Event &#123; private String messgae; public Event(String messgae) &#123; this.messgae = messgae; &#125; public String getMessgae() &#123; return messgae; &#125;&#125; 发布事件：1EventBus.getDefault().post(new Event(\"Just do it\")); 订阅事件： 12345678910/** * 事件响应方法 * @param event */@Subscribe(threadMode = ThreadMode.MAIN)public void onEventMain(Event event) &#123; String msg = event.getMessgae(); mInfoTxt.setText(msg);&#125; 观察可以发现：发布事件中的参数是Event的实例，而订阅函数中的参数也是Event的实例，可以推断EventBus是通过post函数传进去的类的实例来确定调用哪个订阅函数的，是哪个就调用哪个，如果有多个订阅函数呢，那么这些函数都会被调用！ 示例下面我们来验证这个推断： 我们在基本使用章节的例子上进行扩展，首先建立四个类：FirstEvent、SecondEvent、ThirdEvent、FourthEvent。 FirstEvent.java 123456789101112public class FirstEvent &#123; private String messgae; public FirstEvent(String messgae) &#123; this.messgae = messgae; &#125; public String getMessgae() &#123; return messgae; &#125;&#125; SecondEvent.java 123456789101112public class SecondEvent &#123; private String messgae; public SecondEvent(String messgae) &#123; this.messgae = messgae; &#125; public String getMessgae() &#123; return messgae; &#125;&#125; ThirdEvent.java 123456789101112public class ThirdEvent &#123; private String messgae; public ThirdEvent(String messgae) &#123; this.messgae = messgae; &#125; public String getMessgae() &#123; return messgae; &#125;&#125; FourthEvent.java 123456789101112public class FourthEvent &#123; private String messgae; public FourthEvent(String messgae) &#123; this.messgae = messgae; &#125; public String getMessgae() &#123; return messgae; &#125;&#125; 然后在MainActivity中，增加四种模式的订阅函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class MainActivity extends AppCompatActivity &#123; private static final String TAG = \"MainActivity\"; @Bind(R.id.btn_open) Button mOpenBtn; @Bind(R.id.tv_showinfo) TextView mInfoTxt; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ButterKnife.bind(this); //注册 EventBus.getDefault().register(this); &#125; /** * 事件响应方法 * @param event */ @Subscribe(threadMode = ThreadMode.MAIN) public void onEventMain(FirstEvent event) &#123; String msg = event.getMessgae(); Log.i(TAG, \"onEventMain: \" + event.getMessgae()); &#125; @Subscribe(threadMode = ThreadMode.POSTING) public void onEventPosting(SecondEvent event) &#123; String msg = event.getMessgae(); Log.i(TAG, \"onEventPosting: \"+ event.getMessgae()); &#125; @Subscribe(threadMode = ThreadMode.BACKGROUND) public void onEventBackgroud(ThirdEvent event) &#123; String msg = event.getMessgae(); Log.i(TAG, \"onEventBackgroud: \" + event.getMessgae()); &#125; @Subscribe(threadMode = ThreadMode.ASYNC) public void onEventAsync(FourthEvent event) &#123; String msg = event.getMessgae(); Log.i(TAG, \"onEventAsync: \" + event.getMessgae()); &#125; //绑定点击事件 @OnClick(R.id.btn_open) public void openSecondActivity(View view) &#123; Intent intent = new Intent(MainActivity.this, SecondActivity.class); startActivity(intent); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //反注册 EventBus.getDefault().unregister(this); &#125;&#125; 接下来在SecondActivity中增加四个按钮，分别发送不同类别的事件 123456789101112131415161718192021222324252627282930313233public class SecondActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); ButterKnife.bind(this); &#125; @OnClick(R.id.btn_post) public void onPostA() &#123; EventBus.getDefault().post(new FirstEvent(\"FirstEvent\")); &#125; @OnClick(R.id.btn_post2) public void onPostB() &#123; EventBus.getDefault().post(new SecondEvent(\"SecondEvent\")); &#125; @OnClick(R.id.btn_post3) public void onPostC() &#123; EventBus.getDefault().post(new ThirdEvent(\"ThirdEvent\")); &#125; @OnClick(R.id.btn_post4) public void onPostD() &#123; EventBus.getDefault().post(new FourthEvent(\"FourthEvent\")); &#125;&#125; 运行后，分别顺序点击SecondActivity的四个按钮，打印信息如下： 123403-31 02:53:45.950 4779-4779/com.example.michael.eventbusdemo I/MainActivity: onEventMain: FirstEvent03-31 02:53:47.528 4779-4779/com.example.michael.eventbusdemo I/MainActivity: onEventPosting: SecondEvent03-31 02:53:48.882 4779-4940/com.example.michael.eventbusdemo I/MainActivity: onEventBackgroud: ThirdEvent03-31 02:53:50.462 4779-4940/com.example.michael.eventbusdemo I/MainActivity: onEventAsync: FourthEvent 由此可见，通过发布不同的事件类的实例，EventBus根据类的实例分别调用了不同的订阅函数来处理事件。 那么，当同一个类的实例有多个函数订阅时，结果会是怎样呢？答案是，这些函数都会执行。下面我们来验证一下，将MainActivity中订阅函数的参数都改为FirstEvent，代码如下: 12345678910111213141516171819202122232425262728293031/** * 事件响应方法 * @param event */ @Subscribe(threadMode = ThreadMode.MAIN) public void onEventMain(FirstEvent event) &#123; String msg = event.getMessgae(); Log.i(TAG, \"onEventMain: \" + event.getMessgae()); &#125; @Subscribe(threadMode = ThreadMode.POSTING) public void onEventPosting(FirstEvent event) &#123; String msg = event.getMessgae(); Log.i(TAG, \"onEventPosting: \"+ event.getMessgae()); &#125; @Subscribe(threadMode = ThreadMode.BACKGROUND) public void onEventBackgroud(FirstEvent event) &#123; String msg = event.getMessgae(); Log.i(TAG, \"onEventBackgroud: \" + event.getMessgae()); &#125; @Subscribe(threadMode = ThreadMode.ASYNC) public void onEventAsync(FirstEvent event) &#123; String msg = event.getMessgae(); Log.i(TAG, \"onEventAsync: \" + event.getMessgae()); &#125; 运行程序，点击SecondActivity的FirstEvent按钮，打印信息如下： 123403-31 03:14:07.032 23611-23746/com.example.michael.eventbusdemo I/MainActivity: onEventAsync: FirstEvent03-31 03:14:07.033 23611-23611/com.example.michael.eventbusdemo I/MainActivity: onEventMain: FirstEvent03-31 03:14:07.033 23611-23611/com.example.michael.eventbusdemo I/MainActivity: onEventPosting: FirstEvent03-31 03:14:07.034 23611-23748/com.example.michael.eventbusdemo I/MainActivity: onEventBackgroud: FirstEvent 分析可知，当SecondActivity发送FirstEvent事件过来的时候，这个四个订阅函数会同时接收到这个事件并执行。 总结： 订阅函数的执行是根据参数中的事件类的类名来决定的。","tags":[{"name":"实战","slug":"实战","permalink":"http://liuguoquan727.github.io/tags/实战/"}]},{"title":"Android开发模式之MVP","date":"2016-04-17T07:28:06.000Z","path":"2016/04/17/Android开发模式之MVP/","text":"背景在开发Android App时，越到最后肯定会发现，Activity的负担非常重，既要初始化控件，又要写一些逻辑操作的展示等等，很多Activity中的代码都充当了Controller和Model的角色，因而发现Activity违背了单一职责原则，负担过重。所以，MVP架构模式应运而生。 MVP架构是什么MVP就是Model-View-Presenter，MVP是从经典的MVC演变而来，它们的基本思想有相通的地方：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。作为一种新的模式，MVP与MVC有着一个重大的区别：在MVP中View并不会直接使用Model，它们之间的通信是通过Presenter（MVC中是Controller）来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过Controller。 在MVC里，View是可以直接访问Model的，从而View里会包含Model信息，不可避免的还要包括一些业务逻辑。在MVC模型里，更关注的是Model的不变，而同时有多个对Model的不同显示的View。所有在MVC模型里，Model不依赖于View，但是View依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。 用流程图的方式解释就更清楚了： MVC与MVP的区别MVP架构 View：对应于Activity，负责View的绘制以及与用户交互、Model：业务逻辑和实体模型Presenter：负责完成View与Model间的交互 View不直接与Model交互，而是通过Presenter交互来与Model间接交互 Presenter与View的交互是通过接口来进行的 通过View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑 MVC架构 View：对应于布局文件Model：业务逻辑和实体模型Controller：对应于Activity View可以和Model直接交互 Controller是基于行为的，并且可以被多个View共享。 可以复杂决定显示哪个View 总的就是说：从MVC到MVP的一个转变，就是减少了Activity的职责，减轻了它的负担，简化了Activity中的代码和一些操作，将逻辑代码提取到了Presenter中进行处理，降低其耦合度。 在MVP里，Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现。而且，Presenter与具体的View是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更View时候可以保持Presenter的不变，即重用！ 不仅如此，我们还可以编写测试用的View，模拟用户的各种操作，从而实现对Presenter的测试–而不需要使用自动化的测试工具。 我们甚至可以在Model和View都没有完成时候，就可以通过编写Mock Object（即实现了Model和View的接口，但没有具体的内容的）来测试Presenter的逻辑。 在MVP里，应用程序的逻辑主要在Presenter来实现，其中的View是很薄的一层。因此就有人提出了Presenter First的设计模式，就是根据User Story来首先设计和开发Presenter。在这个过程中，View是很简单的，能够把信息显示清楚就可以了。在后面，根据需要再随便更改View，而对Presenter没有任何的影响了。 如果要实现的UI比较复杂，而且相关的显示逻辑还跟Model有关系，就可以在View和Presenter之间放置一个Adapter。由这个 Adapter来访问Model和View，避免两者之间的关联。而同时，因为Adapter实现了View的接口，从而可以保证与Presenter之间接口的不变。这样就可以保证View和Presenter之间接口的简洁，又不失去UI的灵活性。 在MVP模式里，View只应该有简单的Set/Get的方法，用户输入和设置界面显示的内容，除此就不应该有更多的内容，绝不容许直接访问Model–这就是与MVC很大的不同之处。 MVP的优点 降低耦合度，隐藏数据，Activity中代码更简洁 模块职责划分明显 方便测试驱动开发 代码复用度较高 代码灵活性增强 MVP架构模式示例这个示例是根据用户id获取用户信息并展示的一个过程，其中获取信息用了一个线程进行了模拟获取。 先看一下MVP包结构图： 1.Model层首先是建一个JavaBean User实体类 123456789101112131415161718192021222324252627282930313233package com.deason.mvpdemo.bean;public class User &#123; private String name; private String id; private String sex; private String age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125;&#125; 新建Model层抽象接口 1234public interface IGetUser &#123; public void getUserInfo(int id,OnUserInfoListener listener);&#125; 12345public interface OnUserInfoListener &#123; public void getUserInfoSuccess(User user); public void getUserInfoFailed();&#125; Model层抽象接口实现： 123456789101112131415161718192021222324252627public class GetUserInfo implements IGetUser&#123; @Override public void getUserInfo(final int id, final OnUserInfoListener listener) &#123; // TODO Auto-generated method stub new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub SystemClock.sleep(5000); //模拟子线程耗时操作 if (id == 1) &#123; User user = new User(); user.setName(\"liu\"); user.setAge(\"27\"); user.setSex(\"男\"); user.setId(\"1\"); listener.getUserInfoSuccess(user); &#125; else &#123; listener.getUserInfoFailed(); &#125; &#125; &#125;).start(); &#125;&#125; 2.View层Presenter和View交互是通过接口，所有我们需要定义一个IShowUserView的接口，这个接口封装的方法基本都跟视图展示有关。 1234567public interface IShowUserView &#123; public void showLoading(); public void hideLoading(); public void toMainActivity(User user); public void showFailedError();&#125; 3.Presenter层Presenter是Model和View之间交互的桥梁，里面有一些业务逻辑的操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class UserInfoPresenter &#123; private IGetUser iGetUser; private IShowUserView iShowUserView; private Handler mHandler = new Handler(); public UserInfoPresenter(IShowUserView iShowUserView) &#123; this.iShowUserView = iShowUserView; this.iGetUser = new GetUserInfo(); &#125; public void getUserInfoToShow(int id) &#123; iShowUserView.showLoading(); iGetUser.getUserInfo(id, new OnUserInfoListener() &#123; @Override public void getUserInfoSuccess(final User user) &#123; // UI线程执行 mHandler.post(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub iShowUserView.toMainActivity(user); iShowUserView.hideLoading(); &#125; &#125;); &#125; @Override public void getUserInfoFailed() &#123; // TODO Auto-generated method stub mHandler.post(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub iShowUserView.showFailedError(); iShowUserView.hideLoading(); &#125; &#125;); &#125; &#125;); &#125;&#125; 4.Activity中调用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MainActivity extends Activity implements IShowUserView &#123; private TextView mNameTxt; private TextView mAgeTxt; private TextView mSexTxt; private Button mLoadBtn; private ProgressDialog mDialog; private UserInfoPresenter mPresenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mPresenter = new UserInfoPresenter(this); mDialog = new ProgressDialog(this); mNameTxt = (TextView) findViewById(R.id.tv_name); mAgeTxt = (TextView) findViewById(R.id.tv_age); mSexTxt = (TextView) findViewById(R.id.tv_sex); mLoadBtn = (Button) findViewById(R.id.btn_load); mLoadBtn.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub mPresenter.getUserInfoToShow(1); &#125; &#125;); &#125; @Override public void showLoading() &#123; // TODO Auto-generated method stub mDialog.show(); &#125; @Override public void hideLoading() &#123; // TODO Auto-generated method stub mDialog.dismiss(); &#125; @Override public void toMainActivity(User user) &#123; // TODO Auto-generated method stub mNameTxt.setText(user.getName()); mAgeTxt.setText(user.getAge()); mSexTxt.setText(user.getSex()); &#125; @Override public void showFailedError() &#123; // TODO Auto-generated method stub Toast.makeText(this, \"Load failed\", Toast.LENGTH_SHORT).show(); &#125;&#125; 可以看出，虽说是代码量增加了，但是Activity中的代码变得简洁起来，程序也清晰明了，好处还是很多的。好记性不如烂笔头，勤加练习和实践。","tags":[{"name":"架构","slug":"架构","permalink":"http://liuguoquan727.github.io/tags/架构/"}]},{"title":"Android-Universal-Image-Loader源码分析","date":"2016-04-17T07:25:31.000Z","path":"2016/04/17/Android-Universal-Image-Loader源码分析/","text":"功能介绍Android-Universal-Image-LoaderAndroid-Universal-Image-Loader是一个强大的、可高度定制的开源图片缓存框架，简称UIL。简单的说UIL就做了一件事–获取图片并显示在相应的控件上。 基本使用初始化添加完依赖后再Application或Activity中初始化ImageLoader，一般式在Application中初始化，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class UILApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); initImageLoader(getApplicationContext()); &#125; public static void initImageLoader(Context context) &#123; //缓存目录 File cacheDir = StorageUtils.getCacheDirectory(context); //添加配置需求 ImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(context) .memoryCacheExtraOptions(480, 800) // default = device screen dimensions .diskCacheExtraOptions(480, 800, CompressFormat.JPEG, 75, null) .taskExecutor(...) .taskExecutorForCachedImages(...) .threadPoolSize(3) // default 线程池大小 .threadPriority(Thread.NORM_PRIORITY - 1) // default 线程优先级 .tasksProcessingOrder(QueueProcessingType.FIFO) // default 任务队列模式 .denyCacheImageMultipleSizesInMemory() .memoryCache(new LruMemoryCache(2 * 1024 * 1024)) // .memoryCacheSize(2 * 1024 * 1024) .memoryCacheSizePercentage(13) // default .diskCache(new UnlimitedDiscCache(cacheDir)) // default .diskCacheSize(50 * 1024 * 1024) .diskCacheFileCount(100) .diskCacheFileNameGenerator(new HashCodeFileNameGenerator()) // default .imageDownloader(new BaseImageDownloader(context)) // default .imageDecoder(new BaseImageDecoder()) // default .defaultDisplayImageOptions(DisplayImageOptions.createSimple()) // default .writeDebugLogs() .build(); // 初始化ImageLoader配置 ImageLoader.getInstance().init(config); &#125;&#125; ImageLoaderConfiguration表示ImageLoader的配置信息，可包括图片最大尺寸、线程池、下载器、缓存等参数的配置。 Manifest配置12345678910&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt;&lt;application android:name=\".UILApplication\" `` `` ``/application&gt; 添加网络权限和添加读写外部存储权限 下载显示图片下载图片，解析为Bitmap并在ImageView中显示。 123456789101112131415161718192021222324252627282930313233343536373839private ImageLoadingListener animateFirstListener = new AnimateFirstDisplayListener();private DisplayImageOptions options;ImageAdapter(Context context) &#123; inflater = LayoutInflater.from(context); //下载图片选项options = new DisplayImageOptions.Builder() .showImageOnLoading(R.drawable.ic_stub) //下载中 .showImageForEmptyUri(R.drawable.ic_empty) //空URL .showImageOnFail(R.drawable.ic_error) //失败 .cacheInMemory(true) .cacheOnDisk(true) .considerExifParams(true) .displayer(new CircleBitmapDisplayer(Color.WHITE, 5)) .build();//显示图片ImageLoader.getInstance().displayImage(imageUrl, holder.image, options, animateFirstListener); /***监听下载图片，传递Bitmap给回调接口*/private static class AnimateFirstDisplayListener extends SimpleImageLoadingListener &#123; static final List&lt;String&gt; displayedImages = Collections.synchronizedList(new LinkedList&lt;String&gt;()); @Override public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) &#123; if (loadedImage != null) &#123; ImageView imageView = (ImageView) view; boolean firstDisplay = !displayedImages.contains(imageUri); if (firstDisplay) &#123; FadeInBitmapDisplayer.animate(imageView, 500); displayedImages.add(imageUri); &#125; &#125; &#125;&#125; 特点 可配置度高。支持任务线程池、下载器、解码器、内存及磁盘缓存、显示选项等的配置。 包含内存缓存和磁盘缓存两级缓存。 支持多线程，支持异步和同步加载 支持多种缓存算法、下载进度监听、ListView图片错乱解决等。 总体设计总体设计框图 上面是UIL的总体框架图。整个库主要分为ImageLoader、ImageLoaderEngine、Cache、ImageDownloader、ImageDecoder、BitmapDisplayer、BitmapProcessor七大模块，其中Cache分为Memory Cache和DiskCache两部分。 简单的讲就是ImageLoader收到加载及显示图片的任务，并将它交给ImageLoaderEngine，ImageLoaderEngine分发任务到具体线程池去执行，任务通过Cache及ImageDownloader获取图片，中间可能经过BitmapProcessor和ImageDecoder处理，最终转换为Bitmap交给BitmapDisplayer在ImageAware中显示。 UIL中的概念 ImageLoaderEngine 任务分发器，负责分发LoadAndDisplayImageTask和ProcessAndDisplayImageTask给具体的线程去执行。 LoadAndDisplayImageTask 用于加载并显示图片的任务。 ProcessAndDisplayImageTask 用于处理并显示图片的任务。 DisplayBitmapTask 用于显示图片的任务 ImageAware 显示图片的对象，可以是ImageView等。 BitmapDisplayer 将Bitmap对象显示在相应的控件ImageAware上。 ImageDownloader 图片下载器，负责从图片的各个来源获取输入流 MemoryCache 内存图片缓存，可向内存缓存图片或从内存读取图片 DiskCache 本地图片缓存，可向本地磁盘缓存保存图片或从本地磁盘读取图片 ImageDecoder 图片解码器，负责将图片输入流InputStream转换为Bitmap对象。 BitmapProcessor 图片处理器，负责从缓存读取或写入前对图片进行处理 流程图 上图为图片加载及显示流程图,可知有三种情况: [ 1 ] - 图片没有缓存 先下载图片，然后显示图片，同时异步将图片缓存到磁盘和内存中。 [ 2 ] - 图片缓存在磁盘上 若图片不在缓存中，则从磁盘缓存中查找图片，然后将图片解码为Bitmap对象并显示在控件上。 [ 3 ] - Bitmap对象缓存在内存里 直接从内存缓存取出相应的Bitmap对象并显示在控件上。 详细设计类关系图 核心类介绍ImageLoader.java图片加载器，对外的主要API，采用了单例设计模式，用于图片的加载和显示。 主要函数： getInstance() 得到ImageLoader单例，通过双层是否为null判断提高性能。 init(ImageLoaderConfiguration configuration) 初始化配置参数，参数为configuration为ImageLoader的配置信息，包括图片最大尺寸、任务线程池、磁盘缓存、下载器、解码器等等。实现中会初始化ImageLoaderEngine engine属性，该属性为任务分发器。 displayImage(String uri, ImageAware imageAware, DisplayImageOptions options, ImageLoadingListener listener, ImageLoadingProgressListener progressListener) 加载并显示图片或加载并执行回调接口。ImageLoader加载图片主要分为三类接口： displayImage()表示异步加载并显示图片到对应的ImageAware上。 loadImage()表示异步加载图片并执行回调接口。 loadImageSync()表示同步加载图片。 以上三类接口最终都会调用到这个函数进行图片加载。函数参数解释如下： Uri: 图片的uri，uri支持多种来源的图片，包括http、https、file、content、assets、drawable及自定义ImageAware： 一个接口，表示需要加载图片的对象，可包装View。Options： 图片显示的配置项。比如加载前、加载中、加载失败应该显示的占位图片，图片是否需要在磁盘缓存，是否需要在内存缓存等。listener： 图片加载各种时刻的回调接口，包括开始加载、加载失败、加载成功、取消加载四个时刻的回调函数。progressListener： 图片加载进度的回调接口。 函数流程图如下： ImageLoaderConfiguration.javaImageLoader的配置信息，包括图片最大尺寸、线程池、缓存、下载器、解码器等等。 主要属性： Resources resources 程序本地资源访问器，用于加载DisplayImageOptions中设置的一些App中图片资源。 int maxImageWidthForMemoryCache 内存缓存的图片最大宽度。 int maxImageHeightForMemoryCache 内存缓存的图片最大高度。 int maxImageWidthForDiskCache 磁盘缓存的图片最大宽度。 int maxImageHeightForDiskCache 磁盘缓存的图片最大高度。 BitmapProcessor processorForDiskCache 图片处理器，用于处理从磁盘缓存中读取到的图片。 Executor taskExecutor ImageLoaderEngine中用于执行从源获取图片的任务 Executor taskExecutorForCachedImages ImageLoaderEngine中用于执行从缓存获取图片任务的Executor。 boolean customExecutor 用户是否自定义了上面的taskExecutor boolean customExecutorForCachedImages 用户是否自定义了上面的taskExecutorForCachedImages int threadPoolSize 上面两个默认线程池的核心池大小，即最大并发数 int threadPriority 上面默认线程池的线程优先级。 QueueProcessingType tasksProcessingType 上面两个默认线程池的线程队列类型，目前只有FIFO，LIFO两种选择 MemoryCache MemoryCache 图片内存缓存 DiskCache diskCache 图片磁盘缓存，一般放在SD卡 ImageDownloader downloader 图片下载器 ImageDecoder decoder 图片解码器，内部可使用我们常见的BitmapFactory.decode()将图片资源解码成Bitmap对象 DisplayImageOptions defaultDisplayImageOptions 图片显示的配置项。比如加载前、加载中、加载失败应该显示的占位图片，图片是否需要在磁盘缓存，是否需要在内存缓存等。 ImageDownloader networkDeniedDownloader 不允许访问网络的图片下载器 ImageDownloader slowNetworkDownloader 慢网络情况下的图片下载器 ImageLoaderConfiguration.Builder.java 静态内部类Builder模式，用于构造参数繁多的ImageLoaderConfiguration。其属性与ImageLoaderConfiguration类似，函数多是属性设置函数。 主要函数及含义： builder() 按照配置，生成ImageLoaderConfiguration。代码如下： 1234public ImageLoaderConfiguration build() &#123; initEmptyFieldsWithDefaultValues(); return new ImageLoaderConfiguration(this);&#125; initEmptyFieldsWithDefaultValues() 初始化值为null的属性。若用户没有配置相关项，UIL会通过调用DefaultConfigurationFactory中的函数返回一个默认值当配置。 taskExecutorForCacheImages、taskExecutor及ImageLoaderEngine的taskDistributor的默认值如下： parameters taskDistributor taskExecutorForCacheImages/taskExecutor corePoolSize 0 3 maximumPoolSize Integer.MAX_VALUE 3 keepAliveTime 60 3 unit SECONDS MILLISECONDS workQueue SynchronousQueue LIFOLinkedBlockingDequeu/LinkedBlockingQueue priority 5 3 diskCacheFileNameGenerator默认值为HashCodeFileNameGenerator memoryCache默认值为LruMemoryCache。如果内存缓存不允许缓存一张图片的多个尺寸，则用FuzzyKeyMemoryCache做封装，同一个图片新的尺寸会覆盖缓存中该图片老的尺寸。 diskCache默认值与diskCacheSize和diskCacheFileCount值有关，如果他们有一个大于0，则默认为LruDiskCache，否则使用无大小限制的UnlimitedDiskCache。 downloader默认值为BaseImageDownloader。 decoder默认值为BaseImageDecoder defaultDisplayImageOptions为Builder().build() denyCacheImageMultipleSizeInMemory() 设置内存缓存不允许缓存一张图片的多个尺寸，默认允许。后面会讲到的View的getWidth()在初始化前后的不同值与这个设置的关系。 diskCacheSize(int maxCacheSize) 设置磁盘缓存的最大字节数，如果大于0或者下面的maxFileCount大于0，默认的DiskCache会用LruDiskCache，否则使用无大小限制的UnlimitedDiskCache。 diskCacheFileCount(int maxFileCount) 设置磁盘缓存的最大文件数，如果大于0或者上面的maxCacheSize大于0，默认的DiskCache会用LruDiskCache，否则使用无大小限制的UnlimitedDiskCache。 ImageLoaderConfiguration.NetworkDeniedDownloader.java 静态内部类不允许访问网络的图片下载器，实现了ImageDownloader接口。实现也比较简单，包装了一个ImageDownloader对象，通过getStream()函数中禁止Http和Https Scheme禁止网络访问，如下： 12345678910111213141516171819private static class NetworkDeniedImageDownloader implements ImageDownloader &#123; private final ImageDownloader wrappedDownloader; public NetworkDeniedImageDownloader(ImageDownloader wrappedDownloader) &#123; this.wrappedDownloader = wrappedDownloader; &#125; @Override public InputStream getStream(String imageUri, Object extra) throws IOException &#123; switch (Scheme.ofUri(imageUri)) &#123; case HTTP: case HTTPS: throw new IllegalStateException(); default: return wrappedDownloader.getStream(imageUri, extra); &#125; &#125;&#125; ImageLoaderConfiguration.SlowNetworkingImageDownloader.java 静态内部类慢网络情况下的图片下载器，实现了ImageDownloader接口。通过包装一个ImageDownloader对象实现，在getStream()函数中当Scheme为Http和Https时，用FlushedInputStream代替InputStream处理慢网络情况。 1234567891011121314151617181920private static class SlowNetworkImageDownloader implements ImageDownloader &#123; private final ImageDownloader wrappedDownloader; public SlowNetworkImageDownloader(ImageDownloader wrappedDownloader) &#123; this.wrappedDownloader = wrappedDownloader; &#125; @Override public InputStream getStream(String imageUri, Object extra) throws IOException &#123; InputStream imageStream = wrappedDownloader.getStream(imageUri, extra); switch (Scheme.ofUri(imageUri)) &#123; case HTTP: case HTTPS: return new FlushedInputStream(imageStream); default: return imageStream; &#125; &#125;&#125; ImageLoaderEngine.javaLoadAndDisplayImageTask和ProcessAndDisplayImageTask任务分发器，负责分发任务给具体的线程池。 主要属性： ImageLoaderConfiguration configuration ImageLoader的配置信息，可包括图片最大尺寸、线程池、缓存、下载器、解码器等等。 Executor taskExecutor 用于执行从源执行获取图片任务的Executor，为configuration中的taskExecutor，如果为null，则会调用DefaultConfigurationFactory.createExecutor()根据配置返回一个默认的线程池。 Executor taskExecutorForCachedImages 用于执行从缓存获取图片任务的Executor，为configuration中的taskExecutorForCachedImages，如果为null，则会调用DefaultConfigurationFactory.createExecutor()根据配置返回一个默认的线程池。 Executor taskDistributor 任务分发线程池，任务指LoadAndDisplayImageTask和ProcessAndDisplayImageTask，因为需要分发给上面的两个Executor去执行任务，不存在较耗时或阻塞操作，所以无并发数（Int最大值）限制的线程池即可。 Map cacheKeysForImageAwares ImageAware与内存缓存key对应的map，key为ImageAware的id，value为内存缓存的key。 Map uriLocks 图片正在加锁的重入锁map，key为图片的uri，value为标识其正在加载的重入锁。 AtomicBoolean pause 是否被暂停。如果为true，则所有新的加载或显示任务都会等待直到取消暂停（为false） AtomicBooleannetWorkDenied 是否不允许访问网络，如果为true，通过回调ImageLoadingListener.onLoadingFailed()获取图片，则所有不在缓存中需要网络访问的请求都会失败，返回失败的原因为：网络访问被禁止。 AtomicBoolean slowNetwork 是否是慢网络情况，如果未true，则自动调用SlowNetworkImageDownloader下载图片 Object pauseLock 暂停的等待锁，可在engine被暂停后调用这个锁等待 主要函数： void submit(final LoadAndDisplayImageTask task) 传入一个LoadAndDisplayImageTask，直接用taskDistributor执行一个Runnable，在Runnable内部根据图片是否被磁盘缓存过确定使用taskExecutorForCachedImages还是taskExecutor执行该task。 void submit(ProcessAndDisplayImageTask task) 传入一个ProcessAndDisplayImageTask，直接用taskExecutorForCachedImages执行该task，从缓存中去图片。 void pause() 暂停图片加载任务，所有新的加载或显示任务都会等待直到取消暂停为止。 void resume() 继续图片加载任务 stop() 暂停所有加载和显示图片任务并清除这里的内部属性值。 fireCallBack(Runnable r) taskDistributor立即执行某个任务 getLockForUri(String uri) 得到某个uri的重入锁，如果不存在则新建一个 private Executor createTaskExecutor() 调用DefaultConfigurationFactor.createExecutor()创建一个线程池 String getLoadingUriForView(ImageAware imageAware) 得到某个ImageAware正在加载的图片uri prepareDisplayTaskFor(ImageAware imageAware, String memoryCacheKey) 准备开始一个Task。向cacheKeysForImageAwares中插入ImageAware的id和图片在内存缓存中的key void cancelDisplayTaskFor(ImageAware imageAware) 取消一个显示任务。从cacheKeysForImageAwares中删除ImageAware对应元素 void denyNetworkDownloads(boolean denyNetworkDownloads) 设置是否不允许网络访问 void handleSlowNetwork(boolean handleSlowNetwork) 设置是否慢网络情况 DefaultConfigurationFactory.java为ImageLoaderConfiguration及ImageLoaderEngine提供一些默认配置 主要函数： Executor createExecutor(int threadPoolSize, int threadPriority,QueueProcessingType tasksProcessingType) 创建线程池：threadPoolSize表示核心线程池大小（最大并发数）threadPriority表示线程优先级tasksProcessingType表示线程队列类型，目前只有FIFO，LIFO两种可选择 内部实现会调用createThreadFactory(…)返回一个支持线程优先级设置，并且以固定规则命名新建的线程的线程工厂类DefaultConfigurationFactory.DefaultThreadFactory。 Executor createTaskDistributor() 为ImageLoaderEngine中的任务分发器taskDistributor提供线程池，该线程池为normal优先级的无并发大小限制的线程池。 FileNameGenerator createFileNameGenerator() 返回一个HashCodeFileNameGenerator对象，即以uri HashCode为文件名的文件名生成器。 DiskCache createDiskCache(Context context, FileNameGenerator diskCacheFileNameGenerator,long diskCacheSize, int diskCacheFileCount) 创建一个 Disk Cache。如果 diskCacheSize 或者 diskCacheFileCount 大于 0，返回一个LruDiskCache，否则返回无大小限制的UnlimitedDiskCache。 MemoryCache createMemoryCache(Context context, int memoryCacheSize) 创建一个 Memory Cache。返回一个LruMemoryCache，若 memoryCacheSize 为 0，则设置该内存缓存的最大字节数为App最大可用内存的1/8。这里的App的最大可用内存也支持系统在Honeycomb之后（Api Level &gt;= 11)application中android:largeHeap=”true”的设置。 ImageDownloader createImageDownloader(Context context) 创建图片下载器，返回一个BaseImageDownloader。 ImageDecoder createImageDecoder(boolean loggingEnabled) 创建图片解码器，返回一个BaseImageDecoder。 BitmapDisplayer createBitmapDisplayer() 创建图片显示器，返回一个SimpleBitmapDisplayer。 DefaultConfigurationFactory.DefaultThreadFactory默认的线程工厂类，为 DefaultConfigurationFactory.createExecutor(…)和DefaultConfigurationFactory.createTaskDistributor(…)提供线程工厂。支持线程优先级设置，并且以固定规则命名新建的线程。 ImageAware需要显示图片的对象的接口，可包装View表示某个需要显示图片的View。 主要函数： View getWrappedView() 得到被包装的View，图片显示在该View上 int getWidth()和int getHeight() 得到宽度高度，在计算图片缩放比例时会用到 int getId() 得到唯一标识id。ImageLoaderEngine中用这个id标识正在加载图片的ImageAware和图片内存缓存key的对应关系，图片请求前会将内存缓存key与新的内存缓存key进行比较，如果不相等，则之前的图片请求会被取消。这样当ImageAware被复用时就不会因异步加载（前面任务未取消）而造成错乱了。 ViewAware.java封装Android View来显示图片的抽象类，实现类ImageAware接口，利用Reference来Wrap View防止内存泄露。 主要函数： ViewAware(View view, boolean checkActualViewSize) 构造函数：view表示需要显示图片的对象checkActualViewSize表示通过getWidth()和getHeight()获取图片宽高时返回真实的宽和高，还是LayoutParams的宽高，true表示返回真实宽和高。 如果为true会导致一个问题，view在还没有初始化完成时加载图片，这是它的真实宽高为0，会取它LayoutParams的宽高，而图片缓存的key与这个宽高有关，所以当view的初始化完成再次需要加载该图片时，getWidth()和getHeight()返回的宽高都已经变化了，缓存key不一样，从而导致缓存读取失败会再次从网络下载一次图片。可通过ImageLoaderConfiguration.Builder.denyCacheImageMultipleSizesInMemory()设置不允许内存缓存缓存一张图片的多个尺寸。 boolean setImageDrawable(Drawable drawable) 如果当前操作在主线程并且View没有被回收，则调用抽象函数setImageDrawableInto(Drawable drawable, View view)去向view设置图片。 boolean setImageBitmap(Bitmap bitmap) 如果当前操作在主线程并且View没有被回收，则调用抽象函数setImageBitmapInto(Bitmap bitmap, View view)去向view设置图片。 ImageViewAware.java封装Android ImageView来显示图片的ImageAware，继承了viewAware，利用Reference来Wrap View防止内存泄露。 如果getWidth()函数小于等于0，会利用反射获取mMaxWidth的值作为宽。如果getHeight()函数小于等于0，会利用反射获取mMaxHeight的值作为高。 NonViewAware仅包含处理图片相关信息却没有需要显示图片的View的ImageAware，实现了ImageAware接口。常用于加载图片后调用回调接口而不是显示的情况。 DisplayImagesOptions.java图片显示的配置项。比如加载前、加载中、加载失败应该显示的占位图片，图片是否需要在磁盘缓存，是否需要在memory缓存等。 主要属性及含义： int imageResOnLoading 图片正在加载中的占位图片的resource id，优先级比下面的imageOnLoading高，当存在时，imageOnLoading不起作用。 int imageResForEmptyUri 空uri时的占位图片的resource id，优先级比下面的imageForEmptyUri高，当存在时，imageForEmptyUri不起作用。 int imageResOnFail 加载失败时的占位图片的resource id，优先级比下面的imageOnFail高，当存在时，imageOnFail不起作用。 Drawable imageOnLoading 加载中的占位图片的Drawable对象，默认为null Drawable imageForEmptyUri 空uri时的占位图片drawable对象，默认为null boolean resetViewBeforeLoading 在加载前是否重置view，通过Builder构建的对象默认为false boolean cacheInMemory 是否缓存在内存中，通过Builder构建的对象默认为false。 boolean cacheOnDisk 是否缓存在磁盘中，通过Builder构建的对象默认为false。 ImageScaleType imageScaleType 图片的缩放类型，通过Builder构建的对象默认为IN_SAMPLE_POWER_OF_2 Options decodingOptions 为BitmapFactory.Options，用于BitmapFactory.decodeStream(imageStream, null, decodingOptions)得到图片尺寸等信息。 int delayBeforeLoading 设置在开始加载前的延迟时间，单位为毫秒，通过Builder构建的对象默认为0。 boolean considerExitParams 是否考虑图片的EXIF信息，通过Builder构建的对象默认为false。 Object extraForDownloader 下载器需要的辅助信息。下载时传入ImageDownloader.getStream(String,Object)的对象，方面用户自己扩展，默认为null BitmapProcessor preProcessor; 缓存在内存之前的处理程序，默认为null BitmapProcessor postProcessor 缓存在内存之后的处理程序，默认为null BitmapDisplayer displayer; 图片的显示方式，通过Builder构建的对象默认为SimpleBitmapDisplayer Handler handler; handler对象，默认为null boolean isSyncLoading; 是否同步加载，通过Builder构建的对象默认为false。 DisplayImageOptions.Builder.java 静态内部类Builder模式，用于构造参数繁多的DisplayImageOptions。 ImageLoadingListener图片加载各种时刻的回调接口，可在图片加载的某些点做监听。包括开始加载（onLoadingStarted）、加载失败（onLoadingFailed）、加载成功（onLoadingComplete）、取消加载（onLoadingCancelled）四个回调函数。 SimpleImageLoadingListener实现ImageLoadingListener接口，不过各个函数都是空实现，表示不在Image加载过程中做任何回调监听实现。ImageLoader.displayImage()函数中当listener传入值为null时的默认值。 ImageLoadingProgressListener.javaImage加载进度的回调接口 123456789101112public interface ImageLoadingProgressListener &#123; /** * Is called when image loading progress changed. * * @param imageUri Image URI * @param view View for image. Can be &lt;b&gt;null&lt;/b&gt;. * @param current Downloaded size in bytes * @param total Total size in bytes */ void onProgressUpdate(String imageUri, View view, int current, int total);&#125; 会在获取图片存储到文件系统时被调用，其中total表示图片总大小，为网络请求结果Response Header中content-length字段，如果不存在则为-1。 DisplayBitmapTask.java显示图片的Task，实现类Runnable接口，必须在主线程调用。 主要函数： run() 首先判断ImageAware是否被GC回收，如果是直接调用取消加载回调接口listener.onLoadingCancelled()；否则判断ImageAware是否被复用，如果是直接调用取消加载回调接口listener.onLoadingCancelled()；否则调用diaplay显示图片，并将ImageAware从正在加载的map中移除。调用加载成功回调接口listener.onLoadingComplete()； 对于ListView或是GridView这里缓存item的View来说，单个Item中如果含有ImageView，在滑动过程中可能因为异步加载及View复用导致图片错乱，这里对ImageAware是否被复用的判断就能很好的解决这个问题。原因类似：Android ListView滑动过程中图片显示重复错位闪烁问题解决 ProcessAndDisplayImageTask.java处理并显示图片的Task，实现了Runnable接口。 主要函数： run() 主要通过imageLoadingInfo得到BitmapProcessor处理图片，并且处理后的图片和配置新建一个DisplayBitmapTask在ImageAware中显示图片。 LoadAndDisplayImageTask.java加载并显示图片的Task，实现了Runnable接口，用于从网络、文件系统或内存获取图片并解析，然后调用DisplayBitmapTask在ImageAware中显示图片。 主要函数： run() 获取图片并显示，核心代码如下： 1234567891011121314151617181920212223bmp = configuration.memoryCache.get(memoryCacheKey);if (bmp == null || bmp.isRecycled()) &#123; bmp = tryLoadBitmap(); if (bmp == null) return; // listener callback already was fired if (bmp != null &amp;&amp; options.isCacheInMemory()) &#123; L.d(LOG_CACHE_IMAGE_IN_MEMORY, memoryCacheKey); configuration.memoryCache.put(memoryCacheKey, bmp); &#125; if (bmp != null &amp;&amp; options.shouldPostProcess()) &#123; L.d(LOG_POSTPROCESS_IMAGE, memoryCacheKey); bmp = options.getPostProcessor().process(bmp); if (bmp == null) &#123; L.e(ERROR_POST_PROCESSOR_NULL, memoryCacheKey); &#125; &#125;&#125;DisplayBitmapTask displayBitmapTask = new DisplayBitmapTask(bmp, imageLoadingInfo, engine, loadedFrom);runTask(displayBitmapTask, syncLoading, handler, engine); 从上面代码可以看到显示从内存缓存中去读bitmap对象，若bitmap对象不存在，则调用tryLoadBitma()函数获取bitmap对象，获取成功后若在DisplayImageOptions.Builder中设置类cacheInMemory(true),同时将Bitmap对象缓存到内存中。最后新建DisplayBitmapTask对象显示图片。 函数流程图如下： 判断图片的内存缓存是否存在，若存在直接执行步骤8； 判断图片的内存缓存是否存在，若存在直接执行步骤5； 从网络上下载图片 将图片缓存在磁盘上 将图片decode成bitmap对象； 根据DisplayImageOptions配置对图片进行预处理； 将Bitmap对象缓存到内存中； 根据DisplayImageOptions配置对图片进行后处理； 执行DisplayBitmapTask将图片显示在相应的控件上； tryLoadBitmap() 从磁盘缓存或网络获取图片，核心代码如下： 1234567891011121314151617181920212223242526272829private Bitmap tryLoadBitmap() throws TaskCancelledException &#123; Bitmap bitmap = null; try &#123; File imageFile = configuration.diskCache.get(uri); if (imageFile != null &amp;&amp; imageFile.exists() &amp;&amp; imageFile.length() &gt; 0) &#123; ... bitmap = decodeImage(Scheme.FILE.wrap(imageFile.getAbsolutePath())); &#125; if (bitmap == null || bitmap.getWidth() &lt;= 0 || bitmap.getHeight() &lt;= 0) &#123; ... String imageUriForDecoding = uri; if (options.isCacheOnDisk() &amp;&amp; tryCacheImageOnDisk()) &#123; imageFile = configuration.diskCache.get(uri); if (imageFile != null) &#123; imageUriForDecoding = Scheme.FILE.wrap(imageFile.getAbsolutePath()); &#125; &#125; checkTaskNotActual(); bitmap = decodeImage(imageUriForDecoding); &#125; &#125; return bitmap;&#125; 首先根据uri看磁盘中是不是已经缓存了这个文件，如果已经缓存，调用decodeImage函数，将图片文件decode成Bitmap对象；如果Bitmap对象不合法或缓存文件不存在，判断是否需要缓存在磁盘，需要则调用tryCacheImageOnDisk()函数去下载并缓存图片到本地磁盘，再通过decodeImage(imageUri)函数将图片文件decode成bitmap对象，否则直接通过decodeImage(imageUriForDecoding)下载图片并解析。 tryCacheImageOnDisk()下载图片并存储在磁盘内，根据磁盘缓存图片最长宽高的配置处理图片 1234567891011121314151617181920private boolean tryCacheImageOnDisk() throws TaskCancelledException &#123; L.d(LOG_CACHE_IMAGE_ON_DISK, memoryCacheKey); boolean loaded; try &#123; loaded = downloadImage(); //调用下载器并保存图片 if (loaded) &#123; int width = configuration.maxImageWidthForDiskCache; int height = configuration.maxImageHeightForDiskCache; if (width &gt; 0 || height &gt; 0) &#123; L.d(LOG_RESIZE_CACHED_IMAGE_FILE, memoryCacheKey); resizeAndSaveImage(width, height); // TODO : process boolean result &#125; &#125; &#125; catch (IOException e) &#123; L.e(e); loaded = false; &#125; return loaded;&#125; 如果你在ImageLoaderConfiguration中配置了maxImageWidthForDiskCache或者maxImageHeightForDiskCache，还会调用resizeAndSaveImage()函数，调整图片尺寸，并保存新的图片文件。 downloadImage()下载图片并存储在磁盘内。调用getDownloader()得到ImageDownloader其下载图片。 resizeAndSaveImage(int maxWidth,int maxHeight)从磁盘缓存中得到图片，重新设置大小及进行一些处理后保存。 geDownloader()根据ImageLoaderEngine配置得到下载器。如果不允许访问网络，则使用不允许访问网络的图片下载器NetWorkDeniedImageDownloader；如果是慢网络情况，则使用慢网络情况下的图片下载器SlowNetworkImageDownloader；否则直接使用ImageLoaderConfiguration中的downloader。 ImageLoadingInfo.java加载和显示图片任务需要的信息。成员变量如下： String uri 图片urlString memoryCacheKey 图片缓存keyImageAware imageAware 需要加载图片的对象ImageSize targetSize 图片的显示尺寸DisplayImageOptions options; 图片显示的配置项ImageLoadingListener listener; 图片加载时状态的回调接口ImageLoadingProgressListener progressListener; 图片加载进度的回调接口ReentrantLock loadFromUriLock; 图片加载中的重入锁 ImageDownloader.java图片下载接口，待实现函数 1getString(String imageUri, Object extra) 表示通过uri得到InputStream通过内部定义的枚举Scheme，可以看出UIL支持哪些图片来源。 1HTTP(\"http\"), HTTPS(\"https\"), FILE(\"file\"), CONTENT(\"content\"), ASSETS(\"assets\"), DRAWABLE(\"drawable\"), UNKNOWN(\"\"); BaseImageDownloader.javaImageDownloader的具体实现类。得到上面各种Scheme对应的图片InputStream。 主要函数： InputStream getStream(String imageUri, Object extra) 函数内根据不同Scheme类型获取图片输入流 123456789101112131415161718public InputStream getStream(String imageUri, Object extra) throws IOException &#123; switch (Scheme.ofUri(imageUri)) &#123; case HTTP: case HTTPS: return getStreamFromNetwork(imageUri, extra); case FILE: return getStreamFromFile(imageUri, extra); case CONTENT: return getStreamFromContent(imageUri, extra); case ASSETS: return getStreamFromAssets(imageUri, extra); case DRAWABLE: return getStreamFromDrawable(imageUri, extra); case UNKNOWN: default: return getStreamFromOtherSource(imageUri, extra); &#125;&#125; InputStream getStreamFromNetwork(String imageUri, Object extra) 通过HttpURLConnection从网络获取图片的InputStream，支持response code为3xx的重定向。这里有个小细节代码如下： 123456789101112InputStream imageStream;try &#123; imageStream = conn.getInputStream();&#125; catch (IOException e) &#123; // Read all data to allow reuse connection (http://bit.ly/1ad35PY) IoUtils.readAndCloseStream(conn.getErrorStream()); throw e;&#125;if (!shouldBeProcessed(conn)) &#123; IoUtils.closeSilently(imageStream); throw new IOException(\"Image request failed with response code \" + conn.getResponseCode());&#125; 在发生异常时会调用conn.getErrorStream()继续读取Error Stream，这是为了利用网络连接回收及复用，但有意思的是在2.2之前，HttpURLConnection有个重大Bug，调用close()函数会影响连接池，导致连接复用失效，不过2.3以后已经解决了此went。 InputStream getStreamFromFile(String imageUri, Object extra) 从文件系统获取图片的InputStream。如果uri的类型是Video，则得到video的缩略图返回，否则按照一般文件操作返回。 123456789protected InputStream getStreamFromFile(String imageUri, Object extra) throws IOException &#123; String filePath = Scheme.FILE.crop(imageUri); if (isVideoFileUri(imageUri)) &#123; return getVideoThumbnailStream(filePath); //缩略图 &#125; else &#123; BufferedInputStream imageStream = new BufferedInputStream(new FileInputStream(filePath), BUFFER_SIZE); return new ContentLengthInputStream(imageStream, (int) new File(filePath).length()); &#125;&#125; InputStream getStreamFromContent(String imageUri, Object extra) 从ContentProvider获取图片的InputStream。如果是video类型，则先从MediaStore得到video的缩略图返回；如果是联系人类型，则通过ContactsContract.Contacts.openContactPhotoInputStream(res, uri, true)读取内容返回；否则通过ContentResolver..openInputStream(uri)读取内容返回 InputStream getStreamFromAssets(String imageUri, Object extra) 从Assets文件夹中获取图片的InputStream 1234protected InputStream getStreamFromAssets(String imageUri, Object extra) throws IOException &#123; String filePath = Scheme.ASSETS.crop(imageUri); return context.getAssets().open(filePath);&#125; InputStream getStreamFromDrawable(String imageUri, Object extra) 从Drawable资源中获取图片的InputStream。 InputStream getStreamFromOtherSource(String imageUri, Object extra) UNKNOWN类型的处理，目前直接抛出不支持的异常 MemoryCache.javaBitmap内存缓存接口，需要实现的接口包括get()、put()、remove()、clear()、keys() 123456789101112131415161718public interface MemoryCache &#123; /** * Puts value into cache by key */ boolean put(String key, Bitmap value); /** Returns value by key. If there is no value for key then null will be returned. */ Bitmap get(String key); /** Removes item by key */ Bitmap remove(String key); /** Returns all keys of cache */ Collection&lt;String&gt; keys(); /** Remove all items from cache */ void clear();&#125; BaseMemoryCache.java实现了MemoryCache主要函数的抽象类，以Map&lt;String, Reference&lt;Bitmap&gt;&gt; softMap作为缓存池，利于虚拟机在内存不足是回收缓存对象。提供抽象函数： 1protected abstract Reference&lt;Bitmap&gt; createReference(Bitmap value); 表示根据Bitmap创建一个Reference作为缓存对象。Reference可以是WeakReference、SoftReference等。 WeakMemoryCache.java以WeakReference&lt;Bitmap&gt;作为缓存value的内存缓存，实现了BaseMemoryCache的createReference(Bitmap value)函数，直接返回一个new WeakReference&lt;Bitmap&gt;(value)作为缓存value。 LimitedMemoryCache.java限制总字节大小的内存缓存，继承自BaseMemoryCache抽象类。会在put(…)函数中判断总体大小是否超出上限，超出则循环删除缓存对象直到小于上限。删除顺序由抽象函数protected abstract Bitmap removeNext()决定。抽象函数protected abstract int getSize(Bitmap value)表示每个元素大小。 LargestLimitedMemoryCache.java限制总字节大小的内存缓存，会在缓存满时优先删除size最大的元素，继承自LimitedMemoryCache。实现了LimitedMemoryCache的removeNext()函数，总是返回当前缓存中size最大的元素。 UsingFreqLimitedMemoryCache.java限制总字节大小的内存缓存，会在缓存满时优先删除使用次数最少的元素，继承自LimitedMemoryCache。实现了LimitedMemoryCache的removeNext()函数，总是返回当前缓存中使用次数最少的元素。 LRULimitedMemoryCache.java限制总字节大小的内存缓存，会在缓存满时优先删除最近最少使用的元素，继承自LimitedMemoryCache。通过new LinkedHashMap&lt;String, Bitmap&gt;(10, 1.1f, true)作为缓存池。LinkedHashMap第三个参数表示是否需要根据访问顺序(accessOrder)排序，true表示根据accessOrder排序，最近访问的跟最新加入的一样放到最后面，false表示根据插入顺序排序。这里为true且缓存满时始终删除第一个元素，即始终删除最近最少访问的元素。实现了LimitedMemoryCache的removeNext()函数，总是返回当前缓存中最近最少使用的元素。 FIFOLimitedMemoryCache.java限制总字节大小的内存缓存，会在缓存满的时优先删除进入缓存的元素，继承自LimitedMemoryCache。实现了LimitedMemoryCache的removeNext()函数，总是返回当前缓存中最先进入缓存的元素。 以上所有LimitedMemoryCache子类都有个问题，就是Bitmap虽然通过WeakReference包装，但实际根本不会被虚拟机回收，因为他们子类中同时都保留了Bitmap的强引用。这些大都是UIL早期实现的版本，不推荐使用 LruMemoryCache.java限制总字节大小的内存缓存，会在缓存满时优先删除最近最少使用的元素，实现了MemoryCache。LRU(Least Recently Used)为最少使用算法。 通过new LinkedHashMap&lt;String, Bitmap&gt;(0, 0.75f, true)作为缓存池。LinkedHashMap第三个参数表示是否需要根据访问顺序(accessOrder)排序，true表示根据accessOrder排序，最近访问的跟最新加入的一样放到最后面，false表示根据插入顺序排序。这里为true且缓存满时始终删除第一个元素，即始终删除最近最少访问的元素。 在put(..)函数中通过trimToSize(int maxtSize)函数判断总体大小是否超出了上限，是则删除缓存池中第一个元素，即最近最少使用的元素，指导总体大小小于上限。 LruMemory功能上谕LRULimitedMemoryCache类似，不过在实现上更加优雅，用简单的实现接口方式，而不是不断继承的方式。 LimitedAgeMemoryCache.java限制类对象最长存活周期的内存缓存。MemoryCache的装饰者，相当于为MemoryCache添加一个特性，以一个MemoryCache内存缓存和一个maxAge作为构造函数参数。在get()中判断如果对象存活时间已经超过设置的最长时间，则删除。 FuzzyKeyMemoryCache.java可以将某些原本不同的key看做相等，在put时删除这些相等的key。MemoryCache的装饰者，相当于为MemoryCache添加一个特性，以一个MemoryCache内存缓存和一个 keyComparator作为构造函数参数。在put()函数中判断如果key与缓存中已有key经过Comparator比较后相等，则删除之前的元素。 FileNameGenerator.java根据uri得到文件名的接口 HashCodeFileNameGenerator.java以uri的hashCode值作为文件名 Md5FileNameGenerator.java以uri的MD5值作为文件名 123456789101112131415161718192021222324public class Md5FileNameGenerator implements FileNameGenerator &#123; private static final String HASH_ALGORITHM = \"MD5\"; private static final int RADIX = 10 + 26; // 10 digits + 26 letters @Override public String generate(String imageUri) &#123; byte[] md5 = getMD5(imageUri.getBytes()); BigInteger bi = new BigInteger(md5).abs(); return bi.toString(RADIX); &#125; private byte[] getMD5(byte[] data) &#123; byte[] hash = null; try &#123; MessageDigest digest = MessageDigest.getInstance(HASH_ALGORITHM); digest.update(data); hash = digest.digest(); &#125; catch (NoSuchAlgorithmException e) &#123; L.e(e); &#125; return hash; &#125;&#125; DiskCache.java图片的磁盘缓存接口。 主要函数： File getDirectory() 得到磁盘缓存的根目录 File get(String imageUri) 根据原始图片uri去获取缓存图片的文件 boolean save(String imageUri, InputStream imageStream, IoUtils.CopyListener listener) 保存imageStream到磁盘中，listener表示保存进度且可在其中取消某些段的保存。 boolean save(String imageUri, Bitmap bitmap) 保存图片到磁盘 boolean remove(String imageUri) 根据图片uri删除缓存图片 void close() 关闭磁盘缓存，并释放资源 void clear() 清空磁盘缓存 BaseDiskCache.java一个无大小限制的本地图片缓存，实现了DiskCache主要函数的抽象类。图片缓存在cacheDir文件夹内，当cacheDir不可用时，则使用备用库reserveCacheDir。 主要函数： boolean save(String imageUri, InputStream imageStream, IoUtils.CopyListener listener) 先根据imageUri得到目标文件，将imageStream先写入与目标文件同一文件夹的.tmp结尾的临时文件内，若未被listener取消且写入成功则将临时文件重命名为目标文件并返回true，否则删除临时文件并返回false。 boolean save(String imageUri, Bitmap bitmap) 先根据imageUri得到目标文件，通过Bitmap.compress(..)函数将bitmap先写入与目标文件同一文件夹的.tmp结尾的临时文件内，若写入成功则将临时文件名重命名为目标文件并返回true，否则删除临时文件并返回false。 File getFile(String imageUri) 根据imageUri和fileNameGenerator得到文件名，返回cacheDir文件夹内该文件，若cacheDir不可用，则使用备用库reserveCacheDir。 LimitedAgeDiskCache.java限制缓存对象最长存活周期的磁盘缓存，继承自BaseDiskCache。在get()函数判断如果缓存对象存活时间已经超过设置的最长时间，则删除。在save()中保存当前时间作为对象的创建时间。 UnLimitedDiskCache.java一个无大小限制的本地图片缓存。与BaseDiskCache无异，只是用了个意思明确的类名。 DiskLruCache.java限制总字节大小的磁盘缓存，会在缓存满时优先删除最近最少使用的元素。 通过缓存目录下名为journal的文件记录缓存的所有操作，并在缓存open时读取journal的文件内容存储到LinkedHashMap&lt;String, Bitmap&gt; lruEntries，后面get(String key)获取缓存内容时，会先从lruEntries中得到图片文件名返回文件。 通过new LinkedHashMap&lt;String, Entry&gt;(0, 0.75f, true)作为缓存池。LinkedHashMap第三个参数表示是否需要根据访问顺序(accessOrder)排序，true表示根据accessOrder排序，最近访问的跟最新加入的一样放到最后面，false表示根据插入顺序排序。这里为true且缓存满时trimToSize()函数始终删除第一个元素，即始终删除最近最少访问的元素。 LruDiskCache.java限制总字节大小的本地缓存，会在缓存满时优先删除最近最少使用的元素，实现了DiskCache。内部有个DiskLruCache cache、属性，缓存的存、取操作基本都是由该属性代理完成。 StrictLineReader.java通过readLine()函数从InputStream中读取一行，目前仅用于磁盘缓存操作记录文件journal的解析。 Util.java工具类： String readFully(Reader reader)读取 reader 中内容。deleteContents(File dir)递归删除文件夹内容。 ContentLengthInputStream.javaInputStream的装饰者，可通过available()函数得到 InputStream 对应数据源的长度(总字节数)。主要用于计算文件存储进度即图片下载进度时的总进度。 FailReason.java图片下载及显示时的错误原因，目前包括：IO_ERROR 网络连接或是磁盘存储错误。DECODING_ERROR decode image 为 Bitmap 时错误。NETWORK_DENIED 当图片不在缓存中，且设置不允许访问网络时的错误。OUT_OF_MEMORY 内存溢出错误。UNKNOWN 未知错误。 FlushedInputStream.java为了解决早期 Android 版本BitmapFactory.decodeStream(…)在慢网络情况下 decode image 异常的 Bug。主要通过重写FilterInputStream的 skip(long n) 函数解决，确保 skip(long n) 始终跳过了 n 个字节。如果返回结果即跳过的字节数小于 n，则不断循环直到 skip(long n) 跳过 n 字节或到达文件尾。 ImageScaleType.javaImage 的缩放类型，目前包括：NONE不缩放。NONE_SAFE根据需要以整数倍缩小图片，使得其尺寸不超过 Texture 可接受最大尺寸。IN_SAMPLE_POWER_OF_2根据需要以 2 的 n 次幂缩小图片，使其尺寸不超过目标大小，比较快的缩小方式。IN_SAMPLE_INT根据需要以整数倍缩小图片，使其尺寸不超过目标大小。EXACTLY根据需要缩小图片到宽或高有一个与目标尺寸一致。EXACTLY_STRETCHED根据需要缩放图片到宽或高有一个与目标尺寸一致。 ViewScaleType.javaImageAware的 ScaleType。将 ImageView 的 ScaleType 简化为两种FIT_INSIDE和CROP两种。FIT_INSIDE表示将图片缩放到至少宽度和高度有一个小于等于 View 的对应尺寸，CROP表示将图片缩放到宽度和高度都大于等于 View 的对应尺寸。 ImageSize.java表示图片宽高的类。scaleDown(…) 等比缩小宽高。scale(…) 等比放大宽高。 LoadedFrom.java图片来源枚举类，包括网络、磁盘缓存、内存缓存。 ImageDecoder.java将图片转换为 Bitmap 的接口，抽象函数：Bitmap decode(ImageDecodingInfo imageDecodingInfo) throws IOException;表示根据ImageDecodingInfo信息得到图片并根据参数将其转换为 Bitmap。 BaseImageDecoder.java实现类ImageDecoder。调用ImageDownloader获取图片，然后根据ImageDecodingInfo或图片Exif信息处理图片转换为Bitmap。 主要函数： decode(ImageDecodingInfo decodingInfo) 调用ImageDownloader获取图片，再调用defineImageSizeAndRotation()函数得到图片的相关信息，调用preparedDecodingOptions()得到图片缩放的比例，调用BitmapFactory.decodeStream()将InputStream转换为Bitmap，最后调用considerExactScaleAndOrientatiton()根据参数将图片放大、翻转、旋转为合适的样子返回。 ImageFileInfo defineImageSizeAndRotation(InputStream imageStream, ImageDecodingInfo decodingInfo) 得到图片真实大小以及Exif信息（设置考虑Exif的条件下） ExifInfo defineExifOrientation(String imageUri) 得到图片Exif信息中的翻转以及旋转角度信息。 Options prepareDecodingOptions(ImageSize imageSize, ImageDecodingInfo decodingInfo) 得到图片缩放的比例： 如果scaleType等于ImageScaleType.NONE，则缩放比例为1； 如果scaleType等于ImageScaleType.NONE_SAFE，则缩放比例为ImageSizeUtils.computeImageSampleSize.computeMinImageSampleSize()的返回值。 否则，调用ImageSizeUtils.computeImageSampleSize()计算返回值。 在computeImageSampleSize()中 如果viewScaleType等于FIT_INSIDE： 1.1 如果scaleType等于ImageScaleType.IN_SAMPLE_POWER_OF_2，则缩放比例从1开始不断*2直到宽或高小于最大尺寸。 1.2 否则，取宽和高分别与最大尺寸比例中较大值，即Math.max(srcWidth / targetWidth, srcHeight / targetHeight)。 如果viewScaleType等于CROP； 2.1 如果scaleType等于ImageScaleType.IN_SAMPLE_POWER_OF_2，则缩放比例从1开始不断*2直到宽或高小于最大尺寸。 2.2 否则，取宽和高分别与最大尺寸比例中较小值，即Math.min(srcWidth / targetWidth, srcHeight / targetHeight) 最后，在considerMaxTextureSize()中判断宽和高是否超过最大值，如果是则*2或是+1缩放。 Bitmap considerExactScaleAndOrientatiton(Bitmap subsampledBitmap, ImageDecodingInfo decodingInfo,int rotation, boolean flipHorizontal) 根据参数将图片放大、翻转、旋转为合适的样子返回。 ImageDownloadingInfo.javaImage Decode 需要的信息。String imageKey 图片。String imageUri 图片 uri，可能是缓存文件的 uri。String originalImageUri 图片原 uri。ImageSize targetSize 图片的显示尺寸。imageScaleType 图片的 ScaleType。ImageDownloader downloader 图片的下载器。Object extraForDownloader 下载器需要的辅助信息。boolean considerExifParams 是否需要考虑图片 Exif 信息。Options decodingOptions 图片的解码信息，为 BitmapFactory.Options。 BitmapDisplayer.java在ImageAware中显示 bitmap 对象的接口。可在实现中对 bitmap 做一些额外处理，比如加圆角、动画效果。 FadeInBitmapDisplayer.java图片淡入方式显示在ImageAware中，实现了BitmapDisplayer接口。 RoundedBitmapDisplayer.java为图片添加圆角显示在ImageAware中，实现了BitmapDisplayer接口。主要通过BitmapShader实现。 RoundedVignetteBitmapDisplayer.java为图片添加渐变效果的圆角显示在ImageAware中，实现了BitmapDisplayer接口。主要通过RadialGradient实现。 SimpleBitmapDisplayer.java直接将图片显示在ImageAware中，实现了BitmapDisplayer接口。 BitmapProcessor.java图片处理接口。可用于对图片预处理(Pre-process Bitmap）和后处理(Post-process Bitmap)。抽象函数： 1234public interface BitmapProcessor &#123; Bitmap process(Bitmap bitmap);&#125; 用户可以根据自己的需要去实现它。比如你想要为你的图片添加一个水印，那么可以自己去实现BitmapProcessor接口。在DisplayImageOptions中配置Pre-process阶段预处理图片，这样设置后存储在文件系统以及内存缓存中的图片都是加了水印的。如果只希望在显示时改变不动原图片，可以在BitmapDisplayer中处理。 PauseOnScrollListener.java可以在View滚动过程中暂停图片加载的Listener，实现了OnScrollListener接口。它的好处是防止滚动中不必要的图片加载，在ListView或GridView中item加载图片最好使用它，简单的一行代码： 1gridView.setOnScrollListener(new PauseOnScrollListener(ImageLoader.getInstance(), false, true)); 主要成员变量： pauseOnScroll; 触摸(手指依然在屏幕上)滑动过程中是否暂停图片加载pauseOnFling; 甩指(手指已离开屏幕)过程中是否暂停图片加载externalListener; 自定义的OnScrollListener接口，适用于View原来就有自定义OnScrollListener情况设置 实现原理：重写onScrollStateChanged(…)函数判断不同的状态下暂停或继续图片加载。 OnScrollListener.SCROLL_STATE_IDLE表示 View 处于空闲状态，没有在滚动，这时候会加载图片。 OnScrollListener.SCROLL_STATE_TOUCH_SCROLL表示 View 处于触摸滑动状态，手指依然在屏幕上，通过pauseOnScroll变量确定是否需要暂停图片加载。这种时候大都属于慢速滚动浏览状态，所以建议继续图片加载。 OnScrollListener.SCROLL_STATE_FLING表示 View 处于甩指滚动状态，手指已离开屏幕，通过pauseOnFling变量确定是否需要暂停图片加载。这种时候大都属于快速滚动状态，所以建议暂停图片加载以节省资源。 QueueProcessingType.java任务队列的处理类型，包括FIFO先进先出、LIFO后进先出。 LIFOLinkedBlockingDeque.java后进先出阻塞队列。重写LinkedBlockingDeque的offer()函数如下： 1234@Overridepublic boolean offer(T e) &#123; return super.offerFirst(e);&#125; 让LinkedBlockingDeque插入总在最前，而remove()本身始终删除第一个元素，所以就变为了后进先出阻塞队列。实际一般情况只重写offer(…)函数是不够的，但因为ThreadPoolExecutor默认只用到了BlockingQueue的offer(…)函数，所以这种简单重写后做为ThreadPoolExecutor的任务队列没问题。 LIFOLinkedBlockingDeque.java包下的LinkedBlockingDeque.java、BlockingDeque.java、Deque.java都是 Java 1.6 源码中的，这里不做分析。 DiskCacheUtils.java磁盘缓存工具类，可用于查找或删除某个 uri 对应的磁盘缓存。 MemoryCacheUtils.java内存缓存工具类。可用于根据 uri 生成内存缓存 key，缓存 key 比较，根据 uri 得到所有相关的 key 或图片，删除某个 uri 的内存缓存。generateKey(String imageUri, ImageSize targetSize)根据 uri 生成内存缓存 key，key 规则为[imageUri]_[width]x[height]。 StorageUtils.java得到图片 SD 卡缓存目录路径。缓存目录优先选择/Android/data/[app_package_name]/cache；若无权限或不可用，则选择 App 在文件系统的缓存目录context.getCacheDir()；若无权限或不可用，则选择/data/data/[app_package_name]/cache。如果缓存目录选择了/Android/data/[app_package_name]/cache，则新建.nomedia文件表示不允许类似 Galley 这些应用显示此文件夹下图片。不过在 4.0 系统有 Bug 这种方式不生效。 ImageSizeUtils.java用于计算图片尺寸、缩放比例相关的工具类。 IoUtils.javaIO 相关工具类，包括 stream 拷贝，关闭等。 L.javaLog 工具类。 后记UIL的内存缓存默认使用了LRU算法，即近期最少使用算法，选用了基于链表结构的LinkedHashMap作为存储结构。 假设情景：内存缓存设置的阈值只够存储两个bitmap对象，当put第三个bitmap对象时，将近期最少使用的bitmap对象移除。 初始化LinkedHashMap，并按使用顺序来排序，accessOrder = true 向缓存池中放入bitmap1和bitmap2两个对象 继续放入第三个bitmap3，根据假设情景，将会超过设定缓存池阈值 释放对bitmap1对象的引用 bitmap1对象被GC回收 UIL的磁盘缓存默认使用了UnlimitedDiskCache","tags":[{"name":"源码分析","slug":"源码分析","permalink":"http://liuguoquan727.github.io/tags/源码分析/"}]},{"title":"Android官方数据绑定框架DataBinding","date":"2016-04-17T07:23:25.000Z","path":"2016/04/17/Android_DataBinding使用详解/","text":"转载自一叶飘舟 Android新推出了一个官方的数据绑定框架Data Binding Library，既然是官方推出的新玩意，我们就有必要了解一下Android新带来的数据绑定框架，等到该框架推出正式版的时候，我们就可以快速地运用到项目中去。数据绑定框架给我们带来了很大的方便性，以前我们可能需要在Activity里写很多的findViewById，烦人的代码也增加了我们代码的耦合性，现在我们马上就可以抛弃那些findViewById。说到这里，有人可能会问：我使用的一些注解框架也可以不用findViewById啊，是的，但是注解的缺点是拖累代码的效率，Data Binding则不会，Android官方文档说还会提高解析XML的速度，最主要的是Data Binding并不是单单减少我们的findViewById，更多的好处我们接下来一起探寻。 ##1.环境 使用最新的Android Studio 1.5.1正式版，并更新你的Suport Repository到最新的版本，确保Android Studio的Gradle插件不低于1.5.0 1classpath 'com.android.tools.build:gradle:1.5.0' 然后修改对应模块（Module）的build.gradle，添加如下脚本代码： android { //添加DataBinding Library dataBinding { enabled true } } 最后，点击Sync同步一下Gradle即可完成环境配置 ##2.Data Binding示例 首先，我们需要新建一个Java Bean，一个简单的学生类。 1234567891011121314151617181920212223242526272829303132333435package com.example.jimi098.databinding;/** * Created by jimi098 on 2016/2/16. */public class Student &#123; private String name; private String addr; public Student() &#123; &#125; public Student(String name,String addr) &#123; this.addr = addr; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddr() &#123; return addr; &#125; public void setAddr(String addr) &#123; this.addr = addr; &#125;&#125; 其次，编写布局文件data_binding.xml: 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;data&gt; &lt;variable name=\"stu\" type=\"com.example.jimi098.databinding.Student\" /&gt; &lt;/data&gt; &lt;LinearLayout android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;stu.name&#125;\"/&gt; //也可以是android:text=\"@&#123;stu.getName()&#125;\" &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;stu.addr&#125;\"/&gt; //也可以是android:text=\"@&#123;stu.getAddr()&#125;\" &lt;/LinearLayout&gt;&lt;/layout&gt; 最后，实现MainActivity,为变量赋值 12345678910111213import com.example.jimi098.databinding.databinding.DataBindingBinding;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); DataBindingBinding binding = DataBindingUtil.setContentView(this, R.layout.data_binding); binding.setStu(new Student(\"lee\", \"Shenzhen\")); &#125; 由上面可以看出，MainActivity的代码非常简单，就添加了两行代码，需要注意的是我们并没有findViewById然后再去setText。 运行结果如下图所示： ##3.Data Binding详解 上面的示例仅仅是带领我们进入了Data Binding的世界，接下来我们解释一下Data Binding的开发步骤。先看看上面的布局文件。 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;data&gt; &lt;variable name=\"stu\" type=\"com.example.jimi098.databinding.Student\" /&gt; &lt;/data&gt; ..... 根节点使用的是layout，在layout中分成两部分，第一部分是data节点，第二部分才是我们布局的根节点，在data节点下我们定义了一个variable，它是一个变量，变量名称是stu，类型是com.example.jimi098.databinding.Student，这类似我们在java文件中的定义： 1com.example.jimi098.databinding.Student stu; 不过这里要写Student完整的包名，如果这里我们需要多个Student呢？我们可以像写java文件那样导入类包 1234567891011121314151617&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;data&gt; &lt;!--导入类包--&gt; &lt;import type=\"com.example.jimi098.databinding.Student\"/&gt; &lt;variable name=\"stu\" type=\"Student\" /&gt; &lt;/data&gt; .....&lt;/layout&gt; 这样就类似于java中的 123import com.example.jimi098.databinding.Student;Student stu1,stu2,... 既然变量定义好了，那该怎么使用呢？我们仍然看上面的xml文件 123456789101112131415161718192021&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; .... &lt;LinearLayout android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;stu.name&#125;\"/&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;stu.addr&#125;\"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 由上面可以看出，两个TextView的android:text，它的值是以@开始，以{}包裹的形式出现，而值呢？是stu.name，stu就是上面定义的variable，name就是Student类中的成员变量，其实这里就会去调用stu.getName()方法。 最后，我们看看如何给变量赋值呢？如下代码: 12345678910111213import com.example.jimi098.databinding.databinding.DataBindingBinding;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); DataBindingBinding binding = DataBindingUtil.setContentView(this, R.layout.data_binding); binding.setStu(new Student(\"lee\", \"Shenzhen\")); //赋值 &#125; 大部分情况，我们会在Activity中去使用它，以前我们都是在OnCreate方法中通过setContextView去设置布局。但现在不一样了，现在我们是通过DataBindingUtil类的一个静态方法setContentView设置布局，同时该方法会返回一个对象，这个对象时一个自动生成的类的对象，如DataBindingBinding？那么它的命名规则是什么呢？将我们布局文件的首字母大写，并且去掉下划线，将下划线后面的字母大写，加上后缀Binding组成。最后，我们通过这个对象来给变量赋值。 通过以上分析，我们了解Data Binding的具体开发步骤，下面让我们定义不同的几个变量看看 1234567891011121314151617181920212223242526272829303132333435&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;data&gt; &lt;import type=\"com.example.jimi098.databinding.Student\" /&gt; &lt;variable name=\"stu\" type=\"Student\" /&gt; &lt;variable name=\"str\" type=\"String\"/&gt; &lt;variable name=\"error\" type=\"boolean\"/&gt; &lt;variable name=\"num\" type=\"int\" /&gt; &lt;/data&gt; &lt;LinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;stu.name&#125;\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;str&#125;\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;String.valueOf(num)&#125;\"/&gt; &lt;/LinearLayout&gt; &lt;/layout&gt; 由上面代码可以看出，String类型的变量没有导入包，这是因为Data Binding和Java一样，java.lang包里的类，我们是可以不用导入包的，再往下一个boolean和int类型的变量，都是java基本类型，也不用导入包。 再来看看几个TextView，第二个TextView，我们直接使用@{str}来为android:text设置文本内容；接下来注意第三个TextView，我们使用android:text=”@{String.valueOf(num)}”来设置一个int类型的变量，因为在给android:text设置int类型的值一定要转化为String类型，不然系统会认为是资源文件id。此外，我们还学习到了一点，在Xml中，我们不仅可以使用变量，而且还可以调用方法 ##4. 变量定义的高级部分 在上面，我们学会了如何在xml中定义变量，但是我们并没有定义像List、Map等这样的集合变量。那么到底能不能定义呢？答案是肯定的，而且定义的方式和我们上面的基本一致，区别就在于我们还需要为它定义key的变量，例如： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;data&gt; &lt;!--导入类包--&gt; &lt;import type=\"com.example.jimi098.databinding.Student\" /&gt; &lt;import type=\"android.graphics.Bitmap\" /&gt; &lt;import type=\"java.util.ArrayList\" /&gt; &lt;import type=\"java.util.HashMap\" /&gt; &lt;variable name=\"stu\" type=\"Student\" /&gt; &lt;variable name=\"str\" type=\"String\" /&gt; &lt;variable name=\"error\" type=\"boolean\" /&gt; &lt;variable name=\"num\" type=\"int\" /&gt; &lt;variable name=\"list\" type=\"ArrayList&lt;String&gt;\" /&gt; &lt;variable name=\"map\" type=\"HashMap&lt;String, String&gt;\" /&gt; &lt;variable name=\"array\" type=\"String[]\" /&gt; &lt;variable name=\"listKey\" type=\"int\" /&gt; &lt;variable name=\"mapKey\" type=\"String\" /&gt; &lt;variable name=\"arrayKey\" type=\"int\" /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;stu.name&#125;\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;str&#125;\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;String.valueOf(num)&#125;\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;list[listKey]&#125;\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;map[mapKey]&#125;\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;array[arrayKey]&#125;\" /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 然后在java代码中为变量赋值 1234567891011121314151617181920212223242526272829303132333435public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); DataBindingBinding binding = DataBindingUtil.setContentView(this, R.layout.data_binding); binding.setStu(new Student(\"lee\", \"Shenzhen\")); binding.setStr(\"just do it\"); binding.setNum(10); ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"list1\"); list.add(\"list2\"); binding.setList(list); binding.setListKey(0); HashMap&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); map.put(\"name\",\"liu\"); map.put(\"sex\",\"male\"); binding.setMap(map); binding.setMapKey(\"sex\"); String[] array = new String[2]; array[0] = \"array0\"; array[1] = \"array1\"; binding.setArray(array); binding.setArrayKey(1); &#125; ##5.表达式 xml中还支持表达式 1234&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text='@&#123;error ? \"error\" : \"ok\"&#125;'/&gt; 如上所示，android:text后是一个三元表达式，如果error是true，则text就是error，否则是OK。 除此外还支持null合并操作,??–左边的对象如果它不是null，选择左边的对象；或者如果它是null，选择右边的对象 1234&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text='@&#123;str ?? \"not null\"&#125;' /&gt; 还支持以下表达式: 数学 + - / * % 字符串连接 + 逻辑 &amp;&amp; || 二进制 &amp; | ^ 一元运算 + - ! ~ 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 比较 == &gt; &lt; &gt;= &lt;= instanceof 分组 () null Cast 方法调用 数据访问 [] 三元运算 ?: 示例： 123android:text=\"@&#123;String.valueOf(index + 1)&#125;\"android:visibility=\"@&#123;age &lt; 13 ? View.GONE : View.VISIBLE&#125;\"android:transitionName='@&#123;\"image_\" + id&#125;' 但是它不支持一下表达式： this super new 显式泛型调用 ##6. 其他知识点 ###6.1 设置别名 假如我们import了两个相同名称的类咋办？我们可以借助于别名来解决，别名借助alias字段来标识，例如： 123456&lt;data&gt; &lt;import type=\"xxx.Name\" alias=\"MyName\"&gt; &lt;import type=\"xxx.xx.Name\"&gt; &lt;/data&gt; &lt;TextView xxx:@&#123;MyName.getName()&#125;&gt; &lt;TextView xxx:@&#123;Name.getName()&#125;&gt; ###6.2 自定义Binding类名称 默认情况下，Binding类的命名是基于所述layout文件的名称，用大写开头，除去下划线（）以及（）后的第一个字母大写，然后添加“Binding”后缀。这个类将被放置在一个模块封装包里的databinding封装包下。例如，所述layout文件contact_item.xml将生成ContactItemBinding。如果模块包是com.example.my.app，那么它将被放置在com.example.my.app.databinding。 Binding类可通过调整data元素中的class属性来重命名或放置在不同的包中。例如： 123&lt;data class=\"ContactItem\"&gt; ...&lt;/data&gt; 在模块封装包的databinding包中会生成名为ContactItem的Binding类。如果要想让该类生成在不同的包中，你需要添加前缀.，如下： 123&lt;data class=\".ContactItem\"&gt; ...&lt;/data&gt; 在这个情况下，ContactItem类直接在模块包中生成。或者你可以提供整个包名： 123&lt;data class=\"com.example.ContactItem\"&gt; ...&lt;/data&gt; ###6.3 字符串 当使用单引号包含属性值时，在表达式中使用双引号很容易：android:text=’@{map[“firstName”]}’ 使用双引号来包含属性值也是可以的。字符串前后需要使用”&quot;： android:text=&quot;@{map[`firstName`]}” ###6.4 Resources 使用正常的表达式来访问resources也是可行的：android:padding=”@{large? @dimen/largePadding : @dimen/smallPadding}” ###6.5 include 通过使用application namespace以及在属性中的Variable名字从容器layout中传递Variables到一个被包含的layout： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:bind=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;data&gt; &lt;variable name=\"user\" type=\"com.example.User\"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;include layout=\"@layout/name\" bind:user=\"@&#123;user&#125;\"/&gt; &lt;include layout=\"@layout/contact\" bind:user=\"@&#123;user&#125;\"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 注意：在name.xml以及contact.xml两个layout文件中必需要有user variable ##7.事件绑定 大家都知道，在xml中我们可以给button设置一个onClick来达到事件的绑定，现在DataBinding也提供了事件绑定，而且不仅仅是button。首先定义一个对象处理点击事件，如下： 12345678910/** * Created by jimi098 on 2016/2/16. */public class EventHandler &#123; public void handleClick(View view) &#123; Toast.makeText(view.getContext(),\"click\",Toast.LENGTH_SHORT).show(); &#125;&#125; 其次看布局： 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;data&gt; &lt;import type=\"com.example.jimi098.databinding.EventHandler\" /&gt; &lt;variable name=\"handler\" type=\"EventHandler\" /&gt; &lt;/data&gt; &lt;LinearLayout android:orientation=\"vertical\"&gt; &lt;Button android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Click\" android:onClick=\"@&#123;handler.handleClick&#125;\"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 最后，实现事件绑定 1234567891011public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ClickBindingBinding binding = DataBindingUtil.setContentView(this, R.layout.click_binding); binding.setHandler(new EventHandler()); &#125; ##8.Data对象 我们学会了通过binding为我们的变量设置数据，但是不知道你有没有发现一个问题，当我们数据改变的时候会怎样？数据是跟随着改变呢？还是原来的数据呢？这里告诉你答案：很不幸，显示的还是原来的数据？那有没有办法让数据源发生变化后显示的数据也随之发生变化？先来想想ListView是怎么做的， ListView的数据是通过Adapter提供的，当数据发生改变时，我们通过notifyDatasetChanged通过UI去改变数据，这里面的原理其实就是内容观察者，庆幸的是DataBinding也支持内容观察者，而且使用起来也相当方便！ ###8.1 Observable 我们可以通过Observable的方式去通知UI数据已经改变了，当然了，官方为我们提供了更加简便的方式BaseObservable，我们的实体类只需要继承该类，稍做几个操作，就能轻松实现数据变化的通知。如何使用呢？ 首先我们的实体类要继承BaseObservale类，第二步在Getter上使用注解@Bindable，第三步，在Setter里调用方法notifyPropertyChanged，第四步，完成。就是这么简单，下面我们来实际操作一下。 首先定义一个实体类，并继承BaseObservable 12345678910111213141516171819202122232425262728293031323334353637/** * Created by jimi098 on 2016/2/16. */public class Student extends BaseObservable&#123; private String name; private String addr; public Student() &#123; &#125; public Student(String name,String addr) &#123; this.addr = addr; this.name = name; &#125; @Bindable public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; notifyPropertyChanged(com.example.jimi098.databinding.BR.name); &#125; @Bindable public String getAddr() &#123; return addr; &#125; public void setAddr(String addr) &#123; this.addr = addr; notifyPropertyChanged(com.example.jimi098.databinding.BR.addr); &#125;&#125; 观察getName方法，我们使用了@Bindable注解，观察setName，我们调用了notifyPropertyChanged方法，这个方法还需要一个参数，这里参数类似于R.java，保存了我们所有变量的引用地址，这里我们使用了name。 其次，看看布局文件 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;data&gt; &lt;import type=\"com.example.jimi098.databinding.Student\" /&gt; &lt;variable name=\"stu\" type=\"Student\"/&gt; &lt;variable name=\"click\" type=\"com.example.jimi098.databinding.MainActivity\" /&gt; &lt;/data&gt; &lt;LinearLayout android:orientation=\"vertical\"&gt; &lt;TextView android:gravity=\"center\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;stu.name+stu.addr&#125;\" android:onClick=\"@&#123;click.click&#125;\"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 最后，java实现 1234567891011121314151617181920212223public class MainActivity extends AppCompatActivity &#123; private Student mStu; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ClickBindingBinding binding = DataBindingUtil.setContentView(this, R.layout.click_binding); mStu = new Student(\"lau\",\"Shenzhen\"); binding.setStu(mStu); //设置初始显示数据 binding.setClick(this); //设置点击事件 &#125; public void click(View view) &#123; //点击时数据发生改变 mStu.setName(\"lee\"); mStu.setAddr(\"Beijing\"); &#125;&#125; ###8.2 ObservableFields 上面使用BaseObservable已经非常容易了，但是google工程师还不满足，继续给我们封装了一系列的ObservableFields，这里有ObservableField,ObservableBoolean,ObservableByte,ObservableChar,ObservableShort,ObservableInt,ObservableLong,ObservableFloat,ObservableDouble,ObservableParcelable ObservableFields的使用方法就更加简单了，例如下面代码: 12345public class People &#123; public ObservableField&lt;String&gt; name = new ObservableField&lt;&gt;(); public ObservableInt age = new ObservableInt(); public ObservableBoolean isMan = new ObservableBoolean(); &#125; 很简单，只有三个ObservableField变量，并且没有getter和setter，因为我们不需要getter和setter。在xml中怎么使用呢？ 1234567891011121314151617181920212223242526&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;data class=\".Custom\"&gt; &lt;variable name=\"people\" type=\"org.loader.app4.People\" /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;people.name&#125;\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;String.valueOf(people.age)&#125;\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text='@&#123;people.isMan ? \"man\" : \"women\"&#125;'/&gt; &lt;/LinearLayout&gt; &lt;/layout&gt; 也很简单，直接使用变量，那怎么赋值和取值呢?这些ObservableField都会有一对get和set方法，所以使用起来也很方便了： 12345mPeople = new People(); binding.setPeople(mPeople); mPeople.name.set(\"people\"); mPeople.age.set(19); mPeople.isMan.set(true); ###8.3 Observable Collections 既然普通的变量我们有了ObservableFields的分装，那集合呢？当然也有啦，来看着两个：ObservableArrayMap,ObservableArrayList。使用和普通的Map、List基本相同，直接看代码： 1234567891011121314151617181920212223&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;data class=\".Custom\"&gt; &lt;variable name=\"map\" type=\"android.databinding.ObservableArrayMap&lt;String,String&gt;\" /&gt; &lt;variable name=\"list\" type=\"android.databinding.ObservableArrayList&lt;String&gt;\" /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;map[`name`]&#125;\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;list[0]&#125;\"/&gt; &lt;/LinearLayout&gt; &lt;/layout&gt; 在来看java文件，怎么设置数据 123456ObservableArrayMap&lt;String, String&gt; map = new ObservableArrayMap&lt;&gt;(); ObservableArrayList&lt;String&gt; list = new ObservableArrayList&lt;&gt;(); map.put(\"name\", \"loader or qibin\"); list.add(\"loader!!!\"); binding.setMap(map); binding.setList(list); ##9.Inflate 上面的代码我们都是在activity中通过DataBindingUtil.setContentView来加载的布局的，现在有个问题了，如果我们是在Fragment中使用呢？Fragment没有setContentView怎么办？不要着急，Data Binding也提供了inflate的支持！ 使用方法如下，大家肯定会觉得非常眼熟。 12MyLayoutBinding binding = MyLayoutBinding.inflate(layoutInflater); MyLayoutBinding binding = MyLayoutBinding.inflate(layoutInflater, viewGroup, false); 接下来，我们就尝试着在Fragment中使用一下Data Binding吧。 首先还是那个学生类，Student 1234567891011121314151617181920212223242526272829303132public class Student extends BaseObservable &#123; private String name; private int age; public Student() &#123; &#125; public Student(int age, String name) &#123; this.age = age; this.name = name; &#125; @Bindable public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; notifyPropertyChanged(org.loader.app5.BR.age); &#125; @Bindable public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; notifyPropertyChanged(org.loader.app5.BR.name); &#125; &#125; 其次，activity的布局 123456789101112&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;FrameLayout android:id=\"@+id/container\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; &lt;/RelativeLayout&gt; Activity的实现 12345678910public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); getSupportFragmentManager().beginTransaction() .replace(R.id.container, new MyFragment()).commit(); &#125; &#125; 重点来了，我们这里data binding的操作都放在了fragment里，那么我们先来看看fragment的布局。 123456789101112131415161718192021222324252627&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;data class=\".Custom\"&gt; &lt;import type=\"org.loader.app5.Student\" /&gt; &lt;variable name=\"stu\" type=\"Student\" /&gt; &lt;variable name=\"frag\" type=\"org.loader.app5.MyFragment\" /&gt; &lt;/data&gt; &lt;LinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"@&#123;frag.click&#125;\" android:text=\"@&#123;stu.name&#125;\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;String.valueOf(stu.age)&#125;\"/&gt; &lt;/LinearLayout&gt; &lt;/layout&gt; 两个TextView分别绑定了Student的name和age字段，而且给name添加了一个点击事件，点击后会调用Fragment的click方法。我们来迫不及待的看一下Fragment怎么写： 123456789101112131415161718192021public class MyFragment extends Fragment &#123; private Student mStu; @Nullable @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; org.loader.app5.Custom binding = DataBindingUtil.inflate(inflater, R.layout.frag_layout, container, false); mStu = new Student(20, \"loader\"); binding.setStu(mStu); binding.setFrag(this); return binding.getRoot(); &#125; public void click(View view) &#123; mStu.setName(\"qibin\"); mStu.setAge(18); &#125; &#125; 在onCreateView中，不同于在Activity中，这里我们使用了DataBindingUtil.inflate方法，接受4个参数，第一个参数是一个LayoutInflater对象，正好，我们这里可以使用onCreateView的第一个参数，第二个参数是我们的布局文件，第三个参数是一个ViewGroup，第四个参数是一个boolean类型的，和在LayoutInflater.inflate一样，后两个参数决定了是否想container中添加我们加载进来的布局。 下面的代码和我们之前写的并无差别，但是有一点，onCreateView方法需要返回一个View对象，我们从哪获取呢？ViewDataBinding有一个方法getRoot可以获取我们加载的布局，是不是很简单？ 来看一下效果： ##10.Data Binding VS RecyclerView 有了上面的思路，大家是不是也会在ListView和RecyclerView中使用了？我们仅以一个RecyclerView来学习一下。 首先来看看item的布局， 1234567891011121314151617181920212223242526&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;data&gt; &lt;variable name=\"stu\" type=\"org.loader.app6.Student\" /&gt; &lt;/data&gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;stu.name&#125;\" android:layout_alignParentLeft=\"true\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;String.valueOf(stu.age)&#125;\" android:layout_alignParentRight=\"true\"/&gt; &lt;/RelativeLayout&gt; &lt;/layout&gt; 可以看到，还是用了那个Student实体，这样得代码，相信你也已经看烦了吧。那我们来看看activity的。 1234567891011121314151617private RecyclerView mRecyclerView; private ArrayList&lt;Student&gt; mData = new ArrayList&lt;Student&gt;() &#123; &#123; for (int i=0;i&lt;10;i++) add(new Student(\"loader\" + i, 18 + i)); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mRecyclerView = (RecyclerView) findViewById(R.id.recycler); mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)); mRecyclerView.setAdapter(new MyAdapter(mData)); &#125; 这里给RecyclerView设置了一个Adapter，相信最主要的代码就在这个Adapter里。 1234567891011121314151617181920212223242526272829303132333435363738394041424344private class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt; &#123; private ArrayList&lt;Student&gt; mData = new ArrayList&lt;&gt;(); private MyAdapter(ArrayList&lt;Student&gt; data) &#123; mData.addAll(data); &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup viewGroup, int i) &#123; ViewDataBinding binding = DataBindingUtil.inflate(LayoutInflater .from(viewGroup.getContext()), R.layout.item, viewGroup, false); ViewHolder holder = new ViewHolder(binding.getRoot()); holder.setBinding(binding); return holder; &#125; @Override public void onBindViewHolder(ViewHolder viewHolder, int i) &#123; viewHolder.getBinding().setVariable(org.loader.app6.BR.stu, mData.get(i)); viewHolder.getBinding().executePendingBindings(); &#125; @Override public int getItemCount() &#123; return mData.size(); &#125; class ViewHolder extends RecyclerView.ViewHolder &#123; private ViewDataBinding binding; public ViewHolder(View itemView) &#123; super(itemView); &#125; public void setBinding(ViewDataBinding binding) &#123; this.binding = binding; &#125; public ViewDataBinding getBinding() &#123; return this.binding; &#125; &#125; 果然，这个adapter的写法和我们之前的写法不太一样，首先看看ViewHolder，在这个holder里，我们保存了一个ViewDataBinding对象，并给它提供了Getter和Setter方法， 这个ViewDataBinding是干嘛的？我们稍后去讲。继续看看onCreateViewHolder，在这里面，我们首先调用DataBindingUtil.inflate方法返回了一个ViewDataBinding的对象，这个ViewDataBinding是个啥？我们以前没见过啊，这里告诉大家我们之前返回的那些都是ViewDataBinding的子类！继续看代码，我们new了一个holder，参数是肯定是我们的item布局了，继续看，接着我们又把binding设置给了holder，最后返回holder。这时候，我们的holder里就保存了刚刚返回的ViewDataBinding对象，干嘛用呢?继续看onBindViewHolder就知道了。 12345@Override public void onBindViewHolder(ViewHolder viewHolder, int i) &#123; viewHolder.getBinding().setVariable(org.loader.app6.BR.stu, mData.get(i)); viewHolder.getBinding().executePendingBindings(); &#125; 只有两行代码，但是都是我们没有见过的，首先第一行，我们以前都是使用类似binding.setStu这样方法去设置变量，那这个setVariable呢？ 为什么没有setStu，这里要记住，ViewDataBinding是我们之前用的那些binding的父类，只有自动生成的那些子类才会有setXXX方法，那现在我们需要在ViewDataBinding中设置变量咋办？这个类为我们提供了setVariable去设置变量，第一个参数是我们的变量名的引用，第二个是我们要设置的值。 第二行代码，executePendingBindings的作用是干嘛的？ 官方的回答是：当数据改变时，binding会在下一帧去改变数据，如果我们需要立即改变，就去调用executePendingBindings方法。所以这里的作用就是去让数据的改变立即执行。 ok，现在看起来，我们的代码更加简洁了，而且不需要保存控件的实例，是不是很爽？ 来看看效果： ##11.View with ID 在使用Data Binding的过程中，我们发现并没有保存View的实例，但是现在我们有需求需要这个View的实例咋办？难道走老路findViewById？当然不是啦，当我们需要某个view的实例时，我们只要给该view一个id，然后Data Binding框架就会给我们自动生成该view的实例，放哪了？当然是ViewDataBinding里面。 上代码： 1234567891011121314151617&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;data class=\".Custom\"&gt; &lt;variable name=\"str\" type=\"android.databinding.ObservableField&lt;String&gt;\" /&gt; &lt;variable name=\"handler\" type=\"org.loader.app7.MainActivity\" /&gt; &lt;/data&gt; &lt;TextView android:id=\"@+id/textView\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;str.get&#125;\" android:onClick=\"@&#123;handler.click&#125;\"/&gt; &lt;/layout&gt; xml中代码没有什么好说的，都是之前的代码。需要注意的是，我们给TextView设定了一个id-textView。 activity代码如下： 123456789101112131415161718192021public class MainActivity extends AppCompatActivity &#123; private org.loader.app7.Custom mBinding; private ObservableField&lt;String&gt; mString; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mBinding = DataBindingUtil.setContentView(this, R.layout.activity_main); mString = new ObservableField&lt;String&gt;(); mString.set(\"loader\"); mBinding.setStr(mString); mBinding.setHandler(this); &#125; public void click(View view) &#123; mString.set(\"qibin\"); mBinding.textView.setTextColor(Color.GREEN); //找到控件 &#125; &#125; 通过ViewDataBinding类的实例直接去获取的。只要我们给了view一个id，那么框架就会在ViewDataBinding中自动帮我们保存这个view的实例，变量名就是我们设置的id。 ##12.自定义setter(BindingAdapter) 想想这样的一种情景，一个ImageView需要通过网络去加载图片，那我们怎么办？看似好像使用DataBinding不行，恩，我们上面所学到东西确实不能够解决这个问题，但是DataBinding框架给我们提供了很好的扩展，允许我们自定义setter，那该怎么做呢？这里就要引出另一个知识点——BindingAdapter，这是一个注解，参数是一个数组，数组中存放的是我们自定义的’属性’。接下来就以一个例子学习一下BindingAdapter的使用。 12345678910111213&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;data class=\".Custom\"&gt; &lt;variable name=\"imageUrl\" type=\"String\" /&gt; &lt;/data&gt; &lt;ImageView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:image=\"@&#123;imageUrl&#125;\"/&gt; &lt;/layout&gt; 这里我们增加了一个命名空间app，并且注意ImageView的app:image属性，这里和我们自定义view时自定义的属性一样，但是这里并不需要我们去重写ImageView，这条属性的值是我们上面定义的String类型的imageUrl，从名称中看到这里我们可能会塞给他一个url。 activity代码如下: 12345678910public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); org.loader.app8.Custom binding = DataBindingUtil.setContentView(this, R.layout.activity_main); binding.setImageUrl(\"http://images.csdn.net/20150810/Blog-Image%E5%89%AF%E6%9C%AC.jpg\"); &#125; &#125; 果然在这里我们set了一个url，那图片怎么加载呢？这里就要使用到我们刚才说的BindingAdapter注解了。 123456public class Utils &#123; @BindingAdapter(&#123;\"bind:image\"&#125;) public static void imageLoader(ImageView imageView, String url) &#123; ImageLoaderUtils.getInstance().displayImage(url, imageView); &#125; &#125; 我们定义了一个Utils类，这个类你可以随便起名，该类中只有一个静态的方法imageLoader，该方法有两个参数，一个是需要设置数据的view，一个是我们需要的url。值得注意的是那个BindingAdapter注解，看看他的参数，是一个数组，内容只有一个bind:image，仅仅几行代码，我们不需要 手工调用Utils.imageLoader，也不需要知道imageLoader方法定义到哪了，一个网络图片加载就搞定了，是不是很神奇，这里面起关键作用的就是BindingAdapter 注解了，来看看它的参数怎么定义的吧，难道是乱写？当然不是，这里要遵循一定的规则, 以bind:开头，接着书写你在控件中使用的自定义属性名称。 这里就是image了，不信来看。 1234&lt;ImageView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:image=\"@&#123;imageUrl&#125;\"/&gt; ##13.Converters Converter是什么呢？举个例子吧：假如你的控件需要一个格式化好的时间，但是你只有一个Date类型额变量咋办？肯定有人会说这个简单，转化完成后在设置，恩，这也是一种办法，但是DataBinding还给我们提供了另外一种方式，虽然原理一样，但是这种方式使用的场景更多，那就是——Converter。和上面的BindingAdapter使用方法一样，这也是一个注解。下面还是以一段代码的形式进行学习。 123456789101112&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;data class=\".Custom\"&gt; &lt;variable name=\"time\" type=\"java.util.Date\" /&gt; &lt;/data&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@&#123;time&#125;\"/&gt; &lt;/layout&gt; 看TextView的text属性，我们需要一个String类型的值，但是这里确给了一个Date类型的，这就需要我们去定义Converter去转换它， activity代码如下: 12345678910public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); org.loader.app9.Custom binding = DataBindingUtil.setContentView(this, R.layout.activity_main); binding.setTime(new Date()); &#125; &#125; 去给这个Date类型的变量设置值。怎么去定义Converter呢？ 看代码： 12345678public class Utils &#123; @BindingConversion public static String convertDate(Date date) &#123; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); return sdf.format(date); &#125; &#125; 和上面一样，我们不需要关心这个convertDate在哪个类中，重要的是他的@BindingConversion注解，这个方法接受一个Date类型的变量，正好我们的android:text设置的就是一个Date类型的值，在方法内部我们将这个Date类型的变量转换成String类型的日期并且返回。这样UI上就显示出我们转化好的字符串。看看效果：","tags":[{"name":"实战","slug":"实战","permalink":"http://liuguoquan727.github.io/tags/实战/"}]},{"title":"Butterknife使用详解","date":"2016-04-17T07:20:54.000Z","path":"2016/04/17/Android_Butterknife使用详解/","text":"项目地址GitHub地址:https://github.com/JakeWharton/butterknife 简介ButterKnife这个开源库可以让我们从大量的findViewById和setOnClickListener中解放出来，其对性能的影响微乎其微（其自定义注解的实现都是限定为RetentionPolicy.CLASS，也就是编译出.class文件为止有效，在运行时不额外消耗性能，其实通过java注解自动生成java代码的形式来完成工作），但也有一个明显的缺点，那就是代码的可读性差些，凡事有利有弊，我们需要做到有的放矢。 应用Activity Binding123456789101112class ExampleActivity extends Activity &#123; @Bind(R.id.title) TextView title; @Bind(R.id.subtitle) TextView subtitle; @Bind(R.id.footer) TextView footer; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.simple_activity); ButterKnife.bind(this); // TODO Use fields... &#125;&#125; 调用注解bind生成的代码是可见的并且能够调试，上面的示例通过Bind注解生成的代码相当于下面的代码： 12345public void bind(ExampleActivity activity) &#123; activity.subtitle = (android.widget.TextView) activity.findViewById(2130968578); activity.footer = (android.widget.TextView) activity.findViewById(2130968579); activity.title = (android.widget.TextView) activity.findViewById(2130968577);&#125; RESOURCE BINDINGBind pre-defined resources with @BindBool, @BindColor, @BindDimen, @BindDrawable, @BindInt, @BindString, which binds an R.bool ID (or your specified type) to its corresponding field. 1234567class ExampleActivity extends Activity &#123; @BindString(R.string.title) String title; @BindDrawable(R.drawable.graphic) Drawable graphic; @BindColor(R.color.red) int red; // int or ColorStateList field @BindDimen(R.dimen.spacer) Float spacer; // int (for pixel size) or float (for exact value) field // ...&#125; NON-ACTIVITY BINDING1234567891011public class FancyFragment extends Fragment &#123; @Bind(R.id.button1) Button button1; @Bind(R.id.button2) Button button2; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fancy_fragment, container, false); ButterKnife.bind(this, view); // TODO Use fields... return view; &#125;&#125; ADAPTER BINDING1234567891011121314151617181920212223242526public class MyAdapter extends BaseAdapter &#123; @Override public View getView(int position, View view, ViewGroup parent) &#123; ViewHolder holder; if (view != null) &#123; holder = (ViewHolder) view.getTag(); &#125; else &#123; view = inflater.inflate(R.layout.whatever, parent, false); holder = new ViewHolder(view); view.setTag(holder); &#125; holder.name.setText(\"John Doe\"); // etc... return view; &#125; static class ViewHolder &#123; @Bind(R.id.title) TextView name; @Bind(R.id.job_title) TextView jobTitle; public ViewHolder(View view) &#123; ButterKnife.bind(this, view); &#125; &#125;&#125; LIST OR ARRAY BINDING1234567891011121314151617181920@Bind(&#123; R.id.first_name, R.id.middle_name, R.id.last_name &#125;)List&lt;EditText&gt; nameViews;//允许同时作用于list中的viewButterKnife.apply(nameViews, DISABLE);ButterKnife.apply(nameViews, ENABLED, false);//Action and Setter interfaces allow specifying simple behavior.static final ButterKnife.Action&lt;View&gt; DISABLE = new ButterKnife.Action&lt;View&gt;() &#123; @Override public void apply(View view, int index) &#123; view.setEnabled(false); &#125;&#125;;static final ButterKnife.Setter&lt;View, Boolean&gt; ENABLED = new ButterKnife.Setter&lt;View, Boolean&gt;() &#123; @Override public void set(View view, Boolean value, int index) &#123; view.setEnabled(value); &#125;&#125;;//An Android Property can also be used with the apply method.ButterKnife.apply(nameViews, View.ALPHA, 0.0f); LISTENER BINDING12345//带View参数@OnClick(R.id.submit)public void submit(View view) &#123; // TODO submit data to server...&#125; 12345//不带View参数@OnClick(R.id.submit)public void submit() &#123; // TODO submit data to server...&#125; 12345//带Button参数@OnClick(R.id.submit)public void sayHi(Button button) &#123; button.setText(\"Hello!\");&#125; 123456789//同时注入多个View事件@OnClick(&#123; R.id.door1, R.id.door2, R.id.door3 &#125;)public void pickDoor(DoorView door) &#123; if (door.hasPrizeBehind()) &#123; Toast.makeText(this, \"You win!\", LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(this, \"Try again\", LENGTH_SHORT).show(); &#125;&#125; 123456public class FancyButton extends Button &#123; @OnClick public void onClick() &#123; // TODO do something! &#125;&#125; BINDING RESET相对于Activity，Fragment有与之不同的视图声明周期。当早onCreateView中bind一个Fragment的时候，需要在OnDestroyView中将views设置为null。Butter Knife 通过一个ButterKnife.Unbinder接口来自动完成这个过程. Simply bind an unbinder with @Unbinder to the fragment. 1234567891011121314151617public class FancyFragment extends Fragment &#123; @Bind(R.id.button1) Button button1; @Bind(R.id.button2) Button button2; @Unbinder ButterKnife.Unbinder unbinder; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fancy_fragment, container, false); ButterKnife.bind(this, view); // TODO Use fields... return view; &#125; @Override public void onDestroyView() &#123; super.onDestroyView(); unbinder.unbind(); &#125;&#125; OPTIONAL BINDINGS默认情况下,@Bind和绑定的目标是必须存在的，如果目标View不存在将会抛出异常。 为了避免这样情况并且创建一个可选的绑定目标，给变量增加@Nullable注解或者给方法增加 @Optional注解. Note: Any annotation named @Nullable or can be used for fields. It is encouraged to use the @Nullable annotation from Android’s “support-annotations” library. 12//给变量增加@Nullable注解@Nullable @Bind(R.id.might_not_be_there) TextView mightNotBeThere; 1234//给方法增加@Optional注解@Optional @OnClick(R.id.maybe_missing) void onMaybeMissingClicked() &#123; // TODO ...&#125; MULTI-METHOD LISTENERS1234@OnItemSelected(R.id.list_view)void onItemSelected(int position) &#123; // TODO ...&#125; 1234@OnItemSelected(value = R.id.maybe_missing, callback = NOTHING_SELECTED)void onNothingSelected() &#123; // TODO ...&#125; BONUSAlso included are findById methods which simplify code that still has to find views on a View, Activity, or Dialog. It uses generics to infer the return type and automatically performs the cast. 1234View view = LayoutInflater.from(context).inflate(R.layout.thing, null);TextView firstName = ButterKnife.findById(view, R.id.first_name);TextView lastName = ButterKnife.findById(view, R.id.last_name);ImageView photo = ButterKnife.findById(view, R.id.photo);","tags":[{"name":"实战","slug":"实战","permalink":"http://liuguoquan727.github.io/tags/实战/"}]},{"title":"Java内部类","date":"2016-04-17T07:17:46.000Z","path":"2016/04/17/Java内部类/","text":"可以将一个类的定义放在另一个类的定义内部，这就是内部类。 内部类是一种非常有用的特性，因为它允许你把一些逻辑相关的类组织在一起，并控制位于内部的类的可视性。然而必须要了解的是内部类与组合是完全不同的概念。 创建局部内部类创建内部类的方式就是把类的定义置于外部类的里面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.michael.java.innerclass;public class Parcel1 &#123; class Content &#123; private int i = 11; public int value() &#123; return i; &#125; &#125; class Destination &#123; private String label; public Destination(String where) &#123; label = where; &#125; public String readLabel() &#123; return label; &#125; &#125; public void ship(String dest) &#123; Content content = new Content(); System.out.println(content.value()); Destination destination = new Destination(dest); System.out.println(destination.readLabel()); &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub Parcel1 parcel = new Parcel1(); parcel.ship(\"ShangHai\"); &#125;&#125;打印结果：11ShangHai 当我们在ship()方法里面使用内部类的时候，与使用普通类没有什么不同。在这里实际的区别只是内部类的名字是嵌套在Parcel里面的。不过这不是唯一的区别。 更典型的情况是，外部类将有一个方法，该方法返回一个指向内部类的引用，就像to()和contexts()看到的那样： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.michael.java.innerclass;public class Parcel2 &#123; class Content &#123; private int i = 11; public int value() &#123; return i; &#125; &#125; class Destination &#123; private String label; public Destination(String where) &#123; label = where; &#125; public String readLabel() &#123; return label; &#125; &#125; public Destination to(String dest) &#123; return new Destination(dest); &#125; public Content content() &#123; return new Content(); &#125; public void ship(String dest) &#123; Content content = content(); System.out.println(content.value()); Destination destination = to(dest); System.out.println(destination.readLabel()); &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub Parcel2 p = new Parcel2(); p.ship(\"ShangHai\"); Parcel2 q = new Parcel2(); Parcel2.Content content = q.content(); System.out.println(content.value()); Parcel2.Destination destination = q.to(\"Beijing\"); System.out.println(destination.readLabel()); &#125;&#125;打印结果：11ShangHai11Beijing 如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须像在main()方法中那样，具体地指明这个对象的类型：OuterClassName.InnerClassName. 链接到外部类当生产一个内部类的对象时，此对象与生产它的外部类对象之间就有了一种联系，所以它能访问其外部类对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外部类的所有元素的访问权。看看下面的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.michael.java.innerclass;interface Selector &#123; boolean end(); Object cuurent(); void next();&#125;public class Sequence &#123; private Object[] items; private int next = 0; public Sequence(int size) &#123; items = new Object[size]; &#125; public void add(Object obj) &#123; if (next &lt; items.length) &#123; items[next++] = obj; &#125; &#125; private class SequenceSelecotr implements Selector &#123; private int i = 0; @Override public boolean end() &#123; // TODO Auto-generated method stub return i == items.length; //直接使用外部类的对象 &#125; @Override public Object cuurent() &#123; // TODO Auto-generated method stub return items[i]; &#125; @Override public void next() &#123; // TODO Auto-generated method stub if (i &lt; items.length) &#123; i++; &#125; &#125; &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub Sequence sequence = new Sequence(10); for(int i = 0;i &lt; 10;i++) &#123; sequence.add(Integer.toString(i)); &#125; SequenceSelecotr selector = sequence.new SequenceSelecotr(); while(!selector.end()) &#123; System.out.println(\"current: \" + selector.cuurent()); selector.next(); &#125; &#125;&#125;打印结果：current: 0current: 1current: 2current: 3current: 4current: 5current: 6current: 7current: 8current: 9 有结果可以得知，内部类可以直接访问其外部类的方法和字段，内部类自动拥有对其外部类所有成员的访问权。这是如何做到的呢？当某个外部类的对象创建一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外部类对象的引用。然后，在你访问此外部类的成员时，就是用那个引用来选择外部类的成员。幸运的是，编译器会帮你处理所有的细节。但你现在可以看到的是：内部类的对象只能在与其外部类的对象相关联的情况下才能被创建（在内部类是非static类时）。构建内部类对象时，需要一个指向其外部类的引用，如果编译器访问不到这个引用就会报错。 使用.this与.new如果你需要生产对象外部类对象的引用，可以使外部类的名字后面紧跟.this。这样产生的引用自动地具有正确的类型，这一点在编译期就被知晓并受到检查，因此没有任何运行时开销。下面例子展示如何使用.this: 12345678910111213141516171819202122232425262728public class DoThis &#123; public class InnerClass &#123; public DoThis outer() &#123; return DoThis.this; &#125; &#125; public void f() &#123; System.out.println(\"DoThis.f()\"); &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub DoThis dt = new DoThis(); InnerClass innerClass = dt.new InnerClass(); innerClass.outer().f(); &#125;&#125;打印结果:DoThis.f() 有时候你肯想要告知某些其他对象，去创建其某个内部类的对象。要实现此目的，你必须在new表达式中提供对其他外部类对象的引用，这时需要使用.new语法，就像下面这样： 1234567891011121314151617public class DotNew &#123; public class Inner &#123; &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub DotNew dn = new DotNew(); Inner inner = dn.new Inner(); &#125;&#125; 要想直接创建内部类的对象，不能去引用外部类的名字DotNew，而是必须使用外部类的对象来创建该内部类对象。这也解决了内部类名字作用域的问题，因此你不必声明也不能声明dn.new DotNew.Inner()。 在拥有外部类对象之前是不可能创建内部类对象的，这是因为内部类对象会暗地里连接到创建它的外部类引用对象上。但是如果你创建的是静态内部类，那么它就不需要对外部类对象的引用。 内部类与向上转型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public interface Destination &#123; String readlabel();&#125;public interface Contents &#123; int value();&#125;class Parcel4 &#123; private class PContents implements Contents &#123; private int i = 11; @Override public int value() &#123; // TODO Auto-generated method stub return 11; &#125; &#125; protected class PDestination implements Destination &#123; private String label; private PDestination(String dest) &#123; label = dest; &#125; @Override public String readlabel() &#123; // TODO Auto-generated method stub return label; &#125; &#125; public Destination destination() &#123; return new PDestination(\"Beijing\"); &#125; public Contents contents() &#123; return new PContents(); &#125;&#125;public class TestParcel &#123; public static void main(String[] args) &#123; Parcel4 parcel4 = new Parcel4(); Contents contents = parcel4.contents(); System.out.println(contents.value()); Destination destination = parcel4.destination(); System.out.println(destination.readlabel()); //不能向下转型// PContents contents1 = parcel4.contents();// PDestination destination1 = parcel4.destination(); //不能访问Parcel4的私有成员// Contents contents2 = parcel4.new PContents(); &#125;&#125;打印结果：11Beijing 在Parcel4类中，PDestination相当于Parcel4类的protected成员，所以只有Parcel4及其子类、还有与Parcel4在同一个包中的类能访问PDestination;PContents相当于Parcel4的私有成员，只有Parcel4类能够访问它。 在方法和作用域内的内部类下面的例子展示在方法的作用域内（而不是在其他类的作用域内）创建一个完整的类，这称为局部内部类。 123456789101112131415161718192021222324252627282930public class Parcel5 &#123; public Destination destination(String dest) &#123; class PDestination implements Destination&#123; private String label; private PDestination(String dest) &#123; label = dest; &#125; @Override public String readlabel() &#123; // TODO Auto-generated method stub return label; &#125; &#125; return new PDestination(dest); &#125; public static void main(String[] args) &#123; Parcel5 p = new Parcel5(); Destination destination = p.destination(\"Beijing\"); System.out.println(destination.readlabel()); &#125;&#125; 注意：在destination()中定义了内部类PDestination，并不意味着一旦dest()方法执行完毕，PDestination就不可用了。你可以在同一个子目录下的任意类对某个内部类使用类标识符PDestination，这并不会有命名冲突。 下面的例子展示如何在任意的作用域内嵌入一个内部类： 1234567891011121314151617181920212223242526272829303132333435363738394041public class Parcel6 &#123; public void destination(boolean isCreate) &#123; if (isCreate) &#123; class PDestination implements Destination &#123; private String label; private PDestination(String dest) &#123; label = dest; &#125; @Override public String readlabel() &#123; // TODO Auto-generated method stub return label; &#125; &#125; PDestination destination = new PDestination(\"Beijing\"); System.out.println(destination.readlabel()); &#125; //error，超出作用域范围// PDestination destination = new PDestination(\"Beijing\");// System.out.println(destination.readlabel()); &#125; public static void main(String[] args) &#123; Parcel6 p = new Parcel6(); p.destination(true); &#125;&#125;打印结果：Beijing 匿名内部类先看一个匿名内部类示例： 12345678910111213141516171819public class Parcel7 &#123; public Contents contents() &#123; //匿名内部类 return new Contents() &#123; @Override public int value() &#123; // TODO Auto-generated method stub return 11; &#125; &#125;; &#125; public static void main(String[] args) &#123; Parcel7 p = new Parcel7(); System.out.println(p.contents().value()); &#125;&#125; 这种语句的意思是：创建一个继承自Contents的匿名类的对象。 上述匿名内部类的语法是下述形式的简化形式： 12345678910111213141516171819202122public class Parcel7 &#123; class MyContents implements Contents &#123; @Override public int value() &#123; // TODO Auto-generated method stub return 11; &#125; &#125; public Contents contents() &#123; return new MyContents(); &#125; public static void main(String[] args) &#123; Parcel7 p = new Parcel7(); System.out.println(p.contents().value()); &#125;&#125; 上面的匿名内部类中，使用了默认的构造函数来生成Contents。下面的代码展示了带参数的构造器的匿名内部类： 123456789101112131415161718192021222324252627282930313233class Wrapper &#123; private int i = 0; public Wrapper(int x) &#123; this.i = x; &#125; public int value() &#123; return i; &#125;&#125;public class Parcel8 &#123; public Wrapper wrapper(int x) &#123; return new Wrapper(x) &#123; @Override public int value() &#123; // TODO Auto-generated method stub return super.value() * 22; &#125; &#125;; &#125; public static void main(String[] args) &#123; Parcel8 p = new Parcel8(); System.out.println(p.wrapper(3).value()); &#125;&#125; 实例初始化匿名内部类成员变量： 1234567891011121314151617181920212223242526272829303132333435363738394041package com.michael.java.innerclass;public class Parcel9 &#123; public Destination destination(final String dest,final float price)&#123; return new Destination() &#123; private int cost; //实例初始化成员变量 &#123; cost = Math.round(price); System.out.println(\"Price: \" + cost); &#125; private String label = dest; @Override public String readlabel() &#123; // TODO Auto-generated method stub return label; &#125; &#125;; &#125; public static void main(String[] args) &#123; Parcel9 p = new Parcel9(); Destination destination = p.destination(\"Beijing\", 25.6f); System.out.println(destination.readlabel()); &#125;&#125;打印结果：Price: 26Beijing 对于匿名类而言，实例初始化的实际效果就是构造器，当然它受到了限制-你不能重载实例初始化方法。 嵌套类(静态内部类)如果不需要内部类对象与其外部类对象之间有联系，那么将内部类声明为static，这就是静态内部类(嵌套类)。静态内部类与普通内部类的区别在于： 要创建静态内部的对象并不需要其外部类的对象 不能从静态内部类的对象中访问非静态的外部类对象 普通内部类的字段和方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含静态内部类，但是静态内部类可以包含这些特性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.michael.java.innerclass;import com.michael.java.innerclass.Parcel11.ParcelDestination.AnotherLevel;public class Parcel11 &#123; private static class ParcelContents implements Contents &#123; private int i = 11; @Override public int value() &#123; // TODO Auto-generated method stub return i; &#125; &#125; protected static class ParcelDestination implements Destination &#123; private String label; private ParcelDestination(String dest) &#123; label = dest; &#125; @Override public String readlabel() &#123; // TODO Auto-generated method stub return label; &#125; //静态方法 public static void f() &#123; System.out.println(\"f()\"); &#125; //静态变量 static int x = 10; //静态内部类 static class AnotherLevel &#123; public static void f() &#123; System.out.println(\"AnotherLevel f()\"); &#125; static int x = 10; &#125; &#125; public static Destination destination(String dest) &#123; return new ParcelDestination(\"Beijing\"); &#125; public static Contents contents() &#123; return new ParcelContents(); &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub Contents contents = contents(); contents.value(); Destination destination = destination(\"Beijing\"); destination.readlabel(); System.out.println(ParcelDestination.x); ParcelDestination.f(); AnotherLevel.f(); System.out.println(AnotherLevel.x); &#125;&#125; 在main方法中，不需要任何Parcel11对象，而是使用选取static成员的普通语法来调用方法。 接口的内部类正常情况下，不能在接口内放置任何代码，但静态内部类可以作为接口的一部分，你放到接口中的任何类都自动地是public和static、的。因为类是static的，只是将嵌套类置于接口的命名空间内，这并不违反接口的规则。你甚至可以在内部类中实现外部接口，如下所示： 12345678910111213141516171819202122232425public interface ClassInInterface &#123; void howdy(); class Test implements ClassInInterface &#123; @Override public void howdy() &#123; // TODO Auto-generated method stub System.out.println(\"Howdy\"); &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Test test = new Test(); test.howdy(); &#125;&#125; 为什么需要内部类内部类最吸引人的原因是：每个内部类都能独立地继承自一个（接口的）实现，所有无论外部类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 下面让我们考虑这样一种情况：即必须在一个类中以某种方式实现两个接口。由于接口的灵活性，你有两种选择：使用单一类，或者使用内部类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344interface A &#123; &#125;interface B &#123; &#125;class X implements A,B &#123; &#125;class Y implements A &#123; //内部类实现接口 B makeB() &#123; return new B() &#123; &#125;; &#125;&#125;public class MultiInterface &#123; static void takesA(A a)&#123;&#125; static void takesB(B b)&#123;&#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub X x = new X(); Y y = new Y(); takesA(x); takesA(y); takesB(x); takesB(y.makeB()); &#125;&#125; 如果使用的是抽象的类或具体的类，而不是接口，那就只能使用内部类才能实现多重继承。 123456789101112131415161718192021222324252627class D &#123;&#125;abstract class E &#123;&#125;class Z extends D &#123; E makeE() &#123; return new E() &#123; &#125;; &#125;&#125;public class MultiImplementation &#123; static void takesD(D d)&#123;&#125; static void takesE(E e)&#123;&#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub Z z = new Z(); takesD(z); takesE(z.makeE()); &#125;&#125; 使用内部类可以获得一些特性： 内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外部类对象的信息相互独立 在单个外部类中，可以让对个内部类以不同的方式实现同一个接口，或继承同一个类 创建内部类对象的时刻并不依赖于外部类对象的创建 内部类就是一个独立的实体 内部类的继承1234567891011121314151617181920212223242526272829303132package com.michael.java.innerclass;class WithInner &#123; class Inner&#123; public void print() &#123; System.out.println(\"Inner\"); &#125; &#125;&#125;public class InheritInner extends WithInner.Inner &#123; // !public InheritInner() 不会被编译 InheritInner(WithInner wi) &#123; wi.super(); &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub WithInner wi = new WithInner(); InheritInner inner = new InheritInner(wi); inner.print(); &#125;&#125; 可以看到，InheritInner只继承自内部类，而不是外部类，但是当要生成一个构造器时，默认的构造器并不能通过，并且不能只是传递一个指向外部类对象的引用，还必须在构造器中使用如下语句OuterClassNameReference.super() 内部类可以被覆盖吗123456789101112131415161718192021222324252627282930313233343536373839class Egg &#123; private Yolk yolk; protected class Yolk &#123; public Yolk() &#123; System.out.println(\"Egg.Yolk()\"); &#125; &#125; public Egg() &#123; System.out.println(\"New Egg\"); yolk = new Yolk(); &#125;&#125;public class BigEgg extends Egg &#123; public class Yolk &#123; public Yolk() &#123; System.out.println(\"BigEgg.Yolk()\"); &#125; &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub new BigEgg(); &#125;&#125;打印结果是：New EggEgg.Yolk() 结果说明，当BigEgg继承了Egg之后，BigEgg里面的内部类Yolk并没有覆盖Egg里面的内部类Yolk，这两个内部类是完全独立的两个实体，各自在自己的命名空间内。 内部类标识符由于每个类都会产生一个。class文件，其中包含了如何创建该类型的对象的全部信息（此信息产生一个“meta-class”，叫做Class对象），内部类也必须生成一个.class文件以包含它们的Class对象信息。这些类文件的命名有严格的规则，加上“$”，再加上内部类的名字。 1234Counter.classLocalInnerClass$1.class ## 匿名内部类 用数字1表示LocalInnerClass$1LocalCounter.class ##局部内部类 LocalCounter在LocalInnerClass里面LocalInnerClass.class","tags":[{"name":"Java","slug":"Java","permalink":"http://liuguoquan727.github.io/tags/Java/"}]},{"title":"Java字符串","date":"2016-04-17T07:17:06.000Z","path":"2016/04/17/Java字符串/","text":"不可变StringString对象时不可变的。查看JDK文档你就会发现，String类中每一个看起来会修改String值的方法，实际上都是创建了一个全新的String对象，这个新的String对象来包含修改后的字符串内容，而最初的String对象则没有变化。 看看下面的代码： 123456789101112131415161718public class Immutable &#123; /** * @param args */ public static void main(String[] args) &#123; String str = \"hello\"; System.out.println(str); //hello String str1 = upCase(str); System.out.println(str1); //HELLO System.out.println(str); //hello &#125; public static String upCase(String s) &#123; return s.toUpperCase(); &#125;&#125; 结果打印如下： 123helloHELLOhello 当把str传给upCase()方法时，实际上传递的是引用的一个拷贝。其实，每当把String对象作为方法的参数时，都会复制一份对象的引用，而该引用所指向的对象其实一直指向同一个内存地址，从未改变。 回到upCase方法的定义，传入其中的引用有了名字s，只有upCase方法运行的时候，局部引用s才回存在，一旦upCase运行结束，s就消失了。当然upCase的返回值，其实只是最终结果的引用。而这个引用已经指向了一个新的对象，而原本的str对象还在原始的位置。 重载”+”与StringBuilderString的不可变性会带来一定的效率问题。为String对象重载的”+”操作符就是一个例子。重载的意思是，一个操作符在应用特定的类时，被赋予特殊的意义（用于String的”+”与”+=”是Java中仅有的两个重载过的操作符，而Java并不允许程序员重载任何操作符）。 操作符”+”可以用来连接String： 1234567891011121314151617public class Concatention &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub String str = \"hello\"; String result = str + \" welcom\" + \" to beijing\"; System.out.println(result); &#125;&#125;结果是:hello welcom to beijing 这段代码可能是这样工作的：String有一个append（）方法，它会生成一个新的String对象，以包含”欢迎来”与str连接后的字符串。然后，该对象再与”到北京”相连，生成一个新的String对象result。 这种工作方式当然是可行的，但是为了生成最终的String，此方式会产生一大堆需要垃圾回收的中间对象。当达到一定的数量之后，性能表现会相当糟糕。 下面来看下以上代码到底是如何工作的，可以用JDK自带的工具javap命令来反编译以上代码。命令如下： 1javap -c Concatention //-c 表示生产JVM字节码 编译后的字节码为： 12345678910111213141516171819202122232425262728Compiled from \"Concatention.java\"class Concatention &#123; Concatention(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return public static void main(java.lang.String[]); Code: 0: ldc #2 // String hello 2: astore_1 3: new #3 // class java/lang/StringBuilder 6: dup 7: invokespecial #4 // Method java/lang/StringBuilder.\"&lt;init&gt;\":()V 10: aload_1 11: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 14: ldc #6 // String welcom 16: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 19: ldc #7 // String to beijing 21: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 24: invokevirtual #8 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 27: astore_2 28: getstatic #9 // Field java/lang/System.out:Ljava/io/PrintStream; 31: aload_2 32: invokevirtual #10 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 35: return&#125; 需要注意的重点是：编译器自动引入了java.lang.StringBuilder类。虽然我们在源代码中并没有使用StringBuilder类，但是编译器却自作主张地使用了它，因为它更高效。 现在，你也行会觉得可以随意使用String对象，反正编译器会自动优化性能。可是在这之前，让我们更深入地看看编译器能为我们优化到什么程序。下面的程序采用两种方式生成一个String：方法一使用说个String对象，方法二使用StringBuilder 1234567891011121314151617181920212223public class WhitherStringBuilder &#123; public String implicit(String[] strs) &#123; String result = \"\"; for(int i = 0;i &lt; strs.length;i++) &#123; result += strs[i]; &#125; return result; &#125; public String explicit(String[] strs) &#123; StringBuilder builder = new StringBuilder(); for(int i = 0;i &lt; strs.length;i++) &#123; builder.append(strs[i]); &#125; return builder.toString(); &#125;&#125; 现在运行javap -c WitherStringBuilder可以看到两个方法对应的字节码，首先是implicit()方法： 12345678910111213141516171819202122232425public java.lang.String implicit(java.lang.String[]); Code: 0: ldc #2 // String 2: astore_2 3: iconst_0 4: istore_3 5: iload_3 6: aload_1 7: arraylength 8: if_icmpge 38 11: new #3 // class java/lang/StringBuilder 14: dup 15: invokespecial #4 // Method java/lang/StringBuilder.\"&lt;init&gt;\":()V 18: aload_2 19: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 22: aload_1 23: iload_3 24: aaload 25: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 28: invokevirtual #6 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 31: astore_2 32: iinc 3, 1 35: goto 5 38: aload_2 39: areturn 从第8行到第35行构成了一个循环体。要注意的重点是：StringBuilder是在循环之内构造的，这意味着每经过循环一次，就会创建一个新的StringBuilder对象。 下面是explicit()方法对应的字节码： 1234567891011121314151617181920212223public java.lang.String explicit(java.lang.String[]); Code: 0: new #3 // class java/lang/StringBuilder 3: dup 4: invokespecial #4 // Method java/lang/StringBuilder.\"&lt;init&gt;\":()V 7: astore_2 8: iconst_0 9: istore_3 10: iload_3 11: aload_1 12: arraylength 13: if_icmpge 30 16: aload_2 17: aload_1 18: iload_3 19: aaload 20: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 23: pop 24: iinc 3, 1 27: goto 10 30: aload_2 31: invokevirtual #6 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 34: areturn 可以看到，不仅循环部分的代码更简短、更简单，而且它只生成一个StringBuilder对象。显示地创建StringBuilder还允许你预先为其指定大小。如果你已经知道最终的字符串大概有多长，那预先指定StringBuilder的大小可以避免多次重新分配缓冲。 因此，当你为一个类编写toString()方法时，如果字符串操作比较简单，那就可以信赖编译器,它会为你合理地构造最终的字符串结果。但是，如果你要在toString方法中使用循环时，最好还是自己创建一个StringBuilder对象，用它来构造最终的结果。 无意识的递归Java中的每个类从根本上都是继承自Object，标准容器类自然也不例外。因此容器类都有toString方法，并复写了该方法，使得它生成的String结果能够表达容器自身，以及容器所包含的对象。例如ArrayList.toString()，它会遍历ArrayList中包含的所有对象，调用每个元素上的toString方法： 如果你希望toString()方法打印出对象的内存地址，也许你会考虑使用this关键字： 1234567891011121314151617181920212223242526public class InfiniteRecursion &#123; public String toString() &#123; return \"Recursion address: \" + this + \"\\n\"; &#125; public static void main(String[] args) &#123; List&lt;InfiniteRecursion&gt; list = new ArrayList&lt;InfiniteRecursion&gt;(); for (int i = 0; i &lt; 10; i++) list.add(new InfiniteRecursion()); System.out.println(list); &#125;&#125;打印结果Exception in thread \"main\" java.lang.StackOverflowError at java.lang.String.getChars(String.java:826) at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:416) at java.lang.StringBuilder.append(StringBuilder.java:132) at com.micheal.java.staticdemo.InfiniteRecursion.toString(InfiniteRecursion.java:12) at com.micheal.java.staticdemo.InfiniteRecursion.toString(InfiniteRecursion.java:12) at com.micheal.java.staticdemo.InfiniteRecursion.toString(InfiniteRecursion.java:12) 这里发生了自动类型转换，由InfiniteRecursion类型转换成String类型。因为编译器看到一个String对象后面跟着”+”，而在后面的对象不是String而是this，于是编译器试着将this转换成一个String。它怎么转换的呢，正是通过调用this上的toString方法，于是就发生了递归调用，造成栈溢出。 如果你真的想要打印出对象的内存地址，应该调用Objec.toString()方法，所有，你应该调用super.toString()方法. String上的操作以下是String对象具备的一些基本方法，重载的方法归纳在同一行中： 上上图表中可以看出，当需要改变字符串的内容时，String类的方法都会返回一个新的String对象。同时，如果内容没有发生改变，String的方法只是返回指向原对象的引用而已，这可以节约存储空间以及避免额外的开销。 格式化输出System.out.printf()1System.out.printf(\"Row: %d %s\\n\",12,\"just\"); System.out.format()1System.out.format(\"Row: %d %s\\n\",12,\"just\");","tags":[{"name":"Java","slug":"Java","permalink":"http://liuguoquan727.github.io/tags/Java/"}]},{"title":"Java中的构造函数调用顺序","date":"2016-04-05T13:21:56.000Z","path":"2016/04/05/Java中的构造函数调用顺序/","text":"面试题中经常这样的题目，分析子类父类构造函数的调用顺序，下面开始分情况讨论父类子类构造函数的调用顺序： 先创建两个类A和B，其中B继承A 12345678910111213141516171819202122232425262728293031323334public class A &#123; public A() &#123; System.out.println(\"A的无参构造函数\"); &#125; public A(String msg) &#123; System.out.println(\"A的有参构造函数: \" + msg); &#125; public void print() &#123; System.out.println(\"A的print方法\"); &#125;&#125;public class B extends A&#123; public B() &#123; System.out.println(\"B的无参构造函数\"); &#125; public B(String msg)&#123; // super(msg); //此句代码表示调用父类A的有参构造函数，不加此句代码则表示调用父类A的默认无参构造函数 System.out.println(\"B的有参构造函数: \" + msg); &#125; public void print() &#123; System.out.println(\"B的print方法\"); &#125; public void add()&#123; System.out.println(\"A的add方法\"); &#125;&#125; 调用上述类： 1234567public static void main(String[] args) &#123; // TODO Auto-generated method stub B b = new B(); B b1 = new B(\"hello\"); b.print(); b.add();&#125; 运行结果： 123456A的无参构造函数B的无参构造函数A的无参构造函数: helloB的有参构造函数: helloB的print方法A的add方法 从运行结果可得出以下结论: 实例化无参子类B时，先调用父类A的无参构造函数，再调用B的无参构造函数； 实例化有参子类B时，先调用父类A的默认无参构造函数，再调用B的有参构造函数；若要调用A的有参构造函数，则在类B的有参构造函数的第一行加上super(msg)这句代码。 子类B调用方法时有两种情况：一是如果子类B中的方法和父类A中的print方法一致时，则调用子类B中print的方法，但是可通过super.print()调用父类中的print方法;二是如果子类B中无add方法而父类A中有add方法时，则子类B的示例直接调用父类A中的add方法； 父类A不能调用子类B中的方法和变量","tags":[{"name":"Java","slug":"Java","permalink":"http://liuguoquan727.github.io/tags/Java/"},{"name":"面试","slug":"面试","permalink":"http://liuguoquan727.github.io/tags/面试/"}]},{"title":"Java中static关键字详解","date":"2016-04-05T13:20:58.000Z","path":"2016/04/05/Java中static关键字详解/","text":"static是Java的一个关键字，我们在Java开发中经常使用static，static主要用于下面五种情况： 静态变量我们可以将类级别的变量声明为static，静态变量是属于类的，而不是属于类创建的对象或实例的。因为静态变量被类的所有实例共用，所以是线程不安全的。通常静态变量还和关键字final一起用，作为所有对象共用的资源或常量。如果静态变量不是私有的，那么可以通过ClassName.variableName来访问它。 123private static int count;public static String name;public static final String DB_NAME = \"contacts\"; 静态方法静态方法也属于类，不属于实例。静态类只能访问类的静态变量或调用类的静态方法。通常静态方法作为工具方法，被其他类使用，而不需要创建类的实例。静态方法如果没有使用静态变量，则是线程安全的。因为静态方法内部声明的变量，每个线程调用时都会重新创建一份，而不会共用同一个存储单元。 12345public class MathUtils &#123; public static int add(int x,int y) &#123; return x + y; &#125;&#125; 静态块静态块是类加载器加载对象时要执行的一组语句，它用于初始化静态变量，通常用于类加载的时候创建静态资源。我们在静态块中不能访问非静态变量。我们可以在一个类中有多个静态块，尽管这么做没什么意义，静态块只会在类加载到内存中的时候执行一次。 1234567891011121314151617181920212223242526272829303132public class FinalDemo &#123; public static String str; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub new FinalDemo(); &#125; public static int add(int x,int y) &#123; return x + y; &#125; static &#123; System.out.println(\"静态块3\"); //仅能访问静态变量和静态方法 str = \"Just\"; add(3,4); &#125; static &#123; System.out.println(\"静态块1\"); &#125; public FinalDemo() &#123; System.out.println(\"构造函数\"); &#125;&#125; 运行结果：123静态块3静态块1构造函数 由运行结果可知： 静态块最先加载，其次是构造函数； 有多个静态块时，按静态块顺序加载； 静态块内部代码按顺序运行; 静态类一般我们对嵌套类使用static关键字，static不能用于最外层的类。静态的嵌套类和其他外层的类别无区别，嵌套只是方便打包。 下面我们来看一个使用static关键字的例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class FinalDemo &#123; /** * 静态变量 */ public static String str; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub System.out.println(\"str: \" + str); System.out.println(\"add(3,4):\"+add(3, 4)); &#125; /** * 静态方法 * @param x * @param y * @return */ public static int add(int x,int y) &#123; return x + y; &#125; /** * 静态块 */ static &#123; System.out.println(\"静态块3\"); //仅能访问静态变量和静态方法 str = \"Test\"; &#125; /** * 静态类 * TODO */ public static class MyStaticClass &#123; public String getTag() &#123; //只能访问外部类的静态变量或方法 return str; &#125; &#125;&#125; 运行结果是：1234静态块3str: Testadd(3,4):7staticclass tag: Test 静态导包静态导包就是java包的静态导入，用import static静态导入包是JDK1.5引入的特性。一般我们导入一个类都用import com.java…className；而静态导入是这样：import static com.java..className.*。这里多了static关键字，还有就是类名后面多了.*，意思是导入这个类里所有的静态方法。当然也可以只导入某个静态方法，只要把.*替换成静态方法名就行了。然后在这个类中，就可以直接调用方法名来调用静态方法，而不必用ClassName.方法名的方式来调用。 优点：这种方法可以简化一些操作，例如打印System.out.println()，就可以将其导入一个静态方法，在使用时直接println()就可以了。下面通过代码来看看两种方式的导包: 普通导包: 12345678910public class NormalImport &#123; public static void main (String[] args) &#123; System.out.println(Integer.MAX_VALUE); System.out.println(Integer.toHexString(42)); &#125; &#125; 静态导包: 12345678910public class StaticImport &#123; public static void main (String[] args) &#123; out.println(MAX_VALUE); out.println(toHexString(43)); &#125;&#125; 两个类的运行结果都是一样的。 静态导包的几条原则： 必须是import static而不是static import 提防含糊不清的static成员。例如，如果对Integer类和Long类执行了静态导入，引用MAX_VALUE时将导致一个编译器错误，因为Integer和Long都有一个MAX_VALUE常量，并且Java不会知道你在引用哪个MAX_VALUE。","tags":[{"name":"Java","slug":"Java","permalink":"http://liuguoquan727.github.io/tags/Java/"}]},{"title":"Java中final关键字详解","date":"2016-04-05T13:19:55.000Z","path":"2016/04/05/Java中final关键字详解/","text":"Java开发中，我们常常见到final关键字，经常在使用匿名内部类的时候可能会经常用到final关键字。Java中的String类就是一个final类，下面我们就来详细了解一下final这个关键字的用法。 final关键字的基本用法Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）。下面就从这三个方面来学习下final关键字的基本用法。 修饰类当final关键字修饰一个类时，表明这个类不能被继承。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。 在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者是出于安全的考虑，尽量不要讲类设计为final类。 修饰方法使用final关键字修饰方法的原因有两个：第一个原因是把方法锁定，以防止任何子类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用，但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升，不需要使用final方法进行这些优化。因此，如果想要禁止该方法在子类中被覆盖，那么久可以将该方法用final关键字修饰。 注：类的private方法会隐式地被指定为final方法。 修饰变量final修饰变量的基本语法： 如果final修饰的是基本数据类型的变量，则其数值一旦在初始化之后便不能更改； 如果final修饰的是引用类型的变量，则其初始化之后便不能再指向另一个对象； 示例如下： 上面代码中，对变量i和obj的重新赋值都报错了。 深入理解final关键字在了解final关键字的基本用法后，我们来看看final关键字容易混淆的地方。 类的final变量和普通变量有什么区别？当用final作用于类的成员变量时，成员变量（注意是类的成员变量，局部变量只需要保证在使用之前被初始化赋值即可）必须在定义时或者构造器中进行初始化赋值，而且final变量一旦被初始化赋值之后，就不能再被赋值了。 final变量和普通变量到底有什么区别呢？先看下面的例子： 12345678910111213public static void main(String[] args) &#123; // TODO Auto-generated method stub String a = \"helloworld\"; final String b = \"hello\"; String c = \"hello\"; String d = b + \"world\"; String e = c + \"world\"; System.out.println((a == d)); System.out.println((a == e));&#125; 运行结果:12truefalse 为什么第一个比较结果是true，而第二个比较结果为false？这就是final变量和普变量的区别了，当final变量是基本数据类型以及String类型时，如果在编译期间能知道它的确切值，则编译器会把它当做编译器常量使用，也就是说用到该final变量的地方相当于直接访问这个常量，不需要在运行时确定。因此在上面的代码中，由于b被final修饰，因此会被当做编译器常量，所以在使用到b的地方会直接将变量b替换为它的值，而对于变量c的访问则在运行时通过链接来运行。要注意，只有在编译期间确切知道final变量值的情况下，编译器才会进行这样的优化，下面的这段代码就不会进行这样的优化： 1234567891011121314151617public static void main(String[] args) &#123; // TODO Auto-generated method stub String a = \"helloworld\"; final String b = getStr(); String c = \"hello\"; String d = b + \"world\"; String e = c + \"world\"; System.out.println((a == d)); System.out.println((a == e));&#125;public static String getStr() &#123; return \"hell0\";&#125; 结果是：12falsefalse 被final修饰的引用变量指向的对象内容可变吗？final修饰的引用变量一旦初始化赋值之后就不能再指向其他的对象，那么该引用变量指向的对象的内容可变吗？先看下面的例子： 1234567891011121314151617181920212223242526public class FinalDemo &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub final Person person = new Person(); person.name = \"liu\"; person.age = 27; System.out.println(person.toString()); &#125;&#125;class Person &#123; public String name = \"zhang\"; public int age = 0; @Override public String toString() &#123; return \"Person [name=\" + name + \", age=\" + age + \"]\"; &#125; &#125; 结果是： 1Person [name=liu, age=27] 由运行结果可知，引用变量被final修饰之后，虽然不能再指向其他的对象，但是它指向的对象的内容是可变的。 final和static我们经常容易把final和static关键字混淆，static作用于成员变量用来表示只保存一份副本，而final的作用是用来保证变量不可变。 12345678910111213141516171819202122232425public class FinalDemo &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub MyClass class1 = new MyClass(); System.out.println(\"i: \" + class1.i); System.out.println(\"j: \" + class1.j); MyClass class2 = new MyClass(); System.out.println(\"i: \" + class2.i); System.out.println(\"j: \" + class2.j); &#125;&#125;class MyClass &#123; public final double i = Math.random(); public static double j = Math.random(); &#125; 运行结果: 12345i: 0.6230804434703052j: 0.8707443438720905i: 0.6451393896255735j: 0.8707443438720905 从结果可知，每次打印的i值不同，而j值都是一样的。从这里口可以知道final和static的区别了。 匿名内部类中使用的外部局部变量为什么只能是final变量？保证数据的一致性。Java编译器限定必须将外部局部变量限制为final变量，不允许对外部局部变量进行更改（对应引用类型的变量，是不允许指向新的对象），这样就保证了数据的一致性。 关于final参数的问题关于网上流传的“当你在方法中不需要改变作为参数的对象变量时，明确使用final进行声明，会防止你无意的修改而影响到调用方法外的变量”，这句话其实是不恰当的。因为无论参数是基本数据类型的变量还是引用类型的变量，使用final声明都不会达到上面所说的效果。 下面看例子： 上面的代码像是让人觉得final修饰之后，就不能在方法中更改变量i的值了。殊不知，方法changValue和main方法中的变量i根本就不是一个变量，因为对于基本类型的变量，Java参数传递采用的是值传递，相当于直接将变量进行了拷贝，所以即使没有final修饰的情况下，在方法内部改变了变量i的值也不会影响方法外的i。 再看下面的代码： 123456789101112131415161718192021222324252627282930public class FinalDemo &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub MyClass myClass = new MyClass(); StringBuffer buffer = new StringBuffer(\"hello\"); myClass.changValue(buffer); System.out.println(buffer.toString()); myClass.changValue2(buffer); System.out.println(buffer.toString()); &#125;&#125;class MyClass &#123; public void changValue(final StringBuffer buffer) &#123; buffer.append(\"world\"); &#125; public void changValue2(StringBuffer buffer) &#123; StringBuffer buffer2 = buffer; buffer2.append(\"你好\"); &#125;&#125; 运行结果是： 12helloworldhelloworld你好 由结果可知，很显然，用final进行修饰参数和不修饰参数都没有阻止在changeValue中改变buffer指向的对象的内容。原因在对于引用数据类型，Java采用的是按引用传递，传递的是引用的地址，也就是变量所对象的内存空间的地址。在这里形参和实参指向的是同一个对象，因此让形参重新指向另一个对象对实参并没有任何影响。","tags":[{"name":"Java","slug":"Java","permalink":"http://liuguoquan727.github.io/tags/Java/"}]},{"title":"Android动画之Interpolator","date":"2016-03-31T13:47:19.000Z","path":"2016/03/31/Android动画之Interpolator/","text":"简介Interpolator可以翻译成插值器。Android中interpolator的最底层接口如下: 12345678910111213141516171819202122232425262728package android.animation; /** * 时间插值器定义了一个动画的变化率。 * 这让动画让非线性的移动轨迹，例如加速和减速。 * &lt;hr/&gt; * A time interpolator defines the rate of change of an animation. This allows animations * to have non-linear motion, such as acceleration and deceleration. */public interface TimeInterpolator &#123; /** * 将动画已经消耗的时间的分数映射到一个表示插值的分数。 * 然后将插值与动画的变化值相乘来推导出当前已经过去的动画时间的动画变化量。 * &lt;hr/&gt; * Maps a value representing the elapsed fraction of an animation to a value that represents * the interpolated fraction. This interpolated value is then multiplied by the change in * value of an animation to derive the animated value at the current elapsed animation time. * * @param input 一个0到1.0表示动画当前点的值，0表示开头。1表示结尾&lt;br/&gt; A value between 0 and 1.0 indicating our current point * in the animation where 0 represents the start and 1.0 represents * the end * @return 插值。它的值可以大于1来超出目标值，也小于0来空破底线。 * interpolators which overshoot their targets, or less than 0 for * interpolators that undershoot their targets. */ float getInterpolation(float input);&#125; TimeInterpolator是在Android API11加入，之前的类叫Interpolator。现在Interpolator继承了TimeInterpolator 12345678910111213141516171819package android.view.animation; import android.animation.TimeInterpolator; /** * * 一个定义动画变化率的插值器。 * 它允许对基本的（如透明，缩放，平移，旋转）进行加速，减速，重复等动画效果 * &lt;hr/&gt; * An interpolator defines the rate of change of an animation. This allows * the basic animation effects (alpha, scale, translate, rotate) to be * accelerated, decelerated, repeated, etc. */public interface Interpolator extends TimeInterpolator &#123; // A new interface, TimeInterpolator, was introduced for the new android.animation // package. This older Interpolator interface extends TimeInterpolator so that users of // the new Animator-based animations can use either the old Interpolator implementations or // new classes that implement TimeInterpolator directly.&#125; 插值器分析AccelerateInterpolator 加速插值器效果：在动画开始的地方速率改变比较慢，然后开始加速 源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package android.view.animation; import android.content.Context;import android.content.res.TypedArray;import android.util.AttributeSet; /** * * 一个开始很慢然后不断加速的插值器。 * &lt;hr/&gt; * An interpolator where the rate of change starts out slowly and * and then accelerates. * */public class AccelerateInterpolator implements Interpolator &#123; private final float mFactor; private final double mDoubleFactor; public AccelerateInterpolator() &#123; mFactor = 1.0f; mDoubleFactor = 2.0; &#125; /** * Constructor * * @param factor * 动画的快慢度。将factor设置为1.0f会产生一条y=x^2的抛物线。增加factor到1.0f之后为加大这种渐入效果（也就是说它开头更加慢，结尾更加快） * &lt;br/&gt;Degree to which the animation should be eased. Seting * factor to 1.0f produces a y=x^2 parabola（抛物线）. Increasing factor above * 1.0f exaggerates the ease-in effect (i.e., it starts even * slower and ends evens faster) */ public AccelerateInterpolator(float factor) &#123; mFactor = factor; mDoubleFactor = 2 * mFactor; &#125; public AccelerateInterpolator(Context context, AttributeSet attrs) &#123; TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.AccelerateInterpolator); mFactor = a.getFloat(com.android.internal.R.styleable.AccelerateInterpolator_factor, 1.0f); mDoubleFactor = 2 * mFactor; a.recycle(); &#125; @Override public float getInterpolation(float input) &#123; if (mFactor == 1.0f) &#123; return input * input; &#125; else &#123; return (float)Math.pow(input, mDoubleFactor); &#125; &#125;&#125; 根据getInterpolation方法可知加速度的大小由参数mFactor决定。当mFactor值为1.0f时，动画加速轨迹相对于一条y=x^2的抛物线。如下图 当mFactor不为1时，轨迹曲线是y=x^(2 * mFactor)(0 &lt; x &lt;= 1)的曲线。示例：当mFractor为4时，插值器的加速轨迹曲线如下图: 如果你在使用AccelerateInterpolator，想要那种一开始很慢，然后突然就很快的加速的动画效果的话，就将mFractor的值设置大点。 DecelerateInterpolator减速插值器效果：在动画开始的地方速率改变比较慢，然后开始加速 源代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package android.view.animation; import android.content.Context;import android.content.res.TypedArray;import android.util.AttributeSet; /** * 一个开始比较快然后减速的插值器 * &lt;hr/&gt; * An interpolator where the rate of change starts out quickly and * and then decelerates. * */public class DecelerateInterpolator implements Interpolator &#123; public DecelerateInterpolator() &#123; &#125; /** * Constructor * * @param factor * 动画的快慢度。将factor值设置为1.0f时将产生一条从上向下的y=x^2抛物线。 * 增加factor到1.0f以上将使渐入的效果增强（也就是说，开头更快，结尾更慢） * &lt;br/&gt; * Degree to which the animation should be eased. Setting factor to 1.0f produces * an upside-down y=x^2 parabola. Increasing factor above 1.0f makes exaggerates the * ease-out effect (i.e., it starts even faster and ends evens slower) */ public DecelerateInterpolator(float factor) &#123; mFactor = factor; &#125; public DecelerateInterpolator(Context context, AttributeSet attrs) &#123; TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.DecelerateInterpolator); mFactor = a.getFloat(com.android.internal.R.styleable.DecelerateInterpolator_factor, 1.0f); a.recycle(); &#125; @Override public float getInterpolation(float input) &#123; float result; if (mFactor == 1.0f) &#123; result = (1.0f - ((1.0f - input) * (1.0f - input))); &#125; else &#123; result = (float)(1.0f - Math.pow((1.0f - input), 2 * mFactor)); &#125; return result; &#125; private float mFactor = 1.0f;&#125; 根据getInterpolation方法可知加速度的大小由参数mFactor决定。当mFactor为1.0f时，它减速的轨迹函数为y=1-(1 - X)^2;如下图 当mFactor不为1.0f时，它减速的轨迹函数为:y=1.0 - (1.0 -x )^(2 * mFactor)。当mFactor增大到4时，曲线轨迹如下图所示： AccelerateDecelerateInterpolator 加速减速插值器效果：动画开始与结束的地方速率改变比较慢，在中间的时候加速 12345678910111213141516171819202122232425package android.view.animation; import android.content.Context;import android.util.AttributeSet; /** * 一个变化率开始慢从中间后开始变快。 * &lt;hr/&gt; * An interpolator where the rate of change starts and ends slowly but * accelerates through the middle. * */public class AccelerateDecelerateInterpolator implements Interpolator &#123; public AccelerateDecelerateInterpolator() &#123; &#125; @SuppressWarnings(&#123;\"UnusedDeclaration\"&#125;) public AccelerateDecelerateInterpolator(Context context, AttributeSet attrs) &#123; &#125; @Override public float getInterpolation(float input) &#123; return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f; &#125;&#125; 根据getInterpolation方法可以得出其变化曲线如下： LinearInterpolator 线性插值器效果:动画按常速率变化 源代码如下: 12345678910111213141516/** * An interpolator where the rate of change is constant * */public class LinearInterpolator implements Interpolator &#123; public LinearInterpolator() &#123; &#125; public LinearInterpolator(Context context, AttributeSet attrs) &#123; &#125; public float getInterpolation(float input) &#123; return input; &#125;&#125; BounceInterpolator 弹跳插值器效果:动画结束的时候弹起 源代码如下: 123456789101112131415161718192021222324252627282930313233343536package android.view.animation; import android.content.Context;import android.util.AttributeSet; /** * 这个插值器的插值在后面呈弹跳状态。 * An interpolator where the change bounces at the end. */public class BounceInterpolator implements Interpolator &#123; public BounceInterpolator() &#123; &#125; @SuppressWarnings(&#123;\"UnusedDeclaration\"&#125;) public BounceInterpolator(Context context, AttributeSet attrs) &#123; &#125; private static float bounce(float t) &#123; return t * t * 8.0f; &#125; @Override public float getInterpolation(float t) &#123; // _b(t) = t * t * 8 // bs(t) = _b(t) for t &lt; 0.3535 // bs(t) = _b(t - 0.54719) + 0.7 for t &lt; 0.7408 // bs(t) = _b(t - 0.8526) + 0.9 for t &lt; 0.9644 // bs(t) = _b(t - 1.0435) + 0.95 for t &lt;= 1.0 // b(t) = bs(t * 1.1226) t *= 1.1226f; if (t &lt; 0.3535f) return bounce(t); else if (t &lt; 0.7408f) return bounce(t - 0.54719f) + 0.7f; else if (t &lt; 0.9644f) return bounce(t - 0.8526f) + 0.9f; else return bounce(t - 1.0435f) + 0.95f; &#125;&#125; 根据getInterpolation方法得到以下插值曲线图： AnticipateInterpolator 回荡秋千插值器效果：开始的时候向后，然后向前甩 源代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package android.view.animation; import android.content.Context;import android.content.res.TypedArray;import android.util.AttributeSet; /** * 一个开始向后荡，然后向前荡的插值器。 * &lt;hr/&gt; * An interpolator where the change starts backward then flings forward. */public class AnticipateInterpolator implements Interpolator &#123; private final float mTension; public AnticipateInterpolator() &#123; mTension = 2.0f; &#125; /** * @param tension * 绷紧程度，当绷紧程序为0.0f时，也就没有了反向作用力。插值器将退化成一个y=x^3的加速插值器。 * &lt;br/&gt; * Amount of anticipation. When tension equals 0.0f, there is * no anticipation and the interpolator becomes a simple * acceleration interpolator. */ public AnticipateInterpolator(float tension) &#123; mTension = tension; &#125; public AnticipateInterpolator(Context context, AttributeSet attrs) &#123; TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.AnticipateInterpolator); mTension = a.getFloat(com.android.internal.R.styleable.AnticipateInterpolator_tension, 2.0f); a.recycle(); &#125; @Override public float getInterpolation(float t) &#123; // a(t) = t * t * ((tension + 1) * t - tension) return t * t * (((mTension + 1) * t) - mTension); &#125;&#125; 根据getInterpolation方法： 当tension为默认值2时，曲线图如下： 当tension为4时，曲线图如下： AnticipateOvershootInterpolator效果：开始的时候向后，然后向前甩一定值后 返回最后的值 源代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package android.view.animation; import android.content.Context;import android.content.res.TypedArray;import android.util.AttributeSet; /** * 一个插值器它开始向上推，然后向下荡，荡过最低线。然后再回到最低线。 * &lt;hr/&gt; * An interpolator where the change starts backward then flings forward and overshoots * the target value and finally goes back to the final value. */public class AnticipateOvershootInterpolator implements Interpolator &#123; private final float mTension; public AnticipateOvershootInterpolator() &#123; mTension = 2.0f * 1.5f; &#125; /** * @param tension * anticipation/overshoot的比值。当和tension值为0.0f时， * 也就没有anticipation/overshoot的比值了，插值器退化为一个加速/减速插值器。 * &lt;br/&gt; * Amount of anticipation/overshoot. When tension equals 0.0f, * there is no anticipation/overshoot and the interpolator becomes * a simple acceleration/deceleration interpolator. */ public AnticipateOvershootInterpolator(float tension) &#123; mTension = tension * 1.5f; &#125; /** * @param tension Amount of anticipation/overshoot. When tension equals 0.0f, * there is no anticipation/overshoot and the interpolator becomes * a simple acceleration/deceleration interpolator. * @param extraTension * 乘以tension的值。例如，在上面构造函数中extraTension的值为1.5f * &lt;br/&gt; * Amount by which to multiply the tension. For instance, * to get the same overshoot as an OvershootInterpolator with * a tension of 2.0f, you would use an extraTension of 1.5f. */ public AnticipateOvershootInterpolator(float tension, float extraTension) &#123; mTension = tension * extraTension; &#125; public AnticipateOvershootInterpolator(Context context, AttributeSet attrs) &#123; TypedArray a = context.obtainStyledAttributes(attrs, AnticipateOvershootInterpolator); mTension = a.getFloat(AnticipateOvershootInterpolator_tension, 2.0f) * a.getFloat(AnticipateOvershootInterpolator_extraTension, 1.5f); a.recycle(); &#125; private static float a(float t, float s) &#123; return t * t * (((s + 1) * t) - s); &#125; private static float o(float t, float s) &#123; return t * t * (((s + 1) * t) + s); &#125; @Override public float getInterpolation(float t) &#123; // a(t, s) = t * t * ((s + 1) * t - s) // o(t, s) = t * t * ((s + 1) * t + s) // f(t) = 0.5 * a(t * 2, tension * extraTension), when t &lt; 0.5 // f(t) = 0.5 * (o(t * 2 - 2, tension * extraTension) + 2), when t &lt;= 1.0 if (t &lt; 0.5f) return 0.5f * a(t * 2.0f, mTension); else return 0.5f * (o((t * 2.0f) - 2.0f, mTension) + 2.0f); &#125;&#125; 当tension为默认值时，曲线图为： CycleInterpolator 正弦周期变化插值器 效果：动画循环播放特定的次数，速率改变沿着正弦曲线 源代码为： 123456789101112131415161718192021222324252627282930313233343536373839package android.view.animation; import android.content.Context;import android.content.res.TypedArray;import android.util.AttributeSet; /** * * 以指定的周期重复动画。变化率曲线为正弦。 * &lt;hr/&gt; * Repeats the animation for a specified number of cycles（周期）. The * rate of change follows a sinusoidal（正弦） pattern. * */public class CycleInterpolator implements Interpolator &#123; /** * * @param cycles 要重复的周期数 */ public CycleInterpolator(float cycles) &#123; mCycles = cycles; &#125; public CycleInterpolator(Context context, AttributeSet attrs) &#123; TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.CycleInterpolator); mCycles = a.getFloat(com.android.internal.R.styleable.CycleInterpolator_cycles, 1.0f); a.recycle(); &#125; @Override public float getInterpolation(float input) &#123; return (float)(Math.sin(2 * mCycles * Math.PI * input)); &#125; private float mCycles;&#125; 当cycle值为1时，即变化一周时，曲线图如下： OvershootInterpolator效果：向前甩一定值后再回到原来位置 源代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package android.view.animation; import android.content.Context;import android.content.res.TypedArray;import android.util.AttributeSet; /** * An interpolator where the change flings forward and overshoots the last value * then comes back. */public class OvershootInterpolator implements Interpolator &#123; private final float mTension; public OvershootInterpolator() &#123; mTension = 2.0f; &#125; /** * @param tension Amount of overshoot. When tension equals 0.0f, there is * no overshoot and the interpolator becomes a simple * deceleration interpolator. */ public OvershootInterpolator(float tension) &#123; mTension = tension; &#125; public OvershootInterpolator(Context context, AttributeSet attrs) &#123; TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.OvershootInterpolator); mTension = a.getFloat(com.android.internal.R.styleable.OvershootInterpolator_tension, 2.0f); a.recycle(); &#125; @Override public float getInterpolation(float t) &#123; // _o(t) = t * t * ((tension + 1) * t + tension) // o(t) = _o(t - 1) + 1 t -= 1.0f; return (t * t * (((mTension + 1) * t) + mTension)) + 1.0f; //plot &#123;(x-1)(x-1)((tension+1)(x-1)+tension)+1,(0&lt;x&lt;=1)&#125; &#125;&#125; 当tension为默认值2时，曲线图如下： 当tension的值为4时，曲线图如下：","tags":[{"name":"Android动画","slug":"Android动画","permalink":"http://liuguoquan727.github.io/tags/Android动画/"}]},{"title":"读书札记","date":"2016-03-17T16:02:15.000Z","path":"2016/03/18/读书札记/","text":"There is always another way. You know, people get up everyday, do the same thing, they tell themselves they change their life one day, they never do. I am gonna change my life. —-《城中大盗》 思考的时候，要像外行一样单纯直接，实践的时候则要像专家一样严密细致，并且要以专业知识和方法武装起来的“我做得到”的乐观精神。要记住，独特的、好的创意和好的结果，不管对研究而言，还是对商业运作而言，都不是自己突然冒出来的东西，那一定是刻苦的努力和长期的思考带来的。 —-金出武雄","tags":[{"name":"读书札记","slug":"读书札记","permalink":"http://liuguoquan727.github.io/tags/读书札记/"}]},{"title":"面向对象编程之依赖倒置原则","date":"2016-03-11T12:45:16.000Z","path":"2016/03/11/面向对象编程之依赖倒置原则/","text":"依赖倒置原则英文全称是Dependence Inversion Principle，缩写是DIP。依赖倒置原则指代了一种特定解耦形式，使得高层次的模块不依赖于低层次的模块的实现细节的目的，依赖模块被颠倒了。这到底是什么意思呢？ 依赖倒置原则则有以下关键点： 高层模块不应该依赖底层模块，两者都应该依赖其抽象； 抽象不应该依赖细节。 细节应该依赖抽象。 在Java语言中，抽象就是指接口或抽象类，两者都是不能直接被实例化的；细节就是实现类，实现接口或者继承抽象类而产生的类就是细节，其特点就是，可以直接被实例化，也就是可以加上关键字new产生的对象。高层模块就是调用端，底层模块就是具体实现类。 依赖倒置原则在Java语言中的表现就是：模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或者抽象类产生的。概况为一句话就是：面向接口编程，或者说是面向抽象编程，这里的抽象只得就是接口或抽象类。面向接口是面向对象的精髓之一。 如果类与类直接依赖于细节，那么他们之间就有直接的耦合，当具体实现需要变化时，意味着需要同时修改依赖者的代码，这限制了系统的可扩展性。 在前面的面向对象编程之开闭原则这一节中，ImageLoader直接依赖于MemoryCache，这个MemoryCache事一个具体实现，而不是一个抽象类或者接口。这就导致了ImageLoader直接依赖了具体的细节，当MemoryCache不能满足ImageLoader而需要被其他缓存实现替换时，此时就必须修改ImageLoader的代码： 12345678910111213141516171819202122public class ImageLoader &#123; /** * 图片缓存 */ MemoryCache mMemoryCache = new MemoryCache(); /** * 显示图片 * @param url * @param imageView */ public void displayImage(final String url, final ImageView imageView) &#123; //判断使用哪种缓存 Bitmap bitmap = mMemoryCache.get(url); if (bitmap != null) &#123; imageView.setImageBitmap(bitmap); return ; &#125; dowloadImage(url,imageView);&#125; 随着产品的升级，用户发现MemoryCache以及不能满足需求，用户需要小民的ImageLoader可以将图片同时缓存到内存和SD卡中，或者可以让用户自定义实现缓存。此时，我们的 MemoryCache这个类名不仅不能够表达内存缓存和SD卡缓存的意义，也不能满足功能。另外，用户需要自定义缓存实现时还必须继承自MemoryCache，而用户的缓存实现可不一定与内存缓存有关，这在命名上的限制也让用户体验不好。重构的时候到了！第一种方案是将MemoryCache修改为DoubleCache，然后在DoubleCache中实现具体的缓存功能。我们需要将ImageLoader修改如下： 12345678910111213141516171819202122public class ImageLoader &#123; /** * 图片缓存 */ DoubleCache mDoubleCache = new DoubleCache(); /** * 显示图片 * @param url * @param imageView */ public void displayImage(final String url, final ImageView imageView) &#123; //判断使用哪种缓存 Bitmap bitmap = mDoubleCache.get(url); if (bitmap != null) &#123; imageView.setImageBitmap(bitmap); return ; &#125; dowloadImage(url,imageView);&#125; 在程序中我们将MemoryCache修改成DoubleCache，然后修改了ImageLoader中缓存类的具体实现，轻轻松松就满足了用户需求。这不还是依赖具体的实现类吗？当用户的需求发生变化时，我们又要通过修改缓存实现类和ImageLoader代码来实现？ 针对这些问题，给出的解决方案就要能够让缓存系统更加灵活。一句话概括起来就是：依赖抽象，而不是依赖具体实现。针对图片缓存，建立ImageCache抽象（开闭原则小节所述），该抽象增加了get和put方法用以实现图片的存取。每种缓存实现都必须实现这个接口，并且实现自己的存取方法。当用户需要使用不同的缓存实现时，直接通过依赖注入即可，保证了系统的灵活性。我们来回顾一下相关代码： ImageCache缓存接口类： 12345678910111213141516public interface ImageCache &#123; /** * 获取图片 * @param url * @return */ public Bitmap get(String url); /** * 缓存图片 * @param url * @param bitmap */ public void put(String url, Bitmap bitmap);&#125; ImageLoader类： 123456789101112131415161718192021222324public class ImageLoader &#123; /** * 图片缓存 */ ImageCache mImageCache = new MemoryCache(); /** * 注入缓存实现 * @param cache */ public void setIamgeCache(ImageCache cache) &#123; mImageCache = cache; &#125; public void displayImage(final String url, final ImageView imageView) &#123; //判断使用哪种缓存 Bitmap bitmap = mImageCache.get(url); if (bitmap != null) &#123; imageView.setImageBitmap(bitmap); return ; &#125; dowloadImage(url,imageView); 在这里，我们建立了ImageCache抽象类，并且让ImageLoader依赖于抽象而不是具体细节。当需求发生变化时，只要实现ImageCache类或者继承其他已有的ImageCache子类完成相应的缓存功能，然后将具体的实现类注入到ImageLoader即可实现缓存功能的替换，这就保证的缓存系统的高可扩展性，有了拥抱变化的能力，这就是依赖倒置原则。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://liuguoquan727.github.io/tags/设计模式/"}]},{"title":"面向对象编程之里氏替换原则","date":"2016-03-08T15:45:48.000Z","path":"2016/03/08/面向对象编程之里氏替换原则/","text":"里氏替换原则的英文全称是Liskov Substitution Principle，缩写是LSP。 LSP第一种定义是：如果对每一个类型的为S的对象O1，都有类型为T的对象O2，使得以T定义的所有程序P在所有对象O1都替换成O2时，程序P的行为不会发生变化，那么类型S是类型T的子类型。这不太好理解。 LSP的第二种定义是：所有引用基类的地方必须能透明地使用其子类的对象。通俗的讲就是：只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或者异常，使用者可能根本就不需要知道是父类还是子类，但是，反过来就不行了，有子类出现的地方，父类未必就能适应。因为子类有的东西父类不一定有。 说了这么多，最终总结就两个字：抽象。为了便于理解这个原则，我们写了一个简单示例来描述，先看UML图： 再来看看具体的代码： 12345678910111213141516171819202122232425262728293031323334353637383940/** * 窗口类 */public class Window &#123; public show(View chile) &#123; chile.draw(); &#125;&#125;/** * 建立视图抽象，测量视图的宽高为公用代码，绘制实现交给具体的子类 */public abstract class View &#123; public abstract void draw(); public void measure(int width,int height) &#123; &#125;&#125;/** * Button的具体实现 */public class Button extends View &#123; @Override public void draw() &#123; //绘制Button &#125;&#125;/** * TextView的具体实现 */public class TextView extends View &#123; @Override public void draw() &#123; //绘制TextV &#125;&#125; 上述示例中，Window依赖于View，而View定义了一个视图抽象，measure是各个子类共享的方法，子类通过覆写View的draw方法实现各自的功能。任何继承自View的子类都可以设置给Window的show方法，这就是里氏替换原则。通过里氏替换，就可以自定义各自各样的view，然后传递个Window，Window负责组织view，并且将View显示到屏幕上。 里氏替换原则的核心是抽象，抽象又依赖于继承这个特性，在OOP当中，继承的优缺点都相当的明显。优点为： 代码重用，减少创建的成本，每个子类拥有父类的方法和属性 子类和父类基本相似，但又与父类有所区别 提高代码的可扩展性,实现父类的方法就可以了，很多开源框架的扩展接口都是通过继承父类完成的。 提高产品或项目的开放性。 继承的缺点： 继承是侵入性的，只要继承就必须拥有父类的所有属性和方法 可能造成子类代码冗余、灵活性降低，因为子类必须拥有父类的属性和方法 增强了耦合性。当父类的常量、变量和方法被修改时，必须考虑子类的修改，而且在缺乏规范的环境下，这种修好可能带来非常糟糕的结果—大片的代码需要重构。 结束开闭原则中的示例图片缓存系统也很好地反应了里氏替换原则，即MemoryCache、DiskCache、DoubleCache都可以替换成ImageCache的工作，并保证行为的正确性。实际中，开闭原则和里氏替换原则往往是相互关联的，通过里氏替换来达到扩展开放、修改关闭的效果。然而，这两个原则都强调一个OOP的重要特性–抽象。 参考书籍《Android源码设计模式》 何红辉、关爱民著 March 17, 2016 11:48 PM","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://liuguoquan727.github.io/tags/设计模式/"}]},{"title":"面向对象编程之开闭原则","date":"2016-03-07T14:53:20.000Z","path":"2016/03/07/面向对象编程之开闭原则/","text":"开闭原则的英文全称是Open Close Principle，缩写是OCP，它是Java世界里最基础的设计原则，它指导我们如何建立一个稳定的、灵活的系统。开闭原则的定义是：软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改是封闭的。 勃兰特-梅耶在1988年出版的《面向对象软件构造》一书中提出这一原则—开闭原则。这一想法认为，程序一旦开发完成，程序中一个类的实现只应该因错误而被修改，新的或者改变的特性应该通过新建不同的类实现，新建的类可以通过继承的方式来重用原类的代码。显然梅耶的定义提倡实现继承，已存在的实现类对于修改时封闭的，但是新的类可以通过覆写父类的接口应对变化。 引入其他缓存方式说了这么多，下面还是以一个简单示例来说明开闭原则： 在对ImageLoader进行了一次重构之后的ImageLoader职责单一、结构清晰，算是个不错的开始。随着用户的增多，有些问题开始暴露出来：缓存系统是最让大家吐槽的地方，通过内存缓存解决了每次从网络加载图片的问题，但是，Android应用的内存很有限，且具有易失性，即当应用重新启动之后，原来已经加载过的图片将会丢失，这样重启之后及需要重新下载图片！而这又会导致加载缓慢、耗费用户流量的问题。针对以上问题考虑引入SD卡缓存，这样下载过的图片就会缓存到本地，即使重启应用也不需要重新下载了，接下来开始实现SD卡缓存。 DiskCache.java类，将图片缓存到SD卡中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.deason.library.ocp;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import java.io.FileOutputStream;import java.io.IOException;/** * SD卡图片缓存 * Created by liuguoquan on 2016/3/17. */public class DiskCache &#123; public static final String CACHE_DIR = \"/sdcard/cache/\"; /** * 从缓存中获取图片 * @param url * @return */ public Bitmap get(String url) &#123; return BitmapFactory.decodeFile(CACHE_DIR + url); &#125; /** * 将图片存入SD卡中 * @param url * @param bitmap */ public void put(String url,Bitmap bitmap) &#123; FileOutputStream out = null; try &#123; out = new FileOutputStream(CACHE_DIR + url); bitmap.compress(Bitmap.CompressFormat.PNG,100,out); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (out != null) &#123; try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; MemoryCache类，把图片缓存到内存中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.deason.library.ocp;import android.graphics.Bitmap;import android.util.LruCache;/** * 处理图片缓存 * Created by liuguoquan on 2016/3/14. */public class MemoryCache &#123; /** * 图片缓存 */ LruCache&lt;String, Bitmap&gt; mImageCache; public MemoryCache() &#123; initImageCache(); &#125; private void initImageCache() &#123; //计算可使用的最大内存 final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); //取内存的四分之一作为缓存 final int cacheSize = maxMemory / 4; mImageCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; @Override protected int sizeOf(String key, Bitmap value) &#123; return value.getRowBytes() * value.getHeight() / 1024; &#125; &#125;; &#125; /** * 将图片存入缓存 * @param key * @param bitmap */ public void put(String key,Bitmap bitmap) &#123; mImageCache.put(key,bitmap); &#125; /** * 取出缓存图片 * @param key * @return */ public Bitmap get(String key) &#123; return mImageCache.get(key); &#125;&#125; 因为需要将图片缓存到SD卡中，所有ImageLoader代码有所更新，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * 图片加载类 * Created by liuguoquan on 2016/3/14. */public class ImageLoader &#123; /** * 图片缓存 */ MemoryCache mMemoryCache = new MemoryCache(); /** * SD卡缓存 */ DiskCache mDiskCache = new DiskCache(); /** * 是否使用SD卡缓存 */ private boolean isUseDiskCache = false; /** * 线程池，线程数量未CPU的数量 */ ExecutorService mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime() .availableProcessors()); /** * 显示图片 * @param url * @param imageView */ public void displayImage(final String url, final ImageView imageView) &#123; //判断使用哪种缓存 Bitmap bitmap = isUseDiskCache ? mDiskCache.get(url) : mMemoryCache.get(url); if (bitmap != null) &#123; imageView.setImageBitmap(bitmap); return ; &#125; //没有缓存则提交线程池下载 imageView.setTag(url); mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; Bitmap bitmap = downloadImage(url); if (bitmap == null) &#123; return; &#125; if (imageView.getTag().equals(url)) &#123; imageView.setImageBitmap(bitmap); &#125; //将下载的图片存入内存 mMemoryCache.put(url,bitmap); mDiskCache.put(url,bitmap); &#125; &#125;); &#125; /** * 设置是否用SD卡缓存 * @param isUseDiskCache */ public void useDiskCache(boolean isUseDiskCache) &#123; this.isUseDiskCache = isUseDiskCache; &#125; /** * 下载图片 * @param url * @return */ public Bitmap downloadImage(String imageUrl) &#123; Bitmap bitmap = null; try &#123; URL url = new URL(imageUrl); HttpURLConnection mConnection = (HttpURLConnection) url.openConnection(); int code = mConnection.getResponseCode(); if (200 == code) &#123; bitmap = BitmapFactory.decodeStream(mConnection.getInputStream()); &#125; mConnection.disconnect(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return bitmap; &#125;&#125; 从上述的代码中可以看到，仅仅新增了一个DiskCache类和往ImageLoader类中加入了少量代码就添加了SD卡缓存的功能，用户可以通过useDiskCache方法来对使用哪种缓存进行设置，例如 12345ImageLoader mImageLoader = new ImageLoader();//使用SD卡缓存mImageLoader.useDiskCache(true);//使用内存缓存mImageLoader.useDisCache(false); 通过useDiskCache方法来让用户设置不同的缓存这个思路是对的，但是会有些明显的问题，就是使用内存缓存时用户不能使用SD卡缓存。类似地，使用SD卡缓存时用户就不能使用内存缓存。 实际上，用户需要这两种缓存的综合，首先缓存优先使用内存缓存，如果内存缓存没有图片再使用SD卡缓存，如果SD卡中也没有图片最后才从网络上获取，这才是最好的缓存策略。 接下来，我们继续重构，新建一个双缓冲类DoubleCache，具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940package com.deason.library.ocp;import android.graphics.Bitmap;/** * 双缓冲。获取图片时先从内存中获取，如果内存中没有缓存该图片，再从SD卡中获取 * Created by liuguoquan on 2016/3/17. */public class DoubleCache &#123; MemoryCache mMemoryCache = new MemoryCache(); DiskCache mDiskCache = new DiskCache(); /** * 先从内存获取图片，没有再从SD卡获取 * @param url * @return */ public Bitmap get(String url) &#123; Bitmap bitmap = mMemoryCache.get(url); if (bitmap == null) &#123; bitmap = mDiskCache.get(url); &#125; return bitmap; &#125; /** * 将图片缓存到内存和SD卡中 * @param url * @param bitmap */ public void put(String url, Bitmap bitmap) &#123; mMemoryCache.put(url, bitmap); mDiskCache.put(url, bitmap); &#125;&#125; 我们再来看看最新的ImageLoader类，代码更新也不多： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** * 图片加载类 * Created by liuguoquan on 2016/3/14. */public class ImageLoader &#123; /** * 图片缓存 */ MemoryCache mMemoryCache = new MemoryCache(); /** * SD卡缓存 */ DiskCache mDiskCache = new DiskCache(); //双缓存 DoubleCache mDoubleCache = new DoubleCache(); /** * 是否使用SD卡缓存 */ private boolean isUseDiskCache = false; //使用双缓存 private boolean isUseDoubleCache = false; /** * 线程池，线程数量未CPU的数量 */ ExecutorService mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime() .availableProcessors()); /** * 显示图片 * @param url * @param imageView */ public void displayImage(final String url, final ImageView imageView) &#123; //判断使用哪种缓存 Bitmap bitmap = null; if (isUseDoubleCache) &#123; bitmap = mDoubleCache.get(url); &#125; else if (isUseDiskCache) &#123; bitmap = mDiskCache.get(url); &#125; else &#123; bitmap = mMemoryCache.get(url); &#125; if (bitmap != null) &#123; imageView.setImageBitmap(bitmap); return ; &#125; //没有缓存则提交线程池下载 imageView.setTag(url); mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; Bitmap bitmap = downloadImage(url); if (bitmap == null) &#123; return; &#125; if (imageView.getTag().equals(url)) &#123; imageView.setImageBitmap(bitmap); &#125; //将下载的图片存入内存 mMemoryCache.put(url,bitmap); mDiskCache.put(url,bitmap); &#125; &#125;); &#125; /** * 设置是否用SD卡缓存 * @param isUseDiskCache */ public void useDiskCache(boolean isUseDiskCache) &#123; this.isUseDiskCache = isUseDiskCache; &#125; /** * 设置是否使用双缓存 * @param isUseDoubleCache */ public void useDoubleCache(boolean isUseDoubleCache) &#123; this.isUseDoubleCache = isUseDoubleCache; &#125; /** * 下载图片 * @param url * @return */ public Bitmap downloadImage(String imageUrl) &#123; Bitmap bitmap = null; try &#123; URL url = new URL(imageUrl); HttpURLConnection mConnection = (HttpURLConnection) url.openConnection(); int code = mConnection.getResponseCode(); if (200 == code) &#123; bitmap = BitmapFactory.decodeStream(mConnection.getInputStream()); &#125; mConnection.disconnect(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return bitmap; &#125;&#125; 此时程序越来越灵活了，通过增加短短几行代码就能够完成如此重要的功能。 人们总会把美好的事情讲在前面，最后给你来个“但是”，我们先来分析一下上面的程序：每次在程序中加入新的缓存实现都需要修改ImageLoader类，然后通过一个布尔类型的变量来让用户选择使用哪种缓存，因此，就使得ImageLoader中存在各种if-else判断语句，通过这些判断语句来确定使用哪种缓存。随着大量逻辑的引用，代码变得越来越复杂脆弱，如果一不小心写错某个if条件，势必会花费大量的时间去调试程序，整个ImageLoader类也会显得臃肿。最重要的是，用户不能自己实现缓存注入到ImageLoader类中，可扩展性较差，而可扩展性是框架的最重要的特性之一。 注入方式设置缓存方式“软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改则是封闭的，这就是开放-关闭原则。也就是说，我们应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现”。现在，我们来实现终极解决方案，遵循开闭原则。 首先，我们先画出UML图，如下 然后，实现UML图上的类和接口，先重构ImageLoader类： 12345678910111213141516171819/** * Created by liuguoquan on 2016/3/17. */public interface ImageCache &#123; /** * 获取图片 * @param url * @return */ public Bitmap get(String url); /** * 缓存图片 * @param url * @param bitmap */ public void put(String url, Bitmap bitmap);&#125; 经过重构后，少了if-else语句，没有了各种各样的缓存实现对象、布尔变量，代码确实清晰、简单了很多。需要注意的是，这次重构的ImageCache把它提取成一个图片缓存的接口，用来抽象图片缓存的功能，我们来看看该接口的声明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * 图片加载类 * Created by liuguoquan on 2016/3/14. */public class ImageLoader &#123; /** * 图片缓存 */ ImageCache mImageCache = new MemoryCache(); /** * 注入缓存实现 * @param cache */ public void setIamgeCache(ImageCache cache) &#123; mImageCache = cache; &#125; /** * 线程池，线程数量未CPU的数量 */ ExecutorService mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime() .availableProcessors()); /** * 显示图片 * @param url * @param imageView */ public void displayImage(final String url, final ImageView imageView) &#123; Bitmap bitmap = mImageCache.get(url); if (bitmap != null) &#123; imageView.setImageBitmap(bitmap); return ; &#125; //没有缓存则提交线程池下载 submitLoadRequest(url, imageView); &#125; private void submitLoadRequest(final String url, final ImageView imageView) &#123; imageView.setTag(url); mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; Bitmap bitmap = downloadImage(url); if (bitmap == null) &#123; return; &#125; if (imageView.getTag().equals(url)) &#123; imageView.setImageBitmap(bitmap); &#125; //将下载的图片存入内存 mImageCache.put(url,bitmap); &#125; &#125;); &#125; /** * 下载图片 * @param url * @return */ public Bitmap downloadImage(String imageUrl) &#123; Bitmap bitmap = null; try &#123; URL url = new URL(imageUrl); HttpURLConnection mConnection = (HttpURLConnection) url.openConnection(); int code = mConnection.getResponseCode(); if (200 == code) &#123; bitmap = BitmapFactory.decodeStream(mConnection.getInputStream()); &#125; mConnection.disconnect(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return bitmap; &#125;&#125; ImageCache接口简单定义了获取、缓存图片两个方法，缓存的可以是图片的url,值是图片的本身。内存缓存、SD卡缓存、爽缓存都实现该接口，我们看看几个缓存的实现： MemoryCache.java 123456789101112131415161718192021222324252627282930313233343536373839public class MemoryCache implements ImageCache &#123; /** * 图片缓存 */ LruCache&lt;String, Bitmap&gt; mMemoryCache; public MemoryCache() &#123; initImageCache(); &#125; /** * 初始化LRU缓存 */ private void initImageCache() &#123; //计算可使用的最大内存 final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); //取内存的四分之一作为缓存 final int cacheSize = maxMemory / 4; mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; @Override protected int sizeOf(String key, Bitmap value) &#123; return value.getRowBytes() * value.getHeight() / 1024; &#125; &#125;; &#125; @Override public Bitmap get(String url) &#123; return mMemoryCache.get(url); &#125; @Override public void put(String url, Bitmap bitmap) &#123; mMemoryCache.put(url, bitmap); &#125;&#125; DiskCache.java 123456789101112131415161718192021222324252627282930313233/** * Created by liuguoquan on 2016/3/17. */public class DiskCache implements ImageCache &#123; public static final String CACHE_DIR = \"/sdcard/cache/\"; @Override public Bitmap get(String url) &#123; return BitmapFactory.decodeFile(CACHE_DIR + url); &#125; @Override public void put(String url, Bitmap bitmap) &#123; FileOutputStream out = null; try &#123; out = new FileOutputStream(CACHE_DIR + url); bitmap.compress(Bitmap.CompressFormat.PNG,100,out); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (out != null) &#123; try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; Double.java 1234567891011121314151617181920212223242526/** * Created by liuguoquan on 2016/3/17. */public class DoubleCache implements ImageCache &#123; ImageCache mMemoryCache = new MemoryCache(); ImageCache mDiskCache = new DiskCache(); @Override public Bitmap get(String url) &#123; Bitmap bitmap = mMemoryCache.get(url); if (bitmap == null) &#123; bitmap = mDiskCache.get(url); &#125; return bitmap; &#125; @Override public void put(String url, Bitmap bitmap) &#123; mMemoryCache.put(url, bitmap); mDiskCache.put(url, bitmap); &#125;&#125; 上述重构后的ImageLoader类中增加了一个setImageCache(ImageCache cache)方法，用户可以通过该函数设置缓存实现，也就是通常所说的依赖注入。 下面看看用户如何通过使用ImageLoader来设置缓存实现的： 1234567891011121314151617181920212223ImageLoader mImageLoader = new ImageLoader();//使用内存缓存mImageLoader.setIamgeCache(new MemoryCache());//使用SD卡缓存mImageLoader.setIamgeCache(new DiskCache());//使用双缓存mImageLoader.setIamgeCache(new DoubleCache());//使用自定义的图片缓存实现mImageLoader.setIamgeCache(new ImageCache() &#123; @Override public Bitmap get(String url) &#123; return null; &#125; @Override public void put(String url, Bitmap bitmap) &#123; &#125;&#125;); 在上述代码中，通过setImageCache(ImageCache cache)方法注入不同的缓存实现，这样不仅能够使ImageLoader更简单、健壮，也使得ImageLoader可课扩展性、灵活性更高。 MemeryCache、DiskCache、DoubleCache缓存图片的具体实现完全不一样，但是，它们有一个特点是，都实现了ImageCache接口。当用户需要自定义缓存实现时，只需要新建一个实现ImageCache接口的类，然后构造该类的对象，并且通过setImageCache(ImageCache cache)注入到ImageLoader中就可以了，这样ImageLoader就实现了千变万化的缓存策略，且扩展这些缓存策略并不会导致ImageLoader类的修改。经过这次重构，ImageLoader在设计模式上基本已经合格了。 开闭原则指导我们，当软件需要变化时，应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。这里的“应该尽量”4个字说明OCP原则并不是说绝对不可以修改原始类的。当确定原来的代码已经“腐化”时，应该尽早的重构，以便让代码恢复带正常的状态，而不是通过继承等方式添加新的代码。因此，在开发过程中需要自己结合具体情况进行考量，是通过修改旧代码还是通过继承使得软件系统更稳当、更灵活，在保证去除“腐化代码”的同时，也保证原有模块的正确性。 优点 增加稳定性 可扩展性提高","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://liuguoquan727.github.io/tags/设计模式/"}]},{"title":"面向对象编程之接口隔离原则","date":"2016-03-05T12:47:56.000Z","path":"2016/03/05/面向对象编程之接口隔离原则/","text":"接口隔离原则英文全称是Interface Segregation Principle，缩写是ISP。 ISP的定义是：客户端不应该依赖它不需要的接口。另一种定义是：类间的依赖关系应该建立在最小的接口上。接口隔离原则将非常庞大、臃肿的接口拆分成更小具体的接口，这样客户讲会只需要知道他们感兴趣的方法。接口隔离原则的目的是系统解开耦合，从而容易重构、更改和重新部署。 接口隔离原则说白了就是,让客户端依赖的接口尽可能的小，这样说可能还有点抽象，我们一一个示例来说明一下。在此之前我们来说一个场景，在Java6以及之前的JDK版本中，有一个非常讨厌的问题，那就是在使用了OutputStream或者其他可关闭的对象之后，我们必须保证它们最终被关闭了，我们的SD卡缓存类中就有这样的代码： 1234567891011121314151617181920212223/** * 将图片存入SD卡中 * @param url * @param bitmap */public void put(String url,Bitmap bitmap) &#123; FileOutputStream out = null; try &#123; out = new FileOutputStream(CACHE_DIR + url); bitmap.compress(Bitmap.CompressFormat.PNG,100,out); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (out != null) &#123; try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 这段代码的可读性非常差，各种try…catch嵌套的都是简单的代码，但是会严重影响代码的可读性，并且多层级的大括号很容易将代码写到错误的层级中。我们对这类代码也非常反感，下面来看看如何解决这类问题。 我们可能知道Java中有一个Closeable接口，该接口标识了一个可关闭的对象，它只有一个close方法，我们要讲的FileOutputStream类就实现类就实现了这个接口，实际上还有100多个类实现了这还接口，这意味着，在关闭着100多个类型的对象时，都需要写出像put方法中finally代码段那样的代码。这是非常让人痛苦的，所以我们要把这个问题变得简单，既然都是实现了Closeable接口，那只要我建一个方法统一来关闭这些对象不就可以了吗，于是我们开始写下如下的工具类： 12345678910111213141516public class CloseUtils &#123; /** *关闭Closeable对象 **/ public static void closeQuietly(Closeable closeable) &#123; if (closeable != null) &#123; try &#123; closeable.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 我们看看把这段代码运用到上述的put方法中的效果如何： 123456789101112public void put(String url,Bitmap bitmap) &#123; FileOutputStream out = null; try &#123; out = new FileOutputStream(CACHE_DIR + url); bitmap.compress(Bitmap.CompressFormat.PNG,100,out); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; CloseUtils.closeQuietly(out); &#125;&#125; 代码简洁了很多，而且这个工具类可以运用到各类可关闭的对象中，保证了代码的重用性。 CloseUtils的closeQuitely方法的基本原理就是依赖于Closeable抽象而不是具体实现（这不是依赖倒置原则么？），并且建立在最小化依赖原则的基础上，它只需要知道这个对象是可关闭的，其他的一概不关心，也就是这里所介绍的接口隔离原则。 优点： 降低耦合性 提高代码的可读性 隐藏实现细节","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://liuguoquan727.github.io/tags/设计模式/"}]},{"title":"面向对象编程之接口迪米特原则","date":"2016-03-04T12:49:10.000Z","path":"2016/03/04/面向对象编程之接口迪米特原则/","text":"迪米特原则英文全称为Law of Demeter，缩写是LOD，也称为最少知识原则（Least of Principle）。虽然名字不同，但描述的是同一个原则：一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，类的内部如何实现与调用者或者依赖者没有关系，调用者或者依赖者只需要知道它需要的方法即可，其他的可一概不管。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。 迪米特法则还有一个英文解释就是Only talk to your immediate friends，翻译就是：只与直接的朋友通信。什么是最直接的朋友呢？每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为朋友关系，这样关系的类型很多，如组合、聚合、依赖等。 下面我们就以租房为例描述迪米特原则的应用： 在外工作的朋友比较了解，我们经常通过中介找房。我们设定的情况为：我只要求房间的面积和租金，其他的一概不管，中介将符合我要求的房子提供给我就可以。下面我们来看看这个示例： 我先来看看示例的UML图： 代码如下： 1234567891011121314151617181920/** * 房子 * @author liuguoquan * */public class Room &#123; public float area; public float price; public Room(float area, float price) &#123; this.area = area; this.price = price; &#125; @Override public String toString() &#123; return \"Room [area=\" + area + \", price=\" + price + \"]\"; &#125;&#125; 12345678910111213141516171819/** * 中介 * @author liuguoquan * */public class Mediator &#123; List&lt;Room&gt; mRooms = new ArrayList&lt;Room&gt;(); public Mediator() &#123; for(int i = 0; i &lt; 5; i++) &#123; mRooms.add(new Room(10 + i, (10 + 1) * 200)); &#125; &#125; public List&lt;Room&gt; getAllRooms() &#123; return mRooms; &#125;&#125; 123456789101112131415161718192021222324252627282930/** * 租户 * @author liuguoquan * */public class Tenant &#123; private float roomArea; private float roomPrice; private static final float DIFF_PRICE = 100.01f; private static final float DIFF_AREA = 0.01f; public void rentRomm(Mediator mediator) &#123; List&lt;Room&gt; rooms = mediator.getAllRooms(); for (Room room : rooms) &#123; if (isSuitable(room)) &#123; System.out.println(\"租到合适的房间啦!\" + room.toString()); &#125; &#125; &#125; public boolean isSuitable(Room room) &#123; return Math.abs(room.price - roomPrice) &lt; DIFF_PRICE &amp;&amp; Math.abs(room.area - roomArea) &lt; DIFF_AREA; &#125;&#125; 从上面的代码可以看到，Tenant依赖了Mediator类，而且依赖了Room类，还需要频繁的与Room类打交道。租户类的要求只是通过中介找到一间适合自己的房子罢了，如果把这些检测条件都放在Tenant类中，那么Mediator类的功能就会被弱化，而且导致Tenant与Room的耦合较高，因为Tenant必须知道许多关于Room的细节。当Room变化时Tenant也必须跟着变化。Tenant又与Mediator耦合，这就出现了许多纠缠不清的关系。这个时候我们需要分析谁是真正的“直接朋友”，在我们所说的情况下，显然是Mediator。 既然耦合太严重，我们就需要解耦。首先要明确的是，我们只和我们的朋友通信，就是指Mediator对象。必须将Room相关的操作从Tenant中移除，而这些操作应在属于Mediator。为此，我们进行重构，重构后的UML图如下： 重构后的Mediator、代码如下： 123456789101112131415161718192021222324252627282930313233/** * 中介 * * @author liuguoquan * */public class Mediator &#123; List&lt;Room&gt; mRooms = new ArrayList&lt;Room&gt;(); public Mediator() &#123; for (int i = 0; i &lt; 5; i++) &#123; mRooms.add(new Room(10 + i, (10 + 1) * 200)); &#125; &#125; public Room rentOut(float area,float price) &#123; for(Room room : mRooms) &#123; if (isSuitable(room, price, area)) &#123; return room; &#125; &#125; return null; &#125; public boolean isSuitable(Room room, float roomPrice, float roomArea) &#123; return Math.abs(room.price - roomPrice) &lt; Tenant.DIFF_PRICE &amp;&amp; Math.abs(room.area - roomArea) &lt; Tenant.DIFF_AREA; &#125;&#125; 123456789101112131415161718/** * 租户 * @author liuguoquan * */public class Tenant &#123; private float roomArea; private float roomPrice; public static final float DIFF_PRICE = 100.01f; public static final float DIFF_AREA = 0.01f; public void rentRomm(Mediator mediator) &#123; System.out.println(\"租到合适的房子了： \" + mediator.rentOut(roomArea, roomPrice).toString()); &#125;&#125; 如上所示，租户不再需要知道太对关于Room的细节，比如与房东签合同，房东的房产证是不是真的等。当我们通过我们的“朋友”–中介租房后，所有的事情我们都通过与中介沟通就好了。 有点： 降低了复杂度 降低了耦合度 增加了稳定性","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://liuguoquan727.github.io/tags/设计模式/"}]},{"title":"面向对象编程之单一职责原则","date":"2016-03-02T14:02:18.000Z","path":"2016/03/02/面向对象编程之单一职责原则/","text":"单一职责的英文名称是Single Responsibility Principle，缩写是SRP。 SRP的定义就是：就一个类而言，应该仅有一个引起它变化的原因。简单说来，一个类中应该是一组相关性很高的函数、数据的封装。单一职责的划分界限并不是总是那么清晰，很多时候需要靠个人经验来界定。当然，最大的问题就是堆职责的定义，什么是类的职责，以及怎么划分类的职责。 接下来以小明的工作过程为示例描述单一职责原则： 小明初入职场，在经历过一周的适应期以及熟悉公司的产品、开发规范后，小民的开发工作就正式开始了。小民的主管是个工作经验丰富的技术专家，对于小民的工作并不是很满意，尤其是小民最薄弱的面向对象设计，而Android开发又是使用Java语言，程序中的抽象、接口、六大原则、23种设计模式等名词把小民弄的晕头转向。于是，小民的主管决定先让小民做一个小项目来锻炼这方面的能力。 在经过一番思考后，主管挑选了使用范围广、难度也适中的图片加载器（ImageLoader）作为小民的训练项目。既然要训练小民的面向对象设计能力，那么久必须考虑到可扩展性、灵活性，而检测这一切是否符合需求的最好途径就是开源。 小民是不服输的，主管的要求很简单，要小民实现图片加载，并且要将图片缓存起来。在分析了需求之后，小民放下心来，胸有成竹，在经历了10分钟的编码之后，小民写下了如下代码： ImageLoader.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.deason.library.srp;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.util.LruCache;import android.widget.ImageView;import java.io.IOException;import java.net.HttpURLConnection;import java.net.URL;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * 图片加载类 * Created by liuguoquan on 2016/3/13. */public class ImageLoader &#123; /** * 图片缓存 */ LruCache&lt;String, Bitmap&gt; mImageCache; /** * 线程池，线程数量未CPU的数量 */ ExecutorService mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime() .availableProcessors()); public ImageLoader() &#123; initImageCache(); &#125; private void initImageCache() &#123; //计算可使用的最大内存 final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); //取内存的四分之一作为缓存 final int cacheSize = maxMemory / 4; mImageCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; @Override protected int sizeOf(String key, Bitmap value) &#123; return value.getRowBytes() * value.getHeight() / 1024; &#125; &#125;; &#125; /** * 显示图片 * @param url * @param imageView */ public void displayImage(final String url, final ImageView imageView) &#123; imageView.setTag(url); mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; Bitmap bitmap = downloadImage(url); if (bitmap == null) &#123; return; &#125; if (imageView.getTag().equals(url)) &#123; imageView.setImageBitmap(bitmap); &#125; &#125; &#125;); &#125; /** * 下载图片 * @param url * @return */ public Bitmap downloadImage(String imageUrl) &#123; Bitmap bitmap = null; try &#123; URL url = new URL(imageUrl); HttpURLConnection mConnection = (HttpURLConnection) url.openConnection(); int code = mConnection.getResponseCode(); if (200 == code) &#123; bitmap = BitmapFactory.decodeStream(mConnection.getInputStream()); &#125; mConnection.disconnect(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return bitmap; &#125;&#125; 随后，小民将代码托管到GitHub上，伴随着git push命令的完成，小民的ImageLoader 0.1版本就发布了。小民开始幻想着待会儿被主管称赞。 在小民给主管报告了ImageLoader发布消息的几分钟后，主管把小民叫到了会议室，叼了小民一顿：“小民，你的ImageLoader耦合太严重啦！简直就没有设计可言，更不要说是扩展性、灵活性了。所有功能写在一个类里面怎么行呢，这样随着功能的增多，ImageLoader类会越来越大。代码也越来越复杂，图片的加载系统就会越来越弱…”，此时，小民默默吞下了泪水。 主管最后说：“你还是把ImageLoader拆分一下，把各个功能独立出来，让它们满足单一职责原则。”小民敏锐的捕捉到单一职责原则这个关键词，他用百度、Google搜索了资料之后，决定对ImageLoader进行一次重构。这次小民认真地先画了一幅UML类图： ImageLoader修改后的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.deason.library.srp.refactor;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.widget.ImageView;import java.io.IOException;import java.net.HttpURLConnection;import java.net.URL;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * 图片加载类 * Created by liuguoquan on 2016/3/14. */public class ImageLoader &#123; /** * 图片缓存 */ ImageCache mImageCache = new ImageCache(); /** * 线程池，线程数量未CPU的数量 */ ExecutorService mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime() .availableProcessors()); /** * 显示图片 * @param url * @param imageView */ public void displayImage(final String url, final ImageView imageView) &#123; //首先检查内存是否存在 Bitmap bitmap = mImageCache.get(url); if (bitmap != null) &#123; imageView.setImageBitmap(bitmap); return ; &#125; imageView.setTag(url); mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; Bitmap bitmap = downloadImage(url); if (bitmap == null) &#123; return; &#125; if (imageView.getTag().equals(url)) &#123; imageView.setImageBitmap(bitmap); &#125; //将下载的图片存入内存 mImageCache.put(url,bitmap); &#125; &#125;); &#125; /** * 下载图片 * @param url * @return */ public Bitmap downloadImage(String imageUrl) &#123; Bitmap bitmap = null; try &#123; URL url = new URL(imageUrl); HttpURLConnection mConnection = (HttpURLConnection) url.openConnection(); int code = mConnection.getResponseCode(); if (200 == code) &#123; bitmap = BitmapFactory.decodeStream(mConnection.getInputStream()); &#125; mConnection.disconnect(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return bitmap; &#125;&#125; 并且添加类一个ImageCache类用于图片缓存，具体代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.deason.library.srp.refactor;import android.graphics.Bitmap;import android.util.LruCache;/** * 处理图片缓存 * Created by liuguoquan on 2016/3/14. */public class ImageCache &#123; /** * 图片缓存 */ LruCache&lt;String, Bitmap&gt; mImageCache; public ImageCache() &#123; initImageCache(); &#125; private void initImageCache() &#123; //计算可使用的最大内存 final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); //取内存的四分之一作为缓存 final int cacheSize = maxMemory / 4; mImageCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; @Override protected int sizeOf(String key, Bitmap value) &#123; return value.getRowBytes() * value.getHeight() / 1024; &#125; &#125;; &#125; /** * 将图片存入缓存 * @param key * @param bitmap */ public void put(String key,Bitmap bitmap) &#123; mImageCache.put(key,bitmap); &#125; /** * 取出缓存图片 * @param key * @return */ public Bitmap get(String key) &#123; return mImageCache.get(key); &#125;&#125; 综上所述，小民将ImageLoader一拆为二，ImageLoader只负责图片加载的逻辑，而ImageCache只负责处理图片缓存的逻辑，这样ImageLoader的代码量变少了，职责也清晰了；当与缓存相关的逻辑需要改变时，不需要修改ImageLoader类，而图片加载的逻辑需要修改时也不会影响到缓存处理逻辑。 从上述例子我们知道，单一职责所表达出来的用意就是“单一”两个字。如何划分一个类、一个函数的职责，每个人都有自己的看法，这需要根据个人经验、具体的业务逻辑而定。但是，它也有一些基本的指导原则，例如，两个完全不一样的功能就不应该方法一个类中，一个类中应该是一组相关性很高的函数、数据的封装。工程师可以不断地审视自己的代码，根据具体的业务、功能对类进行相应的拆分，这是程序员优化代码迈出的第一步。 优点 类的复杂度降低，实现什么职责都有清晰的定义。 复杂性降低，所以可读性提高了。 可读性提高了，所以可维护性提高了 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有很大的帮助。 ##参考资料 《Android源码设计模式》 何红辉、关爱民 著","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://liuguoquan727.github.io/tags/设计模式/"}]},{"title":"Android 5.x之Toolbar和Palette","date":"2016-02-28T14:50:03.000Z","path":"2016/02/28/Android 5.x之Toolbar和Palette/","text":"Toolbar是Android5.0后应用的内容的标准工具栏，可以说是ActionBar的升级版，两者不是独立的关系，要使用Toolbar还是得跟ActionBar有关系的。相比ActionBar，Toolbar最明显的一点就是变得很自由，可以随处放置，具体的使用方法和ActionBar很类似。 Toolbar引入首先还是得引入v7包，Android studio在build.gradle配置如下代码 123456dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:23.0.1' compile 'com.android.support:palette-v7:23.0.1'&#125; 接下来为了显示Toolbar控件，先要将style里的ActionBar去掉: 1234567&lt;!-- Base application theme. --&gt;&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt; 设置各个部分属性的图： 接下来我们引入Toolbar： 123456&lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" app:popupTheme=\"@style/AppTheme.PopupOverlay\" /&gt; 主布局在主布局中我们使用DrawerLayout来完成侧滑效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" tools:context=\"com.deason.library.mytoobar.MainActivity\"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"@style/AppTheme.AppBarOverlay\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" app:popupTheme=\"@style/AppTheme.PopupOverlay\" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.DrawerLayout android:id=\"@+id/id_drawerlayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;!--内容界面--&gt; &lt;LinearLayout android:id=\"@+id/ll_content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:background=\"@drawable/ic_launcher\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:text=\"内容界面\" android:textColor=\"@android:color/white\"/&gt; &lt;/LinearLayout&gt; &lt;!--侧或菜单界面--&gt; &lt;LinearLayout android:id=\"@+id/ll_tabs\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@android:color/darker_gray\" android:orientation=\"vertical\" android:layout_gravity=\"start\"&gt; &lt;TextView android:id=\"@+id/tv_close\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:clickable=\"true\" android:text=\"侧滑界面,点击收回侧滑\" android:textColor=\"@android:color/white\"/&gt; &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.DrawerLayout&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|end\" android:layout_margin=\"@dimen/fab_margin\" android:src=\"@android:drawable/ic_dialog_email\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; Toolbar自定义Item布局我们在menu/main.xml中去声明将在Toobar的Menu item,MenuItem的设置与ActionBar类似 123456789101112131415161718192021222324&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" tools:context=\"com.deason.library.mytoobar.MainActivity\"&gt; &lt;item android:id=\"@+id/ab_search\" android:orderInCategory=\"80\" android:title=\"搜索\" app:actionViewClass=\"android.support.v7.widget.SearchView\" app:showAsAction=\"ifRoom\"/&gt; &lt;item android:id=\"@+id/action_share\" android:orderInCategory=\"90\" android:title=\"分享\" app:actionProviderClass=\"android.support.v7.widget.ShareActionProvider\" app:showAsAction=\"ifRoom\"/&gt; &lt;item android:id=\"@+id/action_settings\" android:orderInCategory=\"100\" android:title=\"设置\" app:showAsAction=\"never\" /&gt;&lt;/menu&gt; java代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154package com.deason.library.mytoobar;import android.content.Intent;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.drawable.ColorDrawable;import android.os.Bundle;import android.support.design.widget.FloatingActionButton;import android.support.design.widget.Snackbar;import android.support.v4.view.MenuItemCompat;import android.support.v4.widget.DrawerLayout;import android.support.v7.app.ActionBarDrawerToggle;import android.support.v7.app.AppCompatActivity;import android.support.v7.graphics.Palette;import android.support.v7.widget.SearchView;import android.support.v7.widget.ShareActionProvider;import android.support.v7.widget.Toolbar;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.Toast;public class MainActivity extends AppCompatActivity &#123; private DrawerLayout mDrawerLayout; private ActionBarDrawerToggle mDrawerToggle; private Toolbar toolbar; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); //是否给左上角图标的左边加上一个返回的图标 getSupportActionBar().setDisplayHomeAsUpEnabled(true);// getSupportActionBar().setLogo(R.mipmap.ic_launcher); FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Snackbar.make(view, \"Replace with your own action\", Snackbar.LENGTH_LONG) .setAction(\"Action\", null).show(); &#125; &#125;); toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem item) &#123; Toast.makeText(MainActivity.this,\"searchView\"+item.getTitle(),Toast.LENGTH_SHORT).show(); return true; &#125; &#125;); initView(); &#125; private void initView() &#123; //实现侧滑栏的切换 mDrawerLayout = (DrawerLayout) findViewById(R.id.id_drawerlayout); mDrawerToggle = new ActionBarDrawerToggle(this, mDrawerLayout, toolbar, R.string.open, R.string.close); mDrawerToggle.syncState(); mDrawerLayout.setDrawerListener(mDrawerToggle); //关闭抽屉栏// mDrawerLayout.closeDrawer(Gravity.LEFT); //Palette取色器 Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.drawable.ic_launcher); Palette.from(bitmap).generate(new Palette.PaletteAsyncListener() &#123; @Override public void onGenerated(Palette palette) &#123; Palette.Swatch swatch = palette.getVibrantSwatch(); //设置Toolbar颜色 getSupportActionBar().setBackgroundDrawable(new ColorDrawable(swatch.getRgb())); //设置系统状态栏颜色 getWindow().setStatusBarColor(swatch.getRgb()); &#125; &#125;); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main, menu); //在菜单中找到对应控件的item MenuItem menuItem = menu.findItem(R.id.ab_search); //获取SearchView SearchView searchView = (SearchView) menuItem.getActionView(); searchView.setOnSearchClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this,\"searchView\",Toast.LENGTH_SHORT).show(); &#125; &#125;); MenuItem shareItem = menu.findItem(R.id.action_share); ShareActionProvider shareActionProvider = (ShareActionProvider)MenuItemCompat.getActionProvider(shareItem); Intent intent = new Intent(Intent.ACTION_SEND); intent.setType(\"image/*\"); shareActionProvider.setShareIntent(intent); shareActionProvider.setOnShareTargetSelectedListener(new ShareActionProvider.OnShareTargetSelectedListener() &#123; @Override public boolean onShareTargetSelected(ShareActionProvider source, Intent intent) &#123; Toast.makeText(MainActivity.this,\"onShareTargetSelected:\"+ intent.getAction(),Toast.LENGTH_SHORT).show(); return false; &#125; &#125;); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) &#123; Toast.makeText(MainActivity.this,\"action_settings\",Toast.LENGTH_SHORT).show(); return true; &#125; return super.onOptionsItemSelected(item); &#125;&#125;最后来看看效果:![Toolbar](http://img.blog.csdn.net/20160227234641589) Paletta的应用Android5.x的Paletta作用是提取图片的颜色，从而让主题能够动态适应当前界面的色调，做到整个App颜色的颜色基调和谐统一。 Android内置了几种提取色调的种类： Vibrant：充满活力的 Vibrant dark 活力黑 Vibrant light 活力亮 Muted 柔和的 Muted dark 柔和的黑 Muted light 柔和的亮 要使用Palette，我们需要引入com.android.support:palette-v7:23.0.1包。 实现提取颜色的步骤： 获取一个Bitmap对象 将Bitmap对象传递给Palette，然后调用generate方法 在onGenerated回调中得到图片的色调，最后我们把Toolbar和系统状态栏的背景设置为该图片的色调 1234567891011121314151617//Palette取色器Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.drawable.ic_launcher);Palette.from(bitmap).generate(new Palette.PaletteAsyncListener() &#123; @Override public void onGenerated(Palette palette) &#123; //这里我们获取的是图片充满活力的黑的色调 Palette.Swatch swatch = palette.getDarkVibrantSwatch(); //设置Toolbar颜色 getSupportActionBar().setBackgroundDrawable(new ColorDrawable(swatch.getRgb())); //设置系统状态栏颜色 getWindow().setStatusBarColor(swatch.getRgb()); &#125;&#125;); 最后来看看效果: 参考文章 Android5.x Toolbar和Palette应用解析","tags":[{"name":"Android5.X","slug":"Android5-X","permalink":"http://liuguoquan727.github.io/tags/Android5-X/"}]},{"title":"Android Design Support Library之CoordinatorLayout和CollapsingToolbarLayout","date":"2016-02-26T15:35:03.000Z","path":"2016/02/26/Android Design Support Library之CoordinatorLayout和CollapsingToolbarLayout/","text":"CoordinatorLayout是Android Design Support Library中比较难的控件，它是用来组织它的子View之间协助的一个父View，它直接继承于ViewGroup。 CoordinatorLayout默认情况下可理解是一个FrameLayout，它的布局方式是一层一层叠加上去的，这里我们来介绍它常用的两种情况。 CoordinatorLayout实现ToolBar的隐藏效果首先看看效果: 接下来开始实现，首先配置build.gradle build.gradle1234567dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs') testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:23.2.0' compile 'com.android.support:design:23.2.0' compile 'com.android.support:recyclerview-v7:23.2.0'&#125; com.android.support:design:23.2.0就是我们需要引入的兼容库 主界面主界面跟前面的Android Design Support Library之NavigationView一致，不同之处在于layout=”@layout/app_bar_main”引入的布局实现的不同 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/drawer_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" tools:openDrawer=\"start\"&gt; &lt;include layout=\"@layout/app_bar_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; &lt;android.support.design.widget.NavigationView android:id=\"@+id/nav_view\" android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" android:fitsSystemWindows=\"true\" app:headerLayout=\"@layout/nav_header_main\" app:menu=\"@menu/activity_main_drawer\" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 下面我们来看看app_bar_main.xml这个布局： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/main_content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"@style/AppTheme.AppBarOverlay\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"100dp\" android:background=\"?attr/colorPrimary\" app:layout_scrollFlags=\"scroll|enterAlways\" /&gt; &lt;android.support.design.widget.TabLayout android:id=\"@+id/tabs\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"?attr/colorPrimary\" app:tabIndicatorColor=\"#ffffffff\" app:tabMode=\"scrollable\"&gt; &lt;/android.support.design.widget.TabLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/viewpager\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" //必须设置，AppBarLayout才能接收到滚动事件 app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"/&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|end\" android:layout_margin=\"@dimen/fab_margin\" android:src=\"@android:drawable/ic_dialog_email\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; CoordinatorLayout中不应该再设置android:fitsSystemWindows=”true”这个配置，因为外层已经设置好，如果设置会出现不和谐的效果。 Toolbar能隐藏的关键在于app:layout_scrollFlags=”scroll|enterAlways”这个事件，设置滚动事件，属性里面至少启用scroll这个flag，这样view才会滚动出屏幕，否则它将一直固定在头部。 Java代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153package com.deason.library.mycoordinatorlayout;import android.content.Intent;import android.os.Bundle;import android.support.design.widget.NavigationView;import android.support.design.widget.TabLayout;import android.support.v4.app.Fragment;import android.support.v4.view.GravityCompat;import android.support.v4.view.ViewPager;import android.support.v4.widget.DrawerLayout;import android.support.v7.app.ActionBarDrawerToggle;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.Toolbar;import android.view.Menu;import android.view.MenuItem;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity implements NavigationView.OnNavigationItemSelectedListener &#123; private ViewPager mViewPager; private TabLayout mTabLayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout); ActionBarDrawerToggle toggle = new ActionBarDrawerToggle( this, drawer, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close); drawer.setDrawerListener(toggle); toggle.syncState(); NavigationView navigationView = (NavigationView) findViewById(R.id.nav_view); navigationView.setNavigationItemSelectedListener(this); mViewPager = (ViewPager) findViewById(R.id.viewpager); initViewPager(); &#125; private void initViewPager() &#123; mTabLayout = (TabLayout) findViewById(R.id.tabs); mTabLayout.setSelectedTabIndicatorHeight(10); List&lt;String&gt; titles = new ArrayList&lt;String&gt;(); titles.add(\"新闻\"); titles.add(\"财经\"); titles.add(\"娱乐\"); titles.add(\"体育\"); titles.add(\"军事\"); titles.add(\"科技\"); titles.add(\"教育\"); titles.add(\"历史\"); titles.add(\"文化\"); titles.add(\"深圳\"); for(int i= 0;i &lt; titles.size();i++) &#123; //设置TabIndicator文字 mTabLayout.addTab(mTabLayout.newTab().setText(titles.get(i))); &#125; List&lt;Fragment&gt; fragments = new ArrayList&lt;Fragment&gt;(); for (int i = 0; i &lt; titles.size(); i++) &#123; fragments.add(new TabFragment()); &#125; //实例化适配器 FragmentAdapter mAdapter = new FragmentAdapter(getSupportFragmentManager(),fragments,titles); //给ViewPager设置适配器 mViewPager.setAdapter(mAdapter); //将TabLayout和ViewPager关联起来 mTabLayout.setupWithViewPager(mViewPager); //给TabLayout设置适配器 mTabLayout.setTabsFromPagerAdapter(mAdapter); &#125; @Override public void onBackPressed() &#123; DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout); if (drawer.isDrawerOpen(GravityCompat.START)) &#123; drawer.closeDrawer(GravityCompat.START); &#125; else &#123; super.onBackPressed(); &#125; &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) &#123; Intent intent = new Intent(this,CollapsingActivity.class); startActivity(intent); return true; &#125; return super.onOptionsItemSelected(item); &#125; @SuppressWarnings(\"StatementWithEmptyBody\") @Override public boolean onNavigationItemSelected(MenuItem item) &#123; // Handle navigation view item clicks here. int id = item.getItemId(); if (id == R.id.nav_camera) &#123; // Handle the camera action &#125; else if (id == R.id.nav_gallery) &#123; &#125; else if (id == R.id.nav_slideshow) &#123; &#125; else if (id == R.id.nav_manage) &#123; &#125; else if (id == R.id.nav_share) &#123; &#125; else if (id == R.id.nav_send) &#123; &#125; DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout); drawer.closeDrawer(GravityCompat.START); return true; &#125;&#125; 其他代码如ViewPager、RecyclerView的实现请参考Android Design Support Library之TabLayout一文。 效果 CoordinatorLayout+CollapsingToolbarLayout实现Toolbar折叠效果首先看看效果： 要实现折叠效果我们需要引入一个新的布局CollapsingToolbarLayout，它作用是提供了一个可以折叠的Toolbar，它继承至FrameLayout，给它设置layout_scrollFlags，它可以控制包含在CollapsingToolbarLayout中的控件比如mageView、Toolbar在响应layout_behavior事件时作出相应的scrollFlags滚动事件。 布局布局文件用CollapsingToolbarLayout将ImageView和Toolbar包含起来作为一个可折叠的Toolbar，再用AppBarLayout包裹起来作为一个Appbar的整体，当然，AppBarLayout目前必须是第一个嵌套在CoordinatorLayout里面的子view。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/main_content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:fitsSystemWindows=\"true\" android:theme=\"@style/AppTheme.AppBarOverlay\"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id=\"@+id/collapsing_toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" app:contentScrim=\"?attr/colorPrimary\" app:expandedTitleMarginEnd=\"64dp\" app:expandedTitleMarginStart=\"48dp\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"&gt; &lt;ImageView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" android:scaleType=\"centerCrop\" android:src=\"@drawable/mao\" /&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:layout_collapseMode=\"pin\" app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;!-- &lt;include layout=\"@layout/content_main\" /&gt; --&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recyclerView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:scrollbars=\"none\" //必须设置，AppBarLayout才能接收到滚动事件 app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; CollapsingToolbarLayout的几个关键属性需要说明一下： app:contentScrim=”?attr/colorPrimary”，用来设置CollapsingToolbarLayout收缩后最顶部的颜色 app:expandedTitleGravity= “left|bottom”，表示将此CollapsingToolbarLayout完全展开后，title所处的位置，默认是left|bottom app:collapsedTitleGravity= “left”，表示当头部的图片ImageView消失后，此title将回归到ToolBar的位置，默认是left app:layout_scrollFlags=”scroll|exitUntilCollapsed”，这个属性我们上面讲过用来设置滚动事件，属性里面必须至少启用scroll这个flag，这样这个view才会滚动出屏幕，否则它将一直固定在顶部。这里我们设置的是app:layout_scrollFlags=”scroll|exitUntilCollapsed”这样能实现折叠效果，如果想要隐藏效果我们可以设置app:layout_scrollFlags=”scroll|enterAlways” 我们需要定义AppBarLayout与滚动视图之间的联系，Design Support Library包含了一个特殊的字符串资源@string/appbar_scrolling_view_behavior，它和AppBarLayout.ScrollingViewBehavior相匹配，用来通知AppBarLayout何时发生了滚动事件，这个behavior需要设置在触发事件的view之上，所以我们应该在RecyclerView或者任意支持嵌套滚动的view比如NestedScrollView上添加app:layout_behavior=”@string/appbar_scrolling_view_behavior这个属性，当然AppBarLayout 中的子view需要设置app:layout_scrollFlags这个属性，否则接收到RecyclerView滚动事件，AppBarLayout 也不会有什么变化。 Java代码实现1234567891011121314151617181920212223242526272829303132package com.deason.library.mycoordinatorlayout;import android.os.Bundle;import android.support.design.widget.CollapsingToolbarLayout;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import android.support.v7.widget.Toolbar;public class CollapsingActivity extends AppCompatActivity &#123; private RecyclerView mRecyclerView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.collapsing_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); CollapsingToolbarLayout collapsingToolbarLayout = (CollapsingToolbarLayout) findViewById(R.id.collapsing_toolbar); collapsingToolbarLayout.setTitle(\"哆啦A梦\"); mRecyclerView = (RecyclerView) findViewById(R.id.recyclerView); mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)); mRecyclerView.setAdapter(new RecyclerViewAdapter(this)); &#125;&#125; 效果 参考文章 Android Design Support Library（三）用CoordinatorLayout实现Toolbar隐藏和折叠","tags":[{"name":"Android5.X","slug":"Android5-X","permalink":"http://liuguoquan727.github.io/tags/Android5-X/"}]},{"title":"TabLayout实现网易新闻滑动标签效果","date":"2016-02-24T13:46:03.000Z","path":"2016/02/24/Android Design Support Library之TabLayout/","text":"TabLayout是Android Design Support Library库中的控件。Google在2015年的IO大会上，给我们带来了更加详细的Material Design设计规范，同时也给我们带来了全新的Android Design Support Library，在这个support库中,Google给我们提供了更加规范的MD设计风格的控件。最重要的是，Android Design Support Library可以向下兼容到Android 2.2。 接下来，我们开始熟悉TabLayout的使用，并完成一个类似网易新闻客户端滑动标签的效果，它的滑动标签由Toolbar+TabLayout实现，内容显示由ViewPager+Fragment实现。 配置build.gradle123456789dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs') testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:23.1.1' compile 'com.android.support:recyclerview-v7:23.1.1' compile 'com.android.support:support-v4:23.1.1' compile 'com.android.support:cardview-v7:23.1.1' compile 'com.android.support:design:23.2.0'&#125; com.android.support:design:23.2.0就是我们需要引入的Android Design Support Library，其次我们还引入了RecyclerView和CardView两个Android 5.X的新控件。 主界面的布局主界面的布局由AppBarLayout、Toolbar和TabLayout，以及ViewPager组成，主界面布局文件activity_main.xml如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" android:orientation=\"vertical\"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"@style/AppTheme.AppBarOverlay\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" app:layout_scrollFlags=\"scroll|enterAlways\" app:popupTheme=\"@style/AppTheme.PopupOverlay\" /&gt; &lt;android.support.design.widget.TabLayout android:id=\"@+id/tabs\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:tabIndicatorColor=\"#ADBE107E\" app:tabMode=\"scrollable\"&gt; &lt;/android.support.design.widget.TabLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/viewpager\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; &lt;/android.support.v4.view.ViewPager&gt;&lt;/LinearLayout&gt; 这里用到AppBarLayout和Toolbar，AppBarLayout是Android Design Support Library新加的空间继承自LinearLayout，它用来将Toolbar和TabLayout组合起来成为一个整体。ViewPager用来实现Fragment页面的切换 布局文件中最关键的一点是android.support.design.widget.TabLayout的app:tabMode=”scrollable”，它表示tab标签的模式是可滑动的，如果不设置次模式的话，标签将不可滑动。 主界面的实现 实例化TabLayout，给TabLayout标签设置文字 实例化FragmentAdapter，加载Fragment 实例化ViewPager，并设置ViewPager的适配器FragmentAdapter TabLayout与ViewPager关联 TabLayout设置适配器FragmentAdapter MainActivity.java如下所示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.deason.library.mytablayout;import android.os.Bundle;import android.support.design.widget.TabLayout;import android.support.v4.app.Fragment;import android.support.v4.view.ViewPager;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.Toolbar;import android.view.Menu;import android.view.MenuItem;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; private ViewPager mViewPager; private TabLayout mTabLayout; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); mViewPager = (ViewPager) findViewById(R.id.viewpager); initViewPager(); &#125; private void initViewPager() &#123; mTabLayout = (TabLayout) findViewById(R.id.tabs); List&lt;String&gt; titles = new ArrayList&lt;String&gt;(); titles.add(\"新闻\"); titles.add(\"财经\"); titles.add(\"娱乐\"); titles.add(\"体育\"); titles.add(\"军事\"); titles.add(\"科技\"); titles.add(\"教育\"); titles.add(\"历史\"); titles.add(\"文化\"); titles.add(\"校园\"); for(int i= 0;i &lt; titles.size();i++) &#123; //设置TabIndicator文字 mTabLayout.addTab(mTabLayout.newTab().setText(titles.get(i))); &#125; List&lt;Fragment&gt; fragments = new ArrayList&lt;Fragment&gt;(); for (int i = 0; i &lt; titles.size(); i++) &#123; fragments.add(new TabFragment()); &#125; //实例化适配器 FragmentAdapter mAdapter = new FragmentAdapter(getSupportFragmentManager(),fragments,titles); //给ViewPager设置适配器 mViewPager.setAdapter(mAdapter); //将TabLayout和ViewPager关联起来 mTabLayout.setupWithViewPager(mViewPager); //给TabLayout设置适配器 mTabLayout.setTabsFromPagerAdapter(mAdapter); &#125;&#125; 实例化FragmentAdapterFragmentAdapter.java 123456789101112131415161718192021222324252627282930313233343536373839package com.deason.library.mytablayout;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentPagerAdapter;import java.util.List;/** * Created by liuguoquan on 2016/2/24. */public class FragmentAdapter extends FragmentPagerAdapter &#123; private List&lt;Fragment&gt; mFragments; private List&lt;String&gt; mTitles; public FragmentAdapter(FragmentManager fm,List&lt;Fragment&gt; fragments,List&lt;String&gt; titles) &#123; super(fm); this.mFragments = fragments; this.mTitles = titles; &#125; @Override public Fragment getItem(int position) &#123; return mFragments.get(position); &#125; @Override public int getCount() &#123; return mFragments.size(); &#125; //Tabs标签名称 @Override public CharSequence getPageTitle(int position) &#123; return mTitles.get(position); &#125;&#125; TabFragment123456789101112131415161718192021222324252627282930313233343536package com.deason.library.mytablayout;import android.os.Bundle;import android.support.v4.app.Fragment;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;/** * A simple &#123;@link Fragment&#125; subclass. */public class TabFragment extends Fragment &#123; private RecyclerView mRecyclerView; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // Inflate the layout for this fragment View view = inflater.inflate(R.layout.fragment_list,container,false); return view; &#125; @Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); &#125;&#125; 运行效果","tags":[{"name":"Android5.X","slug":"Android5-X","permalink":"http://liuguoquan727.github.io/tags/Android5-X/"}]},{"title":"Android Design Support Library之NavigationView","date":"2016-02-22T14:46:03.000Z","path":"2016/02/22/Android Design Support Library之NavigationView/","text":"NavigationView在MD设计中非常重要，之前Google提出使用Drawlayout来实现导航抽屉。这次，在Android Design Support Library中Google官方提供了NavigationView来实现导航菜单界面。 下面，我们开始用NavigationView来实现抽屉菜单界面 配置build.gradle:123456dependencies &#123; compile fileTree(include: ['*.jar'], dir: 'libs') testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:23.2.0' compile 'com.android.support:design:23.2.0'&#125; com.android.support:design:23.2.0就是我们需要引入的Android Design Support Library。 主界面布局activity_main.xml 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/drawer_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" tools:openDrawer=\"start\"&gt; &lt;include layout=\"@layout/app_bar_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; &lt;android.support.design.widget.NavigationView android:id=\"@+id/nav_view\" android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" android:fitsSystemWindows=\"true\" app:headerLayout=\"@layout/nav_header_main\" app:menu=\"@menu/activity_main_drawer\" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; DrawerLayout标签包含了主界面的布局以及抽屉的布局NavigationView标签下的app:headerLayout用于引入抽屉的头部布局，app:menu用于引入抽屉的菜单布局所以上面布局需要引入另外三个布局文件 app_bar_main.xml主界面展示的内容: 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" tools:context=\"com.deason.library.mynavigationview.MainActivity\"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"@style/AppTheme.AppBarOverlay\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" app:popupTheme=\"@style/AppTheme.PopupOverlay\" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;include layout=\"@layout/content_main\" /&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|end\" android:layout_margin=\"@dimen/fab_margin\" android:src=\"@android:drawable/ic_dialog_email\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; nav_header_main.xml抽屉的头布局文件: 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"@dimen/nav_header_height\" android:background=\"@drawable/side_nav_bar\" android:gravity=\"bottom\" android:orientation=\"vertical\" android:paddingBottom=\"@dimen/activity_vertical_margin\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark\"&gt; &lt;ImageView android:id=\"@+id/imageView\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:paddingTop=\"@dimen/nav_header_vertical_spacing\" android:src=\"@android:drawable/sym_def_app_icon\" /&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:paddingTop=\"@dimen/nav_header_vertical_spacing\" android:text=\"Android Studio\" android:textAppearance=\"@style/TextAppearance.AppCompat.Body1\" /&gt; &lt;TextView android:id=\"@+id/textView\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"android.studio@android.com\" /&gt;&lt;/LinearLayout&gt; android:background=”@drawable/side_nav_bar”则是设置了头布局的背景颜色，这里使用的是自定义shape来实现 123456789&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\"&gt; &lt;gradient android:angle=\"135\" android:centerColor=\"#FFFF00\" android:endColor=\"#2E7D32\" android:startColor=\"#81C784\" android:type=\"linear\" /&gt;&lt;/shape&gt; activity_main_drawer.xml抽屉的菜单布局文件 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;group android:checkableBehavior=\"single\"&gt; &lt;item android:id=\"@+id/nav_camera\" android:icon=\"@drawable/ic_menu_camera\" android:title=\"Import\" /&gt; &lt;item android:id=\"@+id/nav_gallery\" android:icon=\"@drawable/ic_menu_gallery\" android:title=\"Gallery\" /&gt; &lt;item android:id=\"@+id/nav_slideshow\" android:icon=\"@drawable/ic_menu_slideshow\" android:title=\"Slideshow\" /&gt; &lt;item android:id=\"@+id/nav_manage\" android:icon=\"@drawable/ic_menu_manage\" android:title=\"Tools\" /&gt; &lt;/group&gt; &lt;item android:title=\"Communicate\"&gt; &lt;menu&gt; &lt;item android:id=\"@+id/nav_share\" android:icon=\"@drawable/ic_menu_share\" android:title=\"Share\" /&gt; &lt;item android:id=\"@+id/nav_send\" android:icon=\"@drawable/ic_menu_send\" android:title=\"Send\" /&gt; &lt;/menu&gt; &lt;/item&gt;&lt;/menu&gt; Java代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package com.deason.library.mynavigationview;import android.os.Bundle;import android.support.design.widget.FloatingActionButton;import android.support.design.widget.Snackbar;import android.view.View;import android.support.design.widget.NavigationView;import android.support.v4.view.GravityCompat;import android.support.v4.widget.DrawerLayout;import android.support.v7.app.ActionBarDrawerToggle;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.Toolbar;import android.view.Menu;import android.view.MenuItem;public class MainActivity extends AppCompatActivity implements NavigationView.OnNavigationItemSelectedListener &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); getSupportActionBar().setDisplayHomeAsUpEnabled(true); FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Snackbar.make(view, \"Replace with your own action\", Snackbar.LENGTH_LONG) .setAction(\"Action\", null).show(); &#125; &#125;); DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout); ActionBarDrawerToggle toggle = new ActionBarDrawerToggle( this, drawer, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close); drawer.addDrawerListener(toggle); //'com.android.support:design:23.2.0'中新增的方法，之版本用drawer.setDrawerListener(toggle)这个方法 toggle.syncState(); NavigationView navigationView = (NavigationView) findViewById(R.id.nav_view); //监听侧滑栏item选择事件 navigationView.setNavigationItemSelectedListener(this); &#125; @Override public void onBackPressed() &#123; DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout); if (drawer.isDrawerOpen(GravityCompat.START)) &#123; drawer.closeDrawer(GravityCompat.START); &#125; else &#123; super.onBackPressed(); &#125; &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item.getItemId(); //noinspection SimplifiableIfStatement if (id == R.id.action_settings) &#123; return true; &#125; return super.onOptionsItemSelected(item); &#125; /** * 监听抽屉菜单栏的点击事件 * @param item * @return */ @SuppressWarnings(\"StatementWithEmptyBody\") @Override public boolean onNavigationItemSelected(MenuItem item) &#123; // Handle navigation view item clicks here. int id = item.getItemId(); if (id == R.id.nav_camera) &#123; // Handle the camera action &#125; else if (id == R.id.nav_gallery) &#123; &#125; else if (id == R.id.nav_slideshow) &#123; &#125; else if (id == R.id.nav_manage) &#123; &#125; else if (id == R.id.nav_share) &#123; &#125; else if (id == R.id.nav_send) &#123; &#125; //关闭侧滑栏 DrawerLayout drawer = (DrawerLayout) findViewById(R.id.drawer_layout); drawer.closeDrawer(GravityCompat.START); return true; &#125;&#125; 效果 参考文章Android Design Support Library（二）用NavigationView实现抽屉菜单界面","tags":[{"name":"Android5.X","slug":"Android5-X","permalink":"http://liuguoquan727.github.io/tags/Android5-X/"}]},{"title":"Android 5.x之RecyclerView","date":"2016-02-20T14:46:03.000Z","path":"2016/02/20/Android 5.x之RecyclerView/","text":"RecyclerView是Android官方推出的旨在取代ListView、GridView的控件，可以通过导入support-V7进行使用。据官方介绍，该控件用于在有限的窗口中展示大量数据集，同样能实现此效果的有ListView、GridView。 那么有了ListView、GridView之后为什么还需要RecyclerView这样的控件呢？整体上看RecyclerView架构，它提供了一种插拔式的体验，高度的解耦，异常的灵活，通过设置它提供不同的LayoutManager、ItemDecoration、ItemAnimator来实现各种各样的效果。 控制其显示的布局方式，请设置布局管理器LayoutManager 控制Item间的间隔，请实现ItemDecoration 控制Item间增删的动画，请实现ItemAnimator 控制其点击、长按事件，不好意思请自己写 下面，我们开始进入RecyclerView的体验之旅 build.gradle要想使用RecyclerView，首先我们要导入support-V7包，Android Studio中需要的build.gradle文件中加入下面代码自动导入V7包。 123456789dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:23.1.1' //v7 compile 'com.android.support:design:23.1.1' compile 'com.android.support:cardview-v7:23.1.1' compile 'com.android.support:recyclerview-v7:23.1.1' compile 'com.android.support:palette-v7:23.1.1'&#125; RecyclerView实现ListView效果 实例化RecyclerView 设置RecyclerView的布局（有ListView、GridView和瀑布流三种效果，水平和垂直两个方向） 设置RecyclerView的Item分割线 设置RecyclerView的Item增删时的动画 实例化一个RecyclerViewAdapter 设置RecyclerView的Adapter 1234567891011121314mRecyclerView = (RecyclerView) findViewById(R.id.recyclerview);//设置布局管理器mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)); //垂直方向的list//mRecyclerView.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false)); //水平方向的list//增加Item分割线，必须在setAdapter方法之前设置mRecyclerView.addItemDecoration(new DividerItemDecoration(this, DividerItemDecoration.VERTICAL_LIST));//设置增加和删除条目时的动画mRecyclerView.setItemAnimator(new DefaultItemAnimator());mAdapter = new RecyclerViewAdapter(this,mDatas);mRecyclerView.setAdapter(mAdapter); 主界面布局RecyclerView的类名全称为android.support.v7.widget.RecyclerView 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" tools:context=\"com.example.michael.recyclerviewdemo.MainActivity\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/appbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"@style/AppTheme.AppBarOverlay\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" app:popupTheme=\"@style/AppTheme.PopupOverlay\" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recyclerview\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;/LinearLayout&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|end\" android:layout_margin=\"@dimen/fab_margin\" android:src=\"@android:drawable/ic_dialog_email\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 分割线DividerItemDecorationDividerItemDecoration是实现的是RecyclerView作为ListView效果时的分割线。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.example.michael.recyclerviewdemo;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Rect;import android.graphics.drawable.Drawable;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import android.view.View;/** * 横向和纵向的分割线 * Created by Michael on 2016/2/25. */public class DividerItemDecoration extends RecyclerView.ItemDecoration &#123; private static final int[] ATTRS = new int[]&#123; android.R.attr.listDivider &#125;; public static final int HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL; public static final int VERTICAL_LIST = LinearLayoutManager.VERTICAL; private Drawable mDivider; private int mOrientation; public DividerItemDecoration(Context context, int orientation) &#123; final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); a.recycle(); setOrientation(orientation); &#125; public void setOrientation(int orientation) &#123; if (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) &#123; throw new IllegalArgumentException(\"invalid orientation\"); &#125; mOrientation = orientation; &#125; @Override public void onDraw(Canvas c, RecyclerView parent) &#123; if (mOrientation == VERTICAL_LIST) &#123; drawVertical(c, parent); &#125; else &#123; drawHorizontal(c, parent); &#125; &#125; public void drawVertical(Canvas c, RecyclerView parent) &#123; final int left = parent.getPaddingLeft(); final int right = parent.getWidth() - parent.getPaddingRight(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); android.support.v7.widget.RecyclerView v = new android.support.v7.widget.RecyclerView(parent.getContext()); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int top = child.getBottom() + params.bottomMargin; final int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; public void drawHorizontal(Canvas c, RecyclerView parent) &#123; final int top = parent.getPaddingTop(); final int bottom = parent.getHeight() - parent.getPaddingBottom(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int left = child.getRight() + params.rightMargin; final int right = left + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; @Override public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) &#123; if (mOrientation == VERTICAL_LIST) &#123; outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); &#125; else &#123; outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); &#125; &#125;&#125; 实现AdapterRecyclerViewAdapter用于RecyclerView作为ListView和GridView效果时Adapter，通过其构造函数传入Context和需要绑定的数据集合。一个基本的Adapter里面有需要实现如下功能： 创建RecyclerView.ViewHolder的子类 视图与数据绑定 点击事件回调接口 Item的增加和删除更新 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.example.michael.recyclerviewdemo;import android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import java.util.List;/** * Created by Michael on 2016/2/25. */public class RecyclerViewAdapter extends RecyclerView.Adapter&lt;RecyclerViewAdapter.MyViewHolder&gt; &#123; private Context mContext; private List&lt;String&gt; mDatas; private OnItemClickListener mListener; /** * 点击事件回调接口 */ public interface OnItemClickListener &#123; void onItemClick(View view, int position); void onItemLongClick(View view, int position); &#125; public void setOnItemClickListener(OnItemClickListener listener) &#123; this.mListener = listener; &#125; public RecyclerViewAdapter(Context context, List&lt;String&gt; datas) &#123; this.mContext = context; mDatas = datas; &#125; //实例化ViewHolder @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item_recyclerview, parent, false); return new MyViewHolder(view); &#125; //绑定数据 @Override public void onBindViewHolder(final MyViewHolder holder, final int position) &#123; System.out.println(position); holder.mClickBtn.setText(mDatas.get(position)); if (mListener != null) &#123; holder.mClickBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //获取实际的位置 int pos = holder.getLayoutPosition(); mListener.onItemClick(holder.mClickBtn,pos); &#125; &#125;); holder.mClickBtn.setOnLongClickListener(new View.OnLongClickListener() &#123; @Override public boolean onLongClick(View v) &#123; int pos = holder.getLayoutPosition(); mListener.onItemLongClick(holder.mClickBtn,pos); return true; //屏蔽单击 false点击事件仍会响应 &#125; &#125;); &#125; &#125; @Override public int getItemCount() &#123; return mDatas.size(); &#125; /** * 在当前Item之前添加Item */ public void addPreItem(String data,int position) &#123; mDatas.add(position,data); notifyItemInserted(position); &#125; /** * 在当前Item之后添加Item */ public void addNextItem(String data,int position) &#123; mDatas.add(position+1,data); notifyItemInserted(position+1); &#125; /** * 删除Item * @param position */ public void removeItem(int position) &#123; mDatas.remove(position); notifyItemRemoved(position); &#125; class MyViewHolder extends RecyclerView.ViewHolder &#123; TextView mClickBtn; public MyViewHolder(View itemView) &#123; super(itemView); mClickBtn = (TextView) itemView.findViewById(R.id.btn_click); &#125; &#125;&#125; RecyclerView的Item布局item_recycleview.xml 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"60dp\" android:orientation=\"vertical\"&gt; &lt;!-- android:background=\"?android:attr/selectableItemBackground设置点击时水波纹效果 Android5.0以上有效果 --&gt; &lt;TextView android:id=\"@+id/btn_click\" android:clickable=\"true\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"?android:attr/selectableItemBackground\" android:gravity=\"center\" android:text=\"点击\"/&gt;&lt;/LinearLayout&gt; 实现RecyclerView123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package com.example.michael.recyclerviewdemo;import android.content.DialogInterface;import android.content.Intent;import android.os.Bundle;import android.support.design.widget.FloatingActionButton;import android.support.design.widget.Snackbar;import android.support.v7.app.AlertDialog;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.DefaultItemAnimator;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import android.support.v7.widget.StaggeredGridLayoutManager;import android.support.v7.widget.Toolbar;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.Toast;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity &#123; private RecyclerView mRecyclerView; private RecyclerViewAdapter mAdapter; private StaggeredAdapter mStaggeredAdapter; private List&lt;String&gt; mDatas; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab); fab.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Snackbar.make(view, \"Replace with your own action\", Snackbar.LENGTH_LONG) .setAction(\"Action\", null).show(); &#125; &#125;); initView(); initData(); initEvent(); &#125; private void initView() &#123; mRecyclerView = (RecyclerView) findViewById(R.id.recyclerview); &#125; private void initData() &#123; mDatas = new ArrayList&lt;String&gt;(); for(int i = 0;i &lt; 20;i++) &#123; mDatas.add(String.valueOf(i)); &#125; setListView(); &#125; /** * ListView效果 */ private void setListView() &#123; //设置布局管理器 mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)); //垂直方向的list// mRecyclerView.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false)); //水平方向的list //增加Item分割线，必须在setAdapter方法之前设置 mRecyclerView.addItemDecoration(new DividerItemDecoration(this, DividerItemDecoration.VERTICAL_LIST)); //设置增加和删除条目时的动画 mRecyclerView.setItemAnimator(new DefaultItemAnimator()); mAdapter = new RecyclerViewAdapter(this,mDatas); mRecyclerView.setAdapter(mAdapter); &#125; private void initEvent()&#123; //实现RecyclerView的点击事件 mAdapter.setOnItemClickListener(new RecyclerViewAdapter.OnItemClickListener() &#123; @Override public void onItemClick(View view, final int position) &#123; Toast.makeText(MainActivity.this,\"onItemClick: \" +position,Toast.LENGTH_SHORT).show(); AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); builder.setTitle(\"添加Item\"); builder.setPositiveButton(\"确定\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; mAdapter.addNextItem(\"add pre\",position); &#125; &#125;); builder.show(); &#125; @Override public void onItemLongClick(View view, final int position) &#123; Toast.makeText(MainActivity.this,\"onItemLongClick \" + position,Toast.LENGTH_SHORT).show(); AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); builder.setTitle(\"删除Item\"); builder.setPositiveButton(\"确定\", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; mAdapter.removeItem(position); &#125; &#125;); builder.show(); &#125; &#125;); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.menu_main,menu); return super.onCreateOptionsMenu(menu); &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.action_settings: Intent intent = new Intent(MainActivity.this,CardViewActivity.class); startActivity(intent); break; &#125; return super.onOptionsItemSelected(item); &#125;&#125; 效果 RecyclerView实现GridView效果RecyclerView实现GridView与实现ListView效果的不同之处有两点： 布局管理器为StaggeredGridLayoutManager Item间隔类为DividerGridItemDecoration DividerGridItemDecoration123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175package com.example.michael.recyclerviewdemo;import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Rect;import android.graphics.drawable.Drawable;import android.support.v7.widget.GridLayoutManager;import android.support.v7.widget.RecyclerView;import android.support.v7.widget.StaggeredGridLayoutManager;import android.view.View;/** * GridView分割线 * Created by Michael on 2016/2/25. */public class DividerGridItemDecoration extends RecyclerView.ItemDecoration &#123; //系统theme.xml中,可以自定义 private static final int[] ATTRS = new int[] &#123; android.R.attr.listDivider &#125;; private Drawable mDivider; public DividerGridItemDecoration(Context context) &#123; final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); a.recycle(); &#125; @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; drawHorizontal(c, parent); drawVertical(c, parent); &#125; private int getSpanCount(RecyclerView parent) &#123; // 列数 int spanCount = -1; RecyclerView.LayoutManager layoutManager = parent.getLayoutManager(); if (layoutManager instanceof GridLayoutManager) &#123; spanCount = ((GridLayoutManager) layoutManager).getSpanCount(); &#125; else if (layoutManager instanceof StaggeredGridLayoutManager) &#123; spanCount = ((StaggeredGridLayoutManager) layoutManager) .getSpanCount(); &#125; return spanCount; &#125; public void drawHorizontal(Canvas c, RecyclerView parent) &#123; int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int left = child.getLeft() - params.leftMargin; final int right = child.getRight() + params.rightMargin + mDivider.getIntrinsicWidth(); final int top = child.getBottom() + params.bottomMargin; final int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; public void drawVertical(Canvas c, RecyclerView parent) &#123; final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int top = child.getTop() - params.topMargin; final int bottom = child.getBottom() + params.bottomMargin; final int left = child.getRight() + params.rightMargin; final int right = left + mDivider.getIntrinsicWidth(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; private boolean isLastColum(RecyclerView parent, int pos, int spanCount, int childCount) &#123; RecyclerView.LayoutManager layoutManager = parent.getLayoutManager(); if (layoutManager instanceof GridLayoutManager) &#123; if ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边 &#123; return true; &#125; &#125; else if (layoutManager instanceof StaggeredGridLayoutManager) &#123; int orientation = ((StaggeredGridLayoutManager) layoutManager) .getOrientation(); if (orientation == StaggeredGridLayoutManager.VERTICAL) &#123; if ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边 &#123; return true; &#125; &#125; else &#123; childCount = childCount - childCount % spanCount; if (pos &gt;= childCount)// 如果是最后一列，则不需要绘制右边 return true; &#125; &#125; return false; &#125; private boolean isLastRaw(RecyclerView parent, int pos, int spanCount, int childCount) &#123; RecyclerView.LayoutManager layoutManager = parent.getLayoutManager(); if (layoutManager instanceof GridLayoutManager) &#123; childCount = childCount - childCount % spanCount; if (pos &gt;= childCount)// 如果是最后一行，则不需要绘制底部 return true; &#125; else if (layoutManager instanceof StaggeredGridLayoutManager) &#123; int orientation = ((StaggeredGridLayoutManager) layoutManager) .getOrientation(); // StaggeredGridLayoutManager 且纵向滚动 if (orientation == StaggeredGridLayoutManager.VERTICAL) &#123; childCount = childCount - childCount % spanCount; // 如果是最后一行，则不需要绘制底部 if (pos &gt;= childCount) return true; &#125; else // StaggeredGridLayoutManager 且横向滚动 &#123; // 如果是最后一行，则不需要绘制底部 if ((pos + 1) % spanCount == 0) &#123; return true; &#125; &#125; &#125; return false; &#125; @Override public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) &#123; int spanCount = getSpanCount(parent); int childCount = parent.getAdapter().getItemCount(); if (isLastRaw(parent, itemPosition, spanCount, childCount))// 如果是最后一行，则不需要绘制底部 &#123; outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); &#125; else if (isLastColum(parent, itemPosition, spanCount, childCount))// 如果是最后一列，则不需要绘制右边 &#123; outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); &#125; else &#123; outRect.set(0, 0, mDivider.getIntrinsicWidth(), mDivider.getIntrinsicHeight()); &#125; &#125;&#125; 实现12345678910111213141516171819202122232425/** * GridView效果 */private void setGridView() &#123; mRecyclerView.setLayoutManager(new GridLayoutManager(this,4)); mRecyclerView.addItemDecoration(new DividerGridItemDecoration(this)); mRecyclerView.setItemAnimator(new DefaultItemAnimator()); mAdapter = new RecyclerViewAdapter(this,mDatas); mRecyclerView.setAdapter(mAdapter);&#125;或者private void setGridView() &#123; mRecyclerView.setLayoutManager(new StaggeredGridLayoutManager(4, StaggeredGridLayoutManager.VERTICAL)); mRecyclerView.addItemDecoration(new DividerGridItemDecoration(this)); mRecyclerView.setItemAnimator(new DefaultItemAnimator()); mAdapter = new RecyclerViewAdapter(this,mDatas); mRecyclerView.setAdapter(mAdapter);&#125; 注意：StaggeredGridLayoutManager构造的第二个参数传一个orientation，如果传入的是StaggeredGridLayoutManager.VERTICAL代表有多少列；那么传入的如果是StaggeredGridLayoutManager.HORIZONTAL就代表有多少行。 效果 RecyclerView实现瀑布流效果RecyclerView实现瀑布流效果与实现ListView效果的不同之处有三点： 布局管理器为StaggeredGridLayoutManager Item间隔类为DividerGridItemDecoration Adapter不同，实现瀑布流需要在adaper写一个随机的高度来控制每个item的高度就可以了，通常这个高度是由服务端返回的数据高度来控制的。 实现123456789101112/** * 瀑布流效果 */private void setWaterfallView() &#123; mRecyclerView.setLayoutManager(new StaggeredGridLayoutManager(4,StaggeredGridLayoutManager.VERTICAL)); mRecyclerView.addItemDecoration(new DividerGridItemDecoration(this)); mRecyclerView.setItemAnimator(new DefaultItemAnimator()); mStaggeredAdapter = new StaggeredAdapter(this,mDatas); mRecyclerView.setAdapter(mStaggeredAdapter);&#125; 注意：StaggeredGridLayoutManager构造的第二个参数传一个orientation，如果传入的是StaggeredGridLayoutManager.VERTICAL代表有多少列；那么传入的如果是StaggeredGridLayoutManager.HORIZONTAL就代表有多少行。 StaggeredAdapterStaggeredAdapter写一个随机的高度来控制每个item的高度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150package com.example.michael.recyclerviewdemo;import android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import java.util.ArrayList;import java.util.List;/** * 实现瀑布流的Adapter,增加一个高度列表，随机生成View的高度 * Created by Michael on 2016/2/25. */public class StaggeredAdapter extends RecyclerView.Adapter&lt;StaggeredAdapter.MyViewHolder&gt; &#123; private Context mContext; private List&lt;String&gt; mDatas; private List&lt;Integer&gt; mHeights; private OnItemClickListener mListener; /** * 点击事件回调接口 */ public interface OnItemClickListener &#123; void onItemClick(View view, int position); void onItemLongClick(View view, int position); &#125; public void setOnItemClickListener(OnItemClickListener listener) &#123; this.mListener = listener; &#125; public StaggeredAdapter(Context context, List&lt;String&gt; datas) &#123; this.mContext = context; mDatas = datas; mHeights = new ArrayList&lt;Integer&gt;(); //生成随机高度 for(int i = 0;i &lt; mDatas.size();i++) &#123; mHeights.add((int) (100 + Math.random() * 300)); &#125; &#125; @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(mContext).inflate(R.layout.item_recyclerview, parent, false); return new MyViewHolder(view); &#125; @Override public void onBindViewHolder(final MyViewHolder holder, final int position) &#123; //设置Item的高度 ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams(); layoutParams.height = mHeights.get(position); holder.itemView.setLayoutParams(layoutParams); holder.mClickBtn.setText(mDatas.get(position)); if (mListener != null) &#123; holder.mClickBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //获取实际的位置 int pos = holder.getLayoutPosition(); mListener.onItemClick(holder.mClickBtn,pos); &#125; &#125;); holder.mClickBtn.setOnLongClickListener(new View.OnLongClickListener() &#123; @Override public boolean onLongClick(View v) &#123; int pos = holder.getLayoutPosition(); mListener.onItemLongClick(holder.mClickBtn,pos); return true; //屏蔽单击 false点击事件仍会响应 &#125; &#125;); &#125; &#125; @Override public int getItemCount() &#123; return mDatas.size(); &#125; /** * 在当前Item之前添加Item */ public void addPreItem(String data,int position) &#123; mDatas.add(position,data); mHeights.add( (int) (100 + Math.random() * 300)); notifyItemInserted(position); &#125; /** * 在当前Item之后添加Item */ public void addNextItem(String data,int position) &#123; mDatas.add(position+1,data); mHeights.add((int) (100 + Math.random() * 300)); notifyItemInserted(position + 1); &#125; /** * 删除Item * @param position */ public void removeItem(int position) &#123; mDatas.remove(position); mHeights.remove(position); notifyItemRemoved(position); &#125; class MyViewHolder extends RecyclerView.ViewHolder &#123; TextView mClickBtn; public MyViewHolder(View itemView) &#123; super(itemView); mClickBtn = (TextView) itemView.findViewById(R.id.btn_click); &#125; &#125;&#125; 效果 修改分割线DividerItemDecoration和DividerGridItemDecoration的实现类都是通过读取系统主题中的android.R.attr.listDivider来作为Item间的分割线，并且支持纵向和横向，获取到listDivider熟悉后，该属性的值是个Drawable，在getItemOffsets中，outRect去设置了绘制的范围，onDraw中实现了真正的绘制。 该分割线是系统默认的，你可以在theme.xml文件中找到该属性的使用情况。那么，使用系统的listDivide有什么好处呢？就是方便我们去随意的改变，该属性我们可以直接声明在： 1234&lt;!-- Application theme. --&gt; &lt;style name=\"AppTheme\" parent=\"AppBaseTheme\"&gt; &lt;item name=\"android:listDivider\"&gt;@drawable/divider_bg&lt;/item&gt; &lt;/style&gt; 然后自己写个Drawable即可，下面我们换一种分隔符 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\" &gt; &lt;gradient android:centerColor=\"#ff00ff00\" android:endColor=\"#ff0000ff\" android:startColor=\"#ffff0000\" android:type=\"linear\" /&gt; &lt;size android:height=\"4dp\"/&gt;&lt;/shape&gt; 效果如下: #参考资料 Android RecyclerView 使用完全解析 体验艺术般的控件Android5.x RecyclerView 应用解析","tags":[{"name":"Android5.X","slug":"Android5-X","permalink":"http://liuguoquan727.github.io/tags/Android5-X/"}]},{"title":"Android 5.x之CardView","date":"2016-02-19T15:45:03.000Z","path":"2016/02/19/Android 5.x之CardView/","text":"Android 5.x版本中增加了CardView控件，CardView继承自FrameLayout类，它的功能是实现在一个卡片布局中显示相同的内容，卡片布局可以设置圆角和阴影，还可以布局其他的View。CardView即可作为一般的布局使用，也可以作为RecyclerView的Item使用。 接来下，我们进入CardView学习之旅 build.gradle首先，和RecyclerView一样，导入v7兼容包 123456789dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:23.1.1' compile 'com.android.support:design:23.1.1' compile 'com.android.support:cardview-v7:23.1.1' //cardview compile 'com.android.support:recyclerview-v7:23.1.1' compile 'com.android.support:palette-v7:23.1.1'&#125; CardView布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:card_view=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:padding=\"5dp\"&gt; &lt;!--android:foreground=\"?android:attr/selectableItemBackground\"点击CardView时前景色水波纹效果--&gt; &lt;android.support.v7.widget.CardView android:id=\"@+id/cardview\" android:layout_width=\"match_parent\" android:layout_height=\"200dp\" android:foreground=\"?android:attr/selectableItemBackground\" card_view:cardCornerRadius=\"20dp\" card_view:cardElevation=\"20dp\" card_view:contentPadding=\"10dp\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#585858\" android:orientation=\"horizontal\"&gt; &lt;ImageView android:id=\"@+id/iv_image\" android:layout_width=\"150dp\" android:layout_height=\"150dp\" android:layout_gravity=\"center_vertical\" android:src=\"@drawable/mao\" /&gt; &lt;TextView android:id=\"@+id/tv_msg\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_vertical\" android:gravity=\"center_vertical\" android:text=\"123456789\" /&gt; &lt;/LinearLayout&gt; &lt;/android.support.v7.widget.CardView&gt; &lt;Button android:id=\"@+id/btn_click\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt;&lt;/LinearLayout&gt; card_view:cardCornerRadius=”20dp”： 设置CardView的圆角半径 card_view:cardElevation=”20dp”： 设置CardView的阴影半径card_view:contentPadding=”10dp”： 设置CardView中子控件和父控件的距离 java代码调用12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.example.michael.recyclerviewdemo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.support.v7.widget.CardView;import android.view.View;import android.widget.Button;import android.widget.TextView;import android.widget.Toast;/** * Created by Michael on 2016/2/25. */public class CardViewActivity extends AppCompatActivity &#123; private CardView mCardView; private Button mButton; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_cardview); mButton = (Button) findViewById(R.id.btn_click); mCardView = (CardView) findViewById(R.id.cardview); mCardView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(CardViewActivity.this, \"click\", Toast.LENGTH_SHORT).show(); &#125; &#125;); //找到CardView中的子View TextView mTextMsg = (TextView) mCardView.findViewById(R.id.tv_msg); mTextMsg.setText(\"text msg\"); mCardView.setRadius(10.0f); //设置CardView的圆角半径 mCardView.setCardElevation(10.0f); //设置CardView的阴影半径 mCardView.setContentPadding(5,5,5,5); //设置CardView的父控件与子控件的距离 &#125;&#125; 运行效果 参考资料Android5.x CardView 应用解析","tags":[{"name":"Android5.X","slug":"Android5-X","permalink":"http://liuguoquan727.github.io/tags/Android5-X/"}]},{"title":"Android 5.x之 Notification","date":"2016-02-18T14:46:03.000Z","path":"2016/02/18/Android 5.x之 Notification/","text":"Notification可以让我们在获得消息的时候，在状态栏、锁屏界面来显示相应的消息，如果没有Notification的话，很难想象我们的QQ和微信以及其他应用就没有办法主动通知我们，我们需要时候打开手机检查是否有新的消息到来，而这着实让人不爽。接下来，我们介绍三种Notification，分别是普通Notification，折叠式Notification和悬挂式Notification。 普通Notification首先，创建Builder对象，创建一个PendingIntent来实现消息点击跳转事件。 123Notification.Builder builder = new Notification.Builder(this);Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(\"https://www.baidu.com/\"));PendingIntent pendingIntent = PendingIntent.getActivity(this,0,intent,0); 其次，通过builder给Notification添加不同的属性： 12345builder.setContentIntent(pendingIntent);builder.setSmallIcon(R.mipmap.ic_launcher);builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));builder.setAutoCancel(true);builder.setContentTitle(\"普通Notification\"); 最后，创建NotifcationManager对象，调用notify发送一个通知 12mManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);mManager.notify(0, builder.build()); 效果如下： 折叠式Notification折叠式Notification是一种自定义视图的Notification，用来显示长文本和一些自定义的布局的场景。它有两种状态，一种是普通状态下的视图（如果不是自定义的话和上面普通通知的视图样式一样）；一种是展开状态下的视图，它需要自定义视图，并且这个自定义视图的显示的进程和我们创建视图的进程不是一个进程，需要使用RemoteViews。 首先，使用RemoteViews创建自定义视图 12//用RemoteViews来创建自定义Notification视图RemoteViews remoteViews = new RemoteViews(getPackageName(),R.layout.fold_notification); 视图的布局： 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"100dp\" android:background=\"#000000\" android:orientation=\"horizontal\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textColor=\"#ffffffff\" android:text=\"自定义的视图\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:textColor=\"#ffffffff\" android:text=\"折叠式通知\"/&gt;&lt;/LinearLayout&gt; 其次，把自定义视图赋给Notification 12345//赋值给Notification展开时的视图notification.bigContentView = remoteViews;或//赋值给Notification普通状态时的视图notification.contentView = remoteViews; 折叠式Notification的完整代码为: 1234567891011121314151617Notification.Builder builder = new Notification.Builder(this);Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(\"https://www.baidu.com/\"));PendingIntent pendingIntent = PendingIntent.getActivity(this,0,intent,0);builder.setContentIntent(pendingIntent);builder.setSmallIcon(R.mipmap.ic_launcher);builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));builder.setAutoCancel(true);builder.setContentTitle(\"折叠式Notification\");//用RemoteViews来创建自定义Notification视图RemoteViews remoteViews = new RemoteViews(getPackageName(),R.layout.fold_notification);Notification notification = builder.build();//指定展开的视图notification.bigContentView = remoteViews;mManager.notify(1,notification); 如果不是自定义普通视图的话，折叠式Notification普通状态和普通Notification没有什么区别，效果如下。 接着把通知栏往下拉，使折叠式Notification完全展开就会出现自定义视图 悬挂式Notification悬挂式Notification是Android 5.0新加的通知方式，与前两种通知不同的是，悬挂式Notification不需要下拉通知栏就直接显示出来悬挂在屏幕上方并且不会占用用户的焦点因此不会打断用户的操作，过几秒就自动消失。 需要调用setFullScreenIntent来讲Notification变为悬挂式Notification。 悬挂式Notification的代码如下: 1234567891011121314151617181920Notification.Builder builder = new Notification.Builder(this);Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(\"https://www.baidu.com/\"));PendingIntent pendingIntent = PendingIntent.getActivity(this,0,intent,0);builder.setContentIntent(pendingIntent);builder.setSmallIcon(R.mipmap.ic_launcher);builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher));builder.setAutoCancel(true);builder.setContentTitle(\"悬挂式Notification\");//设置点击跳转Intent hangIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(\"https://www.baidu.com/\"));hangIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);//如果描述的PendingIntent已经存在，则在产生新的Intent之前会先取消当前的PendingIntent hangPendingIntent = PendingIntent.getActivity(this,0,hangIntent,PendingIntent.FLAG_CANCEL_CURRENT);builder.setFullScreenIntent(hangPendingIntent,true);Notification notification = builder.build();mManager.notify(2,notification); 效果如下： Notification的等级Android5.0加入了一种新的模式Notification的等级，有三种： VISIBILITY_PUBLIC 只有在没有锁屏时会显示通知 VISIBILITY_PRIVATE 任何情况都会显示通知 VISIBILITY_SECRET 在安全锁和没有锁屏的情况下显示通知 只需通过Builder的setVisibility方法就可以了 1builder.setVisibility(Notification.VISIBILITY_PUBLIC); 参考文章 Android5.x Notification应用解析","tags":[{"name":"Android5.X","slug":"Android5-X","permalink":"http://liuguoquan727.github.io/tags/Android5-X/"}]},{"title":"Java并发编程之多线程同步","date":"2015-12-26T14:04:06.000Z","path":"2015/12/26/Java并发编程之线程同步/","text":"线程安全就是防止某个对象或者值在多个线程中被修改而导致的数据不一致问题，因此我们就需要通过同步机制保证在同一时刻只有一个线程能够访问到该对象或数据，修改数据完毕之后，再将最新数据同步到主存中，使得其他线程都能够得到这个最新数据。下面我们就来了解Java一些基本的同步机制。 volatile关键字Java提供了一种稍弱的同步机制即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的。然而，在访问volatile变量时不会执行加锁操作，因此也就不会使线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。 volatile变量对所有的线程都是可见的，对volatile变量所有的写操作都能立即反应到其他线程之中，即volatile变量在各个线程中是一致的。 有一种情况需要注意：volatile的语义不能确保递增（count++）的原子性，除非你能确保只有一个线程对变量执行写操作。 123456789101112131415161718192021222324252627282930313233public class VolatileTest&#123; public static volatile int i; public static void increase()&#123; i++; &#125;&#125;查看字节码: javap -c -l VolatileTest.classpublic class VolatileTest &#123; public static volatile int i; public VolatileTest(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 1: 0 public static void increase(); Code: 0: getstatic #2 // Field i:I, 把i的值取到了操作栈顶,volatile保证了i值此时是正确的. 3: iconst_1 4: iadd // increase,但其他线程此时可能已经把i值加大了好多 5: putstatic #2 // Field i:I ,把这个已经out of date的i值同步回主内存中,i值被破坏了. 8: return LineNumberTable: line 6: 0 line 7: 8&#125; 加锁机制即可以确保原子性又可以确保可见性，而volatile变量只能确保可见性。 内置锁-synchronizedJava中最常用的同步机制就是synchronized关键字，它是一种基于语言的粗略锁，能够作用于对象、函数、Class。每个对象都只有一个锁，谁能够拿到这个锁谁就得到了访问权限。当synchronized作用于函数时，实际上锁的也是对象，锁定的对象是该函数所在类的对象。而synchronized作用于Class时则锁的是这个Class类，并非某个具体对象。 synchronized同步方法和同步块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148public class SynchronizedDemo &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub final Test test = new Test(); new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub test.syncMethod(Thread.currentThread()); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub test.syncMethod(Thread.currentThread()); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub test.asyncMethod(Thread.currentThread()); &#125; &#125;).start(); &#125;&#125;class Test &#123; public synchronized void syncMethod(Thread thread) &#123; for(int i = 0;i &lt; 3;i++) &#123; System.out.println(thread.getName()); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; public void asyncMethod(Thread thread) &#123; synchronized (this) &#123; for(int i = 0;i &lt; 3;i++) &#123; System.out.println(thread.getName()+2); &#125; &#125; &#125;&#125;syncMethod和asyncMethod代码块都加锁时结果:Thread-0Thread-0Thread-0Thread-1Thread-1Thread-1Thread-2Thread-2Thread-2 #多个线程不能同时访问同一个对象中的synchronized锁的方法或代码块syncMethod加锁和asyncMethod代码块不加锁时结果:class Test &#123; public synchronized void syncMethod(Thread thread) &#123; for(int i = 0;i &lt; 3;i++) &#123; System.out.println(thread.getName()); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; public void asyncMethod(Thread thread) &#123; synchronized (this) &#123; for(int i = 0;i &lt; 3;i++) &#123; System.out.println(thread.getName()); &#125; &#125; &#125;&#125;Thread-0Thread-22Thread-22Thread-22Thread-0Thread-0Thread-1Thread-1Thread-1 #其他线程可以访问同一个对象的非同步方法或代码块syncMethod不加锁和asyncMethod代码块不加锁时结果:class Test &#123; public void syncMethod(Thread thread) &#123; for(int i = 0;i &lt; 3;i++) &#123; System.out.println(thread.getName()); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; public void asyncMethod(Thread thread) &#123; for(int i = 0;i &lt; 3;i++) &#123; System.out.println(thread.getName()+2); &#125; &#125;&#125;Thread-0Thread-1Thread-22Thread-22Thread-22Thread-0Thread-1Thread-1Thread-0 synchronized同步方法和同步块锁定的是引用对象，synchronized作用于引用对象是防止其他线程访问同一个对象的synchronized代码块或方法，但可以访问其他非同步代码块或方法。 synchronized同步Class对象和静态方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164public class SynchronizedDemo &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub final Test test = new Test(); new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub Test.syncStaticMethod(Thread.currentThread()); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub Test.syncStaticMethod(Thread.currentThread()); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub Test.asyncStaticMethod(Thread.currentThread()); &#125; &#125;).start(); &#125;&#125;class Test &#123; public synchronized static void syncStaticMethod(Thread thread) &#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(thread.getName()); try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; public static void asyncStaticMethod(Thread thread) &#123; synchronized (Test.class) &#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(thread.getName() + 22); try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;syncStaticMethod和asyncStaticMethod代码块都加锁的结果:Thread-0Thread-0Thread-0Thread-222Thread-222Thread-222Thread-1Thread-1Thread-1 ##多个线程不能同时访问添加了synchronized锁的代码块和方法。syncStaticMethod加锁和asyncStaticMethod代码块不加锁的结果:class Test &#123; public synchronized static void syncStaticMethod(Thread thread) &#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(thread.getName()); try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; public static void asyncStaticMethod(Thread thread) &#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(thread.getName() + 22); try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125;Thread-0Thread-222Thread-222Thread-0Thread-0Thread-222Thread-1Thread-1Thread-1 ##多个线程可以同时访问非同步的代码块和方法syncStaticMethod加锁和asyncStaticMethod代码块都不加锁的结果:class Test &#123; public static void syncStaticMethod(Thread thread) &#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(thread.getName()); try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; public static void asyncStaticMethod(Thread thread) &#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(thread.getName() + 22); try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125;Thread-0Thread-1Thread-222Thread-1Thread-0Thread-222Thread-1Thread-0Thread-222 synchronized同步Class对象和静态方法锁的是Class对象，它的作用是防止多个线程同时访问添加了synchronized锁的代码块和方法。 总结 当一个线程正在访问一个对象的synchronized方法，那么其他线程不能访问该对象的其他synchronized方法，因为一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所有无法访问该对象的其他synchronized方法。 当一个线程正在访问一个对象的synchronized方法，那么其他线程能访问该对象的非synchronized方法。因为非synchronized方法不需要获取该对象的锁。 如果一个线程A需要访问对象object1的synchronized方法fun1，另外一个线程B需要访问对象object2的synchronized方法fun1，即使object1和object2是同一类型，也不会产生线程安全问题，因为他们访问的是不同的对象，所以不存在互斥问题。 如果一个线程执行一个对象的非static synchronized方法，另一个线程执行这个对象所属类的static synchronized方法，此时不会发生互斥现象，因为访问static synchronized方法占用的是类锁，而访问非static synchronized方法占用的是对象锁，所以不存在互斥现象。 需要注意的是：对于synchronized方法或者synchronized代码块，当出现异常时，JVM会自动释放当前线程占用的锁，因此不会由于异常导致出现死锁现象。 显示锁-ReentrantLock与ConditionReentrantLock在JDk 5.0之前，协调共享对象的访问时，只有synchronized和volatile。Java 6.0增加了一种新的机制：ReentrantLock。显示锁ReentrantLock和内置锁synchronized相比，实现了相同的语义，但是具有更高的灵活性。 内置锁synchronized的获取和释放都在同一个代码块中，而显示锁ReentrantLock则可以将锁的获得和释放分开。同时显示锁可以提供轮训锁和定时锁，同时可以提供公平锁或者非公平锁。 ReentrantLock的基本操作如下： 函 数 作 用 lock() 获取锁 tryLock() 尝试获取锁 tryLock(timeout,Timeunit unit) 在指定时间内尝试获取锁 unLock() 释放锁 newCondition 获取锁的Condition 使用ReentrantLock的一般是lock、tryLock与unLock成对出现，需要注意的是，千万不要忘记调用unLock来释放锁，否则会引发死锁等问题。 ReentrantLock的常用形式如下所示： 123456789101112131415Lock lock = new ReentrantLock();public void run() &#123; lock.lock(); try &#123; //执行任务 &#125; finally &#123; lock.unlock(); &#125;&#125; 需要注意的是，lock必须在finally块中释放，否则，如果受保护的代码块抛出异常，锁就有可能永远得不到释放。而使用synchronized同步，JVM将确保锁会获得自动释放，这也是Lock没有完全替代掉synchronized的原因。 当JVM用synchronized管理锁定请求和释放行为时，JVM在生成线程转储时能够包括锁定信息，这些对调式有非常大的价值，因为它们能标识死锁和其他异常行为的来源。Lock类只是普通的类，JVM不知道具体哪个线程拥有Lock对象。 Condition在ReentrantLock类中有一个重要的函数newCondition()，该函数用于获取lock上的一个条件，也就是说Condition是和Lock绑定的。Condition用于实现线程间的通信，它是为了解决Object.wait()、notify()、notifyAll()难以使用的问题。 Condition的基本操作如下所示： 方 法 作 用 await() 线程等待 await(int time,TimeUnit unit) 线程等待特定的时间，超过时间则为超时 signal() 随机唤醒某个等待线程 signalAll() 唤醒所有等待中的线程 综合应用下面通过ReentrantLock和Condition类实现一个简单的阻塞队列。如果调用take方法时集合中没有数据，那么调用线程阻塞；如果调用put方法时，集合数据已满则调用线程阻塞。但是这两个阻塞条件是不同的，分别为notFull和notEmpty。MyArrayBlockingQueue的实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168public class MyArrayBlockingQueue&lt;T&gt; &#123; // 数据数组 private final T[] items; // 锁 private final Lock mLock = new ReentrantLock(); // 数组满的条件 private Condition notFull = mLock.newCondition(); // 数组空的条件 private Condition notEmpty = mLock.newCondition(); // 头部 private int head; // 尾部 private int tail; // 数据数量 private int count; public MyArrayBlockingQueue(int maxSize) &#123; // TODO Auto-generated constructor stub items = (T[]) new Object[maxSize]; &#125; public MyArrayBlockingQueue() &#123; // TODO Auto-generated constructor stub this(10); &#125; public void put(T t) &#123; mLock.lock(); try &#123; // 如果数据已满,等待 while (count == getCapacity()) &#123; System.out.println(\"数据已满，请等待\"); notFull.await(); &#125; System.out.println(\"存入数据\"); items[tail] = t; if (++tail == getCapacity()) &#123; tail = 0; &#125; ++count; // 唤醒等待数据的线程 notEmpty.signalAll(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; mLock.unlock(); &#125; &#125; public T take() &#123; mLock.lock(); try &#123; // 如果数组数据为空，则阻塞 while (count == 0) &#123; System.out.println(\"还没有数据，等待\"); notEmpty.await(); &#125; System.out.println(\"取出数据\"); T t = items[head]; items[head] = null; if (++head == getCapacity()) &#123; head = 0; &#125; --count; // 唤醒添加数据的线程 notFull.signalAll(); return t; &#125; catch (InterruptedException e) &#123; // TODO: handle exception &#125; finally &#123; mLock.unlock(); &#125; return null; &#125; public int getCapacity() &#123; return items.length; &#125; public int size() &#123; mLock.lock(); try &#123; return count; &#125; finally &#123; mLock.unlock(); &#125; &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub final MyArrayBlockingQueue&lt;String&gt; mQueue = new MyArrayBlockingQueue&lt;&gt;( 5); new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub while (true) &#123; for(int i = 0;i &lt; 3;i++) mQueue.put(\"just\"); try &#123; Thread.sleep(50); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub while (true) &#123; mQueue.take(); &#125; &#125; &#125;).start(); &#125;&#125;结果打印存入数据存入数据存入数据取出数据取出数据取出数据还没有数据，等待存入数据存入数据存入数据取出数据取出数据取出数据还没有数据，等待 信号量-SemaphoreSemaphore是一个计数信号量，它的本质是一个“共享锁”。信号量维护一个信号许可集合，线程可以通过调用acquire()来获取信号量的许可。当信号量有可用的许可时，线程能获取该许可；否则线程必须等到，直到有可用的许可为止。线程可以通过release()来释放它所持有的信号量许可。 Semaphore实现的功能类似食堂窗口。例如，食堂只有3个销售窗口，要吃饭的有5个人，那么同时只有3个人买饭菜，每个人占用一个窗口，另外2人只能等待。当前3个人有人离开之后，后续的人才可以占用窗口进行购买。这里的窗口就是我们所说的许可集，这里为3.一个人占用窗口时相当于他调用acquire()获取了许可，当他离开时也就等于调用release()释放了许可，这样后续的人才可以得到许可。下面看看具体的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class SemaphoreTest &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub ExecutorService service = Executors.newFixedThreadPool(3); final Semaphore semaphore = new Semaphore(3); for(int i = 0;i &lt; 5;i++) &#123; service.submit(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub try &#123; semaphore.acquire(); System.out.println(\"剩余许可: \" + semaphore.availablePermits()); Thread.sleep(2000); semaphore.release(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125;&#125;结果打印：剩余许可: 0剩余许可: 0剩余许可: 0剩余许可: 2剩余许可: 1 上述结果中：前三行是立刻输出的，后两行是等待2秒之后才输出。原因是，信号量的许可集是3个，而消费线程是5个。前3个线程获取了许可之后，信号量的许可就为0。此时后面的线程再调用acquire()就会阻塞，直到前3个线程执行完之后，释放了许可（不需要同时释放许可）后两个线程才能获取许可并且继续执行。 循环栅栏-CyclicBarrierCyclicBarrier是一个同步辅助类，允许一组线程互相等待，直到达到某个公共屏障点。因为该barrier在释放等待线程后可以重用，所有称为循环的barrier。 下面看看示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class CyclicBarrierTest &#123; private static final int SIZE = 5; private static CyclicBarrier mCyclicBarrier; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub mCyclicBarrier = new CyclicBarrier(SIZE, new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(\"--满足条件执行特定操作，参与者： \"+ mCyclicBarrier.getParties()); &#125; &#125;); for(int i = 0;i &lt; SIZE;i++) &#123; new WorkerThread().start(); &#125; &#125; static class WorkerThread extends Thread &#123; @Override public void run() &#123; // TODO Auto-generated method stub try &#123; System.out.println(Thread.currentThread().getName() + \"等待CyclicBarrier\"); //将mCyclicBarrier的参与者数量加1 mCyclicBarrier.await(); //mCyclicBarrier的参与者数量加5时，才继续往后执行 System.out.println(Thread.currentThread().getName()+\"继续执行\"); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125;结果打印：Thread-1等待CyclicBarrierThread-0等待CyclicBarrierThread-2等待CyclicBarrierThread-3等待CyclicBarrierThread-4等待CyclicBarrier--满足条件执行特定操作，参与者： 5Thread-4继续执行Thread-3继续执行Thread-2继续执行Thread-0继续执行Thread-1继续执行 从结果可以看出，只有当有5个线程调用了mCyclicBarrier.await()方法后，后续的任务才会继续执行。上述例子中的5个WorkThread就位之后首先会执行一个Runnable，也就是CyclicBarrier构造函数的第二个参数，该参数也可以省略。执行该Runnable之后才会继续执行下面的任务。CyclicBarrier实际上相当于可以用于多个线程等待，直到某个条件被满足后开始继续执行后续的任务。对于该示例来说，这里的条件也就是有指定个数的线程调用了mCyclicBarrier.await()方法。 闭锁-CountDownLatchCountDownLatch是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待，直到条件被满足。 示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class CountDownLatchTest &#123; private static final int LATCH_SIZE = 5; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; CountDownLatch countDownLatch = new CountDownLatch(LATCH_SIZE); for(int i = 0;i &lt; LATCH_SIZE;i++) &#123; new WorkerThread(countDownLatch).start(); &#125; System.out.println(\"主线程等待\"); countDownLatch.await(); System.out.println(\"主线程继续执行\"); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; static class WorkerThread extends Thread &#123; private CountDownLatch latch; public WorkerThread(CountDownLatch latch) &#123; this.latch = latch; &#125; @Override public void run() &#123; // TODO Auto-generated method stub try &#123; Thread.sleep(1000); System.out.println(Thread.currentThread().getName() + \"执行操作\"); //将latch的数量减1 latch.countDown(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125;结果打印：主线程等待Thread-3执行操作Thread-1执行操作Thread-0执行操作Thread-4执行操作Thread-2执行操作主线程继续执行 5个WorkThread对象在执行完操作之后会调用CountDownLatch的countDown()函数，当5个WorkThread全都调用了countDown()之后主线程就会被唤醒继续执行任务。 CountDownLatch与CyclicBarrier区别 CountDownLatch的作用是允许1或者多个线程等待其他线程完成执行，而CyclicBarrier则是允许N个线程相互等待。 CountDownLatch的计数器无法被重置，CyclicBarrier的计数器可以被重置后使用。","tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://liuguoquan727.github.io/tags/并发编程/"}]},{"title":"Java并发编程之多线程和线程池","date":"2015-12-26T13:04:06.000Z","path":"2015/12/26/Java并发编程之多线程和线程池/","text":"线程允许在同一个进程中同时存在多个程序控制流，即通过线程可以实现同时处理多个任务的功能。线程会共享进程范围内的资源，例如内存句柄和文件句柄，但每个线程都有各自的程序计数器、栈以及局部变量。 多线程的实现实现方式对于Java的多线程来说，我们学习的一般都是Thread和Runnable，通过我们使用如下代码启动一个新的线程： 123456789101112131415161718192021222324private void startewThread() &#123; new Thread()&#123; @Override public void run() &#123; // 耗时任务 &#125; &#125;.start();&#125;或者private void startewThread1()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; // 耗时任务 &#125; &#125;).start();&#125; 第一种是覆写了Thread类中的run方法执行任务；第二种是实现Runnable接口中的run方法执行任务。 那么Thread和Runnable是什么关系呢？ Thread和Runnable的关系实际上Thread也是一个Runnable，它实现了Runnable接口，在Thread类中有一个Runnable类型的target字段，代表要被执行在这个子线程的任务。相关代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public class Thread implements Runnable &#123; //要执行的目标任务 private Runnable target; //线程所属的线程组 private ThreadGroup group; public Thread() &#123; init(null, null, \"Thread-\" + nextThreadNum(), 0); &#125; public Thread(Runnable target) &#123; init(null, target, \"Thread-\" + nextThreadNum(), 0); &#125; private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc) &#123; if (name == null) &#123; throw new NullPointerException(\"name cannot be null\"); &#125; this.name = name.toCharArray(); Thread parent = currentThread(); SecurityManager security = System.getSecurityManager(); if (g == null) &#123; /* Determine if it's an applet or not */ /* If there is a security manager, ask the security manager what to do. */ if (security != null) &#123; g = security.getThreadGroup(); &#125; /group为null则获取当前线程的线程组 use the parent thread group. */ if (g == null) &#123; g = parent.getThreadGroup(); &#125; &#125; /* checkAccess regardless of whether or not threadgroup is explicitly passed in. */ g.checkAccess(); /* * Do we have the required permissions? */ if (security != null) &#123; if (isCCLOverridden(getClass())) &#123; security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); &#125; &#125; g.addUnstarted(); this.group = g; this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); //设置target this.target = target; setPriority(priority); if (parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); /* Stash the specified stack size in case the VM cares */ this.stackSize = stackSize; /* Set thread ID */ tid = nextThreadID(); &#125; public synchronized void start() &#123; /** * This method is not invoked for the main method thread or \"system\" * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state \"NEW\". */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try &#123; //调用native函数启动线程 start0(); started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125; &#125; @Override public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125;&#125; 实际上最终被线程执行的任务是Runnable，而非Thread。Thread 只是对Runnable的包装，并且通过一些状态对Thread进行管理和调度。Runnable的声明如下： 12345public interface Runnable &#123; public void run();&#125; 当启动一个线程时，如果Thread的target不为空，则会在子线程中执行这个target的run方法，否则虚拟机就会执行该线程自身的run方法。 线程的wait、sleep、join和yield先通过下面的表格来了解他们的区别： 函数名 作用 wait 当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时释放了对象的锁，使得其他线程可以访问。用户可以使用notify、notifyAll或指定睡眠时间来唤醒当前等待池中的线程。 注意：wait、notify、notifyAll方法必须放在synchronized block中，否则则会抛出异常。 sleep 该函数时Thread的静态函数，作用是使调用线程进入睡眠状态。因为sleep()Thread的静态函数，因此它不能改变对象的锁。所以当一个synchronized块中调用sleep方法时，线程虽然休眠了，但是对象的锁并没有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁） join 等待目标线程执行完成之后再继续执行 yield 线程礼让。目标线程由运行状态转换为就绪状态，也就是让出执行权限，让其他线程得以优先执行，但其他线程能否优先执行时未知的。 wait()下面来看看wait、notify、notifyAll的使用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class WaitDemo &#123; private static Object lockObject = new Object(); private static void waitAndNotifAll() &#123; System.out.println(\"主线程运行\"); //创建并启动子线程 Thread thread = new WaitThread(); thread.start(); long startTime = System.currentTimeMillis(); try &#123; //必须在synchronized块中 synchronized (lockObject) &#123; System.out.println(\"主线程等待\"); lockObject.wait(); &#125; &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; //被唤醒后继续执行 long endTime = System.currentTimeMillis() - startTime; System.out.println(\"主线程继续---&gt;等待耗时： \" + endTime + \"ms\"); &#125; private static class WaitThread extends Thread &#123; @Override public void run() &#123; // TODO Auto-generated method stub synchronized (lockObject) &#123; try &#123; Thread.sleep(3000); //唤醒正在等待中的线程 lockObject.notifyAll(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub waitAndNotifAll(); &#125;&#125;运行结果：主线程运行主线程等待......主线程继续---&gt;等待耗时： 3001ms wait、notify机制通常用于等待机制的实现，当条件未满足时调用wait进入等待状态，一旦条件满足，调用notify或notifyAll唤醒等待的线程继续执行。 join()join函数的原始解释为“Block the cuurent thread(Thread.currentThread()) untile the receiver finishes its execution and dies。意思就是阻塞当前调用join函数的任务所在的线程，直到该任务执行完成后再继续执行所在线程的任务。下面我们来看看一个具体是实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class JoinDemo &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub joinDemo(); &#125; static void joinDemo() &#123; System.out.println(\"主线程开始执行\"); Worker worker1 = new Worker(\"worker-1\"); Worker worker2 = new Worker(\"worker-2\"); worker1.start(); System.out.println(\"启动线程1--执行完毕\"); try &#123; //等待worker1任务执行完成 worker1.join(); System.out.println(\"启动线程2--执行完毕\"); worker2.start(); //等待worker2任务执行完成 worker2.join(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(\"主线程继续执行\"); System.out.println(\"主线程执行完毕\"); &#125; static class Worker extends Thread &#123; public Worker(String name) &#123; super(name); &#125; @Override public void run() &#123; // TODO Auto-generated method stub try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(\"Work in \" + getName()); &#125; &#125;&#125;结果打印：主线程开始执行启动线程1--执行完毕Work in worker-1启动线程2--执行完毕Work in worker-2主线程继续执行主线程执行完毕 上述代码的逻辑是主线程开始执行、启动线程1、等待线程1执行完毕、启动线程2、等待线程2执行完毕、继续执行主线程任务。 yield()1public static native void yield(); yield函数的官方解释是”Causes the calling Thread to yiled execution time to another Thread that is ready to run”,意思是使调用该函数的线程让出执行时间给其他已就绪状态的线程。 线程的执行是有时间片的，每个线程轮流占用CPU固定的时间，执行周期到了之后就让出执行权给其他线程，而yield函数的功能就是主动让出线程的执行权给其他线程，其他线程能否得到优先权就得看各个线程的状态了。下面来看看一个具体的示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class YieldDemo &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub YieldThread t1 = new YieldThread(\"thread-1\"); YieldThread t2 = new YieldThread(\"thread-2\"); t1.start(); t2.start(); &#125; static class YieldThread extends Thread &#123; public YieldThread(String name) &#123; // TODO Auto-generated constructor stub super(name); &#125; @Override public synchronized void run() &#123; // TODO Auto-generated method stub for(int i = 0; i &lt; 5;i++) &#123; System.out.println(this.getName() + \" ; \" + \"线程优先级为： \" + this.getPriority()+ \"---&gt;\" + i); //当i为2时 调用当前线程yield函数 if (i== 2) &#123; Thread.yield(); &#125; &#125; &#125; &#125;&#125;打印结果：thread-1 ; 线程优先级为： 5---&gt;0thread-2 ; 线程优先级为： 5---&gt;0thread-2 ; 线程优先级为： 5---&gt;1thread-2 ; 线程优先级为： 5---&gt;2thread-1 ; 线程优先级为： 5---&gt;1thread-1 ; 线程优先级为： 5---&gt;2thread-2 ; 线程优先级为： 5---&gt;3thread-2 ; 线程优先级为： 5---&gt;4thread-1 ; 线程优先级为： 5---&gt;3thread-1 ; 线程优先级为： 5---&gt;4 从结果可知，thread-2首先执行到i的值为2，此时让出执行权，thread-1得到执行权运行到i的值为2时让出执行权，thread-2得到执行权执行任务结束，然后thread-1再继续执行任务。 注意：yield仅在一个时间片内有效。 Callable、Future和FutureTask除了Runnable之外，Java还有Callable、Future和FutureTask这几个与多线程相关的概念，与Runnable不同的是这个类型都只能运用到线程池中，而Runnable既能运用在Thread中，还能运用在线程池中。 CallableCallable与Runnable的功能大致相似不同的是Callable是一个泛型接口，它有一个泛型参数V，该接口中有一个返回值（类型为V）的Call函数，而Runnable中的run方法不能将结果返回至调用者。Callable的声明如下： 123456789public interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; FutureFuture为线程池制定了一个可管理的任务标准。它提供了对Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果、设置结果操作，分别对应cancel、isDone、get、set函数。get方法会阻塞，直到任务返回结果。Future的声明如下： 123456789101112131415161718public interface Future&lt;V&gt; &#123; //取消任务 boolean cancel(boolean mayInterruptIfRunning); //判断任务是否已经取消 boolean isCancelled(); //判断任务是否已经完成 boolean isDone(); //获取结果，如果任务未完成则等待，直到完成，因此该函数会阻塞 V get() throws InterruptedException, ExecutionException; //获取结果，如果未完成则等待，直到返回结果或timeout，该函数会阻塞 V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; FutureTaskFuture只是定义了一些规范的接口，而FutureTask则是它的实现类。FutureTask实现了RunnableFuture&lt;V&gt;，而RunnableFuture实现了Runnable又实现了Future这两个接口，因此FutureTask同时具备他们的功能。FutureTask的代码如下： 123public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123; .....&#125; RunnableFuture类的定义 12345678public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run();&#125; FutureTask像Thread那样包装Runnable那样对Runnable和Callable&lt;V&gt;进行包装，Runnable与Callable由构造函数注入 123456789101112public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable&#125;public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable&#125; 从上述代码可以看出，如果注入的是Runnable则会被Executors.callable()函数转换为Callable类型，即FutureTask最终都是执行Callable类型的任务，该转换函数如下： 123456789101112131415161718192021public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); return new RunnableAdapter&lt;T&gt;(task, result);&#125;/*** Runnable适配器，将Runnable转换为Callable*/static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123; final Runnable task; final T result; RunnableAdapter(Runnable task, T result) &#123; this.task = task; this.result = result; &#125; public T call() &#123; task.run(); return result; &#125;&#125; 由于FutureTask实现了Runnable，因此它既可以通过Thread包装来执行，也可以提交给ExecuteService来执行，并且还可以通过get()函数来获取执行结果，该函数会阻塞，直到结果返回。因此，FutureTask既是Future、Runnable，又是包装了Callable（Runnable最终也会被转换为Callable），它是这两者的合体。 下面示例演示Runnable、Callable、FutureTask的运用，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143public class FutureTaskDemo &#123; //线程池 static ExecutorService mExecutor = Executors.newSingleThreadExecutor(); /** * 向线程池提交Runnable对象 */ private static void taskRunnable() &#123; //无返回值 Future&lt;?&gt; future = mExecutor.submit(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub fibc(20); &#125; &#125;); System.out.println(\"taskRunnable: \" + future.get()); &#125; /** * 向线程池提交Callable对象 * @throws ExecutionException * @throws InterruptedException */ private static void taskCallable() throws InterruptedException, ExecutionException &#123; Future&lt;Integer&gt; future = mExecutor.submit(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; // TODO Auto-generated method stub return fibc(20); &#125; &#125;); //返回值 Integer result = future.get(); if (result != null) &#123; System.out.println(\"taskCallable: \" + result); &#125; &#125; /** * 向线程池提交FutureTask对象 * @throws ExecutionException * @throws InterruptedException */ private static void taskFutureTask() throws InterruptedException, ExecutionException &#123; FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; // TODO Auto-generated method stub return fibc(20); &#125; &#125;); mExecutor.submit(futureTask); Integer result = futureTask.get(); if (result != null) &#123; System.out.println(\"taskFutureTask: \" + result); &#125; &#125; /** * Thread包装FutureTask * @throws InterruptedException * @throws ExecutionException */ private static void taskThread() throws InterruptedException, ExecutionException &#123; FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; // TODO Auto-generated method stub return fibc(20); &#125; &#125;); new Thread(futureTask).start(); Integer result = futureTask.get(); if (result != null) &#123; System.out.println(\"taskThread: \" + result); &#125; &#125; /** * 斐波那契数列 * @param num * @return */ private static int fibc(int num) &#123; if (num == 0) &#123; return 0; &#125; if (num == 1) &#123; return 1; &#125; return fibc(num - 1) + fibc(num - 2); &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; taskRunnable(); taskCallable(); taskFutureTask(); taskThread(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;打印结果：taskRunnable: nulltaskCallable: 6765taskFutureTask: 6765taskThread: 6765 线程池当我们需要频繁地创建多个线程进行耗时操作时，每次都通过new Thread实现并不是一种好的方式，每次new Thread新建销毁对象性能较差，线程缺乏统一的管理，可能会无限制地创建新的线程，线程之间相互竞争从而占用过多系统资源导致死锁，并且缺乏定期执行、定时执行、线程中断等功能。 Java提供了4中线程池，它能够有效地管理、调度线程，避免过多的资源消耗，它强大到几乎不需要开发人员自定义的程序。它的优点如下： 重用存在的线程，减少对象创建、销毁的开销； 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞； 提供定时执行、定期执行、单线程、并发数控制等功能； 线程池的原理就是会创建创建多个线程并且对这些线程进行管理，提交给线程的任务 会被线程池指派给其中的线程执行，提供线程池的统一调度、管理。使得多线程的使用更简单、高效。 线程池都实现了ExecutorService接口，该接口定义了线程池需要实现的接口，如submit、execute、shutdown等。它的实现有ThreadPoolExecutor和ScheduledPoolExecutor，ThreadPoolExecutor是运行最多的线程池实现，ScheduledPoolExecutor则用于执行周期性任务。 启动指定数量的线程-ThreadPoolExecutorThreadPoolExecutor的功能是启动指定数量的线程以及将任务添加到一个队列中，并且将任务分发给空闲的线程。 ExecutorService的生命周期包括3中状态：运行、关闭、终止，创建后进入运行状态，调用shutdown()方法时便进入了关闭状态，此时ExecutorService不再接受新的任务，但它继续执行完已经提交的任务，当所有已经提交的任务都执行完后，就变成终止状态。 ThreadPoolExecutor的构造函数如下： 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 下面对参数进行详细说明: 参 数 名 作 用 corePoolSize 线程池中所保存的核心线程数。 maximumPoolSize 线程池所容纳的最大线程数，当活动线程达到这个数值后，后续的任务将会被阻塞 keepAliveTime 非核心线程闲置时的超时时间，超出这个时长，非核心线程就会被回收 unit 用于指定keepAliveTime参数的时间单位，有毫秒、秒、分钟等 workQueue 线程池中的任务队列，如果线程池的线程数量已经达到核心线程数并且当前所有线程都处于活动状态时，则将新任务放到此队列中等待执行 threadFactory 线程工厂，为线程池提供创建新线程的功能，通常不需要设置 handler 拒绝策略，当线程池与workQueue队列都满了的情况下，对新任务采取的处理策略 线程池参数也可以参考这篇文章http://liuguoquan727.github.io/2016/04/25/Android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/: 其中workQueue有下列几个常用的实现： ArrayBlockingQueue 基于数组结构的有界队列，此队列按FIFO原则对任务进行排序。如果队列满了还有任务进来，则调用拒绝策略 LinkedBlockingQueue 基于链表结构的无界队列，此队列按FIFO原则对任务进行排序。因为它是无界的，所以才有此队列后线程池将忽略handler参数。 SynchronousQueue 直接将任务提交给线程而不是将它加入到队列，实际上该队列是空的。每个插入的操作必须等到另一个调用移除的操作，如果新任务来了线程池没有任何可用线程处理的话，则调用拒绝策略。 PriorityBlockingQueue 具有优先级的队列的有界队列，可用自定义优先级，默认是按自然排序的。 此外，当线程池与workQueue队列都满了的情况下，对新加任务采取的处理策略也有几个默认实现： AbortPolicy 拒绝任务，抛出RejectedExecutionException异常，线程池默认策略 CallerRunsPolicy 拒绝新任务加入，如果该线程池还没有被关闭，那么将这个新任务执行在调用线程中 DiscardOldestPolicy 如果执行程序还没有关闭，则将位于工作队列头部的任务删除，然后重试执行程序（如果再次失败，则重复此过程） DiscardPolicy 加不进的任务都被抛弃了，同时没有异常抛出 newFixedThreadPool对应Android平台来说，最常使用的就是通过Executors.newFixedThreadPool(int size)函数来启动固定数量的线程池，代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class ExectorsDemo &#123; private static final int MAX = 10; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; fixedThreadPool(MAX); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (ExecutionException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; private static void fixedThreadPool(int size) throws InterruptedException, ExecutionException &#123; ExecutorService service = Executors.newFixedThreadPool(size); for(int i = 0;i &lt; MAX;i++) &#123; //提交任务 Future&lt;Integer&gt; task = service.submit(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; // TODO Auto-generated method stub System.out.println(\"执行线程: \" + Thread.currentThread().getName()); return fibc(20); &#125; &#125;); //获取结果 System.out.println(\"第\"+i+\"次计算结果: \" + task.get()); &#125; &#125; /** * 斐波那契数列 * @param num * @return */ private static int fibc(int num) &#123; if (num == 0) &#123; return 0; &#125; if (num == 1) &#123; return 1; &#125; return fibc(num - 1) + fibc(num - 2); &#125;&#125;结果打印：执行线程: pool-1-thread-1第0次计算结果: 6765执行线程: pool-1-thread-2第1次计算结果: 6765执行线程: pool-1-thread-3第2次计算结果: 6765执行线程: pool-1-thread-1第3次计算结果: 6765执行线程: pool-1-thread-2第4次计算结果: 6765执行线程: pool-1-thread-3第5次计算结果: 6765执行线程: pool-1-thread-1第6次计算结果: 6765执行线程: pool-1-thread-2第7次计算结果: 6765执行线程: pool-1-thread-3第8次计算结果: 6765执行线程: pool-1-thread-1第9次计算结果: 6765 在上述例子中，我们启动了含有3个线程的线程池，调用的是Executors的newFixedThreadPool函数，该函数的实现为 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 可知它的corePoolSize和MaxnumPoolSize值都是nThreads，并且设置keepAliveTime为0毫秒，最后设置无界任务队列，这样该线程池中就含有固定个数的线程，并且能够容纳无数个任务。 newCacheThreadPool有时可能需要任务尽可能快地被执行，这就需要线程池中的线程足够多也就是说此时需要拿空间来换时间，线程越多占用的内存消耗就越大。因此，我们可能需要一种场景，如果来了一个新的任务，并且没有空闲线程可用，此时必须马上创建一个线程来立即执行任务。我们可以通过Executors的newCacheThreadPool函数来实现。 123456789101112131415161718192021222324252627282930private static void newCacheThreadPool() throws InterruptedException, ExecutionException &#123; ExecutorService service = Executors.newCachedThreadPool(); for(int i = 0;i &lt; MAX;i++) &#123; //提交任务 service.submit(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(\"执行线程: \" + Thread.currentThread().getName() + \",结果:\" + fibc(20)); &#125; &#125;); &#125;&#125;结果打印执行线程: pool-1-thread-1,结果:6765执行线程: pool-1-thread-2,结果:6765执行线程: pool-1-thread-4,结果:6765执行线程: pool-1-thread-6,结果:6765执行线程: pool-1-thread-8,结果:6765执行线程: pool-1-thread-5,结果:6765执行线程: pool-1-thread-3,结果:6765执行线程: pool-1-thread-7,结果:6765执行线程: pool-1-thread-10,结果:6765执行线程: pool-1-thread-9,结果:6765 从上述结果可以看出，为了保证吞吐量，该线程池为每个任务都创建了一个线程，当然这是在没有线程空闲的情况下创建的新的线程。假设执行前5个任务时都创建了一个线程，执行到底6个任务时刚好前面的第一个任务执行完毕，此时线程1空闲，那么第六个任务就会被执行在第一个线程中，而不是重新创建。 执行周期性任务的线程-ScheduledPoolExecutor通过Executors的newScheduledThreadPool函数即可创建定时执行任务的线程池。 1234567891011121314151617181920212223242526272829303132333435363738394041private static void newScheduledThreadPool() throws InterruptedException, ExecutionException &#123; ScheduledExecutorService service = Executors.newScheduledThreadPool(4); // 参数2为第一次延迟的时间，参数2为执行周期 service.scheduleAtFixedRate((new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(\"执行线程: \" + Thread.currentThread().getName() + \",定时计算 1结果:\" + fibc(20)); &#125; &#125;), 1, 2, TimeUnit.SECONDS); // 参数2为第一次延迟的时间，参数2为执行周期 service.scheduleAtFixedRate((new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub System.out.println(\"执行线程: \" + Thread.currentThread().getName() + \",定时计算2结果:\" + fibc(30)); &#125; &#125;), 1, 2, TimeUnit.SECONDS);&#125;打印结果：执行线程: pool-1-thread-1,定时计算 1结果:6765执行线程: pool-1-thread-2,定时计算2结果:832040执行线程: pool-1-thread-1,定时计算 1结果:6765执行线程: pool-1-thread-3,定时计算2结果:832040执行线程: pool-1-thread-1,定时计算 1结果:6765执行线程: pool-1-thread-4,定时计算2结果:832040执行线程: pool-1-thread-1,定时计算 1结果:6765执行线程: pool-1-thread-3,定时计算2结果:832040执行线程: pool-1-thread-2,定时计算 1结果:6765执行线程: pool-1-thread-4,定时计算2结果:832040 该线程池有4个线程，我们指定了两个定时任务，因此该线程池中有两个线程来定时执行任务，哪个线程空闲就调度哪个线程来执行任务。 同步集合程序中的优化策略-CopyOnWriteCopy-On-Write是一种用于程序设计中的优化策略，其基本思路是，从多个线程共享同一个列表，当某个线程想要修改这个列表的元素时，会把列表中的元素复制一份，然后进行修改，修改完成之后再将新的元素设置给这个列表，这是一种延时懒惰策略。这样做的好处是我们可以对CopyOnWrite容器进行并发的读而不需要加锁，因为当前容器不会添加、移除任何元素。所有CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。从JDK1.5起Java并发包提供了两个使用CopyOnWrite机制实现的并发容器，它们是CopyOnWriteArrayList和CopyOnWriteSet。 通过这种写时拷贝的原理可以将读、写分离，使并发场景下对列表的操作效率得到提高，但它的缺点是，在添加、移除元素时占用的内存空间翻了一倍，因此，这是以空间换时间的策略。 提高并发效率-ConcurrentHasMapHashTable使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用个图方法来获取元素，所以竞争越激烈效率越低。 HashTable在竞争激烈的并发环境下表现出效率低下的原因是因为所有访问HashTable的线程都必须竞争同一把锁。假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHasMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。有些方法需要跨段，如size()和containsValue()，它们可能需要锁定整个表而不仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。 有效的方法-BlockingQueueBlockingQueue的重要方法: 函 数 名 作 用 add(e) 把元素e添加到队列中，成功返回true，否则抛出异常 offer(e) 把元素e添加到队列中，成功返回true，否则返回false offer(e,time,unit) 把元素e添加到队列中，成功返回true，否则在等待指定的时间之后继续尝试添加，如果失败则返回false put(e) 把元素e添加到队列中，如果队列不能容纳，则调用此方法的线程被阻塞直到队列里面有空间再继续添加 take() 取出队列中的首个元素，若队列为空，则线程进入等待直到队列中新的元素加入为止 poll(time,unit) 取出并移除队列中的首个元素，如果在指定的时间内没有获取元素，则返回null element() 获取队首元素，如果队列为null，那么抛出NoSuchElementException异常 peek() 获取队首元素，如果队列为空，那么返回null remove() 获取并移除队首元素，如果队列为空，那么抛出NoSuchElementException异常 BlockingQueue常用的实现有： ArrayBlockingQueue LinkedBlockingQueue LinkedBlockingDequeue ConcurrentLinkedQueue","tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://liuguoquan727.github.io/tags/并发编程/"}]},{"title":"Java注解Annotation和依赖注入","date":"2015-12-25T13:04:06.000Z","path":"2015/12/25/Java注解Annotation和依赖注入/","text":"注解概念注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 作用 标记作用 用于告诉编译器一些信息让编译器能够实现基本的编译检查，如@Override、@Deprecated， 123456789@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125;@Documented@Retention(RetentionPolicy.RUNTIME)public @interface Deprecated &#123;&#125; 编译时动态处理 动态生成代码，如ButterKnife、Dagger2 运行时动态处理 获取注解信息，如Retrofit 分类按功能分类 标准注解 是指Java自带的几个注解，Override、Deprecated、SuppressWarnings，分别表示重写方法、不推荐使用（过时的）、忽略某项Warning. 元注解 元注解是指用来定义注解的注解，JDK1.5定义了四种元注解：@Retention、@Target、@Inherit、@Documented。 自定义注解（meta-annotation） 自定义注解表示自己根据需要定义的注解，定义时需要用到上面的元注解。 按作用域分类 源码时注解（RetentionPolicy.SOURCE） 编译时注解（RetentionPolicy.CLASS） 运行时注解（RetentionPolicy.RUNTIME） 注解相关知识点元注解知识点 @Target：指Annotation所修饰的对象范围，通过ElementType取值有8中，如下： 取值 含义 TYPE 类、接口（包括注解类型）或枚举 FILED 属性 METHOD 方法 PARAMETER 参数 CONSTRUCTOR 构造函数 LOCAL_VARIABLE 局部变量 ANNOTATION_TYPE 注解类型 PACKAGE 包 @Retention:指Annotation被保留的时间长短，通过RetentionPolicy取值有3种，如 值 含义 SOURCE 在源文件有效，编译时就会忽略 CLASS 在Class文件中有效，但JVM将会忽略 如Override、SuppressWarnings等 RUNTIME 在运行时有效 ，所以它们能在运行时被JVM或其他使用反射机制的代码所读取和使用 @Documented：是一个标记注解，表明这个注解应该被 javadoc工具记录. 默认情况下,javadoc是不包括注解的. 但如果声明注解时指定了 @Documented,则它会被 javadoc 之类的工具处理, 所以注解类型信息也会被包括在生成的文档中. @Inherited：也是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的，默认为false 注解定义格式1public @interface 注解名 &#123;定义体&#125; 注解支持的数据类型 8种基本数据类型 int、float、boolean、byte、double、char、long、short String、Class、enum、Annotation 以上所有类型的数组 注意自定义注解如果只有一个参数成员，最好把定义体参数名称设为”value”，如@Target 123456@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; ElementType[] value();&#125; Annotation自定义调用12345678910public class App &#123; @MethodInfo( author = “trinea.cn+android@gmail.com”, date = \"2014/02/14\", version = 2) public String getAppName() &#123; return \"trinea\"; &#125;&#125; MethodInfo Annotation作用为给方法添加相关信息，包括author、date、version 定义123456789101112@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@Inheritedpublic @interface MethodInfo &#123; String author() default \"trinea@gmail.com\"; String date(); int version() default 1;&#125; 上面是MethondInfo的实现部分： 通过@interface定义，注解名即为自定义注解名 注解配置参数名为注解类的方法名且 所有方法没有方法体，没有参数没有修饰符，实际只允许public&amp;abstract修饰符，默认为public，不允许抛出异常 方法返回值只能是基本类型、String、Class、Annotation、Enum或者是它们的一维数组 若只有一个默认属性，可直接用value（）函数，一个属性都没有表示该 Annotation 为 Mark Annotation 可以加default表示默认值 Annotation解析运行时Annotation解析运行时Annotation指@Retention为RUNTIME的Annotation，可手动调用下面常用API解析： method.getAnnotation(AnnotationName.class) 表示得到该Target某个Annotation的信息，因为一个Target可以被多个Annotation修饰 method.getAnnotations() 表示得到该Target所有Annotation method.isAnnotationPresent(AnnotationName.class) 表示该Target是否被某个Annotation修饰 @Target为METHOND解析示例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class App &#123; @MethodInfo( author = \"trinea.cn+android@gmail.com\", date = \"2014/02/14\", version = 2) public String getAppName() &#123; return \"trinea\"; &#125; @MethodInfo(author = \"liu.cn+android@gmail.com\", date = \"2015/02/14\", version = 3) public String getNewAppName() &#123; return \"liu\"; &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub try &#123; Class&lt;?&gt; clz = Class.forName(\"com.michael.java.annotation.App\"); for(Method method : clz.getMethods()) &#123; MethodInfo methodInfo = method.getAnnotation(MethodInfo.class); if (methodInfo != null) &#123; System.out.println(method.getName()); System.out.println(methodInfo.author()); System.out.println(methodInfo.date()); System.out.println(methodInfo.version()); Annotation[] annotations = method.getAnnotations(); for(Annotation annotation : annotations)&#123; System.out.println(annotation.toString()); &#125; &#125; &#125; &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;运行结果：getAppNametrinea.cn+android@gmail.com2014/02/142@com.michael.java.annotation.MethodInfo(version=2, author=trinea.cn+android@gmail.com, date=2014/02/14)getNewAppNameliu.cn+android@gmail.com2015/02/143interface com.michael.java.annotation.MethodInfo @Target为FIELD1234567891011121314151617181920212223242526272829303132333435363738394041@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface Bind &#123; int value();&#125;public class FieldDemo &#123; @Bind(2) public static int age; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub Class&lt;?&gt; clz = new FieldDemo().getClass(); for(Field field : clz.getFields()) &#123; Bind bind = field.getAnnotation(Bind.class); if (bind != null) &#123; System.out.println(field.getName()); System.out.println(bind.value()); age = bind.value(); System.out.println(age); &#125; &#125; &#125;&#125;运行结果：age22 编译时Annotation解析编译时Annotation指@Retention为CLASS的Annotation，由编译器自动解析。步骤为： 自定义类继承自AbstractProcessor 重写其中的process函数 编译器在编译时自动查找所有继承自AbstractProcessor的类，然后调用它们的process方法去处理 假设MethodInfo的@Retention为CLASS，解析示例如下： 123456789101112131415@SupportedAnnotationTypes(&#123; \"com.michael.java.annotation.MethodInfo\" &#125;)public class MethodInfoProcessor extends AbstractProcessor &#123; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) &#123; HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); for (TypeElement te : annotations) &#123; for (Element element : env.getElementsAnnotatedWith(te)) &#123; MethodInfo methodInfo = element.getAnnotation(MethodInfo.class); map.put(element.getEnclosingElement().toString(), methodInfo.author()); &#125; &#125; return false; &#125;&#125; SupportedAnnotationTypes 表示这个 Processor 要处理的 Annotation 名字。process 函数中参数 annotations 表示待处理的 Annotations，参数 env 表示当前或是之前的运行环境process 函数返回值表示这组 annotations 是否被这个 Processor 接受，如果接受后续子的 rocessor 不会再对这个 Annotations 进行处理。 依赖注入依赖如果在Class A中，有Class B的实例，则称Class A对Class B有一个依赖。例如下面类Human中用到一个Father对象，我们就说Human对类Father有一个依赖。 12345678public class Human &#123; ... Father father; ... public Human() &#123; father = new Father(); &#125;&#125; 仔细看这段代码我们会发现存在一些问题： 如果现在要改变 father 生成方式，如需要用new Father(String name)初始化 father，需要修改 Human 代码； 如果想测试不同 Father 对象对 Human 的影响很困难，因为 father 的初始化被写死在了 Human 的构造函数中； 如果new Father()过程非常缓慢，单测时我们希望用已经初始化好的 father 对象 Mock 掉这个过程也很困难。 依赖注入上面将依赖在构造函数中直接初始化一种Hard init形式，弊端在于两个类不够独立，不方便测试。我们还有另外一种init方式，如下： 12345678public class Human &#123; ... Father father; ... public Human(Father father) &#123; this.father = father; &#125;&#125; 上面代码中，我们将 father 对象作为构造函数的一个参数传入。在调用 Human 的构造方法之前外部就已经初始化好了 Father 对象。像这种非自己主动初始化依赖，而通过外部来传入依赖的方式，我们就称为依赖注入。现在我们发现上面 1 中存在的两个问题都很好解决了，简单的说依赖注入主要有两个好处： 解耦，将依赖之间解耦。 因为已经解耦，所以方便做单元测试，尤其是 Mock 测试。 Java中的依赖注入依赖注入的实现有很多途径，而在Java中，使用注解是最常用的。通过在字段的声明前添加@Inject注解进行标记，来实现对依赖对象的自动注入。 1234567public class Human &#123; ... @Inject Father father; ... public Human() &#123; &#125;&#125; 面这段代码看起来很神奇：只是增加了一个注解，Father 对象就能自动注入了？这个注入过程是怎么完成的？实质上，如果你只是写了一个 @Inject 注解，Father 并不会被自动注入。你还需要使用一个依赖注入框架，并进行简单的配置。现在 Java 语言中较流行的依赖注入框架有 Google Guice、Spring 等，而在 Android 上比较流行的有 RoboGuice、Dagger、Dagger2 等","tags":[{"name":"Java","slug":"Java","permalink":"http://liuguoquan727.github.io/tags/Java/"}]},{"title":"Java反射Reflection","date":"2015-12-24T12:04:06.000Z","path":"2015/12/24/Java反射Reflection/","text":"Java反射什么是反射Java反射是可以让我们在运行时获取类的函数、属性、父类、接口等Class内部信息的机制。通过反射还可以让我们在运行期实例化对象，调用方法，通过调用get/set方法获取和设置变量的值，即使方法或属性是类私有的也可以通过反射的形式调用，这种“看透Class“的能力被称为内省，这种能力在框架开发中尤为重要。有些情况下，我们要使用的类在运行时才会确定，这个时候我们不能在编译期就使用它，因此只能通过反射的形式来使用在运行时才存在的类（该类符合某种特定规范，例如JDBC），这是反射用得比较多的场景。 还有一个比较常见的场景就是编译时我们对于类的内部信息不可知，必须得到运行时才能获取类的具体信息。比如ORM框架，在运行时才能够获取类中的各个属性，然后通过反射的形式获取其属性名和值，存入数据库，这也是反射比较经典应用场景之一。 Class类既然反射是操作Class信息的，那么Class又是什么呢？ 当我们编写完一个Java项目之后，所有的Java文件都会被编译成一个.class文件，这些Class对象承载了这个类型的父类、接口、构造函数、方法、属性等原始信息，这些class文件在程序运行时会被ClassLoader加载到虚拟机中。当一个类被加载以后，Java虚拟机就会在内存中自动产生一个Class对象。我们通过new的形式创建对象实际上就是通过这些Class来创建，只是这个过程对于我们是不透明而已。 反射Class以及构造对象获取Class对象在你想检查一个类的信息之前，你首先需要获取类的Class对象。Java中的所有类型包括基本类型，即使是数组都有与之关联的Class类的对象。如果你在编译期知道一个类的名字的话，那么你可以使用如下的方式获取一个类的Class对象。 12345Class&lt;String&gt; myClass = String.class;System.out.println(myClass);打印：class java.lang.String 如果你已经得到了某个对象，但是你想获取这个对象的Class对象，那么你可以通过下面的方法得到： 123456String str = new String();Class&lt;String&gt; myClass = str.getClass();System.out.println(myClass);打印：class java.lang.String 如果你在编译期获取不到目标类型，但是你知道它的完整类路径，那么你可以通过如下的形式来获取Class对象： 123456789101112Class&lt;?&gt; myClass = null;try &#123; myClass = Class.forName(\"java.lang.String\");&#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace();&#125;System.out.println(myClass);打印结果：class java.lang.String 在使用Class.forName()方法时，你必须提供一个类的全名，这个全名包括类所在的包的名字。例如String类位于java.lang包中，那么它的完整路径就是java.lang.String。如果在调用Class.forName()方法时，没有在编译路径下（classpath）找到对象的类，那么将会抛出ClassNotFoundException。 方法说明 12345678910111213/*** 加载指定的Class对象*@param className 要加载的类的完整路径，例如java.lang.String。*/public static Class&lt;?&gt; forName(String className)throws ClassNotFoundException/*** 加载指定的Class对象*@param className 要加载的类的完整路径，例如java.lang.String。*@param initialize 是否要初始化该Class对象*@param loader 指定加载该类的ClassLoader*/public static Class&lt;?&gt; forName(String name, boolean initialize,ClassLoader loader)throws ClassNotFoundException 通过Class对象构造目标类型的对象一旦你拿到Class对象之后，你就可以为所欲为了，但获取Class对象只是第一步，我们需要在执行那些强大的行为之前通过Class对象构造出该类型的对象，然后才能通过该对象释放它的功能。我们知道，在java中要构造对象，必须通过该类的构造函数，那么其实反射也是一样的。但是它们确实是有区别的，通过反射构造对象，我们首先要获取类的Constructor（构造器）对象，然后通过Constructor来创建目标类的对象。 123456789101112131415161718192021222324252627private static void classForName() &#123; try &#123; //1.获取Class对象 Class&lt;?&gt; clz = Class.forName(\"com.michael.java.reflection.Student\"); //2.通过Class对象获取Constructor，Student构造函数中有一个String参数 Constructor&lt;?&gt; constructor = clz.getConstructor(String.class); //3.通过Constructor创建Student对象 Student object = (Student) constructor.newInstance(\"michael\"); System.out.println(\"obj: \" + object.toString()); object.showMyName(); object.takeAnExamination(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125;打印结果：obj: Student : michaelMy name is michael takeAnExamination 通过上述代码，我们就可以在运行时通过完整的类名来构建对象。 获取构造函数方法 123456//获取一个公有的构造函数，参数为可变参数，如果构造函数有参数，那么需要将参数的类型传递给getConstructor方法public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)//获取目标类所有的公有构造函数public Constructor&lt;?&gt;[] getConstructors() throws SecurityException 注意，当你通过反射获取到Constructor、Method、Filed后，在反射调用之前将此对象的accessible标志设置为true，以此来提升反射速度。值为true则指示反射的对象在使用时应该取消Java语言访问检查。值为false则指示反射的对象应该实施Java语言访问检查。例如： 12345678//设置Constructor的AccessibleConstructor&lt;?&gt; constructor = clz.getConstructor(String.class);constructor.setAccessible(true);Method learnMethod = Student.class.getMethod(\"learn\", String.class);//设置Method的AccessiblelearnMethod.setAccessible(true); Student.java 123456789101112131415161718192021222324252627282930package com.michael.java.reflection;public class Student extends Person implements Examination&#123; // 年级 public int mGrade; private String age; public Student(String aName) &#123; super(aName); &#125; public Student(int grade, String aName) &#123; super(aName); mGrade = grade; &#125; private void learn(String course,int count) &#123; System.out.println(mName + \" learn \" + course + \"--\"+ count); &#125; public void takeAnExamination() &#123; System.out.println(\" takeAnExamination \"); &#125; public String toString() &#123; return \" Student : \" + mName; &#125;&#125; Person.java 1234567891011121314151617181920212223package com.michael.java.reflection;public class Person &#123; String mName; public Person(String aName) &#123; mName = aName; &#125; private void sayHello(String friendName) &#123; System.out.println(mName + \" say hello to \" + friendName); &#125; protected void showMyName() &#123; System.out.println(\"My name is \" + mName); &#125; public void breathe() &#123; System.out.println(\" take breathe \"); &#125;&#125; Examination.java 123456package com.michael.java.reflection;public interface Examination &#123; public void takeAnExamination();&#125; Breathe.java 123456package com.michael.java.reflection;public interface Breathe &#123; public void breathe();&#125; 反射获取类中函数获取当前类中定义的方法要获取当前类中定义的所有方法可以通过Class中的getDeclaredMethods函数，它会获取当前类中的public、default、protected、private的所有方法。getDeclaredMethod(String name, Class...&lt;?&gt; parameterTypes)则是获取某个指定的方法。代码示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private static void showDeclaredMethods() &#123; Student student = new Student(\"Michael\"); // 获取类中所有方法 Method[] methods = student.getClass().getDeclaredMethods(); for (Method method : methods) &#123; System.out.println(\"方法名: \" + method.getName()); &#125; try &#123; Method learnMethod = student.getClass().getDeclaredMethod(\"learn\", String.class, Integer.TYPE); // 获取方法的参数类型列表 Class&lt;?&gt;[] paramClasses = learnMethod.getParameterTypes(); for (Class&lt;?&gt; clz : paramClasses) &#123; System.out.println(\"learn 方法的参数类型: \" + clz.getName()); &#125; // 是否是 private 函数，属性是否是 private 也可以使用这种方式判断 System.out.println(learnMethod.getName() + \" is private method: \" + Modifier.isPrivate(learnMethod.getModifiers())); //调用私有learn函数 learnMethod.setAccessible(true); learnMethod.invoke(student, \"java---&gt;\",2); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125;运行结果:方法名: toString方法名: learn方法名: takeAnExaminationlearn 方法的参数类型: java.lang.Stringlearn 方法的参数类型: intlearn is private method: trueMichael learn java---&gt;---2 获取当前类、父类中定义的公有方法要获取当前类以及父类中的所有public方法可以通过Class中的getMethods函数，而getMethod则是获取某个指定的方法。代码示例如下： 123456789101112131415161718192021222324252627282930313233343536private static void showMethods() &#123; Student student = new Student(\"Michael\"); //获取所有公有方法 Method[] methods = student.getClass().getMethods(); for(Method method : methods)&#123; System.out.println(\"公有方法名： \" + method.getName()); &#125; try &#123; //通过 getMethod 只能获取公有方法，如果获取私有方法则会抛出异常 Method method = student.getClass().getMethod(\"takeAnExamination\"); method.invoke(student); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125;结果打印：公有方法名： toString公有方法名： takeAnExamination公有方法名： breathe公有方法名： wait公有方法名： wait公有方法名： wait公有方法名： equals公有方法名： hashCode公有方法名： getClass公有方法名： notify公有方法名： notifyAll takeAnExamination 接口说明 1234567891011//获取Class对象中指定的所有函数，不包括从父类继承的函数public Method[] getDeclaredMethods()//获取Class对象中指定函数名和参数的函数，参数name表示函数名；参数parameterTypes表示参数类型列表public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)//获取Class对象中的所有公有函数（包括从父类和接口类继承的函数）public Method[] getMethods()//获取Class对象中指定函数名和参数的公有函数，参数name表示函数名；参数parameterTypes表示参数类型列表public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 这里需要注意的是 getDeclaredMethod 和 getDeclaredMethods 包含 private、protected、default、public 的函数，并且通过这两个函数获取到的只是在自身中定义的函数，从父类中集成的函数不能够获取到。而 getMethod 和 getMethods 只包含 public 函数，父类中的公有函数也能够获取到。 反射类获取类中的属性获取当前类中定义的属性要获取当前类中定义的所有属性可以通过Class中的getDeclaredFields函数，它会获取到当前类中的public、protected、private的所有属性，而getDeclaredField则是获取指定的属性。 12345678910111213141516171819202122232425262728293031323334353637383940414243private static void showDeclaredFields() &#123; Student student = new Student(\"Michael\"); //获取当前类的所有属性 Field[] fields = student.getClass().getDeclaredFields(); for(Field field : fields) &#123; System.out.println(\"属性名： \" + field.getName()); &#125; try &#123; //获取当前类的指定属性 Field gradeField = student.getClass().getDeclaredField(\"mGrade\"); //获取属性值 System.out.println(\"grade is:\" + gradeField.getInt(student)); //设置属性值 gradeField.set(student, 10); System.out.println(\"grade is:\" + gradeField.getInt(student)); Field ageField = student.getClass().getDeclaredField(\"age\"); ageField.setAccessible(true); System.out.println(\"age: \" + ageField.get(student)); ageField.set(student, \"26\"); System.out.println(\"age: \" + ageField.get(student)); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125;结果打印：属性名： mGrade属性名： agegrade is:0grade is:10age: nullage: 26 获取当前类、父类中定义的公有属性要获取当前类以及父类中的所有 public 属性可以通过 Class 中的 getFields 函数，而 getField 则是获取某个指定的属性。代码示例如下 : 123456789101112131415161718192021222324252627282930313233343536373839404142private static void showFields() &#123; Student student = new Student(\"Michael\"); //获取当前类的所有属性 Field[] fields = student.getClass().getFields(); for(Field field : fields) &#123; System.out.println(\"属性名： \" + field.getName()); &#125; try &#123; //获取当前类的指定属性 Field gradeField = student.getClass().getField(\"mGrade\"); //获取属性值 System.out.println(\"grade is:\" + gradeField.getInt(student)); //设置属性值 gradeField.set(student, 10); System.out.println(\"grade is:\" + gradeField.getInt(student)); //getField()方法不能获取私有属性 Field ageField = student.getClass().getField(\"age\"); //私有属性需调用次函数 JDK 1.8 ageField.setAccessible(true); System.out.println(\"age: \" + ageField.get(student)); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125;结果打印：属性名： mGradegrade is:0grade is:10java.lang.NoSuchFieldException: age ##getField()方法不能获取私有属性 at java.lang.Class.getField(Unknown Source) at com.michael.java.reflection.Main.showFields(Main.java:153) at com.michael.java.reflection.Main.main(Main.java:172) 接口说明 1234567891011// 获取 Class 对象中指定属性名的属性，参数一为属性名public Method getDeclaredField (String name)// 获取该 Class 对象中的所有属性( 不包含从父类继承的属性 )public Method[] getDeclaredFields ()// 获取Class 对象中的指定的公有属性，参数一为属性名public Method getField (String name)// 获取该 Class 对象中的所有公有属性 ( 包含从父类和接口类集成下来的公有属性 )public Method[] getFields () 这里需要注意的是 getDeclaredField 和 getDeclaredFields 包含 private、protected、default、public 的属性，并且通过这两个函数获取到的只是在自身中定义的属性，从父类中集成的属性不能够获取到。而 getField 和 getFields 只包含 public 属性，父类中的公有属性也能够获取到。 反射获取父类与接口获取父类获取Class对象的父类 1234567891011121314151617private static void showSuperClass() &#123; Student student = new Student(\"Michael\"); Class&lt;?&gt; superClass = student.getClass().getSuperclass(); while(superClass != null) &#123; System.out.println(\"super class is : \" + superClass.getName()); //再获取父类的上一层父类，知道最后的Object类，Object的父类为null superClass = superClass.getSuperclass(); &#125;&#125;打印结果:super class is : com.michael.java.reflection.Personsuper class is : java.lang.Object 获取接口123456789101112private static void showIntefaces() &#123; Student student = new Student(\"Michael\"); Class&lt;?&gt;[] interfaces = student.getClass().getInterfaces(); for(Class&lt;?&gt; clz : interfaces) &#123; System.out.println(\"Student的接口有: \" + clz.getName()); &#125;&#125;结果打印：Student的接口有: com.michael.java.reflection.Examination 获取注解信息在框架开发中，注解加反射的组合使用是最为常见形式的。定义注解时我们会通过@Target 指定该注解能够作用的类型，看如下示例: 1234567@Target(&#123; ElementType.METHOD, ElementType.FIELD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)static @interface Test &#123;&#125; 上述注解的@target 表示该注解只能用在函数上，还有 Type、Field、PARAMETER 等类型，可以参考上述给出的参考资料。通过反射 api 我们也能够获取一个 Class 对象获取类型、属性、函数等相关的对象，通过这些对象的 getAnnotation 接口获取到对应的注解信息。 首先我们需要在目标对象上添加上注解，例如 : 12345678@Test(tag = \"Student class Test Annoatation\")public class Student extends Person implements Examination &#123; // 年级 @Test(tag = \"mGrade Test Annotation \") int mGrade; // ......&#125; 然后通过相关的注解函数得到注解信息，如下所示 : 1234567891011121314private static void getAnnotationInfos() &#123; Student student = new Student(\"mr.simple\"); Test classTest = student.getClass().getAnnotation(Test.class); System.out.println(\"class Annotatation tag = \" + classTest.tag()); Field field = null; try &#123; field = student.getClass().getDeclaredField(\"mGrade\"); Test testAnnotation = field.getAnnotation(Test.class); System.out.println(\"属性的 Test 注解 tag : \" + testAnnotation.tag()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 输出结果为：12class Annotatation tag = Student class Test Annoatation属性的 Test 注解 tag : mGrade Test Annotation 接口说明1234// 获取指定类型的注解public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) ;// 获取 Class 对象中的所有注解public Annotation[] getAnnotations() ; 后记反射作为 Java 语言的重要特性，在开发中有着极为重要的作用。很多开发框架都是基于反射来实现对目标对象的操作，而反射配合注解更是设计开发框架的主流选择","tags":[{"name":"Java","slug":"Java","permalink":"http://liuguoquan727.github.io/tags/Java/"}]},{"title":"Java集合之并发容器LinkedBlockingQueue","date":"2015-12-23T14:40:21.000Z","path":"2015/12/23/Java集合之并发容器LinkedBlockingQueue/","text":"LinkedBlockingQueue是一个基于已链接节点的、范围任意的阻塞队列的实现。 此队列按 FIFO（先进先出）排序元素。队列的头部 是在队列中时间最长的元素。队列的尾部 是在队列中时间最短的元素。新元素插入到队列的尾部，并且队列检索操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列， 但是在大多数并发应用程序中，其可预知的性能要低。 可选的容量范围构造方法参数作为防止队列过度扩展的一种方法。如果未指定容量，则它等于 Integer.MAX_VALUE。除非插入节点会使队列超出容量，否则每次插入后会动态地创建链接节点。 签名12public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable LinkedBlockingQueue实现是线程安全的，实现了先进先出等特性，是作为生产者消费者的首选 构造函数123456789public LinkedBlockingQueue() &#123; this(Integer.MAX_VALUE);&#125;public LinkedBlockingQueue(int capacity) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.capacity = capacity; last = head = new Node&lt;E&gt;(null);&#125; 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class LinkedBlockingQueueDemo &#123; /** * * 定义装苹果的篮子 * */ public class Basket &#123; // 篮子，能够容纳3个苹果 BlockingQueue&lt;String&gt; basket = new LinkedBlockingQueue&lt;String&gt;(3); // 生产苹果，放入篮子 public void produce() throws InterruptedException &#123; // put方法放入一个苹果，若basket满了，等到basket有位置 basket.put(\"An apple\"); //阻塞 // basket.offer(\"An Apple\"); //非阻塞 &#125; // 消费苹果，从篮子中取走 public String consume() throws InterruptedException &#123; // take方法取出一个苹果，若basket为空，等到basket有苹果为止(获取并移除此队列的头部) return basket.take(); //阻塞 //return basket.poll(); //非阻塞 &#125; &#125; // 定义苹果生产者 class Producer implements Runnable &#123; private String instance; private Basket basket; public Producer(String instance, Basket basket) &#123; this.instance = instance; this.basket = basket; &#125; public void run() &#123; try &#123; while (true) &#123; // 生产苹果 System.out.println(\"生产者准备生产苹果：\" + instance); basket.produce(); // 休眠300ms Thread.sleep(300); &#125; &#125; catch (InterruptedException ex) &#123; System.out.println(\"Producer Interrupted\"); &#125; &#125; &#125; // 定义苹果消费者 class Consumer implements Runnable &#123; private String instance; private Basket basket; public Consumer(String instance, Basket basket) &#123; this.instance = instance; this.basket = basket; &#125; public void run() &#123; try &#123; while (true) &#123; // 消费苹果 System.out.println(\"消费者准备消费苹果：\" + instance); System.out.println(\"consume: \" + basket.consume()); // 休眠1000ms// Thread.sleep(1000); &#125; &#125; catch (InterruptedException ex) &#123; System.out.println(\"Consumer Interrupted\"); &#125; &#125; &#125; public static void main(String[] args) &#123; LinkedBlockingQueueDemo test = new LinkedBlockingQueueDemo(); // 建立一个装苹果的篮子 Basket basket = test.new Basket(); ExecutorService service = Executors.newCachedThreadPool(); Producer producer = test.new Producer(\"生产者001\", basket);// Producer producer2 = test.new Producer(\"生产者002\", basket);// Consumer consumer = test.new Consumer(\"消费者001\", basket); service.submit(producer);// service.submit(producer2);// service.submit(consumer); // 程序运行5s后，所有任务停止// try &#123;// Thread.sleep(1000 * 1);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125;// service.shutdownNow(); &#125;&#125;","tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://liuguoquan727.github.io/tags/并发编程/"},{"name":"Collection","slug":"Collection","permalink":"http://liuguoquan727.github.io/tags/Collection/"}]},{"title":"Java集合之并发容器ConcurrentLinkedQueue","date":"2015-12-23T14:35:21.000Z","path":"2015/12/23/Java集合之并发容器ConcurrentLinkedQueue/","text":"在并发编程中我们有时候需要使用线程安全的队列。如果我们要实现一个线程安全的队列，有两种实现方式，一种是阻塞式队列，另外一种是非阻塞式队列。使用阻塞算法的队列可以用一个锁（入队和出对用同一把锁）或两个锁（入队和出对用不同的锁）等方式来实现，而非阻塞的实现则可以使用CAS的方式来实现。ConcurrentLinkedQueue是基于非阻塞式来实现的线程安全队列。 简介ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素的时候，它会返回队列头部的元素。它采用了“wait-free”算法来实现。 签名12public class ConcurrentLinkedQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements Queue&lt;E&gt;, java.io.Serializable 结构首先来看看ConcurrentLinkedQueue的类图 ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素（item）和指向下一个节点的引用（next）组成，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于header节点 1234567private transient volatile Node&lt;E&gt; head;private transient volatile Node&lt;E&gt; tail;public ConcurrentLinkedQueue() &#123; head = tail = new Node&lt;E&gt;(null);&#125; offer入队列入队列就是将新元素添加到队列的尾部，如下图所示 第一步添加元素1。队列更新head节点的next节点为元素1节点。又因为tail节点默认情况下等于head节点，所以它们的next节点都指向元素1节点。 第二步添加元素2。队列首先设置元素1节点的next节点为元素2节点，然后更新tail节点指向元素2节点。 第三步添加元素3，设置tail节点的next节点为元素3节点。 第四步添加元素4，设置元素3的next节点为元素4节点，然后将tail节点指向元素4节点。 入队过程主要做两件事情：第一是将入队节点设置成当前队列尾节点的下一个节点。第二是更新tail节点，如果tail节点的next节点不为空，则将入队节点设置成tail节点；如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点。 上面的分析让我们从单线程入队的角度来理解入队过程，但是多个线程同时进行入队情况就变得更加复杂，因为可能会出现其他线程插队的情况。如果有一个线程正在入队，那么它必须先获取尾节点，然后设置尾节点的下一个节点为入队节点，但这时可能有另外一个线程插队了，那么队列的尾节点就会发生变化，这时当前线程要暂停入队操作，然后重新获取尾节点。让我们再通过源码来详细分析下它是如何使用CAS算法来入队的。 源码分析： 123456789101112131415161718192021222324252627282930public boolean offer(E e) &#123; checkNotNull(e); //创建一个新节点 final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e); for (Node&lt;E&gt; t = tail, p = t;;) &#123; Node&lt;E&gt; q = p.next; if (q == null) &#123; // p is last node if (p.casNext(null, newNode)) &#123; // Successful CAS is the linearization point // for e to become an element of this queue, // and for newNode to become \"live\". if (p != t) // hop two nodes at a time casTail(t, newNode); // Failure is OK. return true; &#125; // Lost CAS race to another thread; re-read next &#125; else if (p == q) // We have fallen off list. If tail is unchanged, it // will also be off-list, in which case we need to // jump to head, from which all live nodes are always // reachable. Else the new tail is a better bet. p = (t != (t = tail)) ? t : head; else // Check for tail updates after two hops. p = (p != t &amp;&amp; t != (t = tail)) ? t : q; &#125;&#125; poll出队列出队列的就是从队列里返回一个节点元素，并清空该节点对元素的引用。 123456789101112131415161718192021222324public E poll() &#123; restartFromHead: for (;;) &#123; for (Node&lt;E&gt; h = head, p = h, q;;) &#123; E item = p.item; if (item != null &amp;&amp; p.casItem(item, null)) &#123; // Successful CAS is the linearization point // for item to be removed from this queue. if (p != h) // hop two nodes at a time updateHead(h, ((q = p.next) != null) ? q : p); return item; &#125; else if ((q = p.next) == null) &#123; updateHead(h, p); return null; &#125; else if (p == q) continue restartFromHead; else p = q; &#125; &#125;&#125;","tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://liuguoquan727.github.io/tags/并发编程/"},{"name":"Collection","slug":"Collection","permalink":"http://liuguoquan727.github.io/tags/Collection/"}]},{"title":"Java集合之并发容器CopyOnWriteArrayList","date":"2015-12-23T13:28:21.000Z","path":"2015/12/23/Java集合之并发容器CopyOnWriteArrayList/","text":"Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后在此基础上进行修改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器，它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。 概念CopyOnWrite容器即写时复制的容器。通俗的理解是当我向一个容器中添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后往新的容器里添加元素，添加元素后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素，所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。 继承关系12public class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 实现原理add()以下代码是向CopyOnWriteArrayList中添加元素add方法的实现，可以发现在添加的时候是需要加锁的，否则多线程写的时候会复制出N个副本出来。 1234567891011121314public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; get()而读数据的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的CopyOnWriteArrayList。 123public E get(int index) &#123; return get(getArray(), index);&#125; 应用场景CopyOnWrite并发容器用于读多写少的并发场景，比如白名单、黑名单、商场类目的访问和更新场景。 使用CopyOnWrite需要注意两件事情： 减少扩容开销。根据时间需要初始化CopyOnWriteArrayList的大小，避免写数据时扩容的开销； 使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。 缺点内存占用问题因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。 针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器如ConcurrentHashMap。 数据一致性问题CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。 参考文章Java并发编程：并发容器之CopyOnWriteArrayList 下面这篇文章验证了CopyOnWriteArrayList和同步容器的性能：http://blog.csdn.net/wind5shy/article/details/5396887 下面这篇文章简单描述了CopyOnWriteArrayList的使用:http://blog.csdn.net/imzoer/article/details/9751591","tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://liuguoquan727.github.io/tags/并发编程/"},{"name":"Collection","slug":"Collection","permalink":"http://liuguoquan727.github.io/tags/Collection/"}]},{"title":"Java集合之并发容器ConcurrentHashMap","date":"2015-12-22T14:35:21.000Z","path":"2015/12/22/Java集合之并发容器ConcurrentHashMap/","text":"术语定义 术语 英文 解释 哈希算法 Hash algorithm 是一种将任意内容的输入转换成相同长度输出的加密方式，其输出被称为哈希值 哈希表 hash table 根据设定的哈希函数和处理冲突方法将一组关键字映射到一个有限的地址区间上，并以关键字在地址区间中的项作为记录在表中的存储位置，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址。 线程不安全的HashMap因为多线程环境下，使用HashMap进行put操作会引起使循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。 效率低下的HashTableHashTable使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用个图方法来获取元素，所以竞争越激烈效率越低。 ConcurrentHashMap锁分段技术HashTable在竞争激烈的并发环境下表现出效率低下的原因是因为所有访问HashTable的线程都必须竞争同一把锁。 假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHasMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 ConcurrentHasMap结构先看看ConcurrentHasMap的类图 ConcurrentHasMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHasMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHasMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment的锁，由于每一个segment写操作只锁定自己的HashEntry数组，所以可能存在多个线程同时写的情况。 ConcurrentHasMap源码初始化ConcurrentHasMap初始化是通过initialCapacityu、loadFactor、concurrencyLevel几个参数来初始化Segment数组的，段偏移量segmentShift，段掩码segmentMask和每个segment里面的HashEntry数组。 初始化Segment数组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static final int DEFAULT_INITIAL_CAPACITY = 16;//默认加载因子,加载因子是表示Hsah表中元素的填满的程度.若:加载因子越大,填满的元素越多,好处是,空间利用率高了,但:冲突的机会加大了.反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了.static final float DEFAULT_LOAD_FACTOR = 0.75f;//默认并发等级static final int DEFAULT_CONCURRENCY_LEVEL = 16;//最大容量static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//最小Segmentstatic final int MIN_SEGMENT_TABLE_CAPACITY = 2;//最大Segmentstatic final int MAX_SEGMENTS = 1 &lt;&lt; 16; // slightly conservativepublic ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (concurrencyLevel &gt; MAX_SEGMENTS) concurrencyLevel = MAX_SEGMENTS; // Find power-of-two sizes best matching arguments int sshift = 0; int ssize = 1; while (ssize &lt; concurrencyLevel) &#123; ++sshift; //Segment数组大小 2的N次方 ssize &lt;&lt;= 1; &#125; this.segmentShift = 32 - sshift; this.segmentMask = ssize - 1; if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; int c = initialCapacity / ssize; if (c * ssize &lt; initialCapacity) ++c; int cap = MIN_SEGMENT_TABLE_CAPACITY; while (cap &lt; c) cap &lt;&lt;= 1; // create segments and segments[0] Segment&lt;K,V&gt; s0 = new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor), (HashEntry&lt;K,V&gt;[])new HashEntry[cap]); Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize]; UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0] this.segments = ss; //初始化Segment数组&#125; ssize数组长度是通过concurrencyLevel计算出来的。为了能通过按位与的哈希算法来定位segments数组的索引，必须保证segments的长度是2的N次方，所以必须计算出一个是大于或等于concurrencyLevel的最小2的N次方来作为segments数组的长度。假如concurrencyLevel等于14、15或16.ssize都会等于16，即容器里锁的个数也是16.注意concurrencyLevel的最大大小为65535，意味着segments数组的最大长度为65536，即2^16次方。 segmentShift用于定位参与hash运算的位数，segmentShift等于32减去sshift，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16,1需要向左移动4位，所以sshift等于4，因此segmentShift等于28.segmentMask是哈希运算的掩码，等于ssize-1，即15，掩码的二进制各个位的值都是1。因为ssize的最长度是65536，所以segmentShift的最大值是16，segmentMask的最大值是65535，即2^16 -1，每位都是1. get操作Segment的get操作实现非常简单和高效，先获取key的哈希值，然后使用这个哈希值通过哈希运算定位到segment，然后遍历该segment的HashEntry数组找到指定的key。 1234567891011121314151617181920//jdk 1.7public V get(Object key) &#123; Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead HashEntry&lt;K,V&gt;[] tab; int h = hash(key); //定位Segment long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE; if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp; (tab = s.table) != null) &#123; //遍历HashEntry for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE); e != null; e = e.next) &#123; K k; if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k))) return e.value; &#125; &#125; return null;&#125; get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空的才会加锁重读。 jdk1.7中的get方法没有使用锁同步，而是使用轻量级同步volatile原语sun.misc.Unsafe.getObjectVolatile(Object, long)，保证读到的是最新的对象。 jdk1.6中get方法里将要使用的共享变量都定义成volatile，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。之所以不会读到过期的值，是根据java内存模型的happen before原则，对volatile字段的写入操作先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景。 put操作1234567891011public V put(K key, V value) &#123; Segment&lt;K,V&gt; s; if (value == null) throw new NullPointerException(); int hash = hash(key); int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask; if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject // nonvolatile; recheck (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) // in ensureSegment s = ensureSegment(j); return s.put(key, hash, value, false);&#125; 如果段不为空，那么进入java.util.concurrent.ConcurrentHashMap.Segment.put(K, int, V, boolean)，否则构造段。由此可以看出段的构造是以懒加载的方式，按需构造。 12345678910111213141516171819202122232425262728293031323334353637383940414243 final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123; HashEntry&lt;K,V&gt; node = tryLock() ? null : scanAndLockForPut(key, hash, value); V oldValue; try &#123; HashEntry&lt;K,V&gt;[] tab = table; int index = (tab.length - 1) &amp; hash; HashEntry&lt;K,V&gt; first = entryAt(tab, index); for (HashEntry&lt;K,V&gt; e = first;;) &#123; if (e != null) &#123; K k; if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) &#123; oldValue = e.value; if (!onlyIfAbsent) &#123; e.value = value; ++modCount; &#125; break; &#125; e = e.next; &#125; else &#123; if (node != null) node.setNext(first); else node = new HashEntry&lt;K,V&gt;(hash, key, value, first); int c = count + 1; if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY) rehash(node); else setEntryAt(tab, index, node); ++modCount; count = c; oldValue = null; break; &#125; &#125; &#125; finally &#123; unlock(); &#125; return oldValue;&#125; 进入段中执行最终put的时候，会使用可重入锁进行tryLock可轮询请求锁，如果成功获取锁，那么条目的插入方式和普通hashmap没多大区别。如果此时有其他线程也再对这个段进行更新操作，那么执行scanAndLockForPut进行重试。 重试的处理逻辑: 123456789101112131415161718192021222324252627282930private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123; HashEntry&lt;K,V&gt; first = entryForHash(this, hash); HashEntry&lt;K,V&gt; e = first; HashEntry&lt;K,V&gt; node = null; int retries = -1; // negative while locating node while (!tryLock()) &#123; HashEntry&lt;K,V&gt; f; // to recheck first below if (retries &lt; 0) &#123; if (e == null) &#123; if (node == null) // speculatively create node node = new HashEntry&lt;K,V&gt;(hash, key, value, null); retries = 0; &#125; else if (key.equals(e.key)) retries = 0; else e = e.next; &#125; else if (++retries &gt; MAX_SCAN_RETRIES) &#123; lock(); break; &#125; else if ((retries &amp; 1) == 0 &amp;&amp; (f = entryForHash(this, hash)) != first) &#123; e = first = f; // re-traverse if entry changed retries = -1; &#125; &#125; return node;&#125; 一旦未获得锁 while (!tryLock()) 则进行重试循环。 第一次重试中retries &lt; 0，如果桶条目不为空，那么遍历桶中条目链表，如果key已经存在，那么直接进入下一个循环，否则构造新条目，进入下一个循环；如果重试次数达到极限，那么使用阻塞同步方法；每隔一次循环，校验下所在桶有没有更新，如果更新了，那么重试次数重置，重新开始。一旦获得锁，直接返回，进行常规的hash put操作。 总的来说，put的同步机制是如果没有其他线程在更新该段，那么直接put。否则轮询请求锁，直至获得锁。 ConcurrentHasMap是弱一致性的迭代器java.util.concurrent 集合返回的迭代器称为弱一致的（weakly consistent）迭代器 ConcurrentHashMap与其他并发容器所提供的多线程环境下不会抛出并发修改异常的迭代器是由其返回的弱一致性迭代器决定的，弱一致性迭代器可以容许并发修改。当迭代器创建的时，它会遍历已有元素，并且可以感应到在迭代器被创建后对容器的修改。这种弱一致性在调用那些需要对整个容器进行加锁的方法如size或isEmpty时可能提供不精确的值，因此只有当程序需要在独占访问中加锁时，才不能使用ConcurrentHashMap，而在绝大多数情况下ConcurrentHashMap可以带来更好的伸缩性。 参考文章 《Java并发编程实践》笔记2——基础同步类 聊聊并发（4）：深入分析ConcurrentHashMap","tags":[{"name":"并发编程","slug":"并发编程","permalink":"http://liuguoquan727.github.io/tags/并发编程/"},{"name":"Collection","slug":"Collection","permalink":"http://liuguoquan727.github.io/tags/Collection/"}]},{"title":"Java集合之LinkedhashMap","date":"2015-12-20T14:35:21.000Z","path":"2015/12/20/Java集合之LinkedHashMap/","text":"简介LinkedHashMap是HashMap的一个子类，它在HashMap的基础上维持了一个双向链表（hash表+双向链表），在遍历的时候可以使用插入顺序（先进先出），或者是最近最少使用（LRU）的顺序。 LinkedHashMap是key键有序的一种集合，使用双向链表来保证key的顺序。 特点一般来说，如果需要使用的Map中的key无序，选择HashMap；如果要求key有序，则选择TreeMap。但是选择TreeMap就会有性能问题，因为TreeMap的get操作的时间复杂度是O(log(n))的，相比于HashMap的O(1)还是差不少的，LinkedHashMap的出现就是为了平衡这些因素，使得能够以O(1)时间复杂度增加查找元素，又能够保证key的有序性。 此外，LinkedHashMap提供了两种key的顺序： 访问顺序（access order）。可以使用这种顺序实现LRU（Least Recently Used）缓存 插入顺序（insertion orde）。同一key的多次插入，并不会影响其顺序 签名12public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; 从定义可以看到LinkedHashMap继承于HashMap，且实现了Map接口。这也就意味着HashMap的一些优秀因素可以被继承下来，比如hash寻址，使用链表解决hash冲突等实现的快速查找，对于HashMap中一些效率较低的内容，比如容器扩容过程，遍历方式，LinkedHashMap是否做了一些优化呢。继续看代码吧。 底层存储LinkedHashMap是基于HashMap，并在其基础上维持了一个双向链表，也就是说LinkedHashMap是一个hash表（数组+单向链表） +双向链表的实现，到底实现方式是怎么样的，来看一下： 12345//双向链表的头结点private transient Entry&lt;K,V&gt; header ;//true 表示最近较少使用顺序，false表示插入顺序private final boolean accessOrder; 下面来看看Entry这个节点类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * LinkedHashMap entry. */ private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; &#123; // These fields comprise the doubly linked list used for iteration. // 双向链表的上一个节点before和下一个节点after Entry&lt;K,V&gt; before, after ; // 构造方法直接调用父类HashMap的构造方法（super） Entry( int hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; /** * 从链表中删除当前节点的方法 */ private void remove() &#123; // 改变当前节点前后两个节点的引用关系，当前节点没有被引用后，gc可以回收 // 将上一个节点的after指向下一个节点 before.after = after; // 将下一个节点的before指向前一个节点 after.before = before; &#125; /** * 在指定的节点前加入一个节点到链表中（也就是加入到链表尾部） */ private void addBefore(Entry&lt;K,V&gt; existingEntry) &#123; // 下面改变自己对前后的指向 // 将当前节点的after指向给定的节点（加入到existingEntry前面嘛） after = existingEntry; // 将当前节点的before指向给定节点的上一个节点 before = existingEntry.before ; // 下面改变前后最自己的指向 // 上一个节点的after指向自己 before.after = this; // 下一个几点的before指向自己 after.before = this; &#125; // 当向Map中获取查询元素或修改元素（put相同key）的时候调用这个方法 void recordAccess(HashMap&lt;K,V&gt; m) &#123; LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m; // 如果accessOrder为true，也就是使用最近较少使用顺序 if (lm.accessOrder ) &#123; lm. modCount++; // 先删除，再添加，也就相当于移动了 // 删除当前元素 remove(); // 将当前元素加入到header前（也就是链表尾部） addBefore(lm. header); &#125; &#125; // 当从Map中删除元素的时候调动这个方法 void recordRemoval(HashMap&lt;K,V&gt; m) &#123; remove(); &#125;&#125; 可以看到Entry继承了HashMap中的Entry，但是LinkedHashMap中的Entry多了两个属性指向上一个节点的before和指向下一个节点的after，也正是这两个属性组成了一个双向链表。等等。。。Entry还有一个继承下来的next属性，这个next是单向链表中用来指向下一个节点的，怎么回事嘛，怎么又是单向链表又是双向链表呢，都要晕了对不对，其实想的没错，这里的节点即是Hash表中的单向链表中的一个节点，它又是LinkedHashMap维护的双向链表中的一个节点。 注：黑色箭头指向表示单向链表的next指向，红色箭头指向表示双向链表的before指向，蓝色箭头指向表示双向链表的after指向。另外LinkedHashMap种还有一个header节点是不保存数据的，这里没有画出来。 从上图可以看出LinkedHashMap仍然是一个Hash表，底层由一个数组组成，而数组的每一项都是个单向链表，由next指向下一个节点。但是LinkedHashMap所不同的是，在节点中多了两个属性before和after，由这两个属性组成了一个双向循环链表（你怎么知道是循环，下面在说喽），而由这个双向链表维持着Map容器中元素的顺序。看下Entry中的recordRemoval方法，该方法将在节点被删除时候调用，Hash表中链表节点被正常删除后，调用该方法修正由于节点被删除后双向链表的前后指向关系，从这一点来看，LinkedHashMap比HashMap的add、remove、set等操作要慢一些（因为要维护双向链表 ）。 源码解析构造方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 构造一个指定初始容量和加载因子的LinkedHashMap，默认accessOrder为false */ public LinkedHashMap( int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor); accessOrder = false; &#125; /** * 构造一个指定初始容量的LinkedHashMap，默认accessOrder为false */ public LinkedHashMap( int initialCapacity) &#123; super(initialCapacity); accessOrder = false; &#125; /** * 构造一个使用默认初始容量(16)和默认加载因子(0.75)的LinkedHashMap，默认accessOrder为false */ public LinkedHashMap() &#123; super(); accessOrder = false; //默认false &#125; /** * 构造一个指定map的LinkedHashMap，所创建LinkedHashMap使用默认加载因子(0.75)和足以容纳指定map的初始容量，默认accessOrder为false 。 */ public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; super(m); accessOrder = false; &#125; /** * 构造一个指定初始容量、加载因子和accessOrder的LinkedHashMap */ public LinkedHashMap( int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125;//重写了HashMap的init方法@Overridevoid init() &#123; // 初始化话header，将hash设置为-1，key、value、next设置为null header = new Entry&lt;K,V&gt;(-1, null, null, null); // header的before和after都指向header自身 header.before = header. after = header ;&#125; 增加LinkedHashMap没有重写HashMap的put方法，只是重写了HashMap被put调用的addEntry方法 12345678910111213141516171819202122232425262728293031323334353637383940414243void addEntry( int hash, K key, V value, int bucketIndex) &#123; // 调用createEntry方法创建一个新的节点 createEntry(hash, key, value, bucketIndex); // Remove eldest entry if instructed, else grow capacity if appropriate // 取出header后的第一个节点（因为header不保存数据，所以取header后的第一个节点） Entry&lt;K,V&gt; eldest = header.after ; // 判断是容量不够了是要删除第一个节点还是需要扩容 if (removeEldestEntry(eldest)) &#123; // 删除第一个节点（可实现FIFO、LRU策略的Cache） removeEntryForKey(eldest. key); &#125; else &#123; // 和HashMap一样进行扩容 if (size &gt;= threshold) resize(2 * table.length ); &#125;&#125;/** * This override differs from addEntry in that it doesn't resize the * table or remove the eldest entry. */void createEntry( int hash, K key, V value, int bucketIndex) &#123; // 下面三行代码的逻辑是，创建一个新节点放到单向链表的头部 // 取出数组bucketIndex位置的旧节点 HashMap.Entry&lt;K,V&gt; old = table[bucketIndex]; // 创建一个新的节点，并将next指向旧节点 Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(hash, key, value, old); // 将新创建的节点放到数组的bucketIndex位置 table[bucketIndex] = e; // 维护双向链表，将新节点添加在双向链表header前面（链表尾部） e.addBefore( header); // 计数器size加1 size++;&#125;/** * 默认返回false，也就是不会进行元素删除了。如果想实现cache功能，只需重写该方法 */protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false;&#125; 可以看到，在添加方法上，比HashMap中多了两个逻辑，一个是当Map容量不足后判断是删除第一个元素，还是进行扩容，另一个是维护双向链表。而在判断是否删除元素的时候，我们发现removeEldestEntry这个方法竟然是永远返回false，原来想要实现Cache功能，需要自己继承LinkedHashMap然后重写removeEldestEntry方法，这里默认提供的是容器的功能。 删除LinkedHashMap没有重写remove方法，只是在实现了Entry类的recordRemoval方法，该方法是HashMap的提供的一个回调方法，在HashMap的remove方法进行回调，而LinkedHashMap中recordRemoval的主要当然是要维护双向链表了，返回上面去看下Entry类的recordRemoval方法吧。 查找LinkedHashMap重写了get方法，但是的确复用了HashMap中的getEntry方法，LinkedHashMap是在get方法中指加入了调用recoreAccess方法的逻辑，recoreAccess方法的目的当然也是维护双向链表了，具体逻辑返回上面去看下Entry类的recoreAccess方法吧。 1234567public V get(Object key) &#123; Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key); if (e == null) return null; e.recordAccess( this); return e.value ;&#125; 是否包含1234567891011121314public boolean containsValue(Object value) &#123; // Overridden to take advantage of faster iterator // 遍历双向链表，查找指定的value if (value==null) &#123; for (Entry e = header .after; e != header; e = e.after ) if (e.value ==null) return true; &#125; else &#123; for (Entry e = header .after; e != header; e = e.after ) if (value.equals(e.value )) return true; &#125; return false;&#125; LinkedHashMap对containsValue进行了重写，我们在HashMap中说过，HashMap的containsValue需要遍历整个hash表，这样是十分低效的。而LinkedHashMap中重写后，不再遍历hash表，而是遍历其维护的双向链表，这样在效率上难道就有所改善吗？我们分析下：hash表是由数组+单向链表组成，而由于使用hash算法，可能会导致散列不均匀，甚至数组的有些项是没有元素的（没有hash出对应的散列值），而LinkedHashMap的双向链表呢，是不存在空项的，所以LinkedHashMap的containsValue比HashMap的containsValue效率要好一些。 自定义LruCache12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.michael.java.construct;import java.util.LinkedHashMap;import java.util.Map;public class LruCache extends LinkedHashMap&lt;String, Object&gt;&#123; /** * */ private static final long serialVersionUID = -2725884916293330545L; private static final int DEFAULT_MAX_CAPACITY = 1024; private static final float DEFAULT_LOAD_FACTOR = 0.75f; private int maxCapacity; public LruCache(boolean accessOrder) &#123; super(DEFAULT_MAX_CAPACITY, DEFAULT_LOAD_FACTOR, accessOrder); this.maxCapacity = DEFAULT_MAX_CAPACITY; &#125; public LruCache(int capacity,boolean accessOrder) &#123; super(DEFAULT_MAX_CAPACITY, DEFAULT_LOAD_FACTOR, accessOrder); this.maxCapacity = capacity; &#125; @Override protected boolean removeEldestEntry( java.util.Map.Entry&lt;String, Object&gt; eldest) &#123; // TODO Auto-generated method stub return this.size() &gt; maxCapacity; &#125; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub LruCache cache = new LruCache(5, true); for(int i = 0;i &lt; 6;i++) &#123; cache.put(\"k\"+i, \"v\"+i); &#125; System.out.println(\"size: \" + cache.size()); for(Map.Entry&lt;String, Object&gt; entry : cache.entrySet()) &#123; System.out.println(entry.getKey() + \" = \" + entry.getValue()); &#125; System.out.println(\"------------\"); System.out.println(\"k3 = \" + cache.get(\"k3\")); System.out.println(\"------------\"); cache.put(\"k6\", \"v6\"); for(Map.Entry&lt;String, Object&gt; entry : cache.entrySet()) &#123; System.out.println(entry.getKey() + \" = \" + entry.getValue()); &#125; &#125;&#125;结果打印：size: 5k1 = v1k2 = v2k3 = v3k4 = v4k5 = v5------------k3 = v3------------k2 = v2k4 = v4k5 = v5k3 = v3k6 = v6 序列中的第一个元素时最近使用最少的元素 参考文章： 给jdk写注释系列之jdk1.6容器(5)-LinkedHashMap源码解析 Java LinkedHashMap源码解析","tags":[{"name":"Collection","slug":"Collection","permalink":"http://liuguoquan727.github.io/tags/Collection/"}]},{"title":"Java集合之TreeMap","date":"2015-12-19T14:35:21.000Z","path":"2015/12/19/Java集合之TreeMap/","text":"TreeMap是基于红黑树结构的一种Map，要分析TreeMap的实现首先要了解红黑树这种数据结构。 二叉树、红黑树简介先简单总结一下数组，链表，Hash表以及树的优缺点: 数组 优点：随机访问效率高（根据下标查询）；搜索效率较高（可使用折半方法） 缺点：内存连续且固定，存储效率低；插入和删除效率低（可能会进行数组扩容或者拷贝） 链表 优点：不要求连续内存，存储效率高；插入和删除效率高（只需要改变指针指向） 缺点：不支持随机访问；搜索效率低（需要遍历） 哈希表 优点：搜索效率高；增删效率高 缺点：内存利用率低（基于数组）；存在散列冲突 二叉树 优点：查询效率高；增删效率高；存储效率高； 缺点：算法复杂 二叉树二叉树的特点： 若左子树不为空，则左子树上所有结点的值均小于它的根结点的值 若右子树不为空，则右子树上所有结点的值均大于它的根结点的值； 左右子树也分别为二叉查找树 没有键值相等的节点 按照二叉查找树存储的数据，对元素的搜索效率是非常高的，比如上图中如果要查找值为48的节点，只需要遍历4个节点就能完成。理论上，一颗平衡的二叉查找树的任意节点平均查找效率为树的高度h，即O(lgn)。但是如果二叉查找树的失去平衡（元素全在一侧），搜索效率就退化为O(n)，因此二叉查找树的平衡是搜索效率的关键所在。而红黑树就是靠红黑规则来维持二叉查找树的平衡性。 红黑树红黑树的红黑规则： 节点是红色或黑色 根节点是黑色 每个叶子节点（NIL节点，空节点）是黑色的 每个红色节点的两个子节点都是黑色（从每个叶子到根的所有路径上不能有两个连续的红色节点） 从任意节点到其每个叶子的所有路径都包含相同数目的黑色节点 第5条规则到底是什么情况，下面简单解释下，比如图中红8到1左边的叶子节点的路径包含两个黑色节点，到6下面的叶子节点的路径也包含两个黑色节点。 但是在在添加或删除节点后，红黑树就发生了变化，可能不再满足上面的5个特性，为了保持红黑树的以上特性，就有了三个动作：左旋、右旋、着色。 下面来看下什么是红黑树的左旋和右旋： 对x进行左旋，意味着将x变成一个左节点。 对y进行右旋，意味着将y变成一个右节点。 TreeMap签名123public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable HashMap是无序的，TreeMap是有序的 接口NavigableMap1public interface NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt; 发现NavigableMap继承了SortedMap，说明这个Map是有序的。这个顺序一般是指由Comparable接口提供的keys自然序，或者也可以在窗口SortedMap时，指定一个Comparator来决定。 Comparator和Comparable的区别 Comparable一般表示类的自然序，比如定义一个Student类，学号为默认排序 Comparator一般表示类在某种场合下的特殊分类，需要定制化排序。比如现在想按照Student类的age来排序。 插入SortedMap中的key的类都必须继承Comparable类（或指定一个comparator），这样才能确定如何比较（通过k1.compareTo(k2)或comparator.compare(k1, k2)）两个key，否则，在插入时，会报ClassCastException的异常。 此外，SortedMap中key的顺序性应该与equals方法保持一致。也就是说k1.compareTo(k2)或comparator.compare(k1, k2)为true时，k1.equals(k2)也应该为true。 介绍完了SortedMap，再来回到我们的NavigableMap上面来。NavigableMap是JDK1.6新增的，在SortedMap的基础上，增加了一些“导航方法”（navigation methods）来返回与搜索目标最近的元素。例如下面这些方法： lowerEntry，返回所有比给定Map.Entry小的元素 floorEntry，返回所有比给定Map.Entry小或相等的元素 ceilingEntry，返回所有比给定Map.Entry大或相等的元素 higherEntry，返回所有比给定Map.Entry大的元素 源码解析红黑树的算法还没有理解深刻，暂时挖个坑 因为红黑树是平衡的二叉搜索树，所以其put（包含update操作）、get、remove的时间复杂度都为log(n) 总结 TreeMap的key是有序的，增删改查操作的时间复杂度为O(log(n))，为了保证红黑树平衡，在必要时会进行旋转 HashMap的key是无序的，增删改查操作的时间复杂度为O(1)，为了做到动态扩容，在必要时会进行resize。 参考文章: 给jdk写注释系列之jdk1.6容器(7)-TreeMap源码解析","tags":[{"name":"Collection","slug":"Collection","permalink":"http://liuguoquan727.github.io/tags/Collection/"}]},{"title":"Java集合之HashMap","date":"2015-12-19T13:30:21.000Z","path":"2015/12/19/Java集合之HashMap/","text":"签名（Signature）123public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 可以看到HashMap实现了： 接口Cloneable，用于表明HashMap对象会重写java.lang.Object.clone()方法，HashMap实现的是浅拷贝 接口Serializable：表明HashMap对象可以被序列化 Map接口Map接口里包含的成员方法不外乎是“增删改查”，Map虽然并不是Collection，但它提供了三种“集合视角”，与下面三个方法一一对应： Set&lt;key&gt; keySet()，提供key的集合视角 Collection&lt;V&gt; values()，提供value的集合视角 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(),提供key-value键值对的集合视角 设计理念哈希表（hash table）HashMap是一种基于哈希表实现的Map，哈希表是一种通用的数据结构，其概念是：key经过hash函数作用后得到一个槽（buckets）的索引（index），槽中保存着我们想要获取的值，如下图所示： 一些不同的key经过同一hash函数后可能产生相同的索引，也就会产生冲突，所以利用哈希表这种数据结构实现具体类时，需要注意两个问题： 设计一个好的hash函数，使冲突尽可能的减少 需要解决发生冲突后的处理 HashMap的特点 线程非安全，并且允许key与value都为null值，HashTable与之相反，为线程安全，key与value都不允许null值 不保证其内部元素的顺序，而且随着时间的推移，同一元素的位置也可能改变（resize的情况） put、get操作的时间复杂度为O（1） 遍历其集合视角的时间复杂度与其容量和现有元素的大小成正比，如果遍历的性能要求很高，不要把capacity设置的过高或者把平衡因子设置的过低。 由于HashMap是线程非安全的，意味着如果有多个线程同时对同一HashMap试图做迭代时有结构上的改变（添加、删除entry，只改变entry的value值不算结构改变），那么会报ConcurrentModificationException异常，专业术语叫fail-fast，尽早报错对应多线程程序来说是很有必要的。 Map m = Collections.synchronizedMap(new HashMap(...));通过这种方式可以得到一个线程安全的Map。 实现原理构造函数HashMap遵循集合框架的约束，提供一个参数为空的构造函数与有一个参数且参数类型为Map的构造函数。除此之外，还提供了两个构造函数，用于设置HashMap的容量（capacity）和平衡因子（loadFactor）。 12345678910111213141516171819202122232425262728293031public HashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);&#125; public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR); inflateTable(threshold); putAllForCreate(m);&#125;public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;public HashMap(int initialCapacity, float loadFactor) &#123; //初始容量和加载因子合法校验 if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; threshold = initialCapacity; init();&#125; 容量与平衡因子都有个默认值，并且容量有个最大值 1234567891011121314151617181920212223242526/** * 默认初始容量为16，必须为2的指数倍 */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16/** * 最大容量为2的30次方 */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** * 默认加载因子为0.75f */static final float DEFAULT_LOAD_FACTOR = 0.75f; // Entry数组，长度必须为2的n次幂 transient Entry[] table; // 已存储元素的数量 transient int size ; // 下次扩容的临界值，size&gt;=threshold就会扩容，threshold等于capacity*load factor int threshold; // 加载因子 final float loadFactor ; 可以看到，默认的平衡因子为0.75，这是权衡了时间复杂度与空间复杂度之后的最好取值（官方说法），过高的因子会降低存储空间但是查找的时间就会增加。 此外，我们注意到容量必须为2的指数被（默认16），这是为什么呢？解答这个问题，需要了解HashMap中哈希函数的设计原理 哈希函数的设计原理12345678910111213141516171819202122final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125;/** * Returns index for hash code h. */static int indexFor(int h, int length) &#123; // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\"; return h &amp; (length-1);&#125; 在哈希表容量为length的情况下，为了使key都能在冲突最小的情况下映射到[0,length)的索引（index）内，HasMap让length为2的指数倍，然后用`hashCode(key) &amp; (length -1)的方法得到索引。 因为length为2的指数倍，所以length-1所对应的二进制位都为1，然后与hashCode(key)坐与运算，即可得到[0,length)内的索引。 但是这里有个问题，如果HashCode（key)的值大于length的值，举个例子： Java中对象的哈希值都是32位整数，而HashMap的默认大小为16，那么如果有两个对象的哈希值为：0xABAB0000与0xBABA0000，它们的后四位都是一样，那么与16异或后得到结果都是一样的为0，也就是产生了冲突。 造成冲突的原因关键在于16限制了只能用低位来计算，高位直接舍弃了，所以我们需要额外的哈希函数而不只是简单的对象的hashCode方法了。具体来说就是HashMap中hash（）函数所实现的功能了。 首先有个随机的hashSeed来降低冲突发生的几率然后如果是字符串。则用了sun.misc.Hashing.stringHash32((String) k)来获取索引值最后通过一系列的无符号右移操作，来把高位与地位进行异或操作，来降低冲突发生的几率。 右移的偏移量20,12,7是怎么来的呢？因为Java中对象的哈希值是32位的，所以这几个数应该就是把高位与地位做异或运算，至于这几个数是如何选取的，就不清楚了。 HashMap.EntryHashMap中存放的是HashMap.Entry对象，它继承自Map.Entry，其比较重要的构造函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; //指向下一个节点 int hash; /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; public final int hashCode() &#123; //用key的hash值与value的hash值与运算的结果作为Entry的hash值 return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); &#125; public final String toString() &#123; return getKey() + \"=\" + getValue(); &#125; /** * 当向HashMap中添加元素时调用这个方法，这里没有实现是供子类回调 */ void recordAccess(HashMap&lt;K,V&gt; m) &#123; &#125; /** * 当从HashMap中删除元素时调用这个方法 */ void recordRemoval(HashMap&lt;K,V&gt; m) &#123; &#125;&#125; 可以看到，Entry实现了单向链表的功能，用next成员变量来级联起来。也就是说HashMap的底层结构是一个数组，而数组的元素是一个单向链表。 介绍完Entry，下面介绍一个重要的成员变量 12//HashMap内部维护一个数组类型的Entry变量table，用来保存添加进来的Entry对象transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; Entry是单链表，怎么这里又需要个数组类型的tabl呢？其实这是解决冲突的一个方式：链地址法（开散列法），效果如下： 就是相同索引值的Entry会以单向链表的形式存在。HashMap采用将相同的散列值存储到一个链表中，也就是说在一个链表中的元素他们的散列值绝对是相同的。 put操作因为put操作有可能需要对HashMap进行resize，所以实现较复杂 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139private void inflateTable(int toSize) &#123; //辅助函数，用于填充HashMap到指定的capacity // Find a power of 2 &gt;= toSize int capacity = roundUpToPowerOf2(toSize); //threshold为resize的阈值，超过后HashMap会进行resize，内容的entry会进行rehash threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); table = new Entry[capacity]; initHashSeedAsNeeded(capacity);&#125;/** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. */public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); //使用key的hashCode计算key对应的hash值 int hash = hash(key); //通过key的哈希值查找在数组中的index位置 int i = indexFor(hash, table.length); //这里的循环是关键 //当新增的key所对应的索引i，对应table[i]中已经有值时，进入循环体 //取出数组index位置的链表，遍历链表查看是否已经存在相同的key for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; //判断是否存在本次插入的key，如果存在用本次的value替换之前oldValue，相当于update操作 //并返回之前的oldValue if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; //如果本次新增key之前不存在于HashMap中，modCount加1，说明结构改变了 modCount++; //在数组i位置处添加一个新的链表节点 addEntry(hash, key, value, i); //没有相同key的情况，返回null return null;&#125;private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(0, null, value, 0); return null;&#125;void addEntry(int hash, K key, V value, int bucketIndex) &#123; //如果增加一个元素会后，HashMap的大小超过阈值，需要resize if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; //增加的幅度是之前的1倍 resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex);&#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123; //首先得到该索引处的冲突链Entries，第一次插入bucketIndex位置时冲突链为null，也就是e为null Entry&lt;K,V&gt; e = table[bucketIndex]; //然后把新的Entry添加到冲突链的开头，也就是说，后插入的反而在前面（第一次还真没看明白） //table[bucketIndex]为新加入的Entry，是bucketIndex位置的冲突链的第一个元素 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125;//下面看看HashMap是如何进行resize，庐山真面目就要揭晓了😊void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; //如果已经达到最大容量，那么就直接返回 if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; //使用新的容量创建一个新的链表数组 Entry[] newTable = new Entry[newCapacity]; //initHashSeedAsNeeded(newCapacity)的返回值决定了是否需要重新计算Entry的hash值 //将当前数组的元素移动到新的数组 transfer(newTable, initHashSeedAsNeeded(newCapacity)); //将当前数组的引用指向新的数组 table = newTable; //重新计算临界值 threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);&#125;/** * Transfers all entries from current table to newTable. */void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; //遍历当前的table，将里面的元素添加到新的newTable中 for (Entry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; //最后这两句用了与put放过相同的技巧 //将后插入的反而在前面 newTable[i] = e; e = next; &#125; &#125;&#125;/** * Initialize the hashing mask value. We defer initialization until we * really need it. */final boolean initHashSeedAsNeeded(int capacity) &#123; boolean currentAltHashing = hashSeed != 0; boolean useAltHashing = sun.misc.VM.isBooted() &amp;&amp; (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD); //这里说明了，在hashSeed不为0或满足useAltHash时，会重算Entry的hash值 //至于useAltHashing的作用可以参考下面的链接 // http://stackoverflow.com/questions/29918624/what-is-the-use-of-holder-class-in-hashmap boolean switching = currentAltHashing ^ useAltHashing; if (switching) &#123; hashSeed = useAltHashing ? sun.misc.Hashing.randomHashSeed(this) : 0; &#125; return switching;&#125; Map中的元素越多，hash冲突的几率也就越大，数组长度是固定的，所以导致链表越来越长，那么查询的效率当然也就越地下了。HasMap的扩容resize，需要将所有的元素重新计算后，一个个重新排列到新的数组中去，这是非常低效的，和ArrayList一样，在可预知容量大小的情况下，提前预设容量会减少HashMap的扩容，提高性能。 get操作123456789101112131415161718192021222324252627282930313233343536public V get(Object key) &#123; //单独处理key为null的情况 if (key == null) return getForNullKey(); Entry&lt;K,V&gt; entry = getEntry(key); return null == entry ? null : entry.getValue();&#125;private V getForNullKey() &#123; if (size == 0) &#123; return null; &#125; //key为null的Entry用于放在table[0]中，但是在table[0]冲突链中的Entry的key不一定为null //所以需要遍历冲突链，查找key是否存在 for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) return e.value; &#125; return null;&#125;final Entry&lt;K,V&gt; getEntry(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : hash(key); //首先定位到索引在table中的位置 //然后遍历冲突链，查找key是否存在 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null;&#125; remove操作123456789101112131415161718192021222324252627282930313233343536public V remove(Object key) &#123; Entry&lt;K,V&gt; e = removeEntryForKey(key); //可以看到删除的key如果存在，就返回其所对应的value return (e == null ? null : e.value);&#125;final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length); //这里用了两个Entry对象，相当于两个指针，为的是防治冲突链发生断裂的情况 //这里的思路就是一般的单向链表的删除思路 Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; //当table[i]中存在冲突链时，开始遍历里面的元素 while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; Object k; //如果hash值和key都相等则认为相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; modCount++; size--; if (prev == e) //当冲突链只有一个Entry时 table[i] = next; else prev.next = next; e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e;&#125; 一般而言，认为HashMap的这四种操作时间复杂度O（1），因为它hash函数性质较好，保证了冲突发生的几率较小。 从删除和查找操作可以看出，在根据key查找元素的时候，还是需要通过遍历，但是由于已经通过hash函数对key散列，要遍历的只是发生冲突后生成的链表，这样遍历的结果就已经少很多了，比完全遍历效率提升了N倍。 fast-fail的HashIterator集合类用Iterator类来遍历其包含的元素，接口Enumeration以及不推荐使用。相比Enumeration，Iterator有下面两个优势： Iterator允许调用者在遍历集合类时删除集合类中包含的元素 比Enumeration命名更简单 HashMap中提供的三种集合视角，底层都是用HashIterator是实现的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; Entry&lt;K,V&gt; next; // next entry to return //在初始化Iterator实例时，纪录下当前的修改次数 int expectedModCount; // For fast-fail int index; // current slot Entry&lt;K,V&gt; current; // current entry HashIterator() &#123; expectedModCount = modCount; if (size &gt; 0) &#123; // advance to first entry Entry[] t = table; //遍历HashMap的table，依次查找元素 while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; final Entry&lt;K,V&gt; nextEntry() &#123; //在访问下一个Entry时，判断是否有其他线程有对集合的修改 //说明HashMap是线程非安全的 if (modCount != expectedModCount) throw new ConcurrentModificationException(); Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if ((next = e.next) == null) &#123; Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; current = e; return e; &#125; public void remove() &#123; if (current == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); Object k = current.key; current = null; HashMap.this.removeEntryForKey(k); expectedModCount = modCount; &#125;&#125;private final class ValueIterator extends HashIterator&lt;V&gt; &#123; public V next() &#123; return nextEntry().value; &#125;&#125;private final class KeyIterator extends HashIterator&lt;K&gt; &#123; public K next() &#123; return nextEntry().getKey(); &#125;&#125;private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125;&#125; 序列化从源码可知，保存Entry的table数组为transient的，也就是说在进行序列化时并不会包含该成员，这是为什么呢？ 1transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE; 为了解答这个问题，我们需要明确下面事实：Object.hasCode方法对于一个类的两个实例返回的是不同的哈希值。 我们可以试想下面的场景： 我们在机器A上算出对象A的哈希值与索引，然后把它插入到HashMap中，然后把该HashMap序列化后，在机器B上重新算出对象的哈希值与索引，这与机器A上算出的是不一样的，所以我们在机器B上get对象A时，会得到错误的结果。所以说，当序列化一个HashMap对象时，保存Entry的table是不需要序列化进来的，因为它在另一台机器上是错误的。因为这个原因，HashMap重写了writeObject和readObject方法 HashMap遍历12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class HashMapDemo &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); for(int i = 0;i &lt; 4;i++ ) &#123; map.put(\"name\"+i, \"liuguoquan\"+i); &#125; long start = System.nanoTime(); //键的集合 Set&lt;String&gt; set = map.keySet(); Iterator&lt;String&gt; iterator = set.iterator(); while (iterator.hasNext()) &#123; String key = (String) iterator.next(); String value = map.get(key); System.out.println(key + \" = \" + value); &#125; long end = System.nanoTime(); System.out.println(\"keySet(): \" + (end - start)+\"纳秒\"); //foreach keyset start = System.nanoTime(); for(String key : map.keySet()) &#123; String value = map.get(key); System.out.println(key + \" = \" + value); &#125; end = System.nanoTime(); System.out.println(\"for keySet(): \" + (end - start)+\"纳秒\"); //Entry集合 效率较高 start = System.nanoTime(); Set&lt;Entry&lt;String, String&gt;&gt; entrySet = map.entrySet(); Iterator&lt;Entry&lt;String, String&gt;&gt; it = entrySet.iterator(); while (it.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = (Map.Entry&lt;String, String&gt;) it .next(); String key = entry.getKey(); String value = entry.getValue(); System.out.println(key + \" = \" + value); &#125; end = System.nanoTime(); System.out.println(\"entrySet(): \"+ (end - start)+\"纳秒\"); start = System.nanoTime(); //foreach entry for(Entry&lt;String, String&gt; entry : map.entrySet()) &#123; String key = entry.getKey(); String value = entry.getValue(); System.out.println(key + \" = \" + value); &#125; end = System.nanoTime(); System.out.println(\"for entrySet(): \"+ (end - start)+\"纳秒\"); &#125;&#125;结果打印：name3 = liuguoquan3name2 = liuguoquan2name1 = liuguoquan1name0 = liuguoquan0keySet(): 403136纳秒name3 = liuguoquan3name2 = liuguoquan2name1 = liuguoquan1name0 = liuguoquan0for keySet(): 84675纳秒name3 = liuguoquan3name2 = liuguoquan2name1 = liuguoquan1name0 = liuguoquan0entrySet(): 109194纳秒name3 = liuguoquan3name2 = liuguoquan2name1 = liuguoquan1name0 = liuguoquan0for entrySet(): 69850纳秒 从上面的结果来看： HashMap遍历，如果既需要可以也需要value,直接用 12345for(Entry&lt;String, String&gt; entry : map.entrySet()) &#123; String key = entry.getKey(); String value = entry.getValue(); System.out.println(key + \" = \" + value);&#125; 如果只是遍历key而无需value的话，可以直接用1234for(String key : map.keySet()) &#123;&#125; 参考文章： 给jdk写注释系列之jdk1.6容器(4)-HashMap源码解析 Java HashMap 源码解析 HashMap的实现原理","tags":[{"name":"Collection","slug":"Collection","permalink":"http://liuguoquan727.github.io/tags/Collection/"}]},{"title":"Java集合之ArrayList和LinkedList","date":"2015-12-18T13:25:21.000Z","path":"2015/12/18/Java集合之ArrayList和LinkedList/","text":"ArrayList概述ArrayList是 Java 集合框架中使用最为普遍的集合类之一。ArrayList 是一种 List 实现，允许包括null在内的所有元素，它的内部用一个动态数组来存储元素，因此 ArrayList 能够在添加和移除元素的时候进行动态的扩展和缩减。 ArrayList有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。 ArrayList按数组下标访问元素–get(i)/set(i,e) 的性能很高，这是数组的基本优势。 ArrayList直接在数组末尾加入元素–add(e)的性能也高，但如果按下标插入、删除元素–add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。 定义123public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, Serializable ArrayList实现对应ArrayList而言，它实现List接口、底层使用数组保存所有元素，其操作基本上都是对数组的操作。下面我们来分析ArrayList的源码： 底层数组实现1private transient Object[] elementData; 构造方法ArrayList提供了三种方式的构造器： 构造一个默认初始容量为10的空列表； 构造一个指定初始容量的空列表； 构造一个包含指定collection集合的元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列的。 12345678910111213141516171819202122232425//指定初始容量的空列表public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); this.elementData = new Object[initialCapacity];&#125;/** * 初始容量为10的空列表. */public ArrayList() &#123; super(); this.elementData = EMPTY_ELEMENTDATA;&#125;public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; 存储ArrayList提供了set、add、addAll这些方法添加元素 set()12345678// 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。 public E set(int index, E element) &#123; RangeCheck(index); E oldValue = (E) elementData[index]; elementData[index] = element; return oldValue; &#125; add()12345678910111213141516171819// 将指定的元素添加到此列表的尾部。 public boolean add(E e) &#123; ensureCapacity(size + 1); elementData[size++] = e; return true; &#125; // 将指定的元素插入此列表中的指定位置。 // 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。 public void add(int index, E element) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(\"Index: \"+index+\", Size: \"+size); // 如果数组长度不足，将进行扩容。 ensureCapacity(size+1); // Increments modCount!! // 将 elementData中从Index位置开始、长度为size-index的元素拷贝到从下标为index+1位置开始的新的elementData数组中。即将当前位于该位置的元素以及所有后续元素右移一个位置。 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; addAll()12345678910111213141516171819202122232425262728// 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacity(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125;// 从指定的位置开始，将指定collection中的所有元素插入到此列表中。 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( \"Index: \" + index + \", Size: \" + size); Object[] a = c.toArray(); int numNew = a.length; ensureCapacity(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; 读取元素123456// 返回此列表中指定位置上的元素。 public E get(int index) &#123; RangeCheck(index); return (E) elementData[index]; &#125; 删除元素12345678910111213141516171819202122232425262728293031323334// 移除此列表中指定位置上的元素。 public E remove(int index) &#123; RangeCheck(index); modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work return oldValue; &#125; // 移除此列表中首次出现的指定元素（如果存在）。这是应为ArrayList中允许存放重复的元素。 public boolean remove(Object o) &#123; // 由于ArrayList中允许存放null，因此下面通过两种情况来分别处理。 if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; // 类似remove(int index)，移除列表中指定位置上的元素。 fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; 注意：从数组中移除元素的操作，也会导致被移除的元素以后的所有元素的向左移动一个位置。 调整数组容量每次向ArrayList中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出数组将会进行扩容，以满足添加数据的需求。数组扩容通过一个公开的方法ensureCapacity()来实现。在实际添加大量元素前，我们也可以使用该方法手动增加ArrayList的容量，以减少递增式再分配的数量。 1234567891011121314151617181920212223242526272829303132public void ensureCapacity(int minCapacity) &#123; //是否是默认容量 int minExpand = (elementData != EMPTY_ELEMENTDATA) ? 0 : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; //扩容 ensureExplicitCapacity(minCapacity); &#125;&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; //判断是否大于当前容量 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // int oldCapacity = elementData.length; //扩展容量为当前容量的一半 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //新容量小于最小容量要求 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // elementData = Arrays.copyOf(elementData, newCapacity);&#125; 从上述代码可以看出，数组进行扩容时，会将老数组中的元素拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素有多少时，要在构造ArrayList实例时就指定其容量大小，以避免数组扩容的发送。或者根据实际需求，通过调用ensureCapacity()方法手动增加ArrayList实例的容量。 ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能，可以通过trimToSize方法来实现： 1234567public void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; if (size &lt; oldCapacity) &#123; elementData = Arrays.copyOf(elementData, size); &#125; &#125; Fail-Fast机制ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。在面对并发的修改时，迭代器很快就会抛出失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。 1234private void checkForComodification() &#123; if (this.modCount != l.modCount) throw new ConcurrentModificationException();&#125; ArrayList遍历有三种方法可以遍历ArrayList数组，分别是for、foreach、Iterator。 12345678910111213141516171819202122232425262728293031323334353637383940public class ArrayListDemo &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; 10; i++) &#123; list.add(\"liu\" + i); &#125; // for循环 优先用这种方式 int len = list.size(); for (int i = 0; i &lt; len; i++) &#123; System.out.println(\"for: \" + list.get(i)); &#125; // foreach语句 for (String str : list) &#123; System.out.println(\"foreach: \" + str); &#125; // 显示调用集合迭代器 Iterator&lt;String&gt; it = list.iterator(); while (it.hasNext()) &#123; System.out.println(\"iterator while: \" + it.next()); &#125; for (Iterator&lt;String&gt; iterator = list.iterator(); iterator.hasNext();) &#123; System.out.println(\"iterator for: \" + iterator.next()); &#125; &#125;&#125; LinkedListLinkedList是一种基于链表结构的一中List，具体是基于双向循环列表设计的。 定义123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable LinkedList实现底层存储123456transient int size = 0; //元素数量transient Node&lt;E&gt; first; //链表的头结点transient Node&lt;E&gt; last; //链表的尾结点 Node表示链表的节点对象。 1234567891011private static class Node&lt;E&gt; &#123; E item; //当前存储元素 Node&lt;E&gt; next; //下一个元素节点 Node&lt;E&gt; prev; //上一个元素节点 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; Node是LinkedList的内部类，其中定义了当前存储的元素，以及该元素的上一个元素和下一个元素。 构造方法12345678910111213/** 构造一个空链表*/public LinkedList() &#123;&#125;/*** 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列*/public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; add()12345678910111213141516//添加到链表末尾public boolean add(E e) &#123; linkLast(e); return true;&#125;//在指定位置添加元素public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125; addAll()12345678910111213141516171819202122232425262728293031323334353637383940414243444546//添加一个集合public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125;//在指定位置添加一个集合public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; Node&lt;E&gt; pred, succ; if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125; for (Object o : a) &#123; @SuppressWarnings(\"unchecked\") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125;` size += numNew; modCount++; return true;&#125; 删除1234567891011121314151617181920212223242526272829303132333435363738394041424344public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125;E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 修改123456789public E set(int index, E element) &#123; checkElementIndex(index); //查找index对应的节点 Node&lt;E&gt; x = node(index); E oldVal = x.item; //替换旧元素 x.item = element; return oldVal;&#125; 查询123456789101112131415161718192021public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125;Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); // 二分法 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 基于双向循环链表实现的LinkedList，通过索引Index的操作时低效的，index所对应的元素越靠近中间所费时间越长。而向链表两端插入和删除元素则是非常高效的（如果不是两端的话，都需要对链表进行遍历查找）。 ArrayList vs LinkedList ArrayList底层实现是数组，LinkedList实现是链表 ArrayList的查找效率高于LinkedList LinkedList的增删效率高于ArrayList ArrayList操作： 查询操作的时间复杂度是O(1) 增删操作的时间复杂度是O(n) LinkedList： 查询操作的时间复杂度是O(n) 增删操作的时间复杂度是O(1) 面试题ArrayList的大小是如何自动增加的？当我们试图在ArrayList中增加一个对象时，首先会检查ArrayList的容量，已确保已存在的数组中有足够的容量来存储新的对象。如果没有足够容量的话，就会新建一个长度更长的数组（长度是原数组长度的1.5倍），然后使用Arrays.copyOf()方法将旧的数组赋值到新的数组中去，并将现有的数组引用指向新的数组。 12345678910111213141516171819202122232425262728public boolean add(E e) &#123; ensureCapacity(size + 1); elementData[size++] = e; return true; &#125; private void ensureCapacity(int minCapacity) &#123; modCount++; //判断是否大于当前容量 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // int oldCapacity = elementData.length; //扩展容量为当前容量的一半 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //新容量小于最小容量要求 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //返回一个新的数组对象，包括原数组中的内容 elementData = Arrays.copyOf(elementData, newCapacity);&#125; 什么情况下使用ArrayList？什么情况下使用LinkedList？多数情况下，当你遇到访问元素比插入或删除元素操作更频繁的时候，你应该使用ArrayList。当你遇到插入或者删除元素操作更加频繁，或者根本不需要访问元素的时候，你应该使用LinkedList。主要原因在于，在ArrayList中访问元素的最糟糕的时间复杂度为1，而在LinkedList中可能就是n；在LinkedList中插入和删除的时间复杂度为1，而在ArrayList中可能就是n。 当传递ArrayList到某个方法中，或者某个方法返回ArrayList，什么时候要考虑安全隐患？如何修护安全违规这个问题？当ArrayList被当做参数传递到某个方法中，如果ArrayList在没有被复制的情况下直接被分配给成员变量，那么久可能发生这种情况，即当原始的ArrayList被改变时，传递到这个方法的数组也会改变。下面来看看实例： 安全隐患的情况： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class ArrayListDemo &#123; private static List&lt;String&gt; mList; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; 3; i++) &#123; list.add(\"liu\" + i); &#125; setList(list); //改变成员变量 mList.set(0, \"lee\"); for(String str : mList) &#123; System.out.println(\"mList: \"+str); &#125; for(String str : list) &#123; System.out.println(\"list: \" + str); &#125; System.out.println(list == mList); //改变原数组 list.set(0, \"Zhang\"); for(String str : mList) &#123; System.out.println(\"mList: \"+str); &#125; for(String str : list) &#123; System.out.println(\"list: \" + str); &#125; System.out.println(list == mList); &#125; public static void setList(List&lt;String&gt; list) &#123; mList = list; &#125; &#125;结果打印:mList: leemList: liu1mList: liu2list: leelist: liu1list: liu2truemList: ZhangmList: liu1mList: liu2list: Zhanglist: liu1list: liu2true 从结果可以看出，原数组和成员变量数组同时发送改变，这是因为在setList()方法中是将数组的引用赋值给了成员变量。 修复安全隐患后的代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class ArrayListDemo &#123; private static List&lt;String&gt; mList; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; 3; i++) &#123; list.add(\"liu\" + i); &#125; setList(list); //改变成员变量 mList.set(0, \"lee\"); for(String str : mList) &#123; System.out.println(\"mList: \"+str); &#125; for(String str : list) &#123; System.out.println(\"list: \" + str); &#125; System.out.println(list == mList); //改变原数组 list.set(0, \"Zhang\"); for(String str : mList) &#123; System.out.println(\"mList: \"+str); &#125; for(String str : list) &#123; System.out.println(\"list: \" + str); &#125; System.out.println(list == mList); &#125; public static void setList(List&lt;String&gt; list) &#123; if (list == null) &#123; mList = new ArrayList&lt;String&gt;(); &#125; else &#123; //创建新的对象,并复制个mList mList = new ArrayList&lt;String&gt;(list); &#125; &#125; &#125;打印:mList: leemList: liu1mList: liu2list: liu0list: liu1list: liu2falsemList: leemList: liu1mList: liu2list: Zhanglist: liu1list: liu2false 从结果可以看出，现在原数组和成员变量mList相互独立，改变自己的同时不会改变对方的数组内容。 数组[]也是如此 如何复制一个ArrayList到另一个ArrayList中去? 使用clone()方法， 使用ArrayList构造方法， 使用Collection的copy方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class ArrayListDemo &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; 3; i++) &#123; list.add(\"liu\" + i); &#125; //clone() ArrayList&lt;String&gt; list1 = (ArrayList&lt;String&gt;) list.clone(); for(String str : list1) &#123; System.out.println(\"list1: \"+str); &#125; System.out.println(list1 == list); //构造方法 ArrayList&lt;String&gt; list2 = new ArrayList&lt;String&gt;(list); for(String str : list2) &#123; System.out.println(\"list2: \"+str); &#125; System.out.println(list2 == list); // ArrayList&lt;String&gt; list3 = new ArrayList&lt;String&gt;(list.size()); list3.add(\"1\"); list3.add(\"2\"); list3.add(\"3\"); Collections.copy(list3, list); for(String str : list3) &#123; System.out.println(\"list3: \"+str); &#125; System.out.println(list3 == list); &#125;&#125;结果打印：list1: liu0list1: liu1list1: liu2falselist2: liu0list2: liu1list2: liu2falselist3: liu0list3: liu1list3: liu2false 在索引中ArrayList的增加或者删除某个对象的运行过程？效率很低吗？解释一下为什么？在ArrayList中增加或删除元素的时候要调用System.arrayCopy()这个数值拷贝函数，每次增加或删除元素都要进行数组的拷贝操作，相对效率较低。如果遇到频繁插入或删除操作的时候，可以考虑使用LinkedList来代替。 在ArrayList的某个索引i处添加元素： 123456789public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 在ArrayList的某个索引i处删除元素： 1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125;","tags":[{"name":"Collection","slug":"Collection","permalink":"http://liuguoquan727.github.io/tags/Collection/"}]},{"title":"Java集合之Arrays和Collections","date":"2015-12-18T13:22:21.000Z","path":"2015/12/18/Java集合之Arrays和Collections/","text":"Arraysjava.util.Arrays Arrays详细介绍 Array是Java特有的数组。在你知道所要处理数据元素个数的情况下非常好用。java.util.Arrays 包含了许多处理数据的实用方法： Arrays.asList：可以从 Array 转换成 List。可以作为其他集合类型构造器的参数。 Arrays.binarySearch：在一个已排序的或者其中一段中快速查找。 Arrays.copyOf：如果你想扩大数组容量又不想改变它的内容的时候可以使用这个方法。 Arrays.copyOfRange：可以复制整个数组或其中的一部分。 Arrays.deepEquals、Arrays.deepHashCode：Arrays.equals/hashCode的高级版本，支持子数组的操作。 Arrays.equals：如果你想要比较两个数组是否相等，应该调用这个方法而不是数组对象中的 equals方法（数组对象中没有重写equals()方法，所以这个方法之比较引用而不比较内容）。这个方法集合了Java 5的自动装箱和无参变量的特性，来实现将一个变量快速地传给 equals() 方法——所以这个方法在比较了对象的类型之后是直接传值进去比较的。 Arrays.fill：用一个给定的值填充整个数组或其中的一部分。 Arrays.hashCode：用来根据数组的内容计算其哈希值（数组对象的hashCode()不可用）。这个方法集合了Java 5的自动装箱和无参变量的特性，来实现将一个变量快速地传给 Arrays.hashcode方法——只是传值进去，不是对象。 Arrays.sort：对整个数组或者数组的一部分进行排序。也可以使用此方法用给定的比较器对对象数组进行排序。 Arrays.toString：打印数组的内容。 如果想要复制整个数组或其中一部分到另一个数组，可以调用 System.arraycopy方法。此方法从源数组中指定的位置复制指定个数的元素到目标数组里。这无疑是一个简便的方法。（有时候用 ByteBuffer bulk复制会更快。可以参考这篇文章）. 最后，所有的集合都可以用T[] Collection.toArray( T[] a ) 这个方法复制到数组中。通常会用这样的方式调用：1return coll.toArray( new T[ coll.size() ] ); 这个方法会分配足够大的数组来储存所有的集合，这样 toArray 在返回值时就不必再分配空间了。 Collectionsjava.util.Collections Collections详细介绍 就像有专门的java.util.Arrays来处理数组，Java中对集合也有java.util.Collections来处理。 第一组方法主要返回集合的各种数据： Collections.checkedCollection / checkedList / checkedMap / checkedSet / checkedSortedMap / checkedSortedSet：检查要添加的元素的类型并返回结果。任何尝试添加非法类型的变量都会抛出一个ClassCastException异常。这个功能可以防止在运行的时候出错。//fixme Collections.emptyList / emptyMap / emptySet ：返回一个固定的空集合，不能添加任何元素。 Collections.singleton / singletonList / singletonMap：返回一个只有一个入口的 set/list/map 集合。 Collections.synchronizedCollection / synchronizedList / synchronizedMap / synchronizedSet / synchronizedSortedMap / synchronizedSortedSet：获得集合的线程安全版本（多线程操作时开销低但不高效，而且不支持类似put或update这样的复合操作） Collections.unmodifiableCollection / unmodifiableList / unmodifiableMap / unmodifiableSet / unmodifiableSortedMap / unmodifiableSortedSet：返回一个不可变的集合。当一个不可变对象中包含集合的时候，可以使用此方法。 第二组方法中，其中有一些方法因为某些原因没有加入到集合中： Collections.addAll：添加一些元素或者一个数组的内容到集合中。 Collections.binarySearch：和数组的Arrays.binarySearch功能相同。 Collections.disjoint：检查两个集合是不是没有相同的元素。 Collections.fill：用一个指定的值代替集合中的所有元素。 Collections.frequency：集合中有多少元素是和给定元素相同的。 Collections.indexOfSubList / lastIndexOfSubList：和String.indexOf(String) / lastIndexOf(String)方法类似——找出给定的List中第一个出现或者最后一个出现的子表。 Collections.max / min：找出基于自然顺序或者比较器排序的集合中，最大的或者最小的元素。 Collections.replaceAll：将集合中的某一元素替换成另一个元素。 Collections.reverse：颠倒排列元素在集合中的顺序。如果你要在排序之后使用这个方法的话，在列表排序时，最好使用Collections.reverseOrder比较器。 Collections.rotate：根据给定的距离旋转元素。 Collections.shuffle：随机排放List集合中的节点，可以给定你自己的生成器——例如java.util.Random / java.util.ThreadLocalRandom or java.security.SecureRandom。 Collections.sort：将集合按照自然顺序或者给定的顺序排序。 Collections.swap：交换集合中两个元素的位置（多数开发者都是自己实现这个操作的）。","tags":[{"name":"Collection","slug":"Collection","permalink":"http://liuguoquan727.github.io/tags/Collection/"}]},{"title":"Java集合框架简介","date":"2015-12-18T13:20:21.000Z","path":"2015/12/18/Java集合框架简介/","text":"Java集合代表了一组对象。Java中的集合框架定义了一套规范，用来表示、操作集合，使具体操作与实现细节解耦。 两大基类Collection与Map在集合框架的类继承体系中，最顶层有两个接口： Collection表示一组纯数据 Map表示一组key-value键值对 一般继承自Collection或Map的集合类，会提供两个标准的构造函数： 没有参数的构造函数，创建一个空的集合类，如ArrayList() 有一个类型与基类（Collection或Map）相同的构造函数，创建一个与给定参数具有相同元素的新集合类，如ArrayList(Collection&lt;? extends E&gt; c) Collection先看看常用的Collection集合类 Collection类主要有三个接口： Set表示不允许有重复元素的集合 List表示允许有重复元素的集合 Queue主要用于存储数据而不是处理数据 Map下图为常用的Map集合类 Map并不是一个真正意义上的集合，但是这个接口提供了三种“集合视角”，使得可以像操作集合一样操作他们。具体如下： 把Map的内容看成key的集合 把Map的内容看成value的集合 把Map的内容看成key-value映射的集合 Java集合与数据结构数组特点：可以随机访问，查询效率较高，增删效率较低、内存固定 Java集合：ArrayList、Vector 链表特点：插入和删除效率高，查询效率低 Java集合：LinkedList、LinkedHashMap、LinkedHashSet 哈希表特点：查找效率高，插入和删除较快，内存固定，存在散列冲突。 Java集合：HashMap、HashSet、HashTable、LinkedHashMap、LinkedHashSet 堆特点：插入、删除效率高，对最大项、最小项存储快，其他项存取较慢。 Java集合：PriorityQueue（二叉堆实现的优先队列） 栈特点：先进后出（FILO） Java集合：Stack 队列特点：先进先出（FIFO） Java集合：ArrayDeque（双端队列）、LinkedList（双端队列） 树特点：查询、删除、插入都比较快，但算法复杂 Java集合：TreeMap（红黑树）、TreeSet（红黑树）","tags":[{"name":"Collection","slug":"Collection","permalink":"http://liuguoquan727.github.io/tags/Collection/"}]},{"title":"Http协议详解","date":"2015-12-18T13:08:05.000Z","path":"2015/12/18/Http协议详解/","text":"HTTP是一种应用层协议，它通过TCP实现了可靠的数据传输，能够保证数据的完整性、正确性，而TCP对于数据传输控制的优点也能够体现在HTTP上，使得HTTP的数据传输吞吐量、效率得到保证。 对于移动开发来说，网络应用基本上都是C/S架构，也就是客户端/服务器架构。客户端通过向服务器发起特定的请求，服务器返回结果，客户端解析结果，再将结果展示在UI上。客户端与服务器的交互如下所示： 详细的交互流程有如下几步： 客户端执行网络请求，从URL解析出服务器的主机名。 将服务器的主机名转换成服务器的IP地址。 将端口号从URL中解析出来 建立一条客户端与Web服务器的TCP连接； 客户端通过输出流向服务器发送一条HTTP请求； 服务器向客户端返回一条HTTP响应报文； 客户端从输入流获取报文； 客户端解析报文，关闭连接； 客户端将结果显示在UI上； HTTP请求方式HTTP提供了几种请求方式，每种请求方式都有不同的作用。被大家熟知的请求方式有7种GET、POST、DELETE、PUT、HEAD、TRACE、OPTIONS。其中PUT、DELETE、POST、GET分别对应着增、删、该、查4个操作，也是客户端运用最多的4个请求。 GET请求GET的作用是获取服务器的某个资源。下图提供一个例子，客户端用GET方法发起一次HTTP请求，然后服务端将对应的资源返回客户端。 需要注意的是：GET请求的参数都需要放到请求的URL中，第一个参数之前有一个？，参数的格式为：参数名=参数值。参数之间通过“&amp;”连接。 POST请求POST起初是用来向服务器传递数据的。POST请求通常会用来提交HTML的表单。表单中填好的数据会被传输给服务器，然后由服务器对这些数据进行处理。下图显示一个用POST请求的执行流程。 PUT请求与GET从服务器读取资源相反，PUT方法会向服务器写入资源。有些发布系统允许用户创建Web页面，并用PUT直接将其传输到Web服务器上。如下图所示： PUT方法的语义就是让服务器用请求的主题部分来创建一个由所请求的URL命名的新文档，如果那个URL已经存在的话，就用这个资源来替代它。 DELETE请求DELETE方法所做的事情就是请服务器删除请求URL所指定的资源。但是，客户端无法保证删除操作一定会被执行。因为，HTTP规范允许服务器在不通知客户端的情况下撤销请求。 DELETE方式与GET请求一样，参数都需要放在请求的URL中。下图显示了一个DELETE方法实例。 HEAD请求HEAD方法与GET方法的行为很类似，但服务器在响应中只返回首部。不会返回实体的主体部分，这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查。使用HEAD可以在不获取资源的情况下了解资源的情况（比如，判断其类型）；通过查看响应中的状态码，看看某个对象是否存在；通过查看首部，测试资源是否被修改了。服务器开发者必须确保返回的首部与GET请求所返回的首部完全相同。遵循HTTP/1.1规范，就必须实现HEAD方法。如下图所示： TRACE请求客户端发起一个请求时，这个请求可能要穿越防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的HTTP请求。TRACE方法运行客户端在最终将请求发送给服务器时，看看它变成了什么样子。 TRACE请求会在目的服务端发起一个“环回”诊断。行程最后一站的服务器会弹回一条TRACE响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间HTTP应用程序组成的请求/响应链上，原始报文是否以及如何被毁坏或修改过，如下图所示。 TRACE方法主要用于诊断，也就是说，用于验证请求是否如愿穿过了请求/响应链。 OPTIONS请求OPTIONS方法请求Web服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法（有些服务器可能只支持对一种特殊类型的对象使用特定的操作）这为客户端应用程序提供了一种手段，使其不用实际访问那些资源就能判定访问各种资源最优方式）。如下图所示： HTTP报文格式请求报文通常一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成。下图为请求报文的一般格式。 起始行 报文的第一行就是起始行，在请求报文中用来说明要以说明方式做什么请求，而在响应报文中初略说明了报文的执行结果。 首部字段 起始行后面有零个或多个首部字段。每个首部字段都包含一个名字和一个值，为了便于解析，两者之间用冒号（如Connection：keep-Alive）来分隔。首部以一个空行结束。添加一个首部字段和添加新行一样简单。 主体 首部字段的空行之后就是可选的报文主体了，其中包含了所以类型的数据。请求主体中包括了要发送给Web服务器的数据；响应主体中装载了要返回给客户端的数据。起始行和首部都是结构化的文本形式，而主体则可以包含任意的二进制数据（如图片、视频、音轨、软件程序）。当然，主体中也可以包含文本。 响应报文HTTP响应也由3个部分组成，分别是：状态行、消息报头、响应正文。如下所示，HTTP响应的格式与请求的格式十分类似： 1234&lt;状态行&gt;&lt;响应报文header&gt;&lt;空行&gt;[响应报文内容] 在响应报文中第一行用状态信息代替了请求信息。状态行通过提供一个状态码来说明所请求的资源情况。状态行格式： HTTP-Version Status-Code Reason-Phrase CRLF HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述； 状态码由三位数字组成，第一个数字定义了响应的类别，且有5中可能取值。 取值范围 含义 100~199 指示信息。表示请求已接收，继续处理 200~299 请求成功。表示请求已被成功接收理解 300~399 重定向。要完成请求必须进行更进一步的操作 400~499 客户端错误。请求有语法错误或请求无法实现 500~599 服务器端错误。服务器未能实现合法的请求 常见状态代码、状态描述的说明如下： 200 OK:客户端请求成功 202 Accepted 服务器已接收请求，但尚未处理。 400 Bad Request：客户端请求有语法错误，不能被服务器所理解 401 Unauthorized：请求未授权，这个状态码必须和WWW-Authenticate报头域一起使用。 403 Forbidden：服务器收到请求，但是拒绝提供服务。 404 Not Found：请求资源不存在，举个例子：输入了错误的URL。 408 Request Timeout 请求超时 500 Internal Server Error：服务器发生不可预期的错误。 502 Bad Gateway 错误的网关 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK 504 网关超时 下面是一个GET去请求的Response返回示例： 12345678910111213HTTP/1.1 200 OKDate:Sat, 31 Dec 2005 23:59:59 GMTContent-Type: text/html;charset=utf-8Content-Length: 122&lt;html&gt; &lt;head&gt; &lt;title&gt;开发技术前线&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 请求头部请求头部由键值对组成，每行一对，关键字和值用英文冒号“：”分隔。HTTP规范定义了几种首部字段，应用程序也可以随意发明自己所用的头部。HTTP首部可以分为以下几类，如表所示： 首部类型 作用 通用首部 既可以出现在请求报文中，也可以出现在响应报文中 请求首部 提供更多有关请求的信息 响应首部 提供更多有关响应的信息 实体首部 描述主体的长度和内容，或者资源自身 扩展首部 HTTP规范中没有定义的新首部 请求头部通知服务器关于客户端请求的信息，典型的请求头有。 Content-Type：请求数据的格式 Content-Length：消息长度 Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机 User-Agent：发出请求的浏览器类型，可以自行设置 Accept：客户端可识别的内容类型列表 Accept-Encoding：客户端可识别的数据编码 Connection：允许客户端和服务器指定与请求/响应连接有关的选项，例如设置为Keep-Alive则表示保持连接 Transfer-Encoding：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。","tags":[{"name":"网络通信","slug":"网络通信","permalink":"http://liuguoquan727.github.io/tags/网络通信/"},{"name":"http","slug":"http","permalink":"http://liuguoquan727.github.io/tags/http/"}]},{"title":"TCP/IP（五）TCP协议详解","date":"2015-12-17T13:08:05.000Z","path":"2015/12/17/TCP-IP5TCP协议详解/","text":"TCP协议是面向有连接的协议，它具有丢包重发和流量控制的功能，这是它区别UDP协议最大的特点。 数据包重发数据发送丢包重发的前提是发送方能够知道接收方是否成功的接收了消息。所以，在TCP协议中，接收端会给发送端返回一个消息，也叫确认应答（ACK），这表示接收方已经收到了数据包。 根据上一节对TCP首部的分析得知：ACK的值和下次发送数据包的序列号相等。因此ACK也可以理解为：“发送方，下次你从这个位置开始发送！“。下图表示了数据发送与确认应答的过程： 由于各种原因，数据包和ACK应答包都有可能丢失，在这种情况下，发送方如果在一段时间内没有收到ACK，就会重发数据： 即使网络正常，由于延迟的存在，接收方也有可能收到重复的数据包，因此接收方通过TCP首部中的SYN判断这个数据包是否曾经接收过。如果已经接收，就会丢弃该数据包。 重传超时时间（RTO）如果发送方等待一段时间后，还是没有收到 ACK 确认，就会启动超时重传。这个等待的时间被称为重传超时时间(RTO，Retransmission TimeOut)。RTO 的值具体是多久呢？ 首先，RTO 的值不是固定的，它是一个动态变化的时间。这个时间总是略大于连接往返时间（RTT，Round Trip Time）。这个设定可以这样理解：“数据发送给对方，再返回到我这里，假设需要 10 秒，那我就等待 12秒，如果超过 12 秒，那估计就是回不来了。” RTT 是动态变化的，因为谁也不知道网络下一时刻是否拥堵。而当前的 RTO 需要根据未来的 RTT 估算得出。RTO 不能估算太大，否则会多等待太多时间；也不能太小，否则会因为网络突然变慢而将不该重传的数据进行重传。 TCP窗口按照之前的理论，在数据包发出后，直至 ACK 确认返回以前，发送端都无法发送数据，而且包的往返时间越长，网络利用效率和通信性能就越低。前两张图片形象的解释了这一点。 为了解决这个问题，TCP 使用了“窗口”这个概念。窗口具有大小，它表示无需等待确认应答就可以继续发送数据包的最大数量。比如窗口大小为 4 时，数据发送的示意图如下： 不等确认就连续发送若干个数据包会不会有问题呢？我们首先来看数据包丢失问题。 我们知道 TCP 首部中的 ACK 字段表示接收方已经收到数据的最后位置。因此，接收方成功接收到了 1-1000 字节的数据后，它会发送一个 ACK = 1001 的确认包。假设 1001-2000 字节的数据包丢失了，由于窗口长度比较大，发送方会继续发送 2001-3000 字节的数据包。接收端并不会返回这个数据包的确认，因为它最后收到的数据还是 1-1000 字节的数据包。 因此，接收端返回的数据包的 ACK 依然是 1001。这表示：“喂，发数据的，别往后发了，你第 1001 字节开始的数据还没来呢”。可以想见，发送端以后每次发送数据包得到的确认中，ACK 的值都是 1001。当连续收到三次确认之后，发送方会意识到：“对方还没有接收到数据，这个包需要重传”。 因此，引入窗口的概念后，被发送的数据不能立刻丢弃，需要缓存起来以备将来需要重发。 利用窗口发送数据的过程可以用下图表示： 果是数据包没有丢失，但是确认包丢失了呢？这就是窗口最擅长处理的问题了。假设发送发收到的确认包中的 ACK 第一次是 1001，第二次是 4001。那么我们完全可以相信中间的两个包是成功被接收的。因为如果有没接收到的包，接收方是不会增加 ACK 的。 在这种情况下，如果不使用窗口，发送方就需要重传第二、三个数据包，但是有了窗口的概念后，发送方就省略了两次重传。因此使用窗口实际上可以理解为“空间换时间”。 流量控制窗口大小如果窗口过大，会导致接收方的缓存区数据溢出。这时候本该被接收的数据反而丢弃了，就会导致无意义的重传。因此，窗口大小是一个可以改变的值，它由接收端主机控制，附加在 TCP 首部的“窗口大小”字段中。 慢启动在连接建立的初期，如果窗口比较大，发送方可能会突然发送大量数据，导致网络瘫痪。因此，在通信一开始时，TCP 会通过慢启动算法得出窗口的大小，对发送数据量进行控制。 流量控制是由发送方和接收方共同控制的。刚刚我们介绍了接收方会把自己能够承受的最大窗口长度写在 TCP 首部中，实际上在发送方这里，也存在流量控制，它叫拥塞窗口。TCP 协议中的窗口是指发送方窗口和接收方窗口的较小值。 慢启动过程如下： 通信开始时，发送方的拥塞窗口大小为 1。每收到一个 ACK 确认后，拥塞窗口翻倍。 由于指数级增长非常快，很快地，就会出现确认包超时。 此时设置一个“慢启动阈值”，它的值是当前拥塞窗口大小的一半。 同时将拥塞窗口大小设置为 1，重新进入慢启动过程。 由于现在“慢启动阈值”已经存在，当拥塞窗口大小达到阈值时，不再翻倍，而是线性增加。 随着窗口大小不断增加，可能收到三次重复确认应答，进入“快速重发”阶段。 这时候，TCP 将“慢启动阈值”设置为当前拥塞窗口大小的一半，再将拥塞窗口大小设置成阈值大小（也有说加 3）。 拥塞窗口又会线性增加，直至下一次出现三次重复确认应答或超时。 以上过程可以用下图概括：","tags":[{"name":"网络通信","slug":"网络通信","permalink":"http://liuguoquan727.github.io/tags/网络通信/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://liuguoquan727.github.io/tags/TCP-IP/"}]},{"title":"TCP/IP（四）TCP与UDP协议","date":"2015-12-17T13:07:53.000Z","path":"2015/12/17/TCP-IP4TCP与UDP协议/","text":"传输层位于OSI七层模型的第四层，传输层的主要作用是实现应用程序之间的通信。网络层主要是保证不同数据链路下数据的可达性，至于如何传输数据则是由传输层负责。 传输层协议简介常见的传输层协议主要有TCP协议和UDP协议。 TCPTCP协议是面向有连接的协议，也就是说在使用TCP协议传输数据之前一定要在发送方和接收方之间建立连接。一般情况下建立连接需要三步，关闭连接需要四步。 建立TCP连接后，由于有数据重传、流量控制等功能，TCP协议能够正确处理丢包问题，保证接收方能够收到数据，与此同时还能够有效利用网络带宽。然而TCP协议中定义了很多复杂的规范，因此效率不如UDP协议，不适合实时的视频和音频传输。 UDPUDP协议是面向无连接的协议，它只会把数据传递给接收端，但是不保证接收端是否真正收到了数据。这种特性适合多播、实时的视频和音频传输，因为个别数据包的丢失并不会影响视频和音频的整体效果。 端口号IP协议中的两大关键要素是源IP地址和目标IP地址。传输层新增了三个要素：源端口号、目标端口号和协议号。 端口号用于区分同一台主机上不同的应用程序。假设你打开了两个浏览器，浏览器A发出的请求不会被浏览器B接收，就是因为A和B具有不要的端口号。 协议号用于区分使用的是TCP还是UDP。 所以：源IP地址、目标IP地址、源端口号、目标端口号和协议号这五个信息只要有一个不同，都被认为是不同的通信。 UDP首部UDP协议的特点就是简单，它的首部如下图所示： 包长度表示UDP首部长度和UDP数据长度之和 校验和用来判断数据在传输过程中是否丢失。 TCP首部TCP首部要复杂得多。解析这个首部的时间也相应的增加，这也是导致TCP连接的效率低于UDP的原因之一。 关键字段解释如下： 序列号：它表示发送数据的位置，假设当前的序列号为s，发送数据长度为I，则下次发送数据的序列号为S + I。在建立连接时通常由计算机生成一个随机数作为序列号的初始值。 确认应答号：它等于下一次应该接收到的数据的序列号。假设当前的序列号为s，发送数据长度为I，则接收端返回的确认应答号为S + I。发送端接收到这个确认应答后，可以认为这个位置以前所有的数据都已被正常接收。 数据偏移：TCP首部的长度，单位为4个字节。如果没有可选字段，那么这里的值就是5，表示TCP首部的长度为20字节。 控制位：长度为8bit，分别有8个控制标志，依次是CWR、ECE、URG、ACK、PSH、RST、SYN和FIN CWR ECE URG ACK:改位为1时，确认应答的字段变为有效。TCP规定除了最初建立连接时的SYN包之外改位必须设置为1 PSH RST SYN：用于建立连接。SYN为1表示希望建立连接 FIN：为1时，表示希望断开连接 窗口大小：用于表示从应答号开始能够接收多少个字节。如果窗口为0，可以发送窗口探测 紧急指针：仅仅在URG控制位为1时有效。表示紧急数据的末尾在TCP数据部分中的位置，通常在暂时中断通信时使用（比如Ctrl + C） TCP握手TCP是面向连接的协议，连接在每次通信前被建立，通信结束时被关闭。了解TCP连接建立和关闭的过程通常是考察的重点。TCP连接的建立和关闭过程可用下图表示： 三次握手建立连接 客户端请求连接SYN 服务端确认客户端连接请求 客户端确认服务端已收到连接请求，建立连接开始通信 为什么是三次握手三次握手的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误” 这是因为在网络请求时，我们时刻要注意“网络是不可靠的，数据包是可能丢失的”。假设没有第三次确认的情况下，客户端向服务端发送SYN，请求建立连接。由于延迟，服务端没有及时收到这个包。于是客户端重新发送一个SYN包。 假设服务端接收到了第二个SYN包，建立了通信，一段时间后通信结束，连接被关闭。这是最初被发送的SYN包抵达服务端，服务端又会发送一次ACK确认。由于两次握手就建立连接，此时的服务端就会建立一个新的连接，然而客户端认为没有请求建立连接，所以就不会向服务端发送数据，从而导致服务端建立一个空连接，浪费资源。 ACK确认包丢失怎么办？三次握手其实解决了第二步的数据包丢失的问题，那么第三步的ACK确认包丢失后，TCP协议是如何处理的呢？ 按照TCP协议处理丢包的一般方法，服务端会重新向客户端发送数据包，直至收到ACK确认为止。但实际上这种做法有可能遭到SYN泛洪攻击。泛洪攻击，是指发送方伪造多个IP地址，模拟三个握手的过程。当服务器返回ACK后，攻击方故意不确认，从而使得服务器不断重发，由于服务器长时间出于半连接状态，最后消耗过多的CPU和内存资源导致死机。 正确的处理方法是服务端发送RST报文，进入CLOSE状态。这个RST数据包的TCP首部中，控制位中的RST设置为1.这表示连接信息全部初始化，原有的TCP通信不能继续进行。客户端如果还想重新建立TCP连接，就必须重新开始第一次握手。 ## 四次握手关闭连接 客户端发送FIN通知服务端 客户端要关闭连接 服务端发送ACK确认客户端关闭连接 服务端发送FIN通知客户端 服务端要关闭连接 客户端发送ACK确认服务端关闭连接 由于连接是双向的，所以双方都要主动关闭自己这一侧的连接。","tags":[{"name":"网络通信","slug":"网络通信","permalink":"http://liuguoquan727.github.io/tags/网络通信/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://liuguoquan727.github.io/tags/TCP-IP/"}]},{"title":"TCP/IP（三）IP协议相关技术","date":"2015-12-17T13:06:45.000Z","path":"2015/12/17/TCP-IP3IP协议相关技术/","text":"IP协议旨在让最终目标主机收到数据包，但是在这一过程中仅仅有IP是无法实现通信的。必须还有能够解析主机名称和MAC地址的功能，以及数据包在发送过程中异常情况处理的功能。本文主要介绍作为IP的辅助和扩展规范的DNS、ARP、ICMP、NAT等协议。 DNS全称Domain Name System，域名系统 IP地址用于识别通信双方的地址，但它是一串长数字，比方便记忆，人们希望主机有自己的名字，这个名字是唯一的，而且容易记住，于是诞生了“域名”的概念。域名是一种为了识别主机名称和机构名的具有分层的名称，比如在域名neu.edu.cn中，neu是主机名，edu和cn是不同层次下的机构名。 域名和IP地址都可以唯一对应一台主机，DNS的作用就是将域名转换成不容易记住的IP地址。 域名是分层的，每层都有自己的DNS服务器用于处理DNS解析的请求，这样的好处在于每层的服务器不用关注过多的信息，它只要知道自己这一层下的域名服务器信息即可。以解析域名：www.itetf.org为例： 根服务器其实并不知道www.itetf.org的IP地址，但是它知道itetf.org域名服务器的地址，所有它把这条查询请求转发给itetf.org域名服务器。DNS请求被逐层下发，直到找到对应的IP地址为止。 ARP全称Address Resolution Protocol，地址解析协议 ARP协议用于通用目标IP地址，定位下一个接收数据包的网络设备的MAC地址。如果目标主机处于同一个数据链路上，那么可以直接得到目标主机的MAC地址，否则会得到下一跳路由器的MAC地址。 ARP协议的工作原理可以分为两部分：ARP请求和ARP响应。首先，源主机会通过广播发送一个ARP请求包：“我要与IP地址为XX的主机通话，谁知道它的MAC地址？”。 下图表示ARP协议的工作机制： 根据ARP可以动态地进行地址解析，因此，在TCP/IP的网络构造中和网络通信中无需事先知道MAC地址究竟是什么，只要有IP地址即可。 如果每发送一个IP数据报都要进行一个ARP请求以确定MAC地址，那将会造成不必要的网络流量，因此通常的做法是把获取到的MAC地址缓存一段时间。一般来说，发送过一次IP数据包的主机，继续发送多次IP数据包的可能性比较高。因此这种缓存能够有效地减少ARP包的发送。当下一次发送ARP请求或超过一定时间后，缓存都会失效，这保证了即使MAC地址与IP地址对应的关系发送了变化，数据包依然能够被正确的发往目标地址。 MAC地址和IP地址看上起功能相似（都用于唯一区分主机），但是两者缺一不可。如果只有IP地址，虽然可以跳过ARP，直接在链路上发一个广播，但是这仅适应于通信双方处于同一个数据链路情况。如果双方处于不同的数据链路，数据报无法穿透中间的路由器。正因为MAC地址缺一不可，所以才产生了ARP这样的协议将两者关联起来。 ICMP全称：Internet Control Message Protocol，Internet控制报文协议。 ICMP的主要功能：确认IP包是否成功送达目标地址，通知在发送过程中IP包被废弃的具体原因，改善网络等设置。有了这些功能以后，就可以获得网络是否正常、设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断。 NAT全称：Network Address Traslator，网络地址转换 NAT是一种用于将局域网中的私有地址转换成全局IP地址的技术。 在连接上路由器的时候，如果检查一下设备的IP地址，你会发现都是类似于192.168.1.1这样局域网的IP地址。那不同网段中，IP地址都是192.168.1.1的主机该如何通信呢？ 下图描述了NAT的工作原理： 局域网中IP地址为10.0.0.10的主机向全局IP地址163.221.120.9发送数据。NAT路由器将数据包的源地址修改成自己的全局IP地址：202.244.174.37。同理，接收数据时，路由器把目标地址202.244.174.37翻译成内网地址：10.0.0.10。 路由器只有一个对外的全局IP地址，如果有多个内网主机都向外部通讯怎么办呢？这时就要使用NAPT技术，它和NAT从原理上类似，但它可以转换TCP和UDP端口号。 使用NAPT技术时，不同的内网IP被转换成同一个公共IP地址，也就是路由器对外显示的全局IP地址，但是被附加不同的端口号以示区分：如下图所示 不管是NAT还是NAPT，都需要路由器内部维护一张自动生成的地址转换表。以TCP为例，建立TCP连接首次握手的SYN包发出时会生成这个表，关闭连接时会发生FIN包，收到这个包的应答时转换表被删除。 DHCP全称：Dynamic Host Configuration Protocol，动态主机配置协议 DHCP的主要用途是实现自动设置IP地址、统一管理IP地址分配。","tags":[{"name":"网络通信","slug":"网络通信","permalink":"http://liuguoquan727.github.io/tags/网络通信/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://liuguoquan727.github.io/tags/TCP-IP/"}]},{"title":"TCP/IP（二）IP协议","date":"2015-12-17T13:05:33.000Z","path":"2015/12/17/TCP-IP2IP协议/","text":"IP协议属于TCP/IP网络模型的第三层-网络层，它的主要作用是实现终端节点之间的通信。IP协议是网络层的一个重要协议，网络层中还有ARP协议（获取MAC地址）和ICMP协议（数据发送异常通知）。 数据链路层的作用在于实现同一中数据链路下的包传递，而网络层则可以实现跨越不同数据链的包传递。比如主机A通过WI-FI连接到路由器B，路由器B通过以太网连接到路由器C，而路由器C又通过WI-FI与主机D保持连接，这时主机A向D发送的数据包就依赖于网络层进行传输。 IP大致分为三大作用模块：IP寻址、路由以及IP分包和组包 IP地址IP地址是一种在网络层用于识别通信对端信息的地址，它有别于数据链路层中的MAC地址，后者用于标识同一链路下不同的计算机。 IP地址由32为正整数表示，为了直观的表示，我们把它分成4个部分，每个部分由8位整数组成，对应十进制的范围就是0-255。比如172.20.1.1可以表示为：10101100 00010100 00000001 00000001.转换规则很简单，就是分别把四个部分的十进制（0-255）与8位二进制数进行转换。 从功能上看，IP地址由两部分组成：网络标识和主机标识。 网络标识用于区分不同的网段，相同段内的主机必须拥有相同的网络标识，不同段内的主机不能拥有相同的网络标识。 主机标识用于区分同一网段下不同的主机，它不能在同一网段内重复出现。 32为IP地址被分为两个部分，到底前多少为是网络标识呢？一般有两种方法表示：IP地址分类、子网掩码 IP分类IP地址分为四个级别，分为A类、B类、C类和D类。分类的依据是IP地址的前四位。 A类地址 A类IP地址是第一位是0的地址。从第1位到第8位是A类IP地址的网络标识，用十进制标识的0.0.0.0~127.0.0.0是A类IP地址的理论范围。A类地址的后24位相当于主机标识。因此一个网段内可容纳的主机地址上线为2的24次方个。 B类地址 B类IP地址是前两位为“10”的地址。B类地址的前16位是网络标识，用十进制标识的话是128.0.0.0~191.255.0.0是B类地址的范围。B类地址的后16位是主机标识，因此一个网段可容纳主机地址上限为65534个。 C类地址 C类IP地址是前三位是“110”的地址。C类地址的前24位是网络标识，用十进制标识的话192.0.0.0~223.255.255.0是C类地址的范围。C类地址的后8位是主机标识，因此一个网段可容纳主机地址上限为254个。 D类地址 D类IP地址是前四位是“1110”的地址。D类地址的前32位是网络标识。用十进制表示的话224.0.0.0~239.255.255.255是D类地址的网络地址，D类地址没有主机标识，因此常用于多播。 关于分配IP主句地址的注意事项 在分配IP地址时关于主机标识有一点需要注意，即要用比特位表示主机地址时，不可以全部为0或者全部为1.因为全部为0只有在表示对应的网络地址或IP地址不可或知的情况下才使用，而全部为1的主机地址通常作为广播地址。 因为在分配过程中，应该去掉这两种情况，这也是为什么C类地址每个网段最多只能有254（2^8 - 2）个主机地址的原因。 广播地址广播地址用于在同一个链路中相互连接的主机之间发送数据的发送端IP地址中的主机地址部分全部设置为1，就是广播地址。例如把172.20.0.0用二进制表示如下：10101100.00010100.00000000.00000000将这个地址的主机部分全部改为1，形成广播地址：10101100.00010100.11111111.11111111再将这个地址用十进制表示，则为172.20.255.255 广播分为本地广播和直接广播 本地广播 在本网络内的广播叫做本地广播。例如网络地址为192.168.0.4的情况下，广播地址是192.168.0.255.因为这个广播地址的IP包会被路由器屏蔽，所以不会到达192.168.0.4以外（如192.168.1.4）的其他链路上。 直接广播 在不同网络之间的广播叫做直接广播。例如网络地址192.168.0.4的主机地址想192.168.1.255的目标地址发送IP包。收到这个包的路由器，将数据转发给192.168.1.0，从而使得所以192.168.1.1~192.168.1.254的主机都能收到这个包。 IP多播多播用于将数据包发送给特定组内的所有主机。由于其直接使用IP协议，因此是不可靠的传输。 多播使用D类地址。因此，如果IP地址的前四位是“1110”，就可以认为是多播地址，而剩下的28位可以成为多播的组编号。 子网编码一个IP地址有两种识别码：一是IP地址本身，而是表示网络部分的子网掩码。子网掩码用二进制表示的话也是一个32位的数字。它对应IP地址网络标识部分的位全部为“1”，对应IP地址主机标识的部分则全部为“0”。由此，一个IP地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是IP地址的首位开始连续的“1”。 以IP地址172.20.100.52为例，它本来是一个B类IP地址（前16位是网络标识），但通过子网掩码，它可以扩展为前26位是网络标识的IP地址，其中定义类10位子网掩码，如图所示。 路由路由控制表发送数据包时所使用的地址是网络层的地址，即IP地址。然而仅仅有IP地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表（Routing Table）。实现IP通信的主机和路由器都必须持有一张这样的表，它们也正是在这个表格的基础上才得以进行数据包发送的。 路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫静态路由控制，而后者叫做动态路由控制。为了让动态路由及时刷新路由表，在网络上互连的路由器之间必须设置好路由协议，保证正常读取路由控制信息。 IP协议始终认为路由表是正确的。然而，IP本身并没有定义制作路由控制表的协议。即IP没有制作路由控制表的机制。该表是由一个叫做“路由协议”的协议制作而成。 路由控制路由器中保存着路由控制表，它在路由控制表中查找目标IP地址对应的下一个路由器地址。 IP地址的网络地址部分用于进行路由控制，如下图所示 主机A的地址是10.1.1.30，要把数据发往地址为10.1.2.10的主机。在主机A的路由表中，保存了两个字段，由于目标地址10.1.2.10与10.1.1.0/24段不匹配，所以它被发往默认路由10.1.1.1也就是图中路由器1的IP地址。 路由器1继续在它自己的路由控制表中查找目标地址10.1.2.10，它发现目标地址属于10.1.2.0/24这一段，因此将数据转发至下一个路由器10.1.0.2，也就是路由器2的左侧网卡IP地址 路由器在自己的路由控制表中查找目标地址10.1.2.10，根据表中记录将数据发往10.1.2.1接口，也就是路由器右侧网卡的IP地址，主机B检查目标IP地址和自己相同，于是接收数据。 环路上图中，假设主机A向一个不存在的IP地址发送数据，并且路由器1、2、3设置的默认路由形成了一个循环，那么数据将在网络中不断转发最终导致网络拥堵，这个问题将在下文分析IP首部时得到解决。 IP报文分割与重组在数据链路层中，我们已经提到过不同的数据链路有不同的最大传输单元（MTU）。因此IP协议的一个任务是对数据进行分片和重组，分片由发送端主机和路由器负责，重组由接收端主机负责。 路径MTU发现分片会加重路由器的负担，因此只要条件允许，我们都不希望路由器对IP数据包进行分片处理。另外，如果一个分片丢失，整个IP数据报都会作废。 解决以上问题的技术是“路径MTU发现”。主机首先获取整个路径中所有数据链路的最小MTU，并按照整个大小将数据分片。因此传输过程中的任何一个路由器都不用进行分片工作。 为了找到路径MTU，主机首先发送整个数据包，并将IP首部的禁止分片标志设为1.这样路由器在遇到需要分片才能处理的包时不会分片，而是直接丢弃数据并通过ICMP协议将整个不可达的消息发回主机。主机将ICMP通知中的MTU设置为当前MTU，根据真个MTU对数据进行分片处理。如此反复下去，直到不再收到ICMP通知，此时的MTU就是路径MTU。 以UDP协议发送数据为例： 重组接收端根据IP首部中的标志（Flag）和片偏移（Fragment Offset）进行数据重组。 IP首部（IPv4）IP首部是一个有些复杂的结构，我们不用记忆它的结构，只需了解每个部分的作用即可，这样可以加深对IP协议的理解。 版本 由4比特构成，表示标识IP首部的版本号。IPv4的版本号即为4 首部长度（IHL，Internet Header Length） 由4比特构成，表明IP首部的大小，单位为4字节。对于没有可选项的IP包，首部长度则设置为5.也就是说，当没有可选项时，IP首部的长度为20字节（4 * 5 = 20） 区分服务（TOS：Type of Service） 由8比特组成，用来表明服务质量 DSCP（Differential Services Codepoint，差分服务代码点）是TOS的一部分，用来进行质量控制，由6个字节组成。ECN（Explicit Congestion Nofication，显示拥塞通告），用来报告网络拥堵情况，由2bit构成。 总长度 表示IP首部与数据部分结合起来的总字节数。该字段为16bit。因此IP包的最大长度为65535（2^16）个字节。虽然不同数据链路的MTU不同，但是IP协议屏蔽了这些区别，通过自己实现的数据分片功能，从上层的角度来看，IP协议总是能够以65535为最大包长进行传输。 标识（ID） 由16比特组成，用于分片重组。同一分片的标识值相同，不同分片的标识值不同。通过每发送一个IP包，它的值也逐渐递增。此外即使ID相同，如果目标地址、源地址或协议不同的话，也会被认为是不同的分片。 标志（Flags） 由3bit组成，表示包被分片的相关信息 片偏移（FO，Fragment Offset） 由13bit构成，用来标识被分片的每一个分段相对于原始数据的位置。第一个分片对应的值为0.由于FO域占13位，因此最多可以表示8192（2^13）个相对位置。单位为8字节，因此最大可表示原始数据8 * 8192 = 65536字节的位置。 生存时间（TTL：Time To Live） 由8比特构成，以秒为单位记录当前包在网络上应该生存的时间。在实际中它是指可以中转多少个路由器的意思。每经过一个路由器，TTL会减少1，直到变成0则丢弃该包。 协议（Protocol） 由8bit构成，表示IP首部的下一个首部隶属于哪个协议。 首部校验和（Header Checksum） 由16比特构成，也叫IP首部校验和。该字段只校验首部，不校验数据部分，主要用来确保IP数据包不被破坏。 源地址（Source Address） 由32bit构成，表示发送端IP地址 目标地址（Destination Address） 由32bit构成，表示接收端IP地址 可选项（Options） 长度可变，通常只在进行实验或诊断时使用 填充（Padding） 在有可选项的情况下，首部长度可能不是32bit的整数倍。为此，通过向字段填充0，调整32bit的整数倍。 数据（Data） 存入数据。将IP协议的首部也作为数据进行处理。","tags":[{"name":"网络通信","slug":"网络通信","permalink":"http://liuguoquan727.github.io/tags/网络通信/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://liuguoquan727.github.io/tags/TCP-IP/"}]},{"title":"TCP/IP（一）分层模型","date":"2015-12-17T13:04:06.000Z","path":"2015/12/17/TCP-IP1模型/","text":"OSI参考模型在OSI参考模型中，网络被分为七层，从下到上依次是：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 物理层：负责0、1比特流（0、1序列）与电压的高低、光的闪灭（电信号）之间的互换。 数据链路层：负责物理层上互连的、节点之间的通信传输。例如一个与以太网相连的2个节点之间的通信 网络层：将数据传输到目标地址。目标地址可以是多个网络通过路由器连接而成的某一个地址。因此这一层主要是负责寻址和路由选择。 传输层：可靠地传输数据。只在通信双方节点上进行处理，而无需在路由器上处理。 会话层：负责建立和断开通信连接，以及数据的分割等数据传输相关的管理。 表示层：将应用处理的信息转换为适合网络传输的格式，或将来自下一层的数据转换为上层能够处理的格式。因此它主要负责数据格式的转换。 应用层：为应用程序提供服务并规定应用程序中通信相关的细节。包括文件传输、电子邮件、远程登录等协议。 数据链路层数据链路层中有两个重要的概念：MAC 地址和分组交换 MAC地址MAC 地址是被烧录到网卡 ROM 中的一串数字，长度为 48 比特，它在世界范围内唯一(不考虑虚拟机自定义 MAC 地址)。由于 MAC 地址的唯一性，它可以被用来区分不同的节点，一旦指定了 MAC 地址，就不可能出现不知道往哪个设备传输数据的情况。 分组交换分组交换是指将大数据分割为一个个叫做包的较小单位进行传输的方法。使用分组交换的原因是不同的数据链路有各自的最大传输单元（MTU）。以以太网为例，它的MTU是1500字节，也就是通过以太网的数据，必须分割为若干帧，每个帧的数据长度不超过1500字节。如果上层传来的数据超过这个长度，数据链路层需要分割后再发送。 传输方式的分类 面向连接型和面向无连接型（网络数据传输方式） 电路交换和分组交换（网络通信方式） 单播、广播、多播、任播（根据接收端数量分类） 单播：一对一通信 广播：将消息从1台主机发送给与之相连的所有其他主机，典型例子就是电视播放 多播（组播）：有一台主机发送消息给特定的多台主机 任播：从目标主机群中选择一台最符合网络条件的主机作为目标主机发送消息，发送端将只会跟这台主机进行通信。 TCP/IPTCP/IP的具体含义全称：Transmission Control Protocol/Internet Protocol TCP/IP是指利用IP进行通信时所必须用到的协议群的统称。具体来说，IP或ICMP、TCP或UDP、TELNET或FTP、以及HTTP等都属于TCP/IP协议。它们与TCP或IP的关系密切，是互联网必不可少的组成部分。TCP/IP泛指这些协议，有时也称为TCP/IP为网际协议族。 TCP/IP规范-RFC那些需要标准化的协议被列入RFC（Request for Comment）文档并在互联网上公布。RFC不仅记录了协议规范内容，还包含了协议的实现和运用的相关信息以及实验方面的信息。 协议 RFC IPv4 RFC791 IPv6 RFC2460 TCP RFC793 UDP RFC768 HTTP(1.1) RFC2616 FTP RFC959 TELNET RFC 854 TCP/IP参考模型TCP/IP参考模型中，网络分为五层，从下到上依次为：物理层、网络接口层、网络层、传输层、应用层。TCP/IP更强调“在计算机上实现协议应该开发哪种程序”。 物理层TCP/IP物理层是负责数据传输的硬件。 网络接口层网络接口层利用以太网的数据链路层进行通信 网络层网络层使用IP协议，相当于OSI参考模型的第三层网络层。IP协议基于IP地址转发分包数据，作用是将分组数据报发送到目的主机。 TCP/IP分层中的网络层与传输层的功能通常由操作系统提供。尤其是路由器，它必须实现通过网络层转发分组数据包的功能。此外，连接互联网的所有主机跟路由器都必须实现IP的功能。 IP IP是跨越网络传送数据包，使整个互联网都能收到数据的协议。IP协议使数据能够发送到地球的另一端，这期间它使用IP地址作为主机的标识。 IP还隐含着数据链路层的功能。通过IP相互通信的主机之间不论经过怎样的底层数据链路都能够实现通信 IP也是分组交换的一种协议，但是它不具有重发机制。即使分组数据包未能到达对端主机也不会重发，因此属于非可靠性传输协议。 ICMP IP数据包在发送过程中一旦发生异常导致无法到达对端目标地址时，需要给发送方发送一个发送异常的通知。ICMP就是为这一功能而制定的，它有时也被用来诊断网络的健康状况。 ARP 从分组数据包中的IP地址中解析出物理地址（MAC地址）的一种协议。 传输层传输层的主要功能就是让应用程序之间实现通信。 TCP传输控制协议 TCP是一种面向有连接的传输层协议，它可以保证两端通信主机之间的数据完整性。TCP能够正确处理在传输过程中丢包、传输顺序乱掉等异常情况。此外TCP还能够有效利用宽带，缓解网络拥堵。然而，为了建立与断开连接，有时它需要至少7次的发包收包，导致网络流量的浪费。 UDP用户数据包协议 UDP是一种面向无连接的传输层协议。它不能保证两端通信主机之间的数据完整性，它是不可靠的。 应用层TCP/IP应用的架构大多数属于客户端/服务器模型。常见的应用有www、E-mail、FTP、TELNET、SNMP（网络管理）。 TCP/IP通信示例数据包首部每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。如下图所示，在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。 发送数据包假设甲给乙发送电子邮件，内容为：“早上好”。而从TCP/IP通信上看，是从一台计算机A向另一台计算机B发送电子邮件。下面，我们通过这个例子来讲解一下TCP/IP通信的过程。 [1]应用程序处理 启动应用程序新建邮件，将收件人邮箱填好，再由键盘输入邮件内容“早上好”，鼠标点击“发送”按钮就可以开始TCP/IP通信了。 首先应用程序会进行编码处理。例如，电子邮件使用UTF-8进行编码，这些编码相当于OSI的表示层功能。 应用在发送邮件的那一刻建立TCP连接，从而利用这个TCP连接发送数据。它的过程首先是将应用的数据发送给下一层的TCP，再做实际的转发处理。 [2]TCP模块的处理 TCP根据应用的指示，负责建立连接、发送数据以及断开连接。TCP提供将应用层发来的数据顺利发送至对端的可靠传输。 为了实现TCP的这一功能，需要在应用层数据的前端附加一个TCP首部。TCP首部中包括源端口号和目标端口号（用以识别发送主机跟接收主机上的应用）、序号（用以识别发送的包中哪部分是数据）以及校验码。随后将附加类TCP首部的包再发送给IP。 [3]IP模块的处理 IP将TCP传过来的TCP首部和TCP数据组合起来作为IP包的数据，并在TCP首部的前端加上IP包的首部。因此，IP数据包中IP首部后面紧跟着TCP首部，然后才是应用的数据首部和数据本身。IP首部中包含数据接收端IP地址以及发送端IP地址。紧随IP首部的还有用来判断数据时TCP还是UDP的信息。 IP包生成后，参考路由控制表决定接受此IP包的路由或主机。随后，IP包将被发送给连接这些路由器或主机网络接口的驱动程序，以实现真正发送数据。 如果不知道接收端的MAC地址，可以利用ARP查找。只要知道了对端的MAC地址，就可以将MAC地址和IP地址交给以太网驱动程序，实现数据传输。 [4]网络接口层的处理 从IP传过来的包，对于以太网驱动来说不过就是数据。给这数据附加上以太网首部并进行发送处理。以太网首部中包含接收端MAC地址、发送端MAC地址以及标志以太网类型的以太网数据的协议。根据上述信息产生的以太网数据包将通过物理层传输给接收端。发送处理中的FCS由硬件计算，添加到包的最后。设置FCS的目的是为了判断数据包是否由于噪声而被破坏。 下图为展示TCP/IP各层对邮件的收发处理 经过数据链路的包分组数据包经过以太网的数据链路时的大致流程如下图所示。 包流动时，从前往后依次被附加了以太网包首部、IP包首部、TCP包首部以及应用自己的包首部和数据。而包的最后则追加以太网包尾。 每个包首部中至少都会包含两个信息：一是发送端和接收端的地址，另一个是上一层的协议类型。 经过每个协议层时，都必须有识别包发送端和接收端的信息。以太网会用MAC地址，IP会用IP地址，而TCP/UDP则会用端口号作为识别两端主机的地址。即使在应用程序中，像电子邮件地址这样的信息也是一种地址标识。这些地址信息都在每个包经由各个分层时，附加到协议对应的包首部里面。 此外，每个分层的包首部中还包含一个识别位，它是用来标识上一层协议的种类信息。例如以太网的包首部中的以太网类型，IP中的协议类型以及TCP/UDP中两个端口的端口号等都起着识别协议类型的作用。就是在应用的首部信息中，有时也会包含一个用来识别其数据类型的标签。 数据包接收处理包的接收流程是发送流程的逆序过程。 [5]网络接口层的处理 主机收到以太网包以后，首先以太网的包首部找到MAC地址判断是否为发给自己的包。如果不是发给自己的包则丢弃数据。 而如果接收到了恰好是发给自己的包，就查找以太网包首部中的类型域从而确定以太网协议所传送过来的数据类型。在这个例子中数据类型显然是IP包，因此再将数据传给处理IP的子程序，如果这时不是IP而是其他诸如ARP的协议，就把数据传给ARP处理。总之，如果以太网包首部的类型域包含了一个无法识别的协议类型，则丢弃数据。 [6]IP模块的处理 IP模块接收到IP包首部及后面的数据部分以后，也做类似的处理。如果判断得出包首部中的IP地址与自己的IP地址匹配，则可接收数据并从中查找上一层的协议。如果上一层是TCP就将IP包首部之后的部分传给TCP处理；如果是UDP则将IP包首部后面的部分传给UDP处理。对于有路由器的情况下，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送达的主机或路由器以后再转发数据。 [7]TCP模块的处理 在TCP模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。 数据接收完毕后，接收端则发送一个“确定回执”给发送端。如果这个回执信息未能达到发送端，那么发送端会认为接收端没有接收到数据而一直反复发送。 数据被完整地接收以后，会传给由端口号识别的应用程序。 [8]应用程序的处理 接收端应用程序会直接接收发送端发送的数据。通过解析数据可以获知邮件的收件人地址是乙的地址。如果主机B上没有乙的邮件信箱，那么主机B返回给发送端一个“无此收件地址”的报错信箱。 但在这个例子中，主机B上有乙的收件箱，所有主机B和收件人乙能够收到电子邮箱的正文。邮件会被保存到本机的硬盘上。如果保存也能正常进行，那么接收端会返回一个“处理正常”的回执给发送端。反之，一旦出现磁盘满、邮件未能成功保存等问题，就会发送一个“处理异常”的回执给发送端。 由此，用户以就可以利用主机B的邮件客户端，接收并阅读由主机A上的用户甲所发送过来的电子邮件。","tags":[{"name":"网络通信","slug":"网络通信","permalink":"http://liuguoquan727.github.io/tags/网络通信/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://liuguoquan727.github.io/tags/TCP-IP/"}]},{"title":"搭建和配置Hexo+Github pages个人博客","date":"2015-12-15T13:46:03.000Z","path":"2015/12/15/搭建和配置Hexo-Github-pages个人博客/","text":"Window下安装GitHub Pages + Hexo本着不重复造轮子的精神，下面提供两篇博文来记录安装过程，因为这两篇文章详细记录了GitHub Pages + Hexo 的安装过程，跟着流程能够成功搭建出基本的个人博客。 Windows下一步步搭建自己的独立博客——使用 GitHub Pages + Hexo 基础教程（一）Windows下一步步搭建自己的独立博客——使用 GitHub Pages + Hexo 基础教程（三） 如有自己有申请独立的域名，可参看下面这篇博文Windows下一步步搭建自己的独立博客——使用 GitHub Pages + Hexo 基础教程（二） Hexo常用命令 安装 1npm install hexo 升级 1npm update hexo 初始化 1hexo init 创建 12hexo new \"新的文件\" #新建文章hexo new page \"新的页面\" #新的页面 操作 123456789101112131415hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动//完成后部署hexo generate --deployhexo deploy --generate 文章头配置12345678title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: Hexokeywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 创建”关于我”页面新建一个about页面： 1$hexo new page \"about\" 菜单显示about链接，在主题theme的_config.yml设置中将menu、中about前面的注释去掉即可。 12345menu: home: / archives: /archives tags: /tags about: /about 创建”分类”页面 1.新建一个页面，命名为categories。终端命令如下： 1hexo new page \"categories\" 2.编辑刚刚新建的页面，将页面的类型设置为categories，主题自动为这个页面显示所有分类。 1234title: 分类date: 2014-12-22 12:39:04type: \"categories\"--- 注意：如果有启用多说或者Dis去上、评论，默认页面也会带有评论。需要关闭的话，请添加字段comments并将值设置为false，如下所示： 12345title: 分类date: 2014-12-22 12:39:04type: \"categories\"comments: false--- 3.在菜单中添加链接。编辑主题的 _config.yml ，将 menu 中的 categories: /categories 注释去掉，如下: 12345menu: home: / categories: /categories archives: /archives tags: /tags 创建”标签云”页面添加一个标签云页面，并在菜单中显示页面链接。 1.新建一个页面，命名为 tags 。命令如下： 1hexo new page \"tags\" 2.编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。 1234title: All tagsdate: 2014-12-22 12:39:04type: \"tags\"--- 注意：如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false，如： 1234title: All tagsdate: 2014-12-22 12:39:04type: \"tags\"comments: false 3.在菜单中添加链接。编辑主题的 _config.yml ，添加 tags 到 menu 中，如下: 1234menu: home: / archives: /archives tags: /tags 设置侧边栏头像编辑站点的 _config.yml，新增字段 avatar， 值设置成头像的链接地址。 其中，头像的链接地址可以是： 完整的互联网 URL，例如：https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460 站点内的地址，例如： /uploads/avatar.jpg 需要将你的头像图片放置在 站点的 source/uploads/（可能需要新建uploads目录） /images/avatar.jpg 需要将你的头像图片放置在 主题的 source/images/ 目录下。 设置侧边栏社交链接编辑站点的 _config.yml，新增字段 social，然后添加社交站点名称与地址即可。例如： 123456social: github: https://github.com/your-user-name twitter: https://twitter.com/your-user-name weibo: http://weibo.com/your-user-name douban: http://douban.com/people/your-user-name zhihu: http://www.zhihu.com/people/your-user-name 设置网页标签LOGO编辑主题的 _config.yml,在favicon: /icon.jpg字段设置LOGO标志，图片防止在Hexo/source/目录下 设置语言NexT 目前支持六种语言版本： English中文简体 (zh-Hans)French (fr-FR)正体中文 (zh-hk/zh-tw)Russian (ru)German (de) 默认语言是英文。编辑站点的 _config.yml ，将 language 字段更改为你所需要的语言版本代号： 1234567language: default# language: zh-Hans# language: fr-FR# language: zh-hk# language: zh-tw# language: ru# language: de 设置代码高亮主题NexT 使用 Tomorrow Theme 作为代码高亮，共有5款主题供你选择. 编辑主题的 _config.yml,找到highlight_theme字段，设置目标主题 1highlight_theme: night 设置站点建立时间这个时间将在站点的底部显示，例如 © 2013 - 2015 编辑站点的 _config.yml，新增字段 since。 1since: 2013 添加站点访问统计与访客数量统计功能网站的浏览次数，即pv；网站的访客数为uv。pv的计算方式是，单个用户连续点击n篇文章，记录n次访问量；uv的计算方式是，单个用户连续点击n篇文章，只记录1次访客数。你可以根据需要添加相应的统计功能。 安装busuanzi.js脚本 如果你使用的是NexT主题（其他主题类似），打开/theme/next/layout/_partial/footer.swig文件，拷贝下面的代码至文件的开头。 12&lt;script async src=\"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 显示统计标签 同样编辑/theme/next/layout/_partial/footer.swig文件。 如果你想要显示pv统计量，复制以下代码至你想要放置的位置， 123&lt;span id=\"busuanzi_container_site_pv\"&gt; 本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次&lt;/span&gt; 如果你想要显示uv统计量，复制以下代码至你想要放置的位置， 123&lt;span id=\"busuanzi_container_site_uv\"&gt; 本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次&lt;/span&gt;","tags":[{"name":"记录","slug":"记录","permalink":"http://liuguoquan727.github.io/tags/记录/"}]}]